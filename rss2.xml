<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Pega Devlog</title>
    <link>https://jehyunlee.github.io/</link>
    
    <atom:link href="https://jehyunlee.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Pega&#39;s Development log for myself and others</description>
    <pubDate>Thu, 30 Sep 2021 03:43:16 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>pytorch &amp; sklearn pipeline</title>
      <link>https://jehyunlee.github.io/2021/09/29/Python-DL-7-skorch_pipeline/</link>
      <guid>https://jehyunlee.github.io/2021/09/29/Python-DL-7-skorch_pipeline/</guid>
      <pubDate>Wed, 29 Sep 2021 02:57:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;저는 tabular data를 다룹니다.&lt;/li&gt;
&lt;li&gt;간혹 딥러닝을 하고 싶지만 표준화등 전처리도 해야 합니다.&lt;/li&gt;
&lt;li&gt;범주형 변수를 인코딩해서 feature importance도 보고 싶습니다.&lt;/li&gt;
&lt;li&gt;skorc</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>저는 tabular data를 다룹니다.</li><li>간혹 딥러닝을 하고 싶지만 표준화등 전처리도 해야 합니다.</li><li>범주형 변수를 인코딩해서 feature importance도 보고 싶습니다.</li><li>skorch(sklearn + pytorch)를 사용하면 가능합니다.</li></ul><h1 id="1-skorch-sklearn-pytorch"><a href="#1-skorch-sklearn-pytorch" class="headerlink" title="1. skorch = sklearn + pytorch"></a>1. skorch = sklearn + pytorch</h1><p><img src="7_skorch_pipeline.png"></p><blockquote><p><a href="https://skorch.readthedocs.io/en/stable/index.html">skorch documentation</a><br><a href="https://skorch.readthedocs.io/en/stable/user/tutorials.html">skorch tutorials</a></p></blockquote><ul><li>저같은 사람들을 위해 skorch라는 라이브러리가 있습니다.</li><li>scikit-learn의 장점인 <b>grid search 등을 딥러닝과 함께</b> 사용할 수 있고</li><li>tutorial에서 transfer learning, U-Net, Seq2Seq 등을 지원합니다.<br><br><img src="7_skorch_pipeline_9.png"><br></li></ul><h1 id="2-sklearn-pipeline"><a href="#2-sklearn-pipeline" class="headerlink" title="2. sklearn pipeline"></a>2. sklearn pipeline</h1><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html">scikit-learn.pipeline.Pipeline</a></p></blockquote><ul><li>scikit-learn의 파이프라인은 데이터 전처리에서 발생하는 불확실성을 줄여줍니다.</li><li>데이터가 거쳐갈 길을 단단하게 만들어줌으로써 실수를 사전에 예방할 수 있습니다.</li><li>특히 PCA나 One-hot encoding처럼 <b>trainset의 정보를 기억해서 testset에 적용해야 할 때 좋습니다</b>.</li></ul><h2 id="2-1-예제-데이터셋"><a href="#2-1-예제-데이터셋" class="headerlink" title="2.1. 예제 데이터셋"></a>2.1. 예제 데이터셋</h2><ul><li>펭귄 데이터셋을 사용해서 펭귄 체중 예측모델을 만들어 봅니다.</li><li>편의를 위해 결측치까지 싹 지운 채로 시작합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 시각화 설정</span></span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line">sns.set_style(<span class="string">&quot;white&quot;</span>)</span><br><span class="line">font_title = &#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux 한글 사용 설정</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>]=[<span class="string">&#x27;NanumGothic&#x27;</span>, <span class="string">&#x27;sans-serif&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 펭귄 데이터셋 불러오기</span></span><br><span class="line">df_peng = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)</span><br><span class="line">df_peng.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line">df_peng.isna().<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure></li><li>실행 결과: 결측치가 모두 제거되었습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">species              0</span><br><span class="line">island               0</span><br><span class="line">bill_length_mm       0</span><br><span class="line">bill_depth_mm        0</span><br><span class="line">flipper_length_mm    0</span><br><span class="line">body_mass_g          0</span><br><span class="line">sex                  0</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></li></ul><ul><li>데이터셋을 준비합니다.</li><li>펭귄 체중만 y, 나머지는 모두 X입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y = df_peng[<span class="string">&quot;body_mass_g&quot;</span>]</span><br><span class="line">X = df_peng.drop(<span class="string">&quot;body_mass_g&quot;</span>, axis=<span class="number">1</span>)</span><br><span class="line">X.head(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><img src="7_skorch_pipeline_10.png"><br></li></ul><ul><li>trainset과 testset으로 나눕니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data split</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2-pipeline-구축"><a href="#2-2-pipeline-구축" class="headerlink" title="2.2. pipeline 구축"></a>2.2. pipeline 구축</h2><ul><li>scikit-learn으로 pipeline을 구축합니다.</li><li>numerical feature는 회귀모델 적용을 고려한 <code>PolynomialFeatures</code>와</li><li>데이터 정규화를 위한 <code>RobustScaler</code>를 거칩니다.</li><li>categorical feature는 <code>OneHotEncoder</code>를 거칩니다.</li></ul><ul><li><p>필요한 라이브러리를 불러옵니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoder</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> RobustScaler</span><br><span class="line"></span><br><span class="line"><span class="comment"># machine learning models</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"></span><br><span class="line"><span class="comment"># pipeline</span></span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.compose <span class="keyword">import</span> ColumnTransformer</span><br><span class="line"></span><br><span class="line"><span class="comment"># metrics</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br></pre></td></tr></table></figure></li><li><p>pipeline을 구축하는 함수를 만듭니다.</p></li><li><p><code>get_model_0()</code>을 실행하면 파이프라인이 만들어질 것입니다.</p></li><li><p>전처리 후 머신러닝 모델로는 선형회귀와 랜덤포레스트를 선택할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_model_0</span>(<span class="params">X_cols, degree=<span class="number">1</span>, method=<span class="string">&quot;lr&quot;</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    X_cols_ = deepcopy(X_cols)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1-1.categorical feature에 one-hot encoding 적용</span></span><br><span class="line">    cat_features = <span class="built_in">list</span>(<span class="built_in">set</span>(X_cols) &amp; <span class="built_in">set</span>([<span class="string">&quot;species&quot;</span>, <span class="string">&quot;island&quot;</span>, <span class="string">&quot;sex&quot;</span>]))</span><br><span class="line">    cat_transformer = OneHotEncoder(sparse=<span class="literal">False</span>, handle_unknown=<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1-2.numerical feature는 Power Transform과 Scaler를 거침</span></span><br><span class="line">    num_features = <span class="built_in">list</span>(<span class="built_in">set</span>(X_cols) - <span class="built_in">set</span>(cat_features))</span><br><span class="line">    num_features.sort()</span><br><span class="line">    num_transformer = Pipeline(steps=[(<span class="string">&quot;polynomial&quot;</span>, PolynomialFeatures(degree=degree)), </span><br><span class="line">                                      (<span class="string">&quot;scaler&quot;</span>, RobustScaler())</span><br><span class="line">                                     ])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 인자 종류별 전처리 적용</span></span><br><span class="line">    preprocessor = ColumnTransformer(transformers=[(<span class="string">&quot;num&quot;</span>, num_transformer, num_features), </span><br><span class="line">                                                   (<span class="string">&quot;cat&quot;</span>, cat_transformer, cat_features)])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 전처리 후 머신러닝 모델 적용</span></span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">&quot;lr&quot;</span>:</span><br><span class="line">        ml = LinearRegression(fit_intercept=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&quot;rf&quot;</span>:</span><br><span class="line">        ml = RandomForestRegressor()</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 3. Pipeline</span></span><br><span class="line">    model = Pipeline(steps=[(<span class="string">&quot;preprocessor&quot;</span>, preprocessor), </span><br><span class="line">                            (<span class="string">&quot;ml&quot;</span>, ml)])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure></li><li><p>6번째, 10번째 행을 보시면 조금 특이한 처리가 들어가 있습니다.</p></li><li><p><b>feature selection에 사용되는 장치</b>입니다.</p></li><li><p>feature 이름들을 하드코딩하면 feature selection이 불가능하기 때문에 이렇게 합니다.</p></li></ul><ul><li>만들어진 구조를 확인합니다.</li><li>일단 모든 인자를 모두 입력합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> set_config</span><br><span class="line">set_config(display=<span class="string">&#x27;diagram&#x27;</span>)</span><br><span class="line">model_0 = get_model_0(<span class="built_in">list</span>(X_train.columns), degree=<span class="number">1</span>, method=<span class="string">&quot;lr&quot;</span>)</span><br><span class="line">model_0</span><br></pre></td></tr></table></figure><img src="7_skorch_pipeline_11.png"><br></li></ul><h2 id="2-3-pipeline-전처리-확인"><a href="#2-3-pipeline-전처리-확인" class="headerlink" title="2.3. pipeline 전처리 확인"></a>2.3. pipeline 전처리 확인</h2><ul><li>pipeline에서 전처리 모듈만 떼어서 실행합니다.</li><li>pipeline의 모듈을 호출하는 방법은 <b>모델이름[“모듈이름”]</b>입니다.</li><li>따라서 우리의 전처리 모듈은 <b>model_0[“preprocessor”]</b>입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X_train_pp = model_0[<span class="string">&quot;preprocessor&quot;</span>].fit_transform(X_train)</span><br><span class="line"><span class="built_in">print</span>(X_train_pp.shape)</span><br><span class="line">X_train_pp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li><li>실행 결과: 첫 행만 찍어봤습니다. <b>숫자가 많습니다</b><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">266</span>, <span class="number">12</span>)</span><br><span class="line">array([ <span class="number">0.</span>        , -<span class="number">0.80645161</span>,  <span class="number">0.08579088</span>,  <span class="number">1.</span>        ,  <span class="number">1.</span>        ,</span><br><span class="line">        <span class="number">0.</span>        ,  <span class="number">0.</span>        ,  <span class="number">0.</span>        ,  <span class="number">0.</span>        ,  <span class="number">1.</span>        ,</span><br><span class="line">        <span class="number">0.</span>        ,  <span class="number">1.</span>        ])</span><br></pre></td></tr></table></figure></li></ul><ul><li>6개의 인자를 넣었는데 12개가 나왔습니다.</li><li>처음의 0은 LinearRegression에서 만든 intercept 항입니다.</li><li>네번째 1부터는 species, island, sex의 one-hot encoding 결과물입니다.</li></ul><ul><li>전처리 이후 데이터 분포도 확인합니다.</li><li>시각화 코드는 다소 길고, 여기선 중요하지 않아서 접었습니다.<details>  <summary><b>코드 보기/접기</b></summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Figure 생성</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>, <span class="number">8</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Subfigures 생성</span></span><br><span class="line">subfigs = fig.subfigures(nrows=<span class="number">2</span>, wspace=<span class="number">0.05</span>)</span><br><span class="line">subfigs[<span class="number">0</span>].set_facecolor(<span class="string">&quot;lightgray&quot;</span>)</span><br><span class="line">subfigs[<span class="number">1</span>].set_facecolor(<span class="string">&quot;beige&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># subfigs[0]: raw data</span></span><br><span class="line">axs0 = subfigs[<span class="number">0</span>].subplots(ncols=<span class="number">3</span>, nrows=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sns.kdeplot(X_train[<span class="string">&quot;bill_depth_mm&quot;</span>], cut=<span class="number">0</span>, fill=<span class="literal">True</span>, ax=axs0[<span class="number">0</span>])</span><br><span class="line">sns.kdeplot(X_train[<span class="string">&quot;bill_length_mm&quot;</span>], cut=<span class="number">0</span>, fill=<span class="literal">True</span>, ax=axs0[<span class="number">1</span>])</span><br><span class="line">sns.kdeplot(X_train[<span class="string">&quot;flipper_length_mm&quot;</span>], cut=<span class="number">0</span>, fill=<span class="literal">True</span>, ax=axs0[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># subfigs[1]: preprocessed data</span></span><br><span class="line">axs1 = subfigs[<span class="number">1</span>].subplots(ncols=<span class="number">3</span>, nrows=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sns.kdeplot(X_train_pp[:,<span class="number">1</span>], cut=<span class="number">0</span>, fill=<span class="literal">True</span>, ax=axs1[<span class="number">0</span>])</span><br><span class="line">sns.kdeplot(X_train_pp[:,<span class="number">2</span>], cut=<span class="number">0</span>, fill=<span class="literal">True</span>, ax=axs1[<span class="number">1</span>])</span><br><span class="line">sns.kdeplot(X_train_pp[:,<span class="number">3</span>], cut=<span class="number">0</span>, fill=<span class="literal">True</span>, ax=axs1[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax <span class="keyword">in</span> axs1:</span><br><span class="line">    ax.axvline(<span class="number">0</span>, c=<span class="string">&quot;gray&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> axs <span class="keyword">in</span> [axs0, axs1]:</span><br><span class="line">    <span class="keyword">for</span> i, (ax, title) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(axs, [<span class="string">&#x27;bill_depth_mm&#x27;</span>, <span class="string">&#x27;bill_length_mm&#x27;</span>, <span class="string">&#x27;flipper_length_mm&#x27;</span>])):</span><br><span class="line">        ax.set_xlabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        ax.set_title(<span class="string">f&quot;<span class="subst">&#123;title&#125;</span>&quot;</span>, fontdict=font_title, pad=<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            ax.set_ylabel(<span class="string">&quot; \n&quot;</span>)</span><br><span class="line"></span><br><span class="line">subfigs[<span class="number">0</span>].suptitle(<span class="string">&quot;raw data\n&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">subfigs[<span class="number">1</span>].suptitle(<span class="string">&quot;preprocessed data\n&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">fig.suptitle(<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><p><img src="7_skorch_pipeline_1.png"><br></p><ul><li>RobustScaler의 효과가 잘 보입니다.</li></ul><h2 id="2-3-pipeline-학습"><a href="#2-3-pipeline-학습" class="headerlink" title="2.3. pipeline 학습"></a>2.3. pipeline 학습</h2><ul><li><p><b>pipeline 전체를 사용해서 학습</b>시킵니다.</p></li><li><p>명령은 scikit-learn 스타일 그대로 <code>.fit()</code>입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model_0.fit(X_train, y_train)</span><br></pre></td></tr></table></figure></li><li><p>학습이 잘 되었는지 결과를 확인합니다.</p></li><li><p>parity plot 시각화 코드는 접어두었습니다.</p><details>  <summary><b>코드 보기/접기</b></summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parity plot</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_parity</span>(<span class="params">model, y_true, y_pred=<span class="literal">None</span>, X_to_pred=<span class="literal">None</span>, ax=<span class="literal">None</span>, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ax:</span><br><span class="line">        fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> y_pred <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        y_pred = model.predict(X_to_pred)</span><br><span class="line">    ax.scatter(y_true, y_pred, **kwargs)</span><br><span class="line">    xbound = ax.get_xbound()</span><br><span class="line">    xticks = [x <span class="keyword">for</span> x <span class="keyword">in</span> ax.get_xticks() <span class="keyword">if</span> xbound[<span class="number">0</span>] &lt;= x &lt;= xbound[<span class="number">1</span>]]</span><br><span class="line">    ax.set_xticks(xticks)</span><br><span class="line">    ax.set_xticklabels([<span class="string">f&quot;<span class="subst">&#123;x:<span class="number">.0</span>f&#125;</span>&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> xticks])</span><br><span class="line">    ax.set_yticks(xticks)</span><br><span class="line">    ax.set_yticklabels([<span class="string">f&quot;<span class="subst">&#123;x:<span class="number">.0</span>f&#125;</span>&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> xticks])</span><br><span class="line">    dxbound = <span class="number">0.05</span>*(xbound[<span class="number">1</span>]-xbound[<span class="number">0</span>])</span><br><span class="line">    ax.set_xlim(xbound[<span class="number">0</span>]-dxbound, xbound[<span class="number">1</span>]+dxbound)</span><br><span class="line">    ax.set_ylim(xbound[<span class="number">0</span>]-dxbound, xbound[<span class="number">1</span>]+dxbound)</span><br><span class="line">    </span><br><span class="line">    rmse = mean_squared_error(y_true, y_pred, squared=<span class="literal">False</span>)</span><br><span class="line">    r2 = r2_score(y_true, y_pred)</span><br><span class="line">    ax.text(<span class="number">0.95</span>, <span class="number">0.1</span>, <span class="string">f&quot;RMSE = <span class="subst">&#123;rmse:<span class="number">.2</span>f&#125;</span>\nR2 = <span class="subst">&#123;r2:<span class="number">.2</span>f&#125;</span>&quot;</span>, transform=ax.transAxes, </span><br><span class="line">            fontsize=<span class="number">14</span>, ha=<span class="string">&quot;right&quot;</span>, va=<span class="string">&quot;bottom&quot;</span>, bbox=&#123;<span class="string">&quot;boxstyle&quot;</span>:<span class="string">&quot;round&quot;</span>, <span class="string">&quot;fc&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;pad&quot;</span>:<span class="number">0.3</span>&#125;)</span><br><span class="line">    </span><br><span class="line">    ax.grid(<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ax</span><br><span class="line">    </span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">8</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line">plot_parity(model_0, y_train, X_to_pred=X_train, ax=axs[<span class="number">0</span>], c=<span class="string">&quot;g&quot;</span>, s=<span class="number">10</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plot_parity(model_0, y_test, X_to_pred=X_test, ax=axs[<span class="number">1</span>], c=<span class="string">&quot;m&quot;</span>, s=<span class="number">10</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [<span class="string">&quot;train&quot;</span>, <span class="string">&quot;test&quot;</span>]):</span><br><span class="line">    ax.set_title(title, fontdict=font_title, pad=<span class="number">16</span>)</span><br></pre></td></tr></table></figure></li></ul><p><img src="7_skorch_pipeline_2.png"><br></p><ul><li><p>단순 선형 회귀 모델인데 제법 쓸만합니다.</p></li><li><p>이제 pipeline에 랜덤포레스트 모델을 탑재해서 돌려봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model_1 = get_model_0(<span class="built_in">list</span>(X_train.columns), degree=<span class="number">1</span>, method=<span class="string">&quot;rf&quot;</span>)</span><br><span class="line">model_1.fit(X_train, y_train)</span><br><span class="line">model_1</span><br></pre></td></tr></table></figure><p><img src="7_skorch_pipeline_3.png"><br></p></li><li><p>과적합이 의심되긴 하지만 랜덤포레스트도 잘 나오네요.</p></li></ul><ul><li><p>이번에는 <b>feature selection</b>도 되는지 확인합니다.</p></li><li><p>부리 길이<code>bill_length_mm</code>와 종<code>species</code>만 가지고 결과를 예측해봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model_2 = get_model_0([<span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;species&quot;</span>], degree=<span class="number">1</span>, method=<span class="string">&quot;rf&quot;</span>)</span><br><span class="line">model_2.fit(X_train, y_train)</span><br></pre></td></tr></table></figure><p><img src="7_skorch_pipeline_4.png"><br></p></li><li><p>멀쩡한 인자들을 제외했으니 성능이 떨어지는 건 정상입니다.</p></li><li><p><b>pipeline을 작성하기에 따라 feature 중 일부만 넣어도 동작한다</b>는 것이 중요합니다.</p></li></ul><h1 id="3-pytorch-deep-learning"><a href="#3-pytorch-deep-learning" class="headerlink" title="3. pytorch deep learning"></a>3. pytorch deep learning</h1><ul><li>딥러닝은 다른 방법에 비해 복잡하고 연산자원이 많이 들지만 장점이 많습니다.</li><li>이미지나 시계열을 다룰 때 큰 힘을 발휘하는데, 간혹 tabular data에도 필요합니다.</li><li>pytorch만을 사용해서 모델을 만들어보고 pipeline에 탑재해서도 결과를 얻어봅니다.</li></ul><h2 id="3-1-pytorch-only"><a href="#3-1-pytorch-only" class="headerlink" title="3.1. pytorch only"></a>3.1. pytorch only</h2><ul><li><p>파이토치로 신경망 모델을 만들고 같은 데이터로 같은 문제를 풀어봅니다.</p></li><li><p>간단한 신경망 모델을 만듭니다. 나중에 pipeline 안에 넣을 겁니다. </p></li><li><p>feature selection을 대비해서 input dimension을 가변적으로 만듭니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim</span><br><span class="line"><span class="keyword">from</span> torch.optim.lr_scheduler <span class="keyword">import</span> CyclicLR</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegressorModule</span>(<span class="params">nn.Module</span>):</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ninput=<span class="number">11</span>, init_weights=<span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(RegressorModule, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self.model = nn.Sequential(nn.Linear(ninput, <span class="number">16</span>),</span><br><span class="line">                                   nn.ReLU(),</span><br><span class="line">                                   nn.Linear(<span class="number">16</span>, <span class="number">16</span>),</span><br><span class="line">                                   nn.ReLU(),</span><br><span class="line">                                   nn.Linear(<span class="number">16</span>, <span class="number">12</span>),</span><br><span class="line">                                   nn.ReLU(),</span><br><span class="line">                                   nn.Linear(<span class="number">12</span>, <span class="number">8</span>),</span><br><span class="line">                                   nn.ReLU(),</span><br><span class="line">                                   nn.Linear(<span class="number">8</span>, <span class="number">1</span>),</span><br><span class="line">                                   )</span><br><span class="line">        <span class="keyword">if</span> init_weights:</span><br><span class="line">            self._initialize_weights()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.model(X)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_initialize_weights</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> self.modules():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Linear):</span><br><span class="line">                nn.init.normal_(m.weight, <span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line">                nn.init.constant_(m.bias, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li><li><p>pytorch에 데이터를 넣으려면 tensor로 만들어야 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X_train_tensor = torch.Tensor(pd.get_dummies(X_train).astype(np.float32).values)</span><br><span class="line">y_train_tensor = torch.Tensor(y_train.astype(np.float32).values)</span><br></pre></td></tr></table></figure></li><li><p>지금 만든 모델에 학습을 시킬 수 있는 코드를 구현합니다.</p></li><li><p>1만 epoch동안 충분히 데이터를 넣어봅니다.</p></li><li><p>loss function으로는 RMSELoss를 구현해서 사용했습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">net = RegressorModule()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RMSELoss</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, eps=<span class="number">1e-6</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.mse = nn.MSELoss()</span><br><span class="line">        self.eps = eps</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,yhat,y</span>):</span></span><br><span class="line">        loss = torch.sqrt(self.mse(yhat,y) + self.eps)</span><br><span class="line">        <span class="keyword">return</span> loss</span><br><span class="line">    </span><br><span class="line">loss_func = RMSELoss()</span><br><span class="line">optimizer = optim.Adam(net.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">losses = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    output = net.forward(X_train_tensor)</span><br><span class="line">    loss = loss_func(output, y_train_tensor.view(-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line">    </span><br><span class="line">    losses.append(loss)</span><br><span class="line">    </span><br><span class="line">plt.plot(losses)</span><br></pre></td></tr></table></figure><p><img src="7_skorch_pipeline_5.png"><br></p></li></ul><ul><li><p>제법 학습이 잘 된 것 같습니다.</p></li><li><p>예측 성능을 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># numpy array를 pytorch tensor로 변환</span></span><br><span class="line">X_test_tensor = torch.Tensor(pd.get_dummies(X_test).astype(np.float32).values)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 예측값</span></span><br><span class="line">y_pred_train_tensor = net.forward(X_train_tensor)</span><br><span class="line">y_pred_test_tensor = net.forward(X_test_tensor)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pytorch tensor를 다시 numpy array로 변환</span></span><br><span class="line">y_pred_train = y_pred_train_tensor.detach().numpy()</span><br><span class="line">y_pred_test = y_pred_test_tensor.detach().numpy()</span><br></pre></td></tr></table></figure><p><img src="7_skorch_pipeline_6.png"><br></p></li><li><p><b>딥러닝으로도 제법 괜찮은 성능이 나오는 것</b>을 확인했습니다.</p></li></ul><h2 id="3-2-pytorch-pipeline"><a href="#3-2-pytorch-pipeline" class="headerlink" title="3.2. pytorch @pipeline"></a>3.2. pytorch @pipeline</h2><ul><li><b>skorch를 이용해서 pytorch를 pipeline 안에 탑재합니다.</b></li><li><b>skorch은 pytorch를 scikit-learn 객체처럼 만들어주는 일</b>을 합니다.</li><li>그래서 skorch로 감싼 pytorch 객체의 학습은 <b><code>fit()</code></b>이고,</li><li>예측은 <b><code>.forward()&lt;/b&gt;가 아니라 &lt;b&gt;</code>.predict()</b>입니다.</li></ul><ul><li>skorch의 <code>NeuralNetRegressor()</code>로 딥러닝 모듈 전체를 감싸고,</li><li>학습에 필요한 인자를 매개변수로 전달합니다.</li></ul><ul><li>그리고 중요한 사항이 하나 있습니다.</li><li><b>scikit-learn이 뱉는 <code>np.float64</code>를 <code>np.float32</code>로 변환</b>해야 합니다.</li><li>이를 위해 custom transformer를 만들어 적용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skorch <span class="keyword">import</span> NeuralNetRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.base <span class="keyword">import</span> BaseEstimator, TransformerMixin</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_model_T</span>(<span class="params">X_cols, degree=<span class="number">1</span>, method=<span class="string">&quot;lr&quot;</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    X_cols_ = deepcopy(X_cols)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1-1.categorical feature에 one-hot encoding 적용</span></span><br><span class="line">    cat_features = <span class="built_in">list</span>(<span class="built_in">set</span>(X_cols) &amp; <span class="built_in">set</span>([<span class="string">&quot;species&quot;</span>, <span class="string">&quot;island&quot;</span>, <span class="string">&quot;sex&quot;</span>]))</span><br><span class="line">    cat_transformer = OneHotEncoder(sparse=<span class="literal">False</span>, handle_unknown=<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1-2.numerical feature는 Power Transform과 Scaler를 거침</span></span><br><span class="line">    num_features = <span class="built_in">list</span>(<span class="built_in">set</span>(X_cols) - <span class="built_in">set</span>(cat_features))</span><br><span class="line">    num_features.sort()</span><br><span class="line">    num_transformer = Pipeline(steps=[(<span class="string">&quot;polynomial&quot;</span>, PolynomialFeatures(degree=degree)), </span><br><span class="line">                                      (<span class="string">&quot;scaler&quot;</span>, RobustScaler())</span><br><span class="line">                                     ])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 인자 종류별 전처리 적용</span></span><br><span class="line">    preprocessor = ColumnTransformer(transformers=[(<span class="string">&quot;num&quot;</span>, num_transformer, num_features), </span><br><span class="line">                                                   (<span class="string">&quot;cat&quot;</span>, cat_transformer, cat_features)])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. float64를 float32로 변환</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FloatTransformer</span>(<span class="params">BaseEstimator, TransformerMixin</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fit</span>(<span class="params">self, X, y=<span class="literal">None</span></span>):</span></span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">transform</span>(<span class="params">self, x</span>):</span></span><br><span class="line">            <span class="keyword">return</span> np.array(x, dtype=np.float32)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 전처리 후 머신러닝 모델 적용</span></span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">&quot;lr&quot;</span>:</span><br><span class="line">        ml = LinearRegression(fit_intercept=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&quot;rf&quot;</span>:</span><br><span class="line">        ml = RandomForestRegressor()</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&quot;torch&quot;</span>:</span><br><span class="line">        ninput = <span class="built_in">len</span>(num_features) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;species&quot;</span> <span class="keyword">in</span> cat_features:</span><br><span class="line">            ninput += <span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;island&quot;</span> <span class="keyword">in</span> cat_features:</span><br><span class="line">            ninput += <span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;sex&quot;</span> <span class="keyword">in</span> cat_features:</span><br><span class="line">            ninput += <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">        net = NeuralNetRegressor(RegressorModule(ninput=ninput, init_weights=<span class="literal">False</span>),</span><br><span class="line">                         max_epochs=<span class="number">1000</span>, verbose=<span class="number">0</span>,</span><br><span class="line">                         warm_start=<span class="literal">True</span>,</span><br><span class="line"><span class="comment">#                          device=&#x27;cuda&#x27;,</span></span><br><span class="line">                         criterion=RMSELoss,</span><br><span class="line">                         optimizer = optim.Adam,</span><br><span class="line">                         optimizer__lr = <span class="number">0.01</span></span><br><span class="line">                        )</span><br><span class="line">        ml = net</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 3. Pipeline</span></span><br><span class="line">    model = Pipeline(steps=[(<span class="string">&quot;preprocessor&quot;</span>, preprocessor), </span><br><span class="line">                            (<span class="string">&quot;float64to32&quot;</span>, FloatTransformer()),</span><br><span class="line">                            (<span class="string">&quot;ml&quot;</span>, ml)])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>모델을 만들고 확인합니다.</p></li><li><p>앞서 pytorch로 구현한 뉴럴넷 구조가 그대로 들어가 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model_T = get_model_T(<span class="built_in">list</span>(X_train.columns), degree=<span class="number">1</span>, method=<span class="string">&quot;torch&quot;</span>)</span><br><span class="line">model_T.fit(X_train, y_train.astype(np.float32).values.reshape(-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">model_T</span><br></pre></td></tr></table></figure><p><img src="7_skorch_pipeline_13.png"><br></p></li><li><p><b>성능을 확인합니다.</b> 준수하네요.<br><img src="7_skorch_pipeline_7.png"><br></p></li></ul><h1 id="4-permutation-feature-importance"><a href="#4-permutation-feature-importance" class="headerlink" title="4. permutation feature importance"></a>4. permutation feature importance</h1><ul><li>같은 파이프라인에서 선형, 트리, 딥러닝이 모두 구현되었습니다.</li><li>각각의 인자 중요도를 한번 확인해보겠습니다.</li><li>permutation importance를 사용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.inspection <span class="keyword">import</span> permutation_importance</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linear Regression</span></span><br><span class="line">pi_0 = permutation_importance(model_0, X_test, y_test, n_repeats=<span class="number">30</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Random Forest</span></span><br><span class="line">pi_1 = permutation_importance(model_1, X_test, y_test, n_repeats=<span class="number">30</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Neural Network</span></span><br><span class="line">pi_T = permutation_importance(model_T, X_test, y_test, n_repeats=<span class="number">30</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 시각화</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">15</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, pi, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [pi_0, pi_1, pi_T], [<span class="string">&quot;Linear Reg.&quot;</span>, <span class="string">&quot;Random Forest&quot;</span>, <span class="string">&quot;Neural Net&quot;</span>]):</span><br><span class="line">    ax.barh(X_test.columns, pi.importances_mean, xerr=pi.importances_std, color=<span class="string">&quot;orange&quot;</span>)</span><br><span class="line">    ax.invert_yaxis()</span><br><span class="line">    ax.set_xlim(<span class="number">0</span>, )</span><br><span class="line">    ax.set_title(title, fontdict=font_title, pad=<span class="number">16</span>)</span><br></pre></td></tr></table></figure><img src="7_skorch_pipeline_8.png"><br></li></ul><ul><li><b>입력 feature별 인자 중요도가 깔끔하게 정리되었습니다.</b></li><li>양상도 전반적으로 비슷하게 나오네요.</li><li>사소한 기능같지만 <b>tabular data를 딥러닝으로 돌렸을 때 이 그림을 그리기가 어려웠습니다.</b></li><li>이 글과 코드가 비슷한 어려움을 겪는 여러분께 도움이 되면 좋겠습니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Deep-Learning/">Deep Learning</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/pytorch/">pytorch</category>
      
      <category domain="https://jehyunlee.github.io/tags/sklearn/">sklearn</category>
      
      <category domain="https://jehyunlee.github.io/tags/pipeline/">pipeline</category>
      
      <category domain="https://jehyunlee.github.io/tags/neural-network/">neural network</category>
      
      
    </item>
    
    <item>
      <title>Full moon</title>
      <link>https://jehyunlee.github.io/2021/09/26/Python-General-9-fullmoon/</link>
      <guid>https://jehyunlee.github.io/2021/09/26/Python-General-9-fullmoon/</guid>
      <pubDate>Sat, 25 Sep 2021 23:52:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;지난 추석, 간만에 긴장을 풀었습니다.&lt;/li&gt;
&lt;li&gt;가끔 취미로 그림을 그리고는 하는데 python으로는 안그렸네요.&lt;/li&gt;
&lt;li&gt;자다가 문득 코드가 떠올라 보름달을 그렸습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-보름달은&quot;&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>지난 추석, 간만에 긴장을 풀었습니다.</li><li>가끔 취미로 그림을 그리고는 하는데 python으로는 안그렸네요.</li><li>자다가 문득 코드가 떠올라 보름달을 그렸습니다.</li></ul><h1 id="1-보름달은"><a href="#1-보름달은" class="headerlink" title="1. 보름달은?"></a>1. 보름달은?</h1><ul><li><p><b>보름달</b>이 어떻게 생겼는지 모르는 사람은 없을 겁니다.<br><br><img src="9_fullmoon_01.jpg"><br></p></li><li><p><b>검은 밤 하늘에 떠 있는 하얀 동그라미</b>로 단순화할 수 있습니다.</p></li><li><p>토끼가 방아를 찧고 있는 듯한 모양이 있지만 잠시 잊기로 합니다.</p></li><li><p>하지만 그냥 동그라미를 그리기엔 심심합니다. 작은 동그라미를 여럿 겹칩니다.</p></li></ul><h1 id="2-코드로-그리는-보름달"><a href="#2-코드로-그리는-보름달" class="headerlink" title="2. 코드로 그리는 보름달"></a>2. 코드로 그리는 보름달</h1><h2 id="2-1-코드로-그리는-그림"><a href="#2-1-코드로-그리는-그림" class="headerlink" title="2.1. 코드로 그리는 그림"></a>2.1. 코드로 그리는 그림</h2><blockquote><p><a href="http://www.genmedia.co.kr/news/articleView.html?idxno=12738">젠미디어: 이주행 ETRI 연구원 인터뷰</a><br><a href="https://techcrunch.com/2016/05/08/the-digital-age-of-data-art/">Techcrunch: The digital age of data art</a></p></blockquote><ul><li>무미건조한 코드나 데이터로 아름다움을 만들어내는 분들이 있으십니다.</li><li>데이터 시각화의 심미적 요소를 한껏 활용하는 것으로 볼 수도 있고</li><li>그림을 그리는 도구가 바뀌었을 뿐 데이터와 무관한 아름다움을 추구하기도 합니다.</li><li>이런 분들을 따라해 보기로 합니다<br><br><img src="9_fullmoon_08.png" alt="(좌) 이주행, &quot;Pixel Stack&quot;, (우) Mark Napier &quot;Black and White&quot;"><br></li></ul><h2 id="2-2-약간의-기하학"><a href="#2-2-약간의-기하학" class="headerlink" title="2.2. 약간의 기하학"></a>2.2. 약간의 기하학</h2><ul><li><p>중심을 (0,0)으로 하는 극좌표계 공간을 만듭니다.</p></li><li><p>반지름이 1인 공간 안에 랜덤하게 한 점을 골라 원의 중심을 잡습니다.</p></li><li><p>극좌표계를 사용하여 원점으로부터의 거리과 방위각으로 좌표를 잡으면 편리합니다.</p></li><li><p>matplotlib의 Circle을 이용해서 원을 생성합니다.</p></li><li><p>원의 반지름을 <code>1-원점으로부터의 거리</code>로 설정하면 원의 윤곽선에 항상 맞닿습니다.</p></li><li><p>10개만 그려봅시다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Circle</span><br><span class="line"></span><br><span class="line">num = <span class="number">10</span>    <span class="comment"># 원의 수</span></span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), </span><br><span class="line">                       constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 극좌표계에서 원 생성</span></span><br><span class="line">R = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)                   <span class="comment"># 반지름의 범위: 0~1</span></span><br><span class="line">pos_r = np.random.choice(R, size=num)        <span class="comment"># 랜덤 위치 (반지름)</span></span><br><span class="line">pos_a = <span class="number">2</span>*np.pi*np.random.uniform(size=num)  <span class="comment"># 랜덤 위치 (방위각)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 직교좌표계 변환</span></span><br><span class="line">pos_x = pos_r * np.cos(pos_a)         <span class="comment"># 직교좌표계 x</span></span><br><span class="line">pos_y = pos_r * np.sin(pos_a)         <span class="comment"># 직교좌표계 y</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x, y, r <span class="keyword">in</span> <span class="built_in">zip</span>(pos_x, pos_y, pos_r):</span><br><span class="line">    r_circle = <span class="number">1</span>-r  <span class="comment"># 원의 반지름</span></span><br><span class="line">    o = Circle((x, y), r_circle, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, alpha=<span class="number">1</span>)</span><br><span class="line">    ax.add_patch(o)</span><br><span class="line">    </span><br><span class="line">ax.set_xlim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">ax.set_ylim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">ax.axvline(<span class="number">0</span>, c=<span class="string">&quot;g&quot;</span>)</span><br><span class="line">ax.axhline(<span class="number">0</span>, c=<span class="string">&quot;g&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="9_fullmoon_02.png"><br></p></li></ul><h2 id="2-3-확률-제어"><a href="#2-3-확률-제어" class="headerlink" title="2.3. 확률 제어"></a>2.3. 확률 제어</h2><ul><li><p>100개를 그리면 이렇습니다.<br><img src="9_fullmoon_03.png"><br></p></li><li><p>뭔가 특이한 점을 느끼셨을까요?</p></li></ul><ul><li><p>원의 중심점 분포를 그리면 이렇습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 점들 사이 최단거리 계산</span></span><br><span class="line">pos_xy = np.array(<span class="built_in">list</span>(<span class="built_in">zip</span>(pos_x, pos_y)))</span><br><span class="line">d_shortests = []</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> pos_xy:</span><br><span class="line">    dp = pos_xy-p</span><br><span class="line">    d_shortest = np.inf</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> dp:</span><br><span class="line">        sd = np.sqrt(d[<span class="number">0</span>]**<span class="number">2</span> + d[<span class="number">1</span>]**<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt; sd &lt; d_shortest:</span><br><span class="line">            d_shortest = sd</span><br><span class="line">    d_shortests.append(d_shortest)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 시각화</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">8</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">0</span>].scatter(pos_x, pos_y)</span><br><span class="line">axs[<span class="number">0</span>].axvline(<span class="number">0</span>, c=<span class="string">&quot;g&quot;</span>)</span><br><span class="line">axs[<span class="number">0</span>].axhline(<span class="number">0</span>, c=<span class="string">&quot;g&quot;</span>)</span><br><span class="line">sns.kdeplot(d_shortests, cut=<span class="number">0</span>, ax=axs[<span class="number">1</span>], fill=<span class="literal">True</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_xlim(<span class="number">0</span>, <span class="built_in">max</span>(d_shortests))</span><br></pre></td></tr></table></figure><p><img src="9_fullmoon_04.png"><br></p></li><li><p>원점 부근을 중심으로 하는 점들이 월등히 많습니다.</p></li><li><p>앞서 그림을 그릴 때 원의 반지름을 <code>1-원점으로부터의 거리</code>로 설정했지요.</p></li><li><p><b>큰 원과 작은 원의 수는 비슷하더라도 작은 원은 여기저기 퍼져있고 큰 원은 뭉쳐있다</b>는 의미입니다.</p></li></ul><ul><li>나쁘다는 것은 아닙니다.</li><li>전체 원의 가운데보다 바깥 부분에 많은 선이 그려진다는 뜻이고,</li><li>원의 갯수를 키우는 것 만으로도 뭔가 3D 느낌이 납니다.</li><li>500개를 그리면 이렇게 됩니다.<br><img src="9_fullmoon_05.png"><br></li></ul><ul><li><p>다만, <b>약간의 확률 조작을 통해 연출이 가능하다</b>는 의미입니다.</p></li><li><p>예를 들어 이런 확률분포를 사용하면,<br><img src="9_fullmoon_06.png"><br></p></li><li><p>그림은 이렇게 바뀝니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), </span><br><span class="line">                       constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 극좌표계에서 원 생성</span></span><br><span class="line">R = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)                   <span class="comment"># 반지름의 범위: 0~1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># np.random.choice에 매개변수 p 적용, 확률 제어</span></span><br><span class="line">f = np.float_power(np.sin(R), <span class="number">10</span>)</span><br><span class="line">p = (f/<span class="built_in">max</span>(f))/<span class="built_in">sum</span>(f/<span class="built_in">max</span>(f))</span><br><span class="line">pos_r = np.random.choice(R, size=num, p=p)   <span class="comment"># 랜덤 위치 (반지름)</span></span><br><span class="line">pos_a = <span class="number">2</span>*np.pi*np.random.uniform(size=num)  <span class="comment"># 랜덤 위치 (방위각)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 직교좌표계 변환</span></span><br><span class="line">pos_x = pos_r * np.cos(pos_a)         <span class="comment"># 직교좌표계 x</span></span><br><span class="line">pos_y = pos_r * np.sin(pos_a)         <span class="comment"># 직교좌표계 y</span></span><br><span class="line"></span><br><span class="line">r_circles = []</span><br><span class="line"><span class="keyword">for</span> x, y, r <span class="keyword">in</span> <span class="built_in">zip</span>(pos_x, pos_y, pos_r):</span><br><span class="line">    r_circle = <span class="number">1</span>-r  <span class="comment"># 원의 반지름</span></span><br><span class="line">    r_circles.append(r_circle)</span><br><span class="line">    o = Circle((x, y), r_circle, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, alpha=<span class="number">1</span>, lw=<span class="number">0.1</span>)</span><br><span class="line">    ax.add_patch(o)</span><br><span class="line">    </span><br><span class="line">ax.set_xlim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">ax.set_ylim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">ax.axvline(<span class="number">0</span>, c=<span class="string">&quot;g&quot;</span>)</span><br><span class="line">ax.axhline(<span class="number">0</span>, c=<span class="string">&quot;g&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="9_fullmoon_07.png"><br></p></li></ul><h2 id="2-4-달-띄우기"><a href="#2-4-달-띄우기" class="headerlink" title="2.4. 달 띄우기"></a>2.4. 달 띄우기</h2><ul><li><p>달을 그리는 함수를 만들어봅니다.</p></li><li><p>앞에서 만든 함수에 딱 하나, <code>faceccolor</code>와 ‘edgecolor`를 제어하는 매개변수를 추가했습니다.</p></li><li><p>facecolor에 numpy array를 넣으면 랜덤하게 색을 입히는 기능을 추가했고요.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_fullmoon</span>(<span class="params">size, scale=<span class="number">5</span>, fc=<span class="string">&quot;w&quot;</span>, ec=<span class="string">&quot;none&quot;</span>, filename=<span class="string">&quot;fullmoon&quot;</span>, **kwargs</span>):</span></span><br><span class="line">    scale = np.<span class="built_in">float</span>(scale)</span><br><span class="line">    fig, ax = plt.subplots(figsize=(<span class="number">20</span>, <span class="number">20</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">    ax.set_facecolor(<span class="string">&quot;k&quot;</span>)</span><br><span class="line">    ax.spines[[<span class="string">&quot;top&quot;</span>, <span class="string">&quot;left&quot;</span>, <span class="string">&quot;bottom&quot;</span>, <span class="string">&quot;right&quot;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.set_xticks([])</span><br><span class="line">    ax.set_yticks([])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># random circle</span></span><br><span class="line">    R = np.linspace(<span class="number">0</span>, <span class="number">1</span>, size)</span><br><span class="line">    F = np.float_power(np.sin(R), <span class="number">10</span>)</span><br><span class="line">    P = (<span class="number">1</span>-F/<span class="built_in">max</span>(F))/<span class="built_in">sum</span>(<span class="number">1</span>-F/<span class="built_in">max</span>(F))</span><br><span class="line"></span><br><span class="line">    pos_r = np.random.choice(R, size=size, p=P)</span><br><span class="line">    pos_a = <span class="number">2</span>*np.pi*np.random.uniform(size=size)</span><br><span class="line">    pos_x = pos_r * np.cos(pos_a)</span><br><span class="line">    pos_y = pos_r * np.sin(pos_a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x, y, r <span class="keyword">in</span> <span class="built_in">zip</span>(pos_x, pos_y, pos_r):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(fc, np.ndarray):</span><br><span class="line">            fc = np.array([<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.8</span>]) + np.array([np.random.normal(loc=<span class="number">0.1</span>, scale=<span class="number">0.05</span>), np.random.normal(loc=<span class="number">0.1</span>, scale=<span class="number">0.05</span>), np.random.normal(loc=<span class="number">0.1</span>, scale=<span class="number">0.05</span>)])</span><br><span class="line">            fc[<span class="number">0</span>] = <span class="built_in">min</span>(fc[<span class="number">0</span>], <span class="number">1</span>)</span><br><span class="line">            fc[<span class="number">1</span>] = <span class="built_in">min</span>(fc[<span class="number">1</span>], <span class="number">1</span>)</span><br><span class="line">            fc[<span class="number">2</span>] = <span class="built_in">min</span>(fc[<span class="number">2</span>], <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        o = Circle((x, y), <span class="number">1</span>-r, fc=fc, ec=ec, alpha=scale/size, **kwargs)</span><br><span class="line">            </span><br><span class="line">        ax.add_patch(o)</span><br><span class="line"></span><br><span class="line">    ax.set_xlim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    ax.set_ylim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    fig.set_facecolor(<span class="string">&quot;k&quot;</span>)</span><br><span class="line">    fig.savefig(<span class="string">f&quot;<span class="subst">&#123;filename&#125;</span>.png&quot;</span>, dpi=<span class="number">300</span>)</span><br><span class="line">    </span><br><span class="line">plot_fullmoon(<span class="number">10</span>, fc=np.array([<span class="number">0.6</span>, <span class="number">0.6</span>, <span class="number">0.6</span>]), filename=<span class="string">&quot;fmc_10&quot;</span>, ec=<span class="string">&quot;w&quot;</span>, lw=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><img src="fmc_10.png"><br></p></li><li><p>원 10개로 그리면 이런 달이 떠오릅니다.</p></li></ul><ul><li>원 20개, 50개, 100개로도 그려볼 수 있겠죠.<br><br><img src="fmc_10-100.png"><br></li></ul><ul><li>꼭 추석이 아니더라도 모두들 둥근 달처럼 행복하시기 바랍니다.<br><br><img src="fmc_200.png"><br></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/art/">art</category>
      
      
    </item>
    
    <item>
      <title>PyTorch GPU setting</title>
      <link>https://jehyunlee.github.io/2021/06/06/Python-DL-6-pytorchGPU/</link>
      <guid>https://jehyunlee.github.io/2021/06/06/Python-DL-6-pytorchGPU/</guid>
      <pubDate>Sun, 06 Jun 2021 03:01:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;PyTorch GPU 버전을 설치한다고 GPU를 사용하지 않습니다.&lt;/li&gt;
&lt;li&gt;GPU가 여럿이라면 어떤 GPU가 사용 가능한지 확인하고,&lt;/li&gt;
&lt;li&gt;변수와 모델에 GPU 사용 설정을 해야 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 </description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>PyTorch GPU 버전을 설치한다고 GPU를 사용하지 않습니다.</li><li>GPU가 여럿이라면 어떤 GPU가 사용 가능한지 확인하고,</li><li>변수와 모델에 GPU 사용 설정을 해야 합니다.</li></ul><h1 id="1-PyTorch-버전-확인"><a href="#1-PyTorch-버전-확인" class="headerlink" title="1. PyTorch 버전 확인"></a>1. PyTorch 버전 확인</h1><ul><li>현재 버전을 확인합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch, torchvision</span><br><span class="line"><span class="built_in">print</span>(torch.__version__)</span><br><span class="line"><span class="built_in">print</span>(torchvision.__version__)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.7.1+cu101</span><br><span class="line">0.8.2+cu101</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="2-GPU-현황-확인"><a href="#2-GPU-현황-확인" class="headerlink" title="2. GPU 현황 확인"></a>2. GPU 현황 확인</h1><ul><li>GPU가 사용 가능한지 확인합니다.</li><li>사용 가능하다면, 메모리 점유 현황을 출력합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(torch.cuda.device_count()):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;# DEVICE <span class="subst">&#123;i&#125;</span>: <span class="subst">&#123;torch.cuda.get_device_name(i)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;- Memory Usage:&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  Allocated: <span class="subst">&#123;<span class="built_in">round</span>(torch.cuda.memory_allocated(i)/<span class="number">1024</span>**<span class="number">3</span>,<span class="number">1</span>)&#125;</span> GB&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  Cached:    <span class="subst">&#123;<span class="built_in">round</span>(torch.cuda.memory_cached(i)/<span class="number">1024</span>**<span class="number">3</span>,<span class="number">1</span>)&#125;</span> GB\n&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;# GPU is not available&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DEVICE 0: Tesla V100-PCIE-32GB</span></span><br><span class="line">- Memory Usage:</span><br><span class="line">  Allocated: 0.0 GB</span><br><span class="line">  Cached:    0.0 GB</span><br><span class="line"></span><br><span class="line"><span class="comment"># DEVICE 1: Tesla V100-PCIE-32GB</span></span><br><span class="line">- Memory Usage:</span><br><span class="line">  Allocated: 0.0 GB</span><br><span class="line">  Cached:    0.0 GB</span><br><span class="line"></span><br><span class="line"><span class="comment"># DEVICE 2: Tesla V100-PCIE-32GB</span></span><br><span class="line">- Memory Usage:</span><br><span class="line">  Allocated: 0.0 GB</span><br><span class="line">  Cached:    0.0 GB</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="3-GPU-할당-변경"><a href="#3-GPU-할당-변경" class="headerlink" title="3. GPU 할당 변경"></a>3. GPU 할당 변경</h1><ul><li>작업할 GPU를 선정합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GPU 할당 변경하기</span></span><br><span class="line">GPU_NUM = <span class="number">2</span> <span class="comment"># 원하는 GPU 번호 입력</span></span><br><span class="line">device = torch.device(<span class="string">f&#x27;cuda:<span class="subst">&#123;GPU_NUM&#125;</span>&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line">torch.cuda.set_device(device) <span class="comment"># change allocation of current GPU</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;# Current cuda device: &#x27;</span>, torch.cuda.current_device()) <span class="comment"># check</span></span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Current cuda device:  2</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="4-GPU-사용을-기본값으로-설정"><a href="#4-GPU-사용을-기본값으로-설정" class="headerlink" title="4. GPU 사용을 기본값으로 설정"></a>4. GPU 사용을 기본값으로 설정</h1><ul><li>변수를 만들때 자동으로 GPU를 사용하게 설정합니다.</li><li>앞서 <code>GPU_NUM</code>으로 지정한 GPU에 할당됩니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    torch.set_default_tensor_type(torch.cuda.FloatTensor)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;using cuda: <span class="subst">&#123;GPU_NUM&#125;</span>, <span class="subst">&#123;torch.cuda.get_device_name(GPU_NUM)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using cuda: 2, Tesla V100-PCIE-32GB</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>변수를 만들어 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = torch.FloatTensor([<span class="number">1.0</span>])</span><br><span class="line">x.<span class="built_in">type</span>()</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;torch.FloatTensor&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>GPU 사용을 기본값으로 명시했는데 안올라갑니다.</p></li><li><p>강제로 올려봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = x.cuda()</span><br><span class="line">x.<span class="built_in">type</span>()</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;torch.cuda.FloatTensor&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>그냥 <b><code>torch.Tensor()</code></b>를 해야 GPU에 올라갑니다.</li><li>자료형도 내가 원하는 <code>torch.cuda.FloatTensor</code>입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = torch.Tensor([<span class="number">1.0</span>])</span><br><span class="line">x.<span class="built_in">type</span>()</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;torch.cuda.FloatTensor&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Deep-Learning/">Deep Learning</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/pytorch/">pytorch</category>
      
      <category domain="https://jehyunlee.github.io/tags/GPU/">GPU</category>
      
      
    </item>
    
    <item>
      <title>Keras Code Examples - Image segmentation with a U-Net-like architecture</title>
      <link>https://jehyunlee.github.io/2020/12/24/Python-DL-5_kerasleraningday/</link>
      <guid>https://jehyunlee.github.io/2020/12/24/Python-DL-5_kerasleraningday/</guid>
      <pubDate>Thu, 24 Dec 2020 11:15:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://aifactory.space/kld&quot;&gt;Keras Learning Day&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.codestates.com/&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><a href="http://aifactory.space/kld">Keras Learning Day</a></p></blockquote><ul><li><a href="https://www.codestates.com/">AI Factory</a>에서 진행한 <b>케라스 러닝 데이</b> 발표입니다.</li><li>2020.12.23 발표영상입니다.  </li><li>Xception 논문의 저자이자 Keras의 창시자인 프랑스와 숄레님의 코드입니다.</li><li>제목에는 U-Net이라는 이름이 있지만 내용은 Xception입니다.</li><li>다만, classification이 아니라 segmentation을 합니다.</li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/3oFR7ajzAZs" frameborder="0" loading="lazy" allowfullscreen></iframe></div><ul><li>Xception 논문에 대한 설명을 위해 Inception, Batch Normalization을 같이 보았습니다.</li><li>miniature model을 만들어 layer별로 feature map을 그려봤습니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Deep-Learning/">Deep Learning</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/keras-learing-day/">keras learing day</category>
      
      <category domain="https://jehyunlee.github.io/tags/xception/">xception</category>
      
      <category domain="https://jehyunlee.github.io/tags/segmentation/">segmentation</category>
      
      
    </item>
    
    <item>
      <title>keras BatchNormalization</title>
      <link>https://jehyunlee.github.io/2020/12/01/Python-DL-4-bn/</link>
      <guid>https://jehyunlee.github.io/2020/12/01/Python-DL-4-bn/</guid>
      <pubDate>Tue, 01 Dec 2020 13:21:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;b&gt;Contributors&lt;/b&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hihunjin&quot;&gt;하헌진&lt;/a&gt;님, 흑염룡님, 머린이왕자님&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;CNN에서 bat</description>
        
      
      
      
      <content:encoded><![CDATA[<p><b>Contributors</b></p><blockquote><p><a href="https://github.com/hihunjin">하헌진</a>님, 흑염룡님, 머린이왕자님</p></blockquote><ul><li>CNN에서 batch normalization은 Convolution layer를 따라다닙니다.</li><li>배치 정규화<code>batch normalization</code>는 그레이디언트 소실<code>gradient vanishing</code>과 폭주<code>exploding</code> 문제를 해결하기 위해 제안되었습니다.</li><li>본 글에서는 배치 정규화의 이론적 내용을 다루지 않습니다.</li><li>tensorflow에 탑재된 keras의 <code>BatchNormalization()</code>이 어떤 결과를 만들어내는지에 집중합니다.</li></ul><blockquote><p><a href="https://arxiv.org/abs/1502.03167">Sergey Ioffe, Christian Szegedy, “Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift”, ICML2015</a><br><a href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/BatchNormalization">tf.keras.layers.BatchNormalization</a></p></blockquote><h3 id="1-예제-데이터-가져오기"><a href="#1-예제-데이터-가져오기" class="headerlink" title="1. 예제 데이터 가져오기"></a>1. 예제 데이터 가져오기</h3><ul><li>실제 상황에서는 많은 이미지를 학습시키겠지만, 3장으로 테스트해봅니다.</li><li>입력 이미지와 히스토그램의 분포 변화를 그려봅니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">img0 = plt.imread(<span class="string">&quot;./4-bn_0.jpg&quot;</span>)</span><br><span class="line">img1 = plt.imread(<span class="string">&quot;./4-bn_1.jpg&quot;</span>)</span><br><span class="line">img2 = plt.imread(<span class="string">&quot;./4-bn_2.jpg&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li>불러온 이미지를 numpy vector로 만들어 줍니다.</li><li>하나의 numpy array에 이미지를 모두 탑재합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">imgs = np.zeros((<span class="number">3</span>, ) + img0.shape)</span><br><span class="line">imgs[<span class="number">0</span>] = img0/<span class="number">255.0</span></span><br><span class="line">imgs[<span class="number">1</span>] = img1/<span class="number">255.0</span></span><br><span class="line">imgs[<span class="number">2</span>] = img2/<span class="number">255.0</span></span><br><span class="line"><span class="built_in">print</span>(img0.shape)</span><br></pre></td></tr></table></figure><ul><li>실행결과 : 256 x 256 크기의 3 channel image입니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(256, 256, 3)</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>이미지를 눈으로 확인합니다.</li><li>앞으로 자주 사용할 기능이니 figure를 리턴하는 함수로 만듭니다.</li><li>연산을 거친 이미지가 <b>그림으로 출력되기 어려운 범위로 환산될 것을 대비</b>하여 이미지 minmax scaling을 미리 수행합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_img</span>(<span class="params">imgs</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 이미지 minmax scaling</span></span><br><span class="line">    <span class="keyword">if</span> imgs.<span class="built_in">min</span>() &lt; <span class="number">0</span>:</span><br><span class="line">        imgs = imgs - imgs.<span class="built_in">min</span>()</span><br><span class="line">    <span class="keyword">if</span> imgs.<span class="built_in">max</span>() &gt; <span class="number">1</span>:</span><br><span class="line">        imgs = imgs/imgs.<span class="built_in">max</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 시각화</span></span><br><span class="line">    fig, axs = plt.subplots(ncols=<span class="built_in">len</span>(imgs), figsize=(<span class="number">3</span>*<span class="built_in">len</span>(imgs), <span class="number">3</span>))</span><br><span class="line">    <span class="keyword">for</span> img, ax <span class="keyword">in</span> <span class="built_in">zip</span>(imgs, axs):</span><br><span class="line">        ax.imshow(img)</span><br><span class="line"></span><br><span class="line">    fig.tight_layout()    </span><br><span class="line">    <span class="keyword">return</span> fig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 데이터 시각화</span></span><br><span class="line">fig = plot_img(imgs)</span><br></pre></td></tr></table></figure><img src="4-bn_3.png"><br></li></ul><h3 id="2-데이터-분포-확인하기"><a href="#2-데이터-분포-확인하기" class="headerlink" title="2. 데이터 분포 확인하기"></a>2. 데이터 분포 확인하기</h3><ul><li>데이터의 분포를 그림으로 그려서 확인합니다.</li><li>컬러 이미지이므로 <b>R, G, B</b> 세 개의 채널이 있습니다.</li><li>세 채널을 각기 <b>빨강, 녹색, 파랑</b>의 밀도함수로 표현합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_kde</span>(<span class="params">imgs, symmetry=<span class="literal">False</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 시각화</span></span><br><span class="line">    fig, axs = plt.subplots(ncols=<span class="built_in">len</span>(imgs), figsize=(<span class="number">3</span>*<span class="built_in">len</span>(imgs), <span class="number">3</span>), sharex=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> img, ax <span class="keyword">in</span> <span class="built_in">zip</span>(imgs, axs):</span><br><span class="line">        channel = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">        color = [<span class="string">&quot;r&quot;</span>, <span class="string">&quot;g&quot;</span>, <span class="string">&quot;b&quot;</span>]</span><br><span class="line">        <span class="comment"># R, G, B 채널 분포 시각화. </span></span><br><span class="line">        <span class="comment"># 오해가 발생하지 않도록 실제 데이터 범위에만 분포 시각화</span></span><br><span class="line">        [sns.kdeplot(img[:,:,ch].flatten(), color=c, fill=<span class="literal">True</span>, ax=ax, cut=<span class="number">0</span>) <span class="keyword">for</span> ch, c <span class="keyword">in</span> <span class="built_in">zip</span>(channel, color)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># x축 범위 설정. </span></span><br><span class="line">    <span class="comment"># 필요시 x축을 0 중심으로 대칭이 되도록 설정할 수 있도록.</span></span><br><span class="line">    xlim = ax.get_xlim()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> symmetry==<span class="literal">True</span>:</span><br><span class="line">        xlim = [-<span class="built_in">max</span>(<span class="built_in">abs</span>(xlim)), <span class="built_in">max</span>(<span class="built_in">abs</span>(xlim))]</span><br><span class="line">        axs[<span class="number">0</span>].set_xlim(xlim)</span><br><span class="line">    </span><br><span class="line">    fig.tight_layout()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 나중에 분포를 겹쳐 그리기 위해 fig 외에도 axes를 함께 리턴합니다.</span></span><br><span class="line">    <span class="keyword">return</span> fig, axs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 데이터 분포 시각화</span></span><br><span class="line">fig, axs = plot_kde(imgs)</span><br></pre></td></tr></table></figure><img src="4-bn_4.png"><br></li></ul><h3 id="3-Batch-Normalization-적용-1-직접"><a href="#3-Batch-Normalization-적용-1-직접" class="headerlink" title="3. Batch Normalization 적용 (1) 직접"></a>3. Batch Normalization 적용 (1) 직접</h3><ul><li><a href="https://jehyunlee.github.io/2020/11/29/Python-DL-1-conv2d/">앞선 글</a>에서 Conv2D만 따로 적용했습니다.</li><li>이번에도 학습과정 없이 <code>BatchNormalization()</code>만 적용해 보겠습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">imgs_tensor = tf.convert_to_tensor(imgs, dtype=<span class="string">&quot;float32&quot;</span>)</span><br><span class="line">bn0 = layers.BatchNormalization(trainable=<span class="literal">True</span>)(imgs_tensor)</span><br><span class="line">bn0_numpy = bn0.numpy()</span><br><span class="line"></span><br><span class="line">fig1 = plot_img(bn0_numpy)</span><br><span class="line">fig2, _ = plot_kde(bn0_numpy)</span><br></pre></td></tr></table></figure><img src="4-bn_5.png"><br><img src="4-bn_6.png"><br></li></ul><ul><li>바뀐 것이 없습니다.</li><li>Batch Normalization은 Conv2D와 달리 <b>학습 과정에서 데이터의 분포를 파악하여 적용</b>하도록 설계되어 있기 때문에 이런 방식으로는 작동하지 않습니다.</li></ul><h3 id="4-Batch-Normalization-적용-2-학습"><a href="#4-Batch-Normalization-적용-2-학습" class="headerlink" title="4. Batch Normalization 적용 (2) 학습"></a>4. Batch Normalization 적용 (2) 학습</h3><ul><li>학습을 위한 최소한의 모델을 만듭니다.</li><li>BatchNormalization 레이어 외에는 아무것도 없습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"></span><br><span class="line">model = Sequential([</span><br><span class="line">    layers.BatchNormalization()</span><br><span class="line">])</span><br><span class="line">model.<span class="built_in">compile</span>()</span><br></pre></td></tr></table></figure></li></ul><ul><li>모델에 데이터를 투입하여 학습을 시킵니다.</li><li>이 때, numpy array를 텐서로 변환하여 입력해야 합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bn1 = model(imgs_tensor, training=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li>잘 적용되었을까요? 확인합시다.</li><li>다시 numpy array로 바꾸어서 이미지와 분포를 그려봅니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bn1_numpy = bn1.numpy()</span><br><span class="line"></span><br><span class="line">fig1 = plot_img(bn1_numpy)</span><br><span class="line">fig2, _ = plot_kde(bn1_numpy)</span><br></pre></td></tr></table></figure><img src="4-bn_7.png"><br><img src="4-bn_8.png"><br></li></ul><ul><li><p>Batch Normalization 이전과 이후를 나란히 놓아봅시다.<br><br><img src="4-bn_13.png" alt="Batch Normalization 이전과 이후 비교"><br></p></li><li><p><b>원본에 비해 색이 흐려진 것</b>이 느껴집니다.</p></li><li><p>이미지는 데이터를 그림으로 표현하기 위해 minmax scaling이 된 것입니다.</p></li></ul><ul><li>실제 데이터의 분포는 아래에 있는 밀도함수를 통해 알 수 있습니다.</li><li>원본에서 0<del>1 사이에 있던 값의 분포가 -2</del>2 사이로 변환되었습니다.</li><li><b>RGB 채널이 각기 독립적으로 normalization</b> 되었습니다.</li></ul><p><b>※ CNN에서 Batch Normalization은 대개 Convolution layer와 activation layer 사이에 위치합니다</b></p><ul><li>Convolution을 거친 이미지는 Batch Normalization에 의해 고르게 분포됩니다.</li><li>잘못된 초기화로 인해 학습이 어려워지는 문제를 해결할 수 있습니다.</li><li>결과적으로 <b>학습이 안정적으로 빠르게 이루어집니다.</b><br></li></ul><p><b>※(추가) 위 그림이 BN효과를 오해할 소지가 있다고 생각되어 수정했습니다.</b></p><ul><li>자세한 고민은 다음 글을 읽어보세요: <a href="https://jehyunlee.github.io/2020/12/03/Python-DS-46-bnvis/">Visualization of Image Exceeding Limitation</a></li><li>기록 차원에서 본 글의 미리보기는 수정하지 않았습니다.<br><br><img src="46-bnvis_10.png"><br></li></ul><h3 id="4-보너스-toy-model"><a href="#4-보너스-toy-model" class="headerlink" title="4. 보너스 - toy model"></a>4. 보너스 - toy model</h3><ul><li>Batch Normalization은 <b>데이터의 평균을 0, 분산을 1로 조정합니다.</b></li><li>간단한 예제 데이터를 통해서 정말 그런지 살펴봅니다.</li><li>numpy array 형태의 예제 데이터를 만듭니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 예제 데이터 생성</span></span><br><span class="line">ex_img0 = np.random.normal(loc=-<span class="number">0.5</span>, scale=<span class="number">0.01</span>, size=<span class="number">256</span>*<span class="number">256</span>*<span class="number">3</span>).reshape((<span class="number">256</span>, <span class="number">256</span>, <span class="number">3</span>))</span><br><span class="line">ex_img1 = np.random.normal(loc=<span class="number">0.5</span>, scale=<span class="number">0.01</span>, size=<span class="number">256</span>*<span class="number">256</span>*<span class="number">3</span>).reshape((<span class="number">256</span>, <span class="number">256</span>, <span class="number">3</span>))</span><br><span class="line">ex_img2 = np.random.normal(loc=-<span class="number">0.5</span>, scale=<span class="number">0.01</span>, size=<span class="number">256</span>*<span class="number">256</span>*<span class="number">3</span>).reshape((<span class="number">256</span>, <span class="number">256</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 예제 데이터 vectorization</span></span><br><span class="line">ex_imgs = np.zeros((<span class="number">3</span>, ) + ex_img0.shape)</span><br><span class="line">ex_imgs[<span class="number">0</span>] = ex_img0</span><br><span class="line">ex_imgs[<span class="number">1</span>] = ex_img1</span><br><span class="line">ex_imgs[<span class="number">2</span>] = ex_img2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 데이터 시각화</span></span><br><span class="line">fig1 = plot_img(ex_imgs)</span><br><span class="line">fig2, _ = plot_kde(ex_imgs)</span><br></pre></td></tr></table></figure><img src="4-bn_9.png"><br><img src="4-bn_10.png"><br></li></ul><ul><li>평균이 각기 -0.5, 0.5, -0.5이고 표준편차가 0.01인 데이터가 만들어졌습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(ex_img0.var())</span><br></pre></td></tr></table></figure><ul><li>실행결과 : 분산이 0.0001, 즉 표준편차는 0.01 맞습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.00010004582097558264</span><br></pre></td></tr></table></figure></li></ul></li><li>Batch Normalization을 적용합니다.</li><li>데이터를 텐서로 만들어 적용하고, 시각화를 위해 다시 numpy로 변환합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ex_imgs_tensor = tf.convert_to_tensor(ex_imgs, dtype=<span class="string">&quot;float32&quot;</span>)</span><br><span class="line">ex_bn1 = model(ex_imgs_tensor, training=<span class="literal">True</span>)</span><br><span class="line">ex_bn1_numpy = ex_bn1.numpy()</span><br></pre></td></tr></table></figure></li></ul><ul><li>변환 결과를 그림으로 확인합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> patches</span><br><span class="line"></span><br><span class="line">fig1 = plot_img(ex_bn1_numpy)</span><br><span class="line"></span><br><span class="line">fig2, axs = plot_kde(ex_bn1_numpy, symmetry=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> ax, ex_img <span class="keyword">in</span> <span class="built_in">zip</span>(axs, ex_imgs):</span><br><span class="line">    sns.kdeplot(ex_img.flatten(), ax=ax, color=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line"></span><br><span class="line">Rectangle0 = patches.Rectangle((<span class="number">0.45</span>, <span class="number">0.9</span>), <span class="number">0.12</span>, <span class="number">0.05</span>, color=<span class="string">&quot;lightgray&quot;</span>, transform=axs[<span class="number">0</span>].transAxes)</span><br><span class="line">axs[<span class="number">0</span>].add_patch(Rectangle0)</span><br><span class="line">axs[<span class="number">0</span>].text(<span class="number">0.6</span>, <span class="number">0.9</span>, <span class="string">&quot;before BN&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">12</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;k&quot;</span>&#125;, transform=axs[<span class="number">0</span>].transAxes)</span><br><span class="line">Rectangle1 = patches.Rectangle((<span class="number">0.45</span>, <span class="number">0.8</span>), <span class="number">0.12</span>, <span class="number">0.05</span>, color=<span class="string">&quot;navy&quot;</span>, transform=axs[<span class="number">0</span>].transAxes)</span><br><span class="line">axs[<span class="number">0</span>].add_patch(Rectangle1)</span><br><span class="line">axs[<span class="number">0</span>].text(<span class="number">0.6</span>, <span class="number">0.8</span>, <span class="string">&quot;after BN&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">12</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;k&quot;</span>&#125;, transform=axs[<span class="number">0</span>].transAxes)</span><br></pre></td></tr></table></figure><img src="4-bn_11.png"><br><img src="4-bn_12.png"><br></li></ul><ul><li>그림으로 봐서는 모르겠습니다. minmax scaling이 적용되었기 때문입니다.</li><li>그러나 분포를 보면, -0.5와 0.5에 분포했던 데이터가 각기 -1과 1 방향으로 이동한 것을 알 수 있습니다.</li><li>정확한 값을 추측해봅시다.<ul><li>-0.5, 0.5, -0.5의 평균은 $$\frac{-1}{6}$$, 표준편차는 $$\frac{\sqrt{2}}{3}$$입니다.</li><li>따라서 -0.5, 0.5, -0.5의 Batch Normalization 결과는 $$\frac{-1}{\sqrt{2}}, \frac{2}{\sqrt{2}}, \frac{-1}{\sqrt{2}}$$가 될 것입니다.</li><li>정말 그런지 확인해봅시다.</li></ul></li></ul><ul><li>평균값을 확인합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>([ex_bn1_numpy[i].mean() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)])</span><br></pre></td></tr></table></figure><ul><li>실행결과 : $$\frac{-1}{\sqrt{2}}, \frac{2}{\sqrt{2}}, \frac{-1}{\sqrt{2}}$$입니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-0.7053814, 1.4107242, -0.70534563]</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>mini-batch의 평균과 variance를 구합니다.</li><li>model의 layer에 데이터가 저장되어 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mean = model.layers[<span class="number">0</span>].variables[<span class="number">2</span>].numpy()</span><br><span class="line">var  = model.layers[<span class="number">0</span>].variables[<span class="number">3</span>].numpy()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mean, mean.mean())</span><br><span class="line"><span class="built_in">print</span>(var, var.mean())</span><br></pre></td></tr></table></figure><ul><li>실행결과 : 0에 가까운 평균과 1에 가까운 분산이 출력되었습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0.00435958 0.00288465 0.00303697] 0.0034270668</span><br><span class="line">[0.9828158 0.983015  0.9831719] 0.98300093</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Deep-Learning/">Deep Learning</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/tensorflow/">tensorflow</category>
      
      <category domain="https://jehyunlee.github.io/tags/keras/">keras</category>
      
      <category domain="https://jehyunlee.github.io/tags/batch-normalization/">batch normalization</category>
      
      
    </item>
    
    <item>
      <title>keras Conv2D</title>
      <link>https://jehyunlee.github.io/2020/11/29/Python-DL-1-conv2d/</link>
      <guid>https://jehyunlee.github.io/2020/11/29/Python-DL-1-conv2d/</guid>
      <pubDate>Sat, 28 Nov 2020 20:21:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;Convolution의 기초 명령어 Conv2D 예시입니다.&lt;/li&gt;
&lt;li&gt;딥러닝의 일부로서가 아닌 명령어 자체 기능을 봅니다.&lt;/li&gt;
&lt;li&gt;무엇을 받아서 무엇으로 바꾸는지 살펴봅니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2D-</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>Convolution의 기초 명령어 Conv2D 예시입니다.</li><li>딥러닝의 일부로서가 아닌 명령어 자체 기능을 봅니다.</li><li>무엇을 받아서 무엇으로 바꾸는지 살펴봅니다.</li></ul><h2 id="1-2D-Convolution"><a href="#1-2D-Convolution" class="headerlink" title="1. 2D Convolution"></a>1. 2D Convolution</h2><blockquote><p><a href="https://www.pyimagesearch.com/2018/12/31/keras-conv2d-and-convolutional-layers/">pyimagesearch: Keras Conv2D and Convolutional Layers</a></p></blockquote><ul><li>convolution, 또는 합성곱 연산은 CNN(Convolution Neural Network)이라는 이름으로 접하신 분이 많을테지만 image processing을 비롯한 signal processing에서 사용되어 온 연산 기법입니다.</li></ul><ul><li>다음 두 가지 특징이 있습니다.<ol><li><b>인접 데이터</b>끼리 연산 (localization)</li><li><b>동일 연산</b>을 전체 데이터에 적용 (weight sharing)<br><br><img src="keras_conv2d_padding.gif" alt="convolution 연산 과정. 출처=pyimagesearch"><br></li></ol></li></ul><h2 id="2-Keras의-Conv2D"><a href="#2-Keras의-Conv2D" class="headerlink" title="2. Keras의 Conv2D"></a>2. Keras의 Conv2D</h2><h3 id="2-1-기본-문법"><a href="#2-1-기본-문법" class="headerlink" title="2.1. 기본 문법"></a>2.1. 기본 문법</h3><blockquote><p><a href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/Conv2D">tf.keras.layers.Conv2D</a></p></blockquote><ul><li>공식 홈페이지에 따르면 입출력은 다음과 같습니다.<ul><li><b>입력 형식</b> : 4차원 이상의 텐서.<br><code>data_format=&#39;channel_first&#39;</code>일 때: <b>batch_shape + (channels, rows, cols)</b>,<br><code>data_format=&#39;channel_last&#39;</code>일 때: <b>batch_shape + (rows, cols, channels)</b>,</li><li><b>출력 형식</b> : 4차원 이상의 텐서.<br><code>data_format=&#39;channel_first&#39;</code>일 때: <b>batch_shape + (filters, rows, cols)</b>,<br><code>data_format=&#39;channel_last&#39;</code>일 때: <b>batch_shape + (rows, cols, filters)</b>,</li></ul></li></ul><ul><li>텐서를 받아 텐서를 출력합니다.</li><li>입력의 channel 자리가 출력의 filter 자리로 바뀝니다.</li><li>또한, rows와 columns는 padding, strides 등에 따라 달라질 수 있습니다.</li></ul><ul><li>텐서를 입력으로 받기 때문에 일반 이미지는 텐서로 변환하여 넣어야 합니다.</li></ul><h3 id="2-2-이미지-입력"><a href="#2-2-이미지-입력" class="headerlink" title="2.2. 이미지 입력"></a>2.2. 이미지 입력</h3><ul><li>텐서플로와 케라스의 버전을 확인합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(tf.__version__)</span><br><span class="line"><span class="built_in">print</span>(tf.keras.__version__)</span><br></pre></td></tr></table></figure><ul><li>실행결과: tensorflow v2.3.1, tf.keras v2.4.0 입니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;2.3.1&#x27;</span></span><br><span class="line"><span class="string">&#x27;2.4.0&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>예제 이미지를 읽어옵니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = plt.imread(<span class="string">&quot;./1-conv2d_1.jpg&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(img))</span><br><span class="line"><span class="built_in">print</span>(img.shape)</span><br><span class="line">plt.imshow(img)</span><br></pre></td></tr></table></figure><ul><li>실행결과 : numpy array 형식, 1080 x 1080 3 channel(RGB) 이미지입니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;</span><br><span class="line">(1080, 1080, 3)</span><br></pre></td></tr></table></figure><img src="1-conv2d_6.png"></li></ul></li></ul><h3 id="2-3-Conv2D-적용-1-1-filter"><a href="#2-3-Conv2D-적용-1-1-filter" class="headerlink" title="2.3. Conv2D 적용 (1) 1 filter"></a>2.3. Conv2D 적용 (1) 1 filter</h3><blockquote><p><a href="https://www.tensorflow.org/api_docs/python/tf/convert_to_tensor">tf.convert_to_tensor</a></p></blockquote><ul><li><p>이미지를 텐서로 변환합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img_tf = tf.convert_to_tensor([img], dtype=<span class="string">&quot;float32&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(img_tf))</span><br><span class="line"><span class="built_in">print</span>(img_tf.shape)</span><br><span class="line"><span class="built_in">print</span>(img_tf.dtype)</span><br></pre></td></tr></table></figure><ul><li>실행결과 : numpy array가 EagerTensor로 변환되었습니다.<pre><code>      3차원을 4차원으로 만들어주기 위해 []를 씌웠습니다.</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;class <span class="string">&#x27;tensorflow.python.framework.ops.EagerTensor&#x27;</span>&gt;</span><br><span class="line">(1, 1080, 1080, 3)</span><br><span class="line">&lt;dtype: <span class="string">&#x27;float32&#x27;</span>&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Convolution을 수행합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conv_1 = layers.Conv2D(<span class="number">1</span>, <span class="number">3</span>, padding=<span class="string">&quot;same&quot;</span>)(img_tf)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(conv_1))</span><br><span class="line"><span class="built_in">print</span>(conv_1.shape)</span><br><span class="line"><span class="built_in">print</span>(conv_1.dtype)</span><br></pre></td></tr></table></figure><ul><li>실행결과 : 1 channel EagerTensor가 출력되었습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;class <span class="string">&#x27;tensorflow.python.framework.ops.EagerTensor&#x27;</span>&gt;</span><br><span class="line">(1, 1080, 1080, 1)</span><br><span class="line">&lt;dtype: <span class="string">&#x27;float32&#x27;</span>&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>matplotlib에서 출력하기 위해 다시 numpy로 변환합니다.</p></li><li><p>연산 범위가 0~1을 넘어갈 수 있으므로 normalize 처리를 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conv_1_np = conv_1.numpy()</span><br><span class="line">plt.imshow((conv_1_np[<span class="number">0</span>]-conv_1_np[<span class="number">0</span>].<span class="built_in">min</span>())/(conv_1_np[<span class="number">0</span>].<span class="built_in">max</span>()-conv_1_np[<span class="number">0</span>].<span class="built_in">min</span>()), cmap=<span class="string">&quot;gist_gray&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행결과 : convolution이 적용되어 그림 모양이 바뀌었습니다.<br><img src="1-conv2d_2.png"></li></ul></li><li><p>그림이 어떻게 바뀔지는 예측할 수 없습니다.</p></li><li><p><code>kernel_initializer</code> 기본값이 <code>glorot_uniform</code>으로, 랜덤이기 때문입니다.</p></li></ul><h3 id="2-3-Conv2D-적용-2-1-filter-x-8회"><a href="#2-3-Conv2D-적용-2-1-filter-x-8회" class="headerlink" title="2.3. Conv2D 적용 (2) 1 filter x 8회"></a>2.3. Conv2D 적용 (2) 1 filter x 8회</h3><ul><li>랜덤한 커널의 영향을 확인해 보겠습니다.</li><li>Conv2D를 반복해서 실행하며 결과가 바뀌는지 확인합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(ncols=<span class="number">4</span>, nrows=<span class="number">2</span>, figsize=(<span class="number">13</span>, <span class="number">6</span>))</span><br><span class="line">axs = axes.ravel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, ax <span class="keyword">in</span> <span class="built_in">enumerate</span>(axs):</span><br><span class="line">    conv_1 = layers.Conv2D(<span class="number">1</span>, <span class="number">3</span>, padding=<span class="string">&quot;same&quot;</span>)(img_tf)</span><br><span class="line">    conv_1_np = conv_1.numpy()</span><br><span class="line">    ax.imshow(conv_1_np[<span class="number">0</span>], cmap=<span class="string">&quot;gist_gray&quot;</span>)</span><br><span class="line">    ax.set_title(<span class="string">f&quot;try <span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><ul><li>실행결과 : 실행할때마다 다른 그림이 나옵니다.<br><img src="1-conv2d_3.png"></li></ul></li></ul><h3 id="2-3-Conv2D-적용-3-16-filter"><a href="#2-3-Conv2D-적용-3-16-filter" class="headerlink" title="2.3. Conv2D 적용 (3) 16 filter"></a>2.3. Conv2D 적용 (3) 16 filter</h3><ul><li>필터의 수를 지정하면 반복된 결과물이 channel로 쌓입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conv_16 = layers.Conv2D(<span class="number">16</span>, <span class="number">3</span>, padding=<span class="string">&quot;same&quot;</span>)(img_tf)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(conv_16))</span><br><span class="line"><span class="built_in">print</span>(conv_16.shape)</span><br><span class="line"><span class="built_in">print</span>(conv_16.dtype)</span><br></pre></td></tr></table></figure><ul><li>실행결과 : 16 channel이 출력됩니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;class <span class="string">&#x27;tensorflow.python.framework.ops.EagerTensor&#x27;</span>&gt;</span><br><span class="line">(1, 1080, 1080, 16)</span><br><span class="line">&lt;dtype: <span class="string">&#x27;float32&#x27;</span>&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>각각의 채널을 출력합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">conv_16_np = conv_16.numpy()</span><br><span class="line">conv_16_norm = (conv_16_np[<span class="number">0</span>]-conv_16_np.<span class="built_in">min</span>())/(conv_16_np.<span class="built_in">max</span>()-conv_16_np.<span class="built_in">min</span>())</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(ncols=<span class="number">4</span>, nrows=<span class="number">4</span>, figsize=(<span class="number">13</span>, <span class="number">13</span>))</span><br><span class="line">axs = axes.ravel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, ax <span class="keyword">in</span> <span class="built_in">enumerate</span>(axs):</span><br><span class="line">    ax.imshow(conv_16_norm[:,:,i], cmap=<span class="string">&quot;gist_gray&quot;</span>)</span><br><span class="line">    ax.set_title(<span class="string">f&quot;Channel <span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><ul><li>실행결과 : 랜덤 커널 적용 결과 16개가 나왔습니다.<br><img src="1-conv2d_5.png"></li></ul></li><li>CNN 학습은 커널의 가중치를 목적에 맞도록 조정하는 과정입니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Deep-Learning/">Deep Learning</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/tensorflow/">tensorflow</category>
      
      <category domain="https://jehyunlee.github.io/tags/keras/">keras</category>
      
      <category domain="https://jehyunlee.github.io/tags/convolution/">convolution</category>
      
      
    </item>
    
    <item>
      <title>Since PyCon, 세상 밖으로</title>
      <link>https://jehyunlee.github.io/2020/11/12/Python-General-8-PyCon2020/</link>
      <guid>https://jehyunlee.github.io/2020/11/12/Python-General-8-PyCon2020/</guid>
      <pubDate>Thu, 12 Nov 2020 07:57:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;PyCon Korea 2020 에서 발표한 라이트닝토크 &lt;b&gt;“Since PyCon, 세상 밖으로”&lt;/b&gt; 영상입니다.&lt;/li&gt;
&lt;li&gt;PyCon Korea 2019에 참여한 이후 제 삶의 변화를 정리한 내용입니다.&lt;/li&gt;
&lt;li&gt;제</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>PyCon Korea 2020 에서 발표한 라이트닝토크 <b>“Since PyCon, 세상 밖으로”</b> 영상입니다.</li><li>PyCon Korea 2019에 참여한 이후 제 삶의 변화를 정리한 내용입니다.</li><li>제가 2019년에 다른 분들의 발표를 보고 큰 용기와 자극을 얻었듯 누군가에게 보탬이 되기를 바라며 올립니다.</li></ul><blockquote><p><a href="https://www.youtube.com/c/PyConKRtube">PyCon Korea 2020 발표 영상 모음</a></p></blockquote><ul><li>제 발표는 9분 28초부터 시작합니다 (<a href="https://youtu.be/s8yBnEcOYN8?t=568">Link</a>)<br></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/s8yBnEcOYN8" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/pycon/">pycon</category>
      
      
    </item>
    
    <item>
      <title>Automatic .gitignore generation</title>
      <link>https://jehyunlee.github.io/2020/11/07/Python-General-7-make_gitignore/</link>
      <guid>https://jehyunlee.github.io/2020/11/07/Python-General-7-make_gitignore/</guid>
      <pubDate>Sat, 07 Nov 2020 10:32:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.github.com/en/free-pro-team@latest/github/using-git/ignoring-files&quot;&gt;GitHub Docs: Ignoring files&lt;/a&gt;&lt;/p</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><a href="https://docs.github.com/en/free-pro-team@latest/github/using-git/ignoring-files">GitHub Docs: Ignoring files</a></p></blockquote><ul><li><b>.gitignore</b> 파일은 git add 할때 <b>이 파일들은 빼놓고 하라</b>는 뜻입니다.</li><li>보안상 민감한 파일일 수도 있고 github 용량제한을 넘어서는 대용량 파일일 수도 있습니다.</li><li>한참 일을 하다보니 발생한 대용량 파일을 잊고 커밋했다가 문제가 되었습니다.</li><li>이를 방지하고자 .gitignore 파일을 자동으로 생성하는 간단한 프로그램을 만들었습니다.</li></ul><h2 id="1-gitignore-파일-구조"><a href="#1-gitignore-파일-구조" class="headerlink" title="1. .gitignore 파일 구조"></a>1. .gitignore 파일 구조</h2><blockquote><p><a href="https://github.com/github/gitignore">github/gitignore</a></p></blockquote><ul><li><p>.gitignore는 아주 간단한 구조를 가지고 있습니다.</p></li><li><p>add하지 않을 파일의 목록을 상대경로로 적어주기만 하면 됩니다.</p></li><li><p>제 .gitignore 파일의 일부입니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data_ml/X_train_full.pkl</span><br><span class="line">data_ml/X3_test_full.pkl</span><br><span class="line">data_ml/X3_train_full.pkl</span><br><span class="line">data_ml/X3_full_poolconv.pkl</span><br></pre></td></tr></table></figure></li><li><p><a href="https://github.com/github/gitignore">더 좋은 구조를 갖춘 .gitignore 파일의 예시</a>를 모아둔 곳도 있습니다</p></li><li><p><a href="https://www.vim.org/">vim</a> 같은 텍스트 편집기로 열어서 항목을 추가하면 됩니다.</p></li></ul><h2 id="2-gitignore-파일-자동-생성-프로그램-제작"><a href="#2-gitignore-파일-자동-생성-프로그램-제작" class="headerlink" title="2. .gitignore 파일 자동 생성 프로그램 제작"></a>2. .gitignore 파일 자동 생성 프로그램 제작</h2><ul><li>용량이 50 MB를 넘어서는 파일을 자동으로 모아 <b>자동으로 .gitignore를 만들어 봅시다.</b></li><li>파일 생성이 귀찮은게 저만은 아니었는지, 이런 일을 하는 프로그램이 종종 보입니다.</li></ul><h3 id="2-1-파이썬-프로그램-제작"><a href="#2-1-파이썬-프로그램-제작" class="headerlink" title="2-1. 파이썬 프로그램 제작"></a>2-1. 파이썬 프로그램 제작</h3><ul><li>다음과 같이 짧은 프로그램을 만듭니다.</li><li><b>make_gitignore.py</b>라는 이름으로 저장했습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">files_50m = <span class="string">&quot;50m.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. find files larger than 50M</span></span><br><span class="line">cmd_50m = <span class="string">f&quot;find -size +50000k &gt; <span class="subst">&#123;files_50m&#125;</span>&quot;</span></span><br><span class="line">os.system(cmd_50m)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. edit lines and save</span></span><br><span class="line">items = []</span><br><span class="line">line = <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(files_50m, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> rf:</span><br><span class="line">    wf = <span class="built_in">open</span>(<span class="string">&quot;.gitignore&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(line):</span><br><span class="line">        line = rf.readline()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;.git&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> line.split(<span class="string">&quot;/&quot;</span>):</span><br><span class="line">            add_item = line.lstrip(<span class="string">&quot;./&quot;</span>)</span><br><span class="line">            items.append(add_item)</span><br><span class="line">            wf.write(add_item)</span><br><span class="line">    wf.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. verification</span></span><br><span class="line">[<span class="built_in">print</span>(item.rstrip(<span class="string">&quot;\n&quot;</span>)) <span class="keyword">for</span> item <span class="keyword">in</span> items]</span><br></pre></td></tr></table></figure></li></ul><ul><li>코드는 이런 작업을 합니다.<ol><li>50MB를 넘는 <b>파일 명단</b> 작성 (50m.txt)</li><li>파일을 열어서 한 줄 한 줄 보면서<br>2-1. <b>.git</b>이 포함된 파일은 무시하고<br>2-2. 상대경로 처음 부분 <b>./ 삭제</b><br>2-3. 바뀐 내용을 <b>.gitignore 파일에 저장</b></li><li><b>목록을 출력</b>합니다.</li></ol></li></ul><h3 id="2-2-alias-설정"><a href="#2-2-alias-설정" class="headerlink" title="2-2. alias 설정"></a>2-2. alias 설정</h3><ul><li>파이썬 프로그램을 만들었지만 이걸 실행하려고 <code>python make_gitignore.py</code>를 입력하기 번거롭습니다.</li><li>그냥 <code>mg</code>만 입력하면 되게 하고 싶네요.</li><li><b>.bashrc</b> 파일을 열고 한 줄 적어줍니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> mg=<span class="string">&#x27;python /workplace/utils/make_gitignore/make_gitignore.py&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>위 줄에서 <code>/workplace/utils/make_gitignore/</code>는 제가 파일을 저장한 경로입니다.</li><li>각자 자기 설정에 맞게 변경하시면 됩니다.</li></ul><h3 id="2-3-환경설정-적용"><a href="#2-3-환경설정-적용" class="headerlink" title="2-3. 환경설정 적용"></a>2-3. 환경설정 적용</h3><ul><li><code>source ~/.bashrc</code>를 해서 바뀐 설정을 적용합니다.</li></ul><h2 id="3-실행"><a href="#3-실행" class="headerlink" title="3. 실행"></a>3. 실행</h2><ul><li>이제 작업공간으로 가서 커밋하기 전에 명령어를 한 줄 실행합니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mg</span><br></pre></td></tr></table></figure><img src="7_mg_1.png"><br></li></ul><ul><li>git <b>add</b>, <b>commit</b>에 이어 <b>push</b>도 해봅니다.<br><br><img src="7_mg_2.png"></li></ul><ul><li>잘 됩니다.</li></ul><p><div style="text-align:center; margin:20px 0px 20px 0px">  <a href="https://donaricano.com/mypage/1543013959_CGtZmr" target="_blank">    <img     src="https://d1u4yishnma8v5.cloudfront.net/donarincano_gift.png"     alt="도움이 되셨나요? 카페인을 투입하시면 다음 포스팅으로 변환됩니다"     style="height:70px !important;width: 200px !important;"     /> </a></div>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/automation/">automation</category>
      
      <category domain="https://jehyunlee.github.io/tags/github/">github</category>
      
      <category domain="https://jehyunlee.github.io/tags/gitignore/">gitignore</category>
      
      
    </item>
    
    <item>
      <title>Shadow Pattern Modeling</title>
      <link>https://jehyunlee.github.io/2020/10/14/GIS-Python-5-shadow/</link>
      <guid>https://jehyunlee.github.io/2020/10/14/GIS-Python-5-shadow/</guid>
      <pubDate>Wed, 14 Oct 2020 01:43:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;태양의 일주운동에 따른 건물 그림자 모델 논문을 구현했습니다.&lt;/li&gt;
&lt;li&gt;pysolar를 이용해 태양의 운동을 계산하고, geopandas를 이용해 그림자 형상을 계산했습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-논문-간단-요약</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>태양의 일주운동에 따른 건물 그림자 모델 논문을 구현했습니다.</li><li>pysolar를 이용해 태양의 운동을 계산하고, geopandas를 이용해 그림자 형상을 계산했습니다.</li></ul><h3 id="1-논문-간단-요약"><a href="#1-논문-간단-요약" class="headerlink" title="1. 논문 간단 요약"></a>1. 논문 간단 요약</h3><blockquote><p>R. Soler-Bientz et al., “Developing a computational tool to assess shadow pattern on a horizontal plane, preliminary results”, IEEE Photovoltaic Specialists Conference p.2312, 2010. doi:10.1109/PVSC.2010.5614490</p></blockquote><ul><li>태양은 아침에 동쪽에서 떠서 남쪽 하늘을 따라 움직이다 저녁이 되면 서쪽으로 넘어갑니다.</li><li>태양광은 아주 멀리서 직진하므로 건물이 만드는 그림자는 태양의 좌표와 건물의 형상으로 구할 수 있습니다.<br><br><img src="5_shadow_11.png"><br></li></ul><ul><li>이 둘을 조합하면 위도와 경도가 다른 지구상 여러 위치에서 건물 그림자를 계산할 수 있습니다.<br><br><img src="5_shadow_12.png"><br></li></ul><ul><li>거의 같은 경도 상에 있는 다섯 도시에서 같은 시간에 생기는 그림자를 그려봅니다.</li><li>위도에 따라 태양의 위치가 달라 다른 방향과 형태의 그림자가 생깁니다.<br><br><img src="5_shadow_13.png"><br></li></ul><h3 id="2-태양-일주운동"><a href="#2-태양-일주운동" class="headerlink" title="2. 태양 일주운동"></a>2. 태양 일주운동</h3><blockquote><p><a href="https://jehyunlee.github.io/2020/10/13/GIS-Python-4-pysolar/">Pega Devlog: pysolar</a><br><a href="https://github.com/pingswept/pysolar">pysolar github</a><br><a href="https://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/points-solar-radiation.htm">ArcGIS: Points Solar Radiation</a></p></blockquote><ul><li>위도와 시간에 따른 태양 고도 변화를 그려봅니다.</li><li>춘분(3월 21일) 06시 일출부터 18시 일몰까지 16등분한 태양의 위치입니다. <ul><li>arcgis에서 360도를 32등분 하더군요.</li></ul></li><li><b>방위각<code>azimuthal angle</code></b>과 <b>고도<code>altitude</code></b>로 그렸습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> pysolar.solar <span class="keyword">import</span> get_altitude, get_azimuth</span><br><span class="line"></span><br><span class="line">lats = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>))</span><br><span class="line">lon = <span class="number">127.3845</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Spring equinox</span></span><br><span class="line">KST = datetime.timezone(datetime.timedelta(hours=<span class="number">9</span>))</span><br><span class="line">date = datetime.datetime(<span class="number">2017</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">0</span>, tzinfo=KST)</span><br><span class="line"></span><br><span class="line"><span class="comment"># data</span></span><br><span class="line">nlats = <span class="built_in">len</span>(lats)</span><br><span class="line">alts_lat = &#123;&#125;</span><br><span class="line">azis_lat = &#123;&#125;</span><br><span class="line">date_hr_lat = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># altitudes and azimuthal angles</span></span><br><span class="line"><span class="keyword">for</span> i, lat <span class="keyword">in</span> <span class="built_in">enumerate</span>(lats):</span><br><span class="line">    alts, azis, dates_hr = [], [], []</span><br><span class="line">    <span class="keyword">for</span> hh <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">24</span>):</span><br><span class="line">        <span class="keyword">for</span> mm <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">60</span>, <span class="number">1</span>):</span><br><span class="line">            date_hr = datetime.datetime(<span class="number">2017</span>, <span class="number">3</span>, <span class="number">21</span>, hh, mm, <span class="number">0</span>, tzinfo=KST)</span><br><span class="line">            dates_hr.append(date_hr)</span><br><span class="line">            alt = get_altitude(lat, lon, date_hr)</span><br><span class="line">            azi = get_azimuth(lat, lon, date_hr)</span><br><span class="line">            alts.append(alt)</span><br><span class="line">            azis.append(azi)</span><br><span class="line"></span><br><span class="line">    date_hr_lat[i] = dates_hr</span><br><span class="line">    alts_lat[i] = np.array(alts)      </span><br><span class="line">    azis_lat[i] = np.array(azis)</span><br><span class="line"></span><br><span class="line">hhmm = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1440</span>))    </span><br><span class="line"></span><br><span class="line">df_azialt = &#123;&#125;</span><br><span class="line">select_values = np.linspace(<span class="number">90</span>, <span class="number">270</span>+<span class="number">11.25</span>, <span class="number">18</span>)</span><br><span class="line">azis_arcgis = &#123;&#125;</span><br><span class="line">alts_arcgis = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, lat <span class="keyword">in</span> <span class="built_in">enumerate</span>(lats):</span><br><span class="line">    df_azialt[i] = pd.DataFrame(&#123;<span class="string">&quot;date_hr&quot;</span>:hhmm, <span class="string">&quot;azimuth&quot;</span>:azis_lat[i], <span class="string">&quot;altitude&quot;</span>:alts_lat[i]&#125;)</span><br><span class="line">    pcut = pd.cut(df_azialt[i][<span class="string">&quot;azimuth&quot;</span>], select_values)</span><br><span class="line">    azis_arcgis[i] = df_azialt[i][<span class="string">&quot;azimuth&quot;</span>].groupby(pcut).nth(<span class="number">0</span>).values</span><br><span class="line">    alts_arcgis[i] = df_azialt[i][<span class="string">&quot;altitude&quot;</span>].groupby(pcut).nth(<span class="number">0</span>).values</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>삽입할 그림을 파워포인트에서 도형으로 그립니다.<br><img src="5_shadow_14.png"><br></p></li><li><p>matplotlib의 <code>.add_axes()</code>를 사용해 <b>그림을 넣을 위치를 지정</b>합니다.</p></li><li><p>그림 삽입 후 <code>.axis(&quot;off&quot;)</code>로 가로 세로 <b>눈금을 떼어버립니다.</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.ticker <span class="keyword">import</span> MultipleLocator</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">lines = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, nlats):</span><br><span class="line">    line = ax.plot(azis_lat[i], alts_lat[i], zorder=<span class="number">1</span>)</span><br><span class="line">    lines.append(line)</span><br><span class="line">    ax.scatter(azis_arcgis[i], alts_arcgis[i], zorder=<span class="number">1.1</span>)</span><br><span class="line">    </span><br><span class="line">ax.set_aspect(<span class="string">&quot;equal&quot;</span>)</span><br><span class="line">ax.set_xlim(<span class="number">90</span>, <span class="number">270</span>)  </span><br><span class="line">ax.set_ylim(<span class="number">0</span>, <span class="number">90</span>)</span><br><span class="line"></span><br><span class="line">xticklabels = [<span class="string">&quot;&quot;</span>]*<span class="built_in">len</span>(ax.get_xticks())</span><br><span class="line">xticklabels[<span class="number">0</span>] = <span class="string">&quot;East&quot;</span></span><br><span class="line">xticklabels[<span class="built_in">int</span>(<span class="built_in">len</span>(ax.get_xticks())/<span class="number">2</span>)] = <span class="string">&quot;South&quot;</span></span><br><span class="line">xticklabels[-<span class="number">1</span>] = <span class="string">&quot;West&quot;</span></span><br><span class="line">ax.set_xticklabels(xticklabels)</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Azimuthal angle&quot;</span>, fontdict=&#123;<span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, labelpad=<span class="number">12</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;Altitude angle (deg.)&quot;</span>, fontdict=&#123;<span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, pad=<span class="number">90</span>)</span><br><span class="line">ax.yaxis.set_major_locator(MultipleLocator(<span class="number">30</span>))</span><br><span class="line"></span><br><span class="line">plt.legend(lats[<span class="number">1</span>:], bbox_to_anchor=(<span class="number">1</span>,<span class="number">1</span>), frameon=<span class="literal">False</span>, title=<span class="string">&quot;Latitude (deg.)&quot;</span>)</span><br><span class="line"></span><br><span class="line">im_sunrise = plt.imread(<span class="string">&quot;sunrise.png&quot;</span>)</span><br><span class="line">ax_sunrise = fig.add_axes([<span class="number">0.06</span>, <span class="number">0.69</span>, <span class="number">0.1</span>, <span class="number">0.1</span>], anchor=<span class="string">&quot;NW&quot;</span>, zorder=<span class="number">2</span>)</span><br><span class="line">ax_sunrise.imshow(im_sunrise)</span><br><span class="line">ax_sunrise.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line"></span><br><span class="line">im_suntop = plt.imread(<span class="string">&quot;suntop.png&quot;</span>)</span><br><span class="line">ax_suntop = fig.add_axes([<span class="number">0.37</span>, <span class="number">0.69</span>, <span class="number">0.1</span>, <span class="number">0.1</span>], anchor=<span class="string">&quot;NW&quot;</span>, zorder=<span class="number">2</span>)</span><br><span class="line">ax_suntop.imshow(im_suntop)</span><br><span class="line">ax_suntop.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">im_sunset = plt.imread(<span class="string">&quot;sunset.png&quot;</span>)</span><br><span class="line">ax_sunset = fig.add_axes([<span class="number">0.68</span>, <span class="number">0.69</span>, <span class="number">0.1</span>, <span class="number">0.1</span>], anchor=<span class="string">&quot;NW&quot;</span>, zorder=<span class="number">2</span>)</span><br><span class="line">ax_sunset.imshow(im_sunset)</span><br><span class="line">ax_sunset.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><p><img src="5_shadow_3.png"><br></p></li></ul><h3 id="3-건물-그리기"><a href="#3-건물-그리기" class="headerlink" title="3. 건물 그리기"></a>3. 건물 그리기</h3><blockquote><p><a href="https://jehyunlee.github.io/2020/09/14/GIS-Python-2-PolygonShapefile/">Pega Devlog: Create Shapefile from Polygon Dots</a><br><a href="https://jehyunlee.github.io/2020/09/21/GIS-Python-3-raster_and_polygon/">Pega Devlog: Mapping Shapefile on Raster Map</a><br><a href="https://geopandas.org/reference/geopandas.GeoDataFrame.html">geopandas: GeoDataFrame</a></p></blockquote><ul><li>좌표로 사각형을 만드는 함수입니다.</li><li><a href="https://jehyunlee.github.io/2020/09/14/GIS-Python-2-PolygonShapefile/">지난 글</a>에서는 파일로 저장했지만 이번엔 <b>메모리</b>에 올려서 사용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> MultiPoint</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_rec</span>(<span class="params">x, y, width, length, angle</span>):</span></span><br><span class="line">    l_half = length/<span class="number">2</span></span><br><span class="line">    w_half = width/<span class="number">2</span></span><br><span class="line">    a_rad = np.deg2rad(angle)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_coord</span>(<span class="params">l_half, w_half, a_rad</span>):</span></span><br><span class="line">        X = x + l_half * np.sin(a_rad) - w_half * np.cos(a_rad)</span><br><span class="line">        Y = y + l_half * np.cos(a_rad) + w_half * np.sin(a_rad)</span><br><span class="line">        <span class="keyword">return</span> (X, Y)</span><br><span class="line">    </span><br><span class="line">    points = [get_coord(l_half, w_half, a_rad),</span><br><span class="line">              get_coord(-l_half, w_half, a_rad),</span><br><span class="line">              get_coord(-l_half, -w_half, a_rad),</span><br><span class="line">              get_coord(l_half, -w_half, a_rad)</span><br><span class="line">             ]</span><br><span class="line">    </span><br><span class="line">    rec = gpd.GeoDataFrame(&#123;<span class="string">&quot;points&quot;</span>:[points], <span class="string">&quot;geometry&quot;</span>:[MultiPoint(points).convex_hull]&#125;)</span><br><span class="line">    <span class="keyword">return</span> rec</span><br></pre></td></tr></table></figure></li></ul><ul><li>이렇게 만들어진 도형은 <code>geopandas</code>의 GeoDataFrame입니다.</li><li>GeoDataFrame은 <b><code>geometry</code></b>와 함께 <b>다른 데이터</b>를 담을 수 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rec = create_rec(<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">45</span>)</span><br><span class="line">rec</span><br></pre></td></tr></table></figure><img src="5_shadow_15.png"><br></li></ul><ul><li>그린 건물을 확인합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots()</span><br><span class="line">rec.plot(ax=ax)</span><br></pre></td></tr></table></figure><img src="5_shadow_2.png"><br></li></ul><h3 id="4-그림자-그리기"><a href="#4-그림자-그리기" class="headerlink" title="4. 그림자 그리기"></a>4. 그림자 그리기</h3><h4 id="4-1-도시별-시간별-태양-위치"><a href="#4-1-도시별-시간별-태양-위치" class="headerlink" title="4.1. 도시별, 시간별 태양 위치"></a>4.1. 도시별, 시간별 태양 위치</h4><blockquote><p><a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time">wikipedia: Coordinated Universal Time</a><br><a href="https://docs.python.org/3.7/library/datetime.html">python: datetime</a></p></blockquote><ul><li>그림자는 <b>태양 위치</b>와 <b>건물 모양</b>의 결과물입니다.<ul><li>태양의 위치는 <b>시간</b>에 대한 함수로 주어집니다.</li><li>그리고 시간은 <a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time">협정 세계시</a>에 따라 <b>위치</b>별로 다릅니다.<br></li></ul></li></ul><ul><li><p>논문에서 제시한 5개 도시는 거의 <b>동경 75도</b>상에 위치합니다.</p></li><li><p>그러나 적용 시간대가 다릅니다.</p></li><li><p>위의 세 도시는 <b>UTC-5</b>, 아래 두 도시는 <b>UTC-4</b>를 따릅니다.<br><br><img src="5_shadow_16.png"><br></p></li><li><p>도시별 데이터를 만들어 줍니다.</p></li><li><p>Antofagasta와 Los Lagos는 UTC-4입니다.</p></li><li><p>그러나 <b>논문 결과는 UTC-5</b>를 넣어야 구현됩니다.</p></li><li><p>저자의 실수로 생각됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cities = [<span class="string">&quot;Philadelphia&quot;</span>, <span class="string">&quot;Adderly&quot;</span>, <span class="string">&quot;Agua Blanca&quot;</span>, <span class="string">&quot;Antofagasta&quot;</span>, <span class="string">&quot;Los Lagos&quot;</span>]</span><br><span class="line">lats = [<span class="number">39</span>+<span class="number">57</span>/<span class="number">60</span>, <span class="number">23</span>+<span class="number">36</span>/<span class="number">60</span>, -<span class="number">2</span>/<span class="number">60</span>, -(<span class="number">23</span>+<span class="number">39</span>/<span class="number">60</span>), -(<span class="number">39</span>+<span class="number">51</span>/<span class="number">60</span>)]</span><br><span class="line">lons = [-(<span class="number">75</span>+<span class="number">9</span>/<span class="number">60</span>), -(<span class="number">75</span>+<span class="number">18</span>/<span class="number">60</span>), -(<span class="number">75</span>+<span class="number">12</span>/<span class="number">60</span>), -(<span class="number">72</span>+<span class="number">0</span>/<span class="number">60</span>), -(<span class="number">72</span>+<span class="number">50</span>/<span class="number">60</span>)]  <span class="comment"># negative for East Longitude</span></span><br><span class="line">TZs = [-<span class="number">5</span>, -<span class="number">5</span>, -<span class="number">5</span>, -<span class="number">5</span>, -<span class="number">5</span>]  <span class="comment"># &quot;Antofagasta&quot;, &quot;Los Lagos&quot; 데이터 오류?</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>각 <b>도시별, 시간대별 태양의 방위각과 고도</b>를 구합니다.</li><li>시간도 다르기 때문에 <b>도시별 timezone 설정</b>을 해 줍니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### data</span></span><br><span class="line">nlats = <span class="built_in">len</span>(lats)</span><br><span class="line">alts_lat = &#123;&#125;</span><br><span class="line">azis_lat = &#123;&#125;</span><br><span class="line">date_hr_lat = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### altitudes and azimuthal angles</span></span><br><span class="line"><span class="keyword">for</span> i, (lat, lon, TZ) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(lats, lons, TZs)):</span><br><span class="line">    <span class="comment"># timezone</span></span><br><span class="line">    tz = datetime.timezone(datetime.timedelta(hours=TZ))</span><br><span class="line">    </span><br><span class="line">    alts, azis, dates_hr = [], [], []</span><br><span class="line">    <span class="keyword">for</span> hh <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">24</span>):</span><br><span class="line">        <span class="keyword">for</span> mm <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">60</span>, <span class="number">30</span>):</span><br><span class="line">            date_hr = datetime.datetime(<span class="number">2008</span>, <span class="number">3</span>, <span class="number">21</span>, hh, mm, <span class="number">0</span>, tzinfo=tz)</span><br><span class="line">            dates_hr.append(date_hr)</span><br><span class="line">            alt = get_altitude(lat, lon, date_hr)</span><br><span class="line">            azi = get_azimuth(lat, lon, date_hr)</span><br><span class="line">            alts.append(alt)</span><br><span class="line">            azis.append(azi)</span><br><span class="line"></span><br><span class="line">    date_hr_lat[i] = dates_hr</span><br><span class="line">    alts = np.array(alts)      </span><br><span class="line">    alts_lat[i] = alts</span><br><span class="line">    azis = np.array(azis)</span><br><span class="line">    azis_lat[i] = azis</span><br></pre></td></tr></table></figure></li></ul><ul><li>결과를 dataframe으로 정리합니다.</li><li><code>datetime.strftime()</code>을 사용해 <b>시각</b>과 <b>분</b>을 추출하고</li><li>방위각과 고도를 이용해 <b>그림자 끝점</b>을 추출합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">df_solars = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, lat <span class="keyword">in</span> <span class="built_in">enumerate</span>(lats):</span><br><span class="line">    df_solar = pd.DataFrame(&#123;<span class="string">&quot;hh&quot;</span>:[date_hr_lat[i][j].strftime(<span class="string">&quot;%H&quot;</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span>)],</span><br><span class="line">                             <span class="string">&quot;mm&quot;</span>:[date_hr_lat[i][j].strftime(<span class="string">&quot;%M&quot;</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span>)],</span><br><span class="line">                             <span class="string">&quot;azimuth&quot;</span>: azis_lat[i],</span><br><span class="line">                             <span class="string">&quot;altitude&quot;</span>: alts_lat[i],</span><br><span class="line">                             <span class="string">&quot;projection&quot;</span>: np.sin(np.deg2rad(alts_lat[i]))</span><br><span class="line">                            &#125;)</span><br><span class="line">    df_solar[<span class="string">&quot;shadow_len&quot;</span>] = df_solar[<span class="string">&quot;altitude&quot;</span>].apply(<span class="keyword">lambda</span> x: <span class="number">1</span>/np.tan(np.deg2rad(x)) <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> np.nan)</span><br><span class="line">    df_solar[<span class="string">&quot;shadow_dx&quot;</span>] = -df_solar[<span class="string">&quot;shadow_len&quot;</span>] * np.sin(np.deg2rad(df_solar[<span class="string">&quot;azimuth&quot;</span>]))</span><br><span class="line">    df_solar[<span class="string">&quot;shadow_dy&quot;</span>] = -df_solar[<span class="string">&quot;shadow_len&quot;</span>] * np.cos(np.deg2rad(df_solar[<span class="string">&quot;azimuth&quot;</span>]))</span><br><span class="line">    </span><br><span class="line">    df_solars[i] = df_solar</span><br></pre></td></tr></table></figure></li></ul><ul><li>데이터를 확인해 봅니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_solars[<span class="number">0</span>].loc[<span class="number">10</span>:<span class="number">15</span>]</span><br></pre></td></tr></table></figure><img src="5_shadow_17.png"></li></ul><h4 id="4-2-그림자-그리기-함수"><a href="#4-2-그림자-그리기-함수" class="headerlink" title="4.2. 그림자 그리기 함수"></a>4.2. 그림자 그리기 함수</h4><blockquote><p><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/style.html">pandas: styling</a></p></blockquote><ul><li><p>상자 모양 건물의 그림자를 그립니다.</p><ul><li>네 꼭지점에서 각기 <b>그림자 포인트</b>를 찾고</li><li>건물 밑의 <b>네 꼭지점</b>을 연결합니다.</li></ul></li><li><p>앞에서 구해둔 데이터프레임을 이용합니다.</p></li><li><p><code>shadow_dx</code>, <code>shadow_dy</code>를 적용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shadows</span>(<span class="params">src_x, src_y, src_width, src_length, src_height, src_angle, df_solar</span>):</span></span><br><span class="line">    <span class="comment"># shadow points</span></span><br><span class="line">    s_points = []</span><br><span class="line">    rec = create_rec(src_x, src_y, src_width, src_length, src_angle)</span><br><span class="line">    points = rec.loc[<span class="number">0</span>, <span class="string">&quot;points&quot;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> px, py <span class="keyword">in</span> points:</span><br><span class="line">        sx = px + src_height * df_solar[<span class="string">&quot;shadow_dx&quot;</span>].values</span><br><span class="line">        sy = py + src_height * df_solar[<span class="string">&quot;shadow_dy&quot;</span>].values</span><br><span class="line">        s_points.append(<span class="built_in">list</span>(<span class="built_in">zip</span>(sx, sy)))</span><br><span class="line">    </span><br><span class="line">    shadows_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(df_solar.shape[<span class="number">0</span>]):</span><br><span class="line">        mpoints_i = MultiPoint(points + np.array(s_points)[:,i].tolist())</span><br><span class="line">        shadows_list.append(mpoints_i)</span><br><span class="line">    </span><br><span class="line">    shadows = gpd.GeoDataFrame(&#123;<span class="string">&quot;geometry&quot;</span>:shadows_list&#125;)</span><br><span class="line">    <span class="keyword">return</span> shadows</span><br></pre></td></tr></table></figure></li></ul><ul><li>테스트를 해 봅니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shadows_test1 = get_shadows(<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">45</span>, df_solars[<span class="number">0</span>])</span><br><span class="line">shadows_test1.head()</span><br></pre></td></tr></table></figure><img src="5_shadow_18.png"></li></ul><ul><li>그림으로 그려봅니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shadows_test1.loc[<span class="number">17</span>, <span class="string">&quot;geometry&quot;</span>]</span><br></pre></td></tr></table></figure><img src="5_shadow_19.png"></li></ul><ul><li>오른쪽 네 개의 점은 바닥면 점,</li><li>왼쪽 네 개의 점은 윗면이 만든 그림자 점입니다.</li><li>위 함수 15번째 줄에 <code>convex_hull</code>을 넣어 면을 만듭니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shadows_list.append(mpoints_i.convex_hull)</span><br></pre></td></tr></table></figure></li></ul><ul><li>다시 그려봅니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shadows_test2 = get_shadows(<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">45</span>, df_solars[<span class="number">0</span>])</span><br><span class="line">shadows_test2.loc[<span class="number">17</span>, <span class="string">&quot;geometry&quot;</span>]</span><br></pre></td></tr></table></figure><img src="5_shadow_20.png"></li></ul><ul><li>앞서 계산한 <b>태양의 이동</b>을 따라 그림자를 그립니다.</li><li>논문에서 제시한 <b>9:30 AM의 그림자</b>를 추가로 그립니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Circle</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(ncols=<span class="number">5</span>, nrows=<span class="number">2</span>, figsize=(<span class="number">15</span>, <span class="number">6</span>))</span><br><span class="line">axs = axes.ravel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    paper_im = plt.imread(<span class="string">f&quot;paper_<span class="subst">&#123;i&#125;</span>.png&quot;</span>)</span><br><span class="line">    axs[i].imshow(paper_im)</span><br><span class="line">    axs[i].set_xticks([])</span><br><span class="line">    axs[i].set_yticks([])</span><br><span class="line">    [axs[i].spines[k].set_edgecolor(<span class="string">&quot;lightgray&quot;</span>) <span class="keyword">for</span> k <span class="keyword">in</span> axs[i].spines.keys()]</span><br><span class="line">    </span><br><span class="line">    axs[i].set_title(cities[i], fontdict=&#123;<span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, pad=<span class="number">16</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        axs[i].set_ylabel(<span class="string">&quot;Soler-Bientz\net al.&quot;</span>, rotation=<span class="number">0</span>, labelpad=<span class="number">56</span>, </span><br><span class="line">                          fontdict=&#123;<span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>, <span class="string">&quot;ha&quot;</span>:<span class="string">&quot;center&quot;</span>, <span class="string">&quot;va&quot;</span>:<span class="string">&quot;center&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">10</span>):</span><br><span class="line">    shadow = get_shadows_2(<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">45</span>, df_solars[i-<span class="number">5</span>])</span><br><span class="line">    shadow.plot(ax=axs[i], facecolor=<span class="string">&quot;gray&quot;</span>, edgecolor=<span class="string">&quot;w&quot;</span>, alpha=<span class="number">0.1</span>, zorder=<span class="number">1</span>)</span><br><span class="line">    shadow_930.idx = df_solars[i-<span class="number">5</span>].loc[df_solars[i-<span class="number">5</span>][<span class="string">&quot;hh&quot;</span>] == <span class="string">&quot;09&quot;</span>].loc[df_solars[i-<span class="number">5</span>][<span class="string">&quot;mm&quot;</span>] == <span class="string">&quot;30&quot;</span>].index[<span class="number">0</span>]</span><br><span class="line">    shadow_930 = gpd.GeoDataFrame(&#123;<span class="string">&quot;geometry&quot;</span>:[shadow.loc[<span class="number">19</span>, <span class="string">&quot;geometry&quot;</span>]]&#125;)</span><br><span class="line">    shadow_930.plot(ax=axs[i], facecolor=<span class="string">&quot;gray&quot;</span>, edgecolor=<span class="string">&quot;k&quot;</span>, linewidth=<span class="number">1</span>, zorder=<span class="number">2</span>)</span><br><span class="line">    rec.plot(ax=axs[i], zorder=<span class="number">3</span>, facecolor=<span class="string">&quot;w&quot;</span>, edgecolor=<span class="string">&quot;k&quot;</span>, linewidth=<span class="number">1</span>)</span><br><span class="line">    axs[i].set_xlim(-<span class="number">21</span>, <span class="number">21</span>)</span><br><span class="line">    axs[i].set_ylim(-<span class="number">21</span>, <span class="number">21</span>)</span><br><span class="line">    axs[i].set_xticks([])</span><br><span class="line">    axs[i].set_yticks([])</span><br><span class="line">    [axs[i].spines[k].set_edgecolor(<span class="string">&quot;lightgray&quot;</span>) <span class="keyword">for</span> k <span class="keyword">in</span> axs[i].spines.keys()]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># patches</span></span><br><span class="line">    circle = Circle((<span class="number">0</span>, <span class="number">0</span>), <span class="number">15</span>, linewidth=<span class="number">0.5</span>, edgecolor=<span class="string">&quot;gray&quot;</span>, fill=<span class="literal">False</span>)</span><br><span class="line">    axs[i].add_patch(circle)</span><br><span class="line">    axs[i].plot([-<span class="number">15</span>, <span class="number">15</span>], [<span class="number">0</span>, <span class="number">0</span>], linewidth=<span class="number">0.5</span>, color=<span class="string">&quot;gray&quot;</span> )</span><br><span class="line">    axs[i].plot([<span class="number">0</span>, <span class="number">0</span>], [-<span class="number">15</span>, <span class="number">15</span>], linewidth=<span class="number">0.5</span>, color=<span class="string">&quot;gray&quot;</span> )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># annotates</span></span><br><span class="line">    axs[i].annotate(<span class="string">&quot;W&quot;</span>, (-<span class="number">17.5</span>, <span class="number">0</span>), ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;12&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">    axs[i].annotate(<span class="string">&quot;E&quot;</span>, (<span class="number">17.5</span>, <span class="number">0</span>), ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;12&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">    axs[i].annotate(<span class="string">&quot;S&quot;</span>, (<span class="number">0</span>, -<span class="number">17.5</span>), ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;12&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">    axs[i].annotate(<span class="string">&quot;N&quot;</span>, (<span class="number">0</span>, <span class="number">17.5</span>), ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;12&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span>:</span><br><span class="line">        axs[i].set_ylabel(<span class="string">&quot;Jehyun Lee\n(Pega)&quot;</span>, rotation=<span class="number">0</span>, labelpad=<span class="number">56</span>, </span><br><span class="line">                          fontdict=&#123;<span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>, <span class="string">&quot;ha&quot;</span>:<span class="string">&quot;center&quot;</span>, <span class="string">&quot;va&quot;</span>:<span class="string">&quot;center&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">fig.align_ylabels([axs[<span class="number">0</span>], axs[<span class="number">5</span>]])            </span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><img src="5_shadow_10.png"></li></ul><ul><li><b>논문 그림이 거의 똑같이 재현</b>되었습니다.</li><li>태양 <b>방위각</b>, <b>고도</b>와 <b>그림자 넓이</b>를 수치로 비교합시다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shadow area at 9:30</span></span><br><span class="line">azis_summary = []</span><br><span class="line">alts_summary = []</span><br><span class="line">areas_summary = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nlats):</span><br><span class="line">    azi = df_solars[i].loc[<span class="number">19</span>, <span class="string">&quot;azimuth&quot;</span>]</span><br><span class="line">    alt = df_solars[i].loc[<span class="number">19</span>, <span class="string">&quot;altitude&quot;</span>]</span><br><span class="line">    shadow = get_shadows_2(<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">45</span>, df_solars[i])</span><br><span class="line">    shadow_930 = gpd.GeoDataFrame(&#123;<span class="string">&quot;geometry&quot;</span>:[shadow.loc[<span class="number">19</span>, <span class="string">&quot;geometry&quot;</span>]]&#125;)</span><br><span class="line">    </span><br><span class="line">    azis_summary.append(azi-<span class="number">180</span>)</span><br><span class="line">    alts_summary.append(alt)</span><br><span class="line">    areas_summary.append(shadow_930.area.values[<span class="number">0</span>] - <span class="number">24</span>)</span><br><span class="line">    </span><br><span class="line">df_summary = pd.DataFrame(&#123;<span class="string">&quot;Cities&quot;</span>: cities, </span><br><span class="line">                           <span class="string">&quot;azimuth (deg.)&quot;</span>: azis_summary, </span><br><span class="line">                           <span class="string">&quot;altitude (deg.)&quot;</span>: alts_summary, </span><br><span class="line">                           <span class="string">&quot;area (m2)&quot;</span>: areas_summary&#125;)</span><br><span class="line"></span><br><span class="line">df_summary.style.<span class="built_in">format</span>(&#123;<span class="string">&quot;azimuth (deg.)&quot;</span>:<span class="string">&quot;&#123;:.1f&#125;&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;altitude (deg.)&quot;</span>:<span class="string">&quot;&#123;:.1f&#125;&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;area (m2)&quot;</span>:<span class="string">&quot;&#123;:.0f&#125;&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><img src="5_shadow_21.png"></li></ul><ul><li>수치적으로도 <b>거의 똑같이 재현되었습니다.</b></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/GIS/">GIS</category>
      
      <category domain="https://jehyunlee.github.io/categories/GIS/Python/">Python</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/gis/">gis</category>
      
      <category domain="https://jehyunlee.github.io/tags/pysolar/">pysolar</category>
      
      <category domain="https://jehyunlee.github.io/tags/shadow/">shadow</category>
      
      
    </item>
    
    <item>
      <title>pysolar</title>
      <link>https://jehyunlee.github.io/2020/10/13/GIS-Python-4-pysolar/</link>
      <guid>https://jehyunlee.github.io/2020/10/13/GIS-Python-4-pysolar/</guid>
      <pubDate>Mon, 12 Oct 2020 22:46:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;태양 위치 계산은 성가십니다.&lt;/li&gt;
&lt;li&gt;날짜별, 시간별, 위치별 태양의 위치를 알고싶다면 pysolar가 편리합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://pypi.org/project/</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>태양 위치 계산은 성가십니다.</li><li>날짜별, 시간별, 위치별 태양의 위치를 알고싶다면 pysolar가 편리합니다.</li></ul><blockquote><p><a href="https://pypi.org/project/Pysolar/">pysolar pypi</a><br><a href="https://github.com/pingswept/pysolar">pysolar github</a><br><a href="https://pysolar.readthedocs.io/en/latest/">pysolar documentation</a></p></blockquote><h3 id="1-pysolar-설치"><a href="#1-pysolar-설치" class="headerlink" title="1. pysolar 설치"></a>1. pysolar 설치</h3><ul><li>pip로 간단하게 설치할 수 있습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pysolar</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-pysolar-사용"><a href="#2-pysolar-사용" class="headerlink" title="2. pysolar 사용"></a>2. pysolar 사용</h3><ul><li>pysolar를 사용하려면 <code>import</code>를 해야 합니다.</li><li>pysolar를 import 하고 모듈을 확인해보면 뭔가 많습니다.</li><li>그런데 <a href="https://pysolar.readthedocs.io/en/latest/">공식문서</a>에 설명이 잘 나와 있지 않아 아쉽습니다.<br><br><img src="4_pysolar_3.png"></li></ul><ul><li>일시와 위치를 넣어주면 태양에 대한 정보를 알려줍니다.</li><li>일시는 <code>datetime</code>을 이용해 설정합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">KST = datetime.timezone(datetime.timedelta(hours=<span class="number">9</span>))</span><br><span class="line">date = datetime.datetime(<span class="number">2017</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">0</span>, tzinfo=KST)</span><br><span class="line">date</span><br></pre></td></tr></table></figure>실행결과: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datetime.datetime(2017, 3, 21, 13, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=32400)))</span><br></pre></td></tr></table></figure></li></ul><ul><li>그리고 태양을 관찰할 지점을 지정합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Daejeon</span></span><br><span class="line">lat = <span class="number">36.3504</span></span><br><span class="line">lon = <span class="number">127.3845</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-1-고도altitude"><a href="#2-1-고도altitude" class="headerlink" title="2.1. 고도altitude"></a>2.1. 고도<code>altitude</code></h4><ul><li>지표면으로부터의 각도입니다.</li><li><code>.get_altitude()</code>를 사용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pysolar.solar <span class="keyword">import</span> get_altitude</span><br><span class="line"></span><br><span class="line">alt = get_altitude(lat, lon, date)</span><br><span class="line">alt</span><br></pre></td></tr></table></figure>실행결과: 출력 단위는 degree 입니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">53.57702210048166</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-방위각azimuthal-angle"><a href="#2-2-방위각azimuthal-angle" class="headerlink" title="2.2. 방위각azimuthal angle"></a>2.2. 방위각<code>azimuthal angle</code></h4><ul><li>정북 기준 시계방향 각도입니다.</li><li><code>.get_azimuth()</code>를 사용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pysolar.solar <span class="keyword">import</span> get_azimuth</span><br><span class="line"></span><br><span class="line">azi = get_azimuth(lat, lon, date)</span><br><span class="line">azi</span><br></pre></td></tr></table></figure>실행결과: 출력 단위는 degree 입니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">189.44917229657798</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-일사량radiation"><a href="#2-3-일사량radiation" class="headerlink" title="2.3. 일사량radiation"></a>2.3. 일사량<code>radiation</code></h3><blockquote><p><a href="https://pysolar.readthedocs.io/en/latest/index.html?highlight=get_radiation_direct#">pysolar get_radiation_direct()</a></p></blockquote><ul><li>pysolar가 제공하는 일사량에는 <b>대기에 의한 산란</b>이 포함되어 있습니다.</li><li>이 때 <b>대기모델은 미국 기준</b>이기 때문에 데이터 활용에 주의해야 합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pysolar.radiation <span class="keyword">import</span> get_radiation_direct</span><br><span class="line"></span><br><span class="line">rad = get_radiation_direct(date, alt)</span><br><span class="line">rad</span><br></pre></td></tr></table></figure>실행결과: 단위는 <b>$W/m^2$</b> 입니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">961.3376847317991</span><br></pre></td></tr></table></figure></li></ul><ul><li>다음과 같은 수식으로 구성되어 있습니다.</li><li>일사량 $$\textrm{direct radiation} = flux \times exp(-1 \times od \times amr) \times daytime$$<ul><li>$$day$$ : <code>datetime.utctimetuple().tm_yday</code></li><li>$$daytime$$ : <code>1 if altitude &gt; 0 else 0</code></li><li>apparent extraterrestrial flux : $$flux = 1160+(75\sin( \frac{2 \pi}{365}(day-275)))$$</li><li>optical depth : $$od = 0.174+(0.035\sin(\frac{2 \pi}{365}(day-100))$$</li><li>air mass ratio : $$amr = 1/\sin(altitude)$$</li></ul></li></ul><h3 id="2-4-시각화"><a href="#2-4-시각화" class="headerlink" title="2.4. 시각화"></a>2.4. 시각화</h3><ul><li>2017년 춘분 다른 위도의 일주운동을 그려봅니다.<ol><li><b>방위각</b> vs <b>고도</b></li><li><b>시간</b> vs <b>고도</b></li><li><b>시간</b> vs <b>일사량</b> (pysolar 제공)</li><li><b>시간</b> vs <b>사상</b> (projection)</li></ol></li><li>극좌표와 직교좌표계를 동시에를 담습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> matplotlib.ticker <span class="keyword">import</span> MultipleLocator, AutoMinorLocator</span><br><span class="line"></span><br><span class="line">lats = [<span class="number">45</span>, <span class="number">23.5</span>, <span class="number">1</span>, -<span class="number">23.5</span>, -<span class="number">45</span>]</span><br><span class="line">lon = <span class="number">127.3845</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### data</span></span><br><span class="line">nlats = <span class="built_in">len</span>(lats)</span><br><span class="line">alts_lat = &#123;&#125;</span><br><span class="line">azis_lat = &#123;&#125;</span><br><span class="line">date_hr_lat = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### altitudes and azimuthal angles</span></span><br><span class="line"><span class="keyword">for</span> i, lat <span class="keyword">in</span> <span class="built_in">enumerate</span>(lats, <span class="number">1</span>):</span><br><span class="line">    alts, azis, dates_hr = [], [], []</span><br><span class="line">    <span class="keyword">for</span> hr <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">24</span>):</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">min</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">60</span>, <span class="number">1</span>):</span><br><span class="line">            date_hr = datetime.datetime(<span class="number">2017</span>, <span class="number">3</span>, <span class="number">20</span>, hr, <span class="built_in">min</span>, <span class="number">0</span>, tzinfo=KST)</span><br><span class="line">            dates_hr.append(date_hr)</span><br><span class="line">            alt = get_altitude(lat, lon, date_hr)</span><br><span class="line">            azi = get_azimuth(lat, lon, date_hr)</span><br><span class="line">            alts.append(alt)</span><br><span class="line">            azis.append(azi)</span><br><span class="line"></span><br><span class="line">    date_hr_lat[i] = dates_hr</span><br><span class="line">    alts = np.array(alts)      </span><br><span class="line">    alts_lat[i] = alts</span><br><span class="line">    azis = np.array(azis)</span><br><span class="line">    azis_lat[i] = azis</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">### Figure</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">30</span>,<span class="number">24</span>))</span><br><span class="line">axs = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, (lat) <span class="keyword">in</span> <span class="built_in">enumerate</span>(lats, <span class="number">1</span>):  </span><br><span class="line">    axs[i] = fig.add_subplot(<span class="number">5</span>, nlats, i, projection=<span class="string">&#x27;polar&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    axs[i].set_theta_zero_location(<span class="string">&quot;N&quot;</span>)</span><br><span class="line">    axs[i].set_theta_direction(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    axs[i].plot(np.deg2rad(azis_lat[i]), alts_lat[i], c=<span class="string">&quot;k&quot;</span>, zorder=<span class="number">1</span>)</span><br><span class="line">    axs[i].scatter(np.deg2rad(azis_lat[i]), alts_lat[i], c=alts_lat[i], </span><br><span class="line">                   cmap=<span class="string">&quot;inferno&quot;</span>, zorder=<span class="number">2</span>, vmin=<span class="number">0</span>, vmax=<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line">    axs[i].fill(np.deg2rad(azis_lat[i]), [<span class="number">0</span>]*<span class="built_in">len</span>(azis_lat[i]), <span class="string">&quot;gray&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">    axs[i].set_ylim(-<span class="number">80</span>, <span class="number">90</span>)</span><br><span class="line">    axs[i].set_title(<span class="string">f&quot;<span class="subst">&#123;lat&#125;</span>&quot;</span> + <span class="string">&quot; $^&#123;\circ&#125;$&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">32</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, pad=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># azimuth vs altitude</span></span><br><span class="line">hrs = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1440</span>))</span><br><span class="line"><span class="keyword">for</span> i, (lat) <span class="keyword">in</span> <span class="built_in">enumerate</span>(lats, nlats+<span class="number">1</span>):  </span><br><span class="line">    axs[i] = fig.add_subplot(<span class="number">5</span>, nlats, i)</span><br><span class="line">    axs[i].scatter(azis_lat[i-nlats], alts_lat[i-nlats], c=alts_lat[i-nlats], </span><br><span class="line">                   cmap=<span class="string">&quot;inferno&quot;</span>, zorder=<span class="number">2</span>, vmin=<span class="number">0</span>, vmax=<span class="number">90</span>)</span><br><span class="line">    </span><br><span class="line">    axs[i].xaxis.set_major_locator(MultipleLocator(<span class="number">180</span>))</span><br><span class="line">    axs[i].xaxis.set_minor_locator(MultipleLocator(<span class="number">60</span>))</span><br><span class="line">    </span><br><span class="line">    axs[i].set_xlim(<span class="number">0</span>, <span class="number">360</span>)</span><br><span class="line">    axs[i].set_ylim(-<span class="number">90</span>, <span class="number">100</span>)</span><br><span class="line">    yticks = [-<span class="number">90</span>, -<span class="number">60</span>, -<span class="number">30</span>, <span class="number">0</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">90</span>]</span><br><span class="line">    axs[i].set_yticks(yticks)</span><br><span class="line">    axs[i].set_yticklabels(yticks)</span><br><span class="line">    axs[i].tick_params(axis=<span class="string">&quot;both&quot;</span>, labelsize=<span class="number">20</span>)</span><br><span class="line">    axs[i].fill_between(hrs, -<span class="number">90</span>, <span class="number">0</span>, facecolor=<span class="string">&quot;gray&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">    axs[i].set_xlabel(<span class="string">&quot;azimuthal angle (deg.)&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">24</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, labelpad=<span class="number">12</span>)</span><br><span class="line">    <span class="keyword">if</span> i == nlats+<span class="number">1</span>:</span><br><span class="line">        axs[i].set_ylabel(<span class="string">&quot;altitude A (deg.)&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">24</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, labelpad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># time vs altitude</span></span><br><span class="line">hrs = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1440</span>))</span><br><span class="line"><span class="keyword">for</span> i, (lat) <span class="keyword">in</span> <span class="built_in">enumerate</span>(lats, <span class="number">2</span>*nlats+<span class="number">1</span>):  </span><br><span class="line">    axs[i] = fig.add_subplot(<span class="number">5</span>, nlats, i)</span><br><span class="line">    axs[i].scatter(hrs, alts_lat[i-<span class="number">2</span>*nlats], c=alts_lat[i-<span class="number">2</span>*nlats], </span><br><span class="line">                   cmap=<span class="string">&quot;inferno&quot;</span>, zorder=<span class="number">2</span>, vmin=<span class="number">0</span>, vmax=<span class="number">90</span>)</span><br><span class="line">    </span><br><span class="line">    axs[i].xaxis.set_major_locator(MultipleLocator(<span class="number">180</span>))</span><br><span class="line">    axs[i].xaxis.set_minor_locator(MultipleLocator(<span class="number">60</span>))</span><br><span class="line">    </span><br><span class="line">    axs[i].set_xlim(<span class="number">0</span>, <span class="number">1440</span>)</span><br><span class="line">    axs[i].set_ylim(-<span class="number">90</span>, <span class="number">100</span>)</span><br><span class="line">    xticks = [<span class="built_in">int</span>(x//<span class="number">60</span>) <span class="keyword">for</span> x <span class="keyword">in</span> axs[i].get_xticks()]</span><br><span class="line">    axs[i].set_xticklabels(xticks)</span><br><span class="line">    axs[i].set_xlabel(<span class="string">&quot;time (hour)&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">24</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, labelpad=<span class="number">12</span>)</span><br><span class="line">    yticks = [-<span class="number">90</span>, -<span class="number">60</span>, -<span class="number">30</span>, <span class="number">0</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">90</span>]</span><br><span class="line">    axs[i].set_yticks(yticks)</span><br><span class="line">    axs[i].set_yticklabels(yticks)</span><br><span class="line">    axs[i].tick_params(axis=<span class="string">&quot;both&quot;</span>, labelsize=<span class="number">20</span>)</span><br><span class="line">    axs[i].fill_between(hrs, -<span class="number">90</span>, <span class="number">0</span>, facecolor=<span class="string">&quot;gray&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">2</span>*nlats+<span class="number">1</span>:</span><br><span class="line">        axs[i].set_ylabel(<span class="string">&quot;altitude A (deg.)&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">24</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, labelpad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># irradiation accounting for the scattering of light (by US atmosphere model)     </span></span><br><span class="line"><span class="keyword">for</span> i, lat <span class="keyword">in</span> <span class="built_in">enumerate</span>(lats, <span class="number">3</span>*nlats+<span class="number">1</span>):</span><br><span class="line">    axs[i] = fig.add_subplot(<span class="number">5</span>, nlats, i)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># irradiation by pysolar</span></span><br><span class="line">    irrs_pysolar = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(date_hr_lat[i-(<span class="number">3</span>*nlats)])):</span><br><span class="line">        irr_pysolar = get_radiation_direct(date_hr_lat[i-(<span class="number">3</span>*nlats)][j], </span><br><span class="line">                                           alts_lat[i-(<span class="number">3</span>*nlats)][j])</span><br><span class="line">        irrs_pysolar.append(irr_pysolar)</span><br><span class="line">    </span><br><span class="line">    axs[i].scatter(hrs, irrs_pysolar, c=irrs_pysolar, </span><br><span class="line">                   cmap=<span class="string">&quot;copper&quot;</span>, zorder=<span class="number">2</span>, vmin=<span class="number">0</span>, vmax=<span class="number">1100</span>)</span><br><span class="line">    axs[i].xaxis.set_major_locator(MultipleLocator(<span class="number">180</span>))</span><br><span class="line">    axs[i].xaxis.set_minor_locator(MultipleLocator(<span class="number">60</span>))</span><br><span class="line">    axs[i].set_xlim(<span class="number">0</span>, <span class="number">1440</span>)</span><br><span class="line">    xticks = [<span class="built_in">int</span>(x//<span class="number">60</span>) <span class="keyword">for</span> x <span class="keyword">in</span> axs[i].get_xticks()]</span><br><span class="line">    axs[i].set_xticklabels(xticks)</span><br><span class="line">    axs[i].set_xlabel(<span class="string">&quot;time (hour)&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">24</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, labelpad=<span class="number">12</span>)</span><br><span class="line">    axs[i].tick_params(axis=<span class="string">&quot;both&quot;</span>, labelsize=<span class="number">20</span>)   </span><br><span class="line">    axs[i].set_ylim(<span class="number">0</span>, <span class="number">1100</span>)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">3</span>*nlats+<span class="number">1</span>:</span><br><span class="line">        axs[i].set_ylabel(<span class="string">&quot;solar irradiation (W/m2)\n incl. diffuse irradiation&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">24</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, labelpad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># direct irradiation, above the atmosphere </span></span><br><span class="line"><span class="keyword">for</span> i, lat <span class="keyword">in</span> <span class="built_in">enumerate</span>(lats, <span class="number">4</span>*nlats+<span class="number">1</span>):</span><br><span class="line">    axs[i] = fig.add_subplot(<span class="number">5</span>, nlats, i)</span><br><span class="line">    irradiation = np.sin(np.deg2rad(alts_lat[i-(<span class="number">4</span>*nlats)]))</span><br><span class="line">    axs[i].scatter(hrs, irradiation, c=irradiation, </span><br><span class="line">                   cmap=<span class="string">&quot;copper&quot;</span>, zorder=<span class="number">2</span>, vmin=<span class="number">0</span>, vmax=<span class="number">1</span>)</span><br><span class="line">    axs[i].xaxis.set_major_locator(MultipleLocator(<span class="number">180</span>))</span><br><span class="line">    axs[i].xaxis.set_minor_locator(MultipleLocator(<span class="number">60</span>))</span><br><span class="line">    axs[i].set_xlim(<span class="number">0</span>, <span class="number">1440</span>)</span><br><span class="line">    xticks = [<span class="built_in">int</span>(x//<span class="number">60</span>) <span class="keyword">for</span> x <span class="keyword">in</span> axs[i].get_xticks()]</span><br><span class="line">    axs[i].set_xticklabels(xticks)</span><br><span class="line">    axs[i].set_xlabel(<span class="string">&quot;time (hour)&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">24</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, labelpad=<span class="number">12</span>)</span><br><span class="line">    axs[i].tick_params(axis=<span class="string">&quot;both&quot;</span>, labelsize=<span class="number">20</span>)   </span><br><span class="line">    axs[i].set_ylim(<span class="number">0</span>, <span class="number">1.2</span>)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">4</span>*nlats+<span class="number">1</span>:</span><br><span class="line">        axs[i].set_ylabel(<span class="string">&quot;projection &quot;</span> + <span class="string">&quot;$cos(A)$&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">24</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, labelpad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">fig.align_ylabels([axs[<span class="number">1</span>], axs[<span class="number">6</span>], axs[<span class="number">11</span>], axs[<span class="number">16</span>], axs[<span class="number">21</span>]])    </span><br><span class="line">fig.tight_layout()      </span><br></pre></td></tr></table></figure><img src="4_pysolar_1.png" alt="위도에 따라 태양의 움직임이 다릅니다."><br></li></ul><ul><li>일주운동의 연중 변화를 살펴봅니다.</li><li>지역은 <b>대전</b>으로 고정하고 날짜만 <b>춘분</b>, <b>하지</b>, <b>추분</b>, <b>동지</b>로 나눕니다.<ol><li><b>방위각</b> vs <b>고도</b></li><li><b>시간</b> vs 높이가 1인 막대기의 <b>그림자 끝 위치</b></li></ol></li></ul><ul><li>시각화 코드입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Daejeon</span></span><br><span class="line">lat = <span class="number">36.3504</span></span><br><span class="line">lon = <span class="number">127.3845</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dates</span></span><br><span class="line">months = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>]</span><br><span class="line">dates = [<span class="number">21</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">22</span>]</span><br><span class="line">colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;purple&quot;</span>]</span><br><span class="line">markers = [<span class="string">&quot;x&quot;</span>, <span class="string">&quot;^&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;o&quot;</span>]</span><br><span class="line"></span><br><span class="line">alts, azis = &#123;&#125;, &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> month, date <span class="keyword">in</span> <span class="built_in">zip</span>(months, dates):</span><br><span class="line">    alts[month], azis[month] = [], []</span><br><span class="line">    <span class="keyword">for</span> hr <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">24</span>):</span><br><span class="line">        <span class="keyword">for</span> minu <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">60</span>, <span class="number">30</span>):</span><br><span class="line">            date_hr = datetime.datetime(<span class="number">2017</span>, month, date, hr, minu, <span class="number">0</span>, tzinfo=KST)</span><br><span class="line">            alt = get_altitude(lat, lon, date_hr)</span><br><span class="line">            azi = get_azimuth(lat, lon, date_hr)</span><br><span class="line">            alts[month].append(alt)</span><br><span class="line">            azis[month].append(azi)</span><br><span class="line">    </span><br><span class="line">    alts[month] = np.array(alts[month])        </span><br><span class="line">    azis[month] = np.array(azis[month])</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="comment">### visualziation</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># diurnal motion</span></span><br><span class="line">ax1 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, projection=<span class="string">&#x27;polar&#x27;</span>)</span><br><span class="line">ax1.set_theta_zero_location(<span class="string">&quot;N&quot;</span>)</span><br><span class="line">ax1.set_theta_direction(-<span class="number">1</span>)</span><br><span class="line">ax1.fill(np.deg2rad(azis[<span class="number">3</span>]), [<span class="number">0</span>]*<span class="built_in">len</span>(azis[<span class="number">3</span>]), <span class="string">&quot;gray&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> month, marker, color <span class="keyword">in</span> <span class="built_in">zip</span>(months, markers, colors):</span><br><span class="line">    ax1.plot(np.deg2rad(azis[month]), alts[month], c=color, zorder=<span class="number">1</span>)</span><br><span class="line">    im1 = ax1.scatter(np.deg2rad(azis[month]), alts[month], marker=marker,</span><br><span class="line">                      c=alts[month], ec=color, lw=<span class="number">1</span>, cmap=<span class="string">&quot;inferno&quot;</span>, </span><br><span class="line">                      vmin=<span class="number">0</span>, vmax=<span class="number">90</span>, zorder=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cbar1 = plt.colorbar(im1, ax=ax1, fraction=<span class="number">0.046</span>, pad=<span class="number">0.15</span>, ticks= [<span class="number">0</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">90</span>])</span><br><span class="line">cbar1.set_label(<span class="string">&quot;altitude (deg.)&quot;</span>, fontsize=<span class="number">20</span>, labelpad=<span class="number">12</span>)    </span><br><span class="line"></span><br><span class="line">ax1.set_title(<span class="string">&quot;diurnal motion&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">20</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, pad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># shadow</span></span><br><span class="line">ax2 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, projection=<span class="string">&#x27;polar&#x27;</span>)</span><br><span class="line">ax2.set_theta_zero_location(<span class="string">&quot;N&quot;</span>)</span><br><span class="line">ax2.set_theta_direction(-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># cmaps = [&quot;Reds_r&quot;, &quot;Greens_r&quot;, &quot;Blues_r&quot;, &quot;Purples_r&quot;]</span></span><br><span class="line">time_arr = np.linspace(<span class="number">0</span>, <span class="number">47</span>, <span class="number">48</span>)/<span class="number">2</span></span><br><span class="line">handles = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> month, color, marker <span class="keyword">in</span> <span class="built_in">zip</span>(months, colors, markers):</span><br><span class="line">    shadow_idx = np.where(alts[month]&gt;<span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">    shadow_azis_rad = np.deg2rad(azis[month][shadow_idx]+<span class="number">180</span>)</span><br><span class="line">    shadow_lengths = <span class="number">1</span>/np.tan(np.deg2rad(alts[month][shadow_idx]))</span><br><span class="line">    ax2.plot(shadow_azis_rad, shadow_lengths, c=color, zorder=<span class="number">1</span>)</span><br><span class="line">    im2 = ax2.scatter(shadow_azis_rad, shadow_lengths, marker=marker,</span><br><span class="line">                      c=time_arr[shadow_idx], ec=color, lw=<span class="number">1</span>, cmap=<span class="string">&quot;gist_gray&quot;</span>, </span><br><span class="line">                      vmin=<span class="number">0</span>, vmax=<span class="number">23.5</span>, zorder=<span class="number">2</span>)</span><br><span class="line">    handles.append(im2)</span><br><span class="line">    </span><br><span class="line">ax2.set_ylim(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">ax2.yaxis.set_major_locator(MultipleLocator(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">cbar2 = plt.colorbar(im2, ax=ax2, fraction=<span class="number">0.046</span>, pad=<span class="number">0.15</span>, ticks= <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">28</span>, <span class="number">4</span>)))</span><br><span class="line">cbar2.set_label(<span class="string">&quot;time (hour)&quot;</span>, fontsize=<span class="number">20</span>, labelpad=<span class="number">12</span>)    </span><br><span class="line"></span><br><span class="line">ax2.set_title(<span class="string">&quot;shadow motion&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">20</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, pad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">fig.legend(handles=handles, labels=[<span class="string">&quot;spring equinox&quot;</span>, <span class="string">&quot;summer soliste&quot;</span>, <span class="string">&quot;autumn equinox&quot;</span>, <span class="string">&quot;winter soliste&quot;</span>],</span><br><span class="line">           ncol=<span class="number">4</span>, bbox_to_anchor=(<span class="number">0.</span>, <span class="number">0.9</span>, <span class="number">1.</span>, <span class="number">.1</span>), mode=<span class="string">&quot;expand&quot;</span>)</span><br><span class="line">fig.tight_layout(rect=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.9</span>])   </span><br></pre></td></tr></table></figure><img src="4_pysolar_2.png" alt="계절에 따라 하루 중 태양과 그림자의 움직임이 다릅니다."><br></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/GIS/">GIS</category>
      
      <category domain="https://jehyunlee.github.io/categories/GIS/Python/">Python</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/gis/">gis</category>
      
      <category domain="https://jehyunlee.github.io/tags/pysolar/">pysolar</category>
      
      
    </item>
    
    <item>
      <title>Mapping Shapefile on Raster Map</title>
      <link>https://jehyunlee.github.io/2020/09/21/GIS-Python-3-raster_and_polygon/</link>
      <guid>https://jehyunlee.github.io/2020/09/21/GIS-Python-3-raster_and_polygon/</guid>
      <pubDate>Mon, 21 Sep 2020 00:46:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;raster map 위에 polygon을 생성하는 과정을 정리했습니다.&lt;/li&gt;
&lt;li&gt;간단한 작업이지만 4 GB 용량의 raster file을 불러오는 과정과 좌표를 맞추는 과정이 중요합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-g</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>raster map 위에 polygon을 생성하는 과정을 정리했습니다.</li><li>간단한 작업이지만 4 GB 용량의 raster file을 불러오는 과정과 좌표를 맞추는 과정이 중요합니다.</li></ul><h3 id="1-geotiff-읽기"><a href="#1-geotiff-읽기" class="headerlink" title="1. geotiff 읽기"></a>1. <code>geotiff</code> 읽기</h3><ul><li><code>geotiff</code>는 지형과 건물 등 여러 정보를 담은 raster image입니다.</li><li>건물 그림자가 담긴 geotiff 파일을 읽고 그 위에 polygon을 그리고자 합니다.</li></ul><h4 id="1-1-matplotlib"><a href="#1-1-matplotlib" class="headerlink" title="1.1. matplotlib"></a>1.1. <code>matplotlib</code></h4><ul><li><code>geotiff</code>는 이미지파일이기 때문에 <code>imagej</code>에서 읽을 수도 있습니다.</li><li><code>matplotlib</code>에서도 이미지를 다룰 수 있습니다.</li><li><code>plt.imread()</code>기능을 이용해 읽을 수 있지만 문제가 있습니다.<br><br><img src="3_rasterpoly_1.png"></li></ul><ul><li>너무 큰 그림은 읽어들이지 못합니다.</li><li>심지어 DOS 공격이라고까지 의심합니다.</li></ul><h4 id="1-2-gdal"><a href="#1-2-gdal" class="headerlink" title="1.2. gdal"></a>1.2. <code>gdal</code></h4><blockquote><p><a href="https://en.wikipedia.org/wiki/GeoTIFF">wikipedia:GeoTIFF</a><br><a href="https://gdal.org/">GDAL</a><br><a href="https://ljvmiranda921.github.io/notebook/2019/04/13/install-gdal/">GDAL install on ubuntu</a></p></blockquote><p><img src="3_rasterpoly_2.png"></p><ul><li><p><b>GDAL</b>은 래스터와 벡터 데이터를 상호 교환하는 translator library입니다.</p><ul><li>ArcGIS, PostGIS를 비롯해 상당히 많은 프로그램에서 사용하는 de-facto 표준입니다.</li><li>그러나 왜인지 설치가 만만치 않습니다.</li></ul></li><li><p>전에는 <code>geopandas</code>설치 과정에서 잘 됐던 것 같은데 새 서버에서 말썽입니다.</p><ul><li>윈도에서는 <a href="https://codedragon.tistory.com/9556">이런 순서</a>로 설치하면 된다고 하고,</li><li>리눅스에서는 <a href="https://ljvmiranda921.github.io/notebook/2019/04/13/install-gdal/">이렇게</a> 하라고 합니다.</li><li>하루 오전을 희생한 끝에 겨우 설치했습니다.</li></ul></li><li><p>파일을 엽니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> osgeo <span class="keyword">import</span> gdal</span><br><span class="line">gdal.UseExceptions()</span><br><span class="line"></span><br><span class="line">ds = gdal.Open(<span class="string">&quot;파일명&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-raster-data-접근"><a href="#2-raster-data-접근" class="headerlink" title="2. raster data 접근"></a>2. raster data 접근</h3><blockquote><p><a href="https://gdal.org/tutorials/raster_api_tut.html">GDAL: Raster API Tutorial</a></p></blockquote><ul><li>Raster API로 파일의 데이터에 접근할 수 있습니다.</li><li><code>.GetDriver()</code>로 파일의 형태를 알 수 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Driver: <span class="subst">&#123;ds.GetDriver().ShortName&#125;</span>/<span class="subst">&#123;ds.GetDriver().LongName&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>Driver: GTiff/GeoTIFF</li></ul><ul><li><code>.RasterXSize</code>와 <code>.RasterYSize</code>로 그림의 크기를 알 수 있습니다.</li><li><code>.RasterCount</code>로 파일에 담긴 raster band의 수를 알 수 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Size is <span class="subst">&#123;ds.RasterXSize&#125;</span> x <span class="subst">&#123;ds.RasterYSize&#125;</span> x <span class="subst">&#123;ds.RasterCount&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>Size is 27001 x 36000 x 1</li></ul><ul><li><code>.GetProjection()</code>으로 사용된 좌표계를 확인할 수 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Projection is <span class="subst">&#123;ds.GetProjection()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>Projection is PROJCS[“Korea 2000 / Central Belt 2010”,GEOGCS[“Korea 2000”,DATUM[“Geocentric_datum_of_Korea”,SPHEROID[“GRS 1980”,6378137,298.257222101,AUTHORITY[“EPSG”,”7019”]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[“EPSG”,”6737”]],PRIMEM[“Greenwich”,0,AUTHORITY[“EPSG”,”8901”]],UNIT[“degree”,0.0174532925199433,AUTHORITY[“EPSG”,”9122”]],AUTHORITY[“EPSG”,”4737”]],PROJECTION[“Transverse_Mercator”],PARAMETER[“latitude_of_origin”,38],PARAMETER[“central_meridian”,127],PARAMETER[“scale_factor”,1],PARAMETER[“false_easting”,200000],PARAMETER[“false_northing”,600000],UNIT[“metre”,1,AUTHORITY[“EPSG”,”9001”]],AUTHORITY[“EPSG”,”5186”]]</li></ul><h3 id="3-raster-data-가져오기"><a href="#3-raster-data-가져오기" class="headerlink" title="3. raster data 가져오기"></a>3. raster data 가져오기</h3><ul><li><code>.GetRasterBand()</code>를 사용해 raster data를 가져옵니다.</li><li>제 데이터에서는 <code>.RasterCount</code>에서 band가 1개라고 했으니 괄호 안에 1을 넣어줘야 합니다.</li><li>분명 파이썬 코드이지만 <b><code>GDAL</code>은 숫자를 1부터 셉니다.</b><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">band = ds.GetRasterBand(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li>band에 저장된 raster band data를 <code>numpy</code> array로 가져옵니다.</li><li>제가 익숙한 방식이고, 다른 데이터와 결합해야 하기 때문입니다.</li><li>가져온 데이터의 차원을 출력해 잘 읽혔는지 확인합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">irrad = band.ReadAsArray()</span><br><span class="line">nrows, ncols = irrad.shape</span><br><span class="line"><span class="built_in">print</span>(nrows, ncols)</span><br></pre></td></tr></table></figure>36000 27001</li></ul><h3 id="4-좌표-매핑"><a href="#4-좌표-매핑" class="headerlink" title="4. 좌표 매핑"></a>4. 좌표 매핑</h3><blockquote><p><a href="https://matplotlib.org/3.3.1/tutorials/intermediate/imshow_extent.html?highlight=origin%20extent%20imshow">matplotlib: origin and extent in imshow</a></p></blockquote><ul><li><code>numpy</code> array의 index가 0이라고 Korea Belt 2000의 좌표도 0은 아닙니다.</li><li>2차원 배열의 좌표와 실제 지점의 좌표를 매핑해야 합니다.</li></ul><ul><li><code>.GetGeoTransform()</code> 명령으로 변환 인자들을 추출합니다.</li><li>raster band에서 가져오는 것이 아닙니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x0, dx, dxdy, y0, dydx, dy = ds.GetGeoTransform()</span><br><span class="line"><span class="built_in">print</span>(x0, dx, dxdy, y0, dydx, dy)</span><br><span class="line"></span><br><span class="line">x1 = x0 + dx * ncols  <span class="comment"># x limit</span></span><br><span class="line">y1 = y0 + dy * nrows  <span class="comment"># y limit</span></span><br></pre></td></tr></table></figure></li></ul><p>222100.0 1.0 0.0 434400.0 0.0 -1.0</p><ul><li>이제 raster data를 화면에 그려봅시다.</li><li><code>matplotlib</code>의 <code>extent</code>는 가로세로축에 실제 데이터값을 찍어줍니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">20</span>, <span class="number">20</span>))</span><br><span class="line">ax.imshow(irrad, cmap=<span class="string">&quot;gist_gray&quot;</span>, extent=[x0, x1, y1, y0])</span><br><span class="line">ax.set_aspect(<span class="string">&quot;equal&quot;</span>, <span class="string">&quot;box&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="3_rasterpoly_3.png"></li></ul><ul><li>위 정보를 이용해 position을 index로 변환하는 함수를 만들 수 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># position to index</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pos2idx</span>(<span class="params">X, Y, ds=ds</span>):</span></span><br><span class="line">    x0, dx, dxdy, y0, dydx, dy = ds.GetGeoTransform()</span><br><span class="line">    X_idx = <span class="built_in">int</span>((X-x0)/dx)  <span class="comment"># x index of X coordinate</span></span><br><span class="line">    Y_idx = <span class="built_in">int</span>((Y-y0)/dy)  <span class="comment"># y index of Y coordinate</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> X_idx, Y_idx</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-Polygon-얹기"><a href="#5-Polygon-얹기" class="headerlink" title="5. Polygon 얹기"></a>5. Polygon 얹기</h3><blockquote><p><a href="https://jehyunlee.github.io/2020/09/14/GIS-Python-2-PolygonShapefile/">Create Shapefile from Polygon</a><br><a href="https://geopandas.org/reference/geopandas.read_file.html">geopandas.read_file</a></p></blockquote><ul><li>살펴볼 지점을 확대해서 그립니다.</li><li>건물들 데이터가 담긴 데이터로부터 목표 건물의 좌표를 추출하고,</li><li>이 건물을 중심으로 가로세로 100 pixel 범위의 그림을 그립니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">idx_range = <span class="number">100</span> <span class="comment">#pixel</span></span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">ax.imshow(irrad[Y_idx-idx_range: Y_idx+idx_range, X_idx-idx_range:X_idx+idx_range], </span><br><span class="line">          cmap=<span class="string">&quot;gist_gray&quot;</span>, </span><br><span class="line">          extent=[idx_x-idx_range, idx_x+idx_range, idx_y-idx_range, idx_y+idx_range])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="3_rasterpoly_5.png"></li></ul><ul><li>여기에 건물을 하나 얹어봅니다.</li><li><a href="https://jehyunlee.github.io/2020/09/14/GIS-Python-2-PolygonShapefile/">중심점과 가로세로 길이, 각도를 이용해서 도형을 생성하는 기술</a>을 사용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> mapping, Polygon</span><br><span class="line"><span class="keyword">import</span> fiona</span><br><span class="line"></span><br><span class="line">shppath = <span class="string">&quot;파일 저장 경로&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_mor</span>(<span class="params">x, y, width, height, angle, filename, shppath=shppath</span>):</span></span><br><span class="line">    h_half = height/<span class="number">2</span></span><br><span class="line">    w_half = width/<span class="number">2</span></span><br><span class="line">    a_rad = np.deg2rad(angle)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_coord</span>(<span class="params">h_half, w_half, a_rad</span>):</span></span><br><span class="line">        X = x + h_half * np.sin(a_rad) - w_half * np.cos(a_rad)</span><br><span class="line">        Y = y + h_half * np.cos(a_rad) + w_half * np.sin(a_rad)</span><br><span class="line">        <span class="keyword">return</span> (X, Y)</span><br><span class="line">    </span><br><span class="line">    points = [get_coord(h_half, w_half, a_rad), </span><br><span class="line">              get_coord(-h_half, w_half, a_rad), </span><br><span class="line">              get_coord(-h_half, -w_half, a_rad), </span><br><span class="line">              get_coord(h_half, -w_half, a_rad), </span><br><span class="line">              get_coord(h_half, w_half, a_rad), </span><br><span class="line">              ]</span><br><span class="line">    </span><br><span class="line">    schema = &#123;<span class="string">&quot;geometry&quot;</span>: <span class="string">&quot;Polygon&quot;</span>, <span class="string">&quot;properties&quot;</span>: &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;int&quot;</span>&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    savefile = os.path.join(shppath, filename)</span><br><span class="line">    <span class="keyword">with</span> fiona.<span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;savefile&#125;</span>&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="string">&quot;ESRI Shapefile&quot;</span>, schema) <span class="keyword">as</span> c:</span><br><span class="line">        c.write(&#123;</span><br><span class="line">            <span class="string">&quot;geometry&quot;</span>: mapping(Polygon(points)),</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;<span class="string">&quot;id&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure></li></ul><ul><li>목표 건물 데이터를 읽고 사각형을 형성합니다.</li><li>geopandas로 그린 건물은 실제 지도에 들어갈 좌표를 갖고 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"></span><br><span class="line">idx_width = df_dir[<span class="string">&quot;OMBB_WIDTH&quot;</span>].loc[idx]</span><br><span class="line">idx_height = df_dir[<span class="string">&quot;OMBB_HEIGHT&quot;</span>].loc[idx]</span><br><span class="line">idx_angle = df_dir[<span class="string">&quot;OMBB_ANGLE&quot;</span>].loc[idx]</span><br><span class="line"></span><br><span class="line">create_mor(idx_x, idx_y, idx_width, idx_height, idx_angle, <span class="string">&quot;idx_100&quot;</span>)</span><br><span class="line"></span><br><span class="line">idx100 = gpd.read_file(<span class="string">&#x27;./data/200917_shadow/idx_100/idx_100.shp&#x27;</span>)</span><br><span class="line">idx100.plot()</span><br></pre></td></tr></table></figure><img src="3_rasterpoly_4.png"></li></ul><ul><li>이렇게 도형을 shapefile로 만들어주고 <code>geopandas</code>로 읽어옵니다.</li><li>예쁘게 겹쳐져 있습니다.<br><br><img src="3_rasterpoly_6.png"></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/GIS/">GIS</category>
      
      <category domain="https://jehyunlee.github.io/categories/GIS/Python/">Python</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/gis/">gis</category>
      
      <category domain="https://jehyunlee.github.io/tags/polygon/">polygon</category>
      
      <category domain="https://jehyunlee.github.io/tags/shapefile/">shapefile</category>
      
      <category domain="https://jehyunlee.github.io/tags/raster/">raster</category>
      
      
    </item>
    
    <item>
      <title>Create Shapefile from Polygon Dots</title>
      <link>https://jehyunlee.github.io/2020/09/14/GIS-Python-2-PolygonShapefile/</link>
      <guid>https://jehyunlee.github.io/2020/09/14/GIS-Python-2-PolygonShapefile/</guid>
      <pubDate>Mon, 14 Sep 2020 04:11:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;csv 파일에서 읽은 기본 정보를 바탕으로 polygon shapefile을 생성하는 과정입니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shapely&lt;/code&gt;와 &lt;code&gt;fiona&lt;/code&gt;를 사용했으며, &lt;code&gt;geopandas 0.</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>csv 파일에서 읽은 기본 정보를 바탕으로 polygon shapefile을 생성하는 과정입니다.</li><li><code>shapely</code>와 <code>fiona</code>를 사용했으며, <code>geopandas 0.8</code>을 설치할 때 함께 설치되는 버전을 사용했습니다.</li><li><code>shapely</code> 버전은 1.7, <code>fiona</code> 버전은 1.8.13.post1 입니다.</li></ul><p><b>References</b></p><blockquote><p><a href="https://shapely.readthedocs.io/en/latest/">shapely</a><br><a href="https://github.com/Toblerity/Fiona">fiona</a><br><a href="https://geopandas.org/">geopandas</a></p></blockquote><h3 id="1-csv-읽기"><a href="#1-csv-읽기" class="headerlink" title="1. csv 읽기"></a>1. csv 읽기</h3><ul><li><code>.csv</code> 파일에서 건물 정보를 읽어옵니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_ombb0914 = pd.read_csv(<span class="string">&#x27;./data/ombb_200914.csv&#x27;</span>)</span><br><span class="line">df_ombb0914.head()</span><br></pre></td></tr></table></figure><img src="2_polygonshp_2.png"><br></li></ul><ul><li>데이터 컬럼은 다음과 같습니다.<ul><li><b><code>BD_MGT_SN</code> : </b>건물관리번호 (건물 고유 번호)</li><li><b><code>width</code> $$w$$ : </b>최소경계도형 폭 ($$m$$)</li><li><b><code>height</code> $$h$$ : </b>최소경계도형 높이 ($$m$$)</li><li><b><code>angle</code> $$\theta$$ : </b>최소경계도형 회전각. 정북 기준 시계방향 ($$\text{deg.}$$)</li><li><b><code>area</code> : </b>최소경계도형 넓이 ($$m^2$$)</li><li><b><code>perimeter</code> : </b>최소경계도형 둘레 ($$m$$)</li><li><b><code>xcoord</code> : </b>최소경계도형 중심점 x좌표 (ESPG:5186)</li><li><b><code>ycoord</code> : </b>최소경계도형 중심점 y좌표 (ESPG:5186)</li></ul></li></ul><p><img src="2_polygonshp_3.png"><br></p><h3 id="2-polygon-변환"><a href="#2-polygon-변환" class="headerlink" title="2. polygon 변환"></a>2. polygon 변환</h3><ul><li>행 하나가 건물 하나에 해당합니다.</li><li>행 하나마다 정보를 좌표로 변환해서 <code>shapefile</code>로 저장합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> mapping, Polygon</span><br><span class="line"><span class="keyword">import</span> fiona</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_polygons</span>(<span class="params">x, y, width, height, angle, filename</span>):</span></span><br><span class="line">    h_half = height/<span class="number">2</span> </span><br><span class="line">    w_half = width/<span class="number">2</span></span><br><span class="line">    a_rad = np.deg2rad(angle)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 꼭지점 좌표 생성</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_coord</span>(<span class="params">x, y, h_half, w_half, a_rad</span>):</span></span><br><span class="line">        X = x + h_half * np.sin(a_rad) - w_half * np.cos(a_rad)</span><br><span class="line">        Y = y + h_half * np.cos(a_rad) + w_half * np.sin(a_rad)</span><br><span class="line">        <span class="keyword">return</span> (X, Y)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># shapefile schema 지정</span></span><br><span class="line">    schema = &#123;<span class="string">&quot;geometry&quot;</span>: <span class="string">&quot;Polygon&quot;</span>, <span class="string">&quot;properties&quot;</span>: &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;int&quot;</span>&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 행 수만큼 반복</span></span><br><span class="line">    n_polygon = <span class="built_in">len</span>(x)</span><br><span class="line">    <span class="keyword">with</span> fiona.<span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;filename&#125;</span>&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="string">&quot;ESRI Shapefile&quot;</span>, schema) <span class="keyword">as</span> c:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_polygon):</span><br><span class="line">            p_x, p_y = x.iloc[i], y.iloc[i]</span><br><span class="line">            p_h, p_w, p_r = h_half.iloc[i], w_half.iloc[i], a_rad.iloc[i]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># closed loop을 이루도록 point 지정.</span></span><br><span class="line">            points = [get_coord(p_x, p_y, p_h, p_w, p_r), </span><br><span class="line">                      get_coord(p_x, p_y, -p_h, p_w, p_r), </span><br><span class="line">                      get_coord(p_x, p_y, -p_h, -p_w, p_r), </span><br><span class="line">                      get_coord(p_x, p_y, p_h, -p_w, p_r), </span><br><span class="line">                      get_coord(p_x, p_y, p_h, p_w, p_r), </span><br><span class="line">                      ]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># shapefile 작성</span></span><br><span class="line">            c.write(&#123;</span><br><span class="line">                <span class="string">&quot;geometry&quot;</span>: mapping(Polygon(points)),</span><br><span class="line">                <span class="string">&quot;properties&quot;</span>: &#123;<span class="string">&quot;id&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-QGIS에서-확인"><a href="#3-QGIS에서-확인" class="headerlink" title="3. QGIS에서 확인"></a>3. QGIS에서 확인</h3><ul><li>QGIS에서 읽어서 잘 보이는지 확인합니다.<ul><li>.csv를 출력한 원본(노랑)과 생성된 shapefile(파랑) 비교 결과 완벽히 일치합니다.</li><li>최소경계도형(보라)과 비교해봐도 잘 복원되었습니다.</li></ul></li></ul><p><img src="2_polygonshp_4.png"><br></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/GIS/">GIS</category>
      
      <category domain="https://jehyunlee.github.io/categories/GIS/Python/">Python</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/gis/">gis</category>
      
      <category domain="https://jehyunlee.github.io/tags/polygon/">polygon</category>
      
      <category domain="https://jehyunlee.github.io/tags/shapefile/">shapefile</category>
      
      
    </item>
    
    <item>
      <title>Minimum Oriented Rectangle</title>
      <link>https://jehyunlee.github.io/2020/09/14/GIS-QGIS-2-OMBB/</link>
      <guid>https://jehyunlee.github.io/2020/09/14/GIS-QGIS-2-OMBB/</guid>
      <pubDate>Sun, 13 Sep 2020 22:23:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;QGIS에서 최소 경계 도형(minimum oriented rectangle)을 생성하고 중심점을 추가하여 csv로 출력하는 방법을 정리합니다.&lt;/li&gt;
&lt;li&gt;사용한 QGIS의 버전은 &lt;code&gt;3.10.9-A Coruña&lt;/code</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>QGIS에서 최소 경계 도형(minimum oriented rectangle)을 생성하고 중심점을 추가하여 csv로 출력하는 방법을 정리합니다.</li><li>사용한 QGIS의 버전은 <code>3.10.9-A Coruña</code> 입니다.</li></ul><p><b>References</b></p><blockquote><p><a href="https://qgis.org/ko/site/">QGIS</a></p></blockquote><h3 id="1-shapefile-읽기"><a href="#1-shapefile-읽기" class="headerlink" title="1. shapefile 읽기"></a>1. shapefile 읽기</h3><ul><li>QGIS에서 <b>shapefile</b>을 읽어옵니다.</li><li>건물 형상이 반영되어 곳곳이 울퉁불퉁합니다.<br><br><img src="2_ombb_1.png"><br></li></ul><h3 id="2-대상-도형-선택"><a href="#2-대상-도형-선택" class="headerlink" title="2. 대상 도형 선택"></a>2. 대상 도형 선택</h3><ul><li>형상을 단순화 할 <b>대상들을 선택</b>합니다.</li><li>전체 도형을 대상으로 할 것이므로 전체를 선택합니다.<br><br><img src="2_ombb_2.png"><br></li></ul><h3 id="3-최소경계도형-옵션-선택"><a href="#3-최소경계도형-옵션-선택" class="headerlink" title="3. 최소경계도형 옵션 선택"></a>3. 최소경계도형 옵션 선택</h3><blockquote><p><a href="https://docs.qgis.org/2.18/en/docs/user_manual/processing_algs/qgis/vector_general_tools.html#id73">QGIS: Oriented minimum bounding box</a><br><a href="https://docs.qgis.org/3.10/ko/docs/user_manual/processing_algs/qgis/vectorgeometry.html#minimum-bounding-geometry">QGIS: 최소 경계 도형</a></p></blockquote><ul><li><p><b>공간 처리<code>Processing</code> &gt; 툴박스<code>Toolbox</code> &gt; 최소 경계 도형<code>Minimum Bounding Geometry</code></b>을 실행합니다.<br><br><img src="2_ombb_3.png"><br></p></li><li><p><b>[선택한 객체만]</b>을 선택합니다.</p></li><li><p><b>[필드]</b>에서 개체식별자를 선택합니다.</p><ul><li>개별 건물을 구분하는 <code>BD_MGT_SN</code>을 선택합니다.</li><li>선택이 되지 않을 경우 전체를 뭉뚱그리는 도형이 생성됩니다.</li></ul></li><li><p><b>[도형 유형]</b>을 선택합니다.<br><br><img src="2_ombb_6.png"><br></p></li><li><p><b>[실행]</b>을 선택하여 최소경계도형을 생성합니다.<br></p></li></ul><p><img src="2_ombb_8.png"><br></p><h3 id="4-최소경계도형-중심점-추출"><a href="#4-최소경계도형-중심점-추출" class="headerlink" title="4. 최소경계도형 중심점 추출"></a>4. 최소경계도형 중심점 추출</h3><blockquote><p><a href="https://docs.qgis.org/3.10/ko/docs/user_manual/processing_algs/qgis/vectorgeometry.html#centroids">QGIS: 중심</a></p></blockquote><ul><li><p><b>벡터<code>Vector</code> &gt; 도형 도구<code>Geometry Tools</code> &gt; 중심점<code>Polygon Centroid</code></b>을 실행합니다.</p></li><li><p><b>[각각의 파트별로 중심점 생성]</b>을 체크합니다.<br><br><img src="2_ombb_4.png"><br></p></li><li><p><b>[실행]</b>을 선택하여 최소경계도형에서 중심점을 추출합니다.<br></p></li></ul><h3 id="5-최소경계도형-중심점-속성-추가"><a href="#5-최소경계도형-중심점-속성-추가" class="headerlink" title="5. 최소경계도형 + 중심점 속성 추가"></a>5. 최소경계도형 + 중심점 속성 추가</h3><blockquote><p><a href="https://docs.qgis.org/3.10/ko/docs/user_manual/processing_algs/qgis/vectorgeometry.html#add-geometry-attributes">QGIS: 도형 속성 추가</a></p></blockquote><ul><li><p>활용을 위해 최소경계도형에 중심점을 추가해야 합니다.</p></li><li><p><b>벡터<code>Vector</code> &gt; 도형 도구<code>Geometry Tools</code> &gt; 도형 속성 추가<code>Expand/Add Geometry</code></b>를 실행합니다.<br><br><img src="2_ombb_5.png"><br></p></li><li><p>중심점 좌표가 <code>xcoord</code>, <code>ycoord</code>로 붙어 있습니다.</p></li></ul><h3 id="6-파일로-저장"><a href="#6-파일로-저장" class="headerlink" title="6. 파일로 저장"></a>6. 파일로 저장</h3><ul><li><p><b>레이어<code>Layer</code> &gt; 다른 이름으로 저장<code>Save As...</code><b>에서 저장합니다.<br><img src="2_ombb_7.png"><br></p></li><li><p><b>shapefile : <code>ESRI shapefile</code></b></p></li><li><p><b>csvfile : <code>쉼표로 구분된 값 [CSV]</code></b></p></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/GIS/">GIS</category>
      
      <category domain="https://jehyunlee.github.io/categories/GIS/QGIS/">QGIS</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/gis/">gis</category>
      
      <category domain="https://jehyunlee.github.io/tags/qgis/">qgis</category>
      
      <category domain="https://jehyunlee.github.io/tags/object-minimum-bounding-box/">object minimum bounding box</category>
      
      <category domain="https://jehyunlee.github.io/tags/minimum-oriented-rectangle/">minimum oriented rectangle</category>
      
      
    </item>
    
    <item>
      <title>Pit Stop for Software Maintenance</title>
      <link>https://jehyunlee.github.io/2020/07/26/Python-General-6_pitstop/</link>
      <guid>https://jehyunlee.github.io/2020/07/26/Python-General-6_pitstop/</guid>
      <pubDate>Sat, 25 Jul 2020 22:10:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;thumbnail image&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.dailymail.co.uk/sport/formulaone/article-4401632/Formula-One-pit-st</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>thumbnail image</li></ul><blockquote><p><a href="https://www.dailymail.co.uk/sport/formulaone/article-4401632/Formula-One-pit-stop-does-crew-work.html">Formula One pit stop: How does the crew work and what are the roles to ensure Sebastian Vettel and Co can return to the track in a matter of seconds?</a></p></blockquote><blockquote><p><a href="https://jupyter.org/">Jupyter Notebook</a><br><a href="https://jupyterlab.readthedocs.io/en/stable/getting_started/installation.html">Jupyter Lab</a></p></blockquote><h2 id="Pit-Stop-Lightspeed-Maintenance"><a href="#Pit-Stop-Lightspeed-Maintenance" class="headerlink" title="Pit Stop: Lightspeed Maintenance"></a>Pit Stop: Lightspeed Maintenance</h2><p><img src="6_pitstop_01.jpg" alt="image: Dailymail"></p><ul><li>F1은 트랙을 먼저 도는 차의 순위를 겨루는 레이싱 경기입니다.<ul><li>동체시력과 판단력, 반사신경에서 인간의 한계를 보여주는 레이서도 멋지지만,  </li><li>차가 경기 도중 정해진 위치에 서자마자 사방에서 대기하고 있던 엔지니어들이 달라붙어 고속주행에 마모된 타이어를 순식간에 교체하는 Pit Stop은 그 자체로 한계에 대한 도전입니다. </li><li>2016년 1.92초 만에 이루어진 타이어 교체는 보면서도 믿기지 않습니다.<br></li></ul></li></ul><iframe width="812" height="457" src="https://www.youtube.com/embed/7VCYBtx6h4g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><ul><li>2년 전 만든 코드에 가끔 수정 요청이 들어옵니다.<ul><li>처음에는 기억을 더듬어 수정했지만 <b>점점 코드를 다시 읽고 해석하는 시간이 길어집니다.</b></li><li><b>배포를 위한 추가 작업이 매번 일어납니다.</b></li><li>수정을 마치면 플랫폼에 올리기 위해 파일 입력을 고치고, 그림 출력을 삭제해야 합니다.</li><li>갑작스런 유지보수가 길어지면 기존 일정이 꼬여버립니다.</li></ul></li></ul><ul><li>업무 방식을 근본적으로 개선하고자 했습니다.<ul><li>개발자 선배들이 쌓아놓은 더 좋은 방법이 있을 것 같은데, 공부할 시간이 없었습니다.</li><li>제 코드가 달리는 트랙은 F1이 아니고, 제 코드도 페라리는 아닙니다.</li><li>그러나 간혹 들어오는 유지보수는 빠르게 끝내고 싶습니다.</li><li>급하게 떠올린 아이디어를 적용했습니다. 더 좋은 방법을 알게 되면 좋겠습니다.</li></ul></li></ul><h2 id="As-Was-Manual-Modification"><a href="#As-Was-Manual-Modification" class="headerlink" title="As Was: Manual Modification"></a>As Was: Manual Modification</h2><ul><li><p><b>Problem 1: 두 개의 버전</b></p><ul><li>개발버전과 배포버전은 데이터 처리만 동일합니다.</li><li>개발버전에서 디버깅과 테스트를 실시한 후 배포버전에서 input과 output을 교체했습니다.</li><li>교체 방식도 초보스러워서, 개발버전의 것을 comment out 처리하고, 디버깅을 하는 동안 comment out 되어 있던 배포버전의 해당 부분을 살리는 식이었습니다.<br><br><img src="6_pitstop_02.png"><br></li></ul></li><li><p><b>Problem 2: 유지보수 요청 원인</b></p><ul><li>제 경우 대개 새로운 input에 대한 대응력이 부족해서 발생합니다.</li><li>제 입장에서는 <b>“처음부터 이런 경우도 있다고 이야기를 해주시던가”</b> 싶습니다.</li><li>그러나 사용자 입장에서는 <b>bug</b>로 인식됩니다.</li></ul></li></ul><ul><li><b>Problem 3: 디버깅 방식</b><ul><li>특정 지점의 데이터를 골라서 <code>print()</code>로 뽑아봅니다.</li><li>특정 데이터를 지정해서 시각화를 합니다.</li><li>그리고 이 코드들은 deploy할 때 comment out됩니다.</li></ul></li></ul><ul><li>마치 동네 카센터 느낌입니다.<ul><li>차가 들어오면 증상을 차주에게 물어보고, </li><li>차를 들어올리고, 문제 부위 위주로 살피다가,</li><li>필요한 부품이 없다면 그제서야 주문하는 듯한 모습입니다.</li><li>몇분 내 pit out이 가능할 리가 없습니다.</li></ul></li></ul><h2 id="Pit-Stop-for-Software-Development"><a href="#Pit-Stop-for-Software-Development" class="headerlink" title="Pit Stop for Software Development"></a>Pit Stop for Software Development</h2><h3 id="1-Car-Tuning"><a href="#1-Car-Tuning" class="headerlink" title="(1) Car Tuning"></a>(1) Car Tuning</h3><ul><li>Pit stop에서 빠른 조치가 되려면 차부터 여기에 맞게 준비가 되어야 합니다.</li><li>코드의 각 부분을 모드(test, debugging, deploy)에 따라 나누었습니다.<ul><li><b>test:</b> 프로세싱 중심 본연의 기능</li><li><b>debugging:</b> 디버깅에 활용하는 data tracking, 시각화</li><li><b>deploy:</b> 웹 플랫폼 탑재시 변경되는 부분<br></li></ul></li></ul><p><img src="6_pitstop_03.png"><br></p><ul><li>집중을 위해 개발 모드를 test와 debugging을 분리했습니다.</li></ul><ul><li><p><b>test 모드는 플랫폼상 동작을 최대한 모사한 환경입니다.</b></p><ul><li>input 수십가지를 자동으로 넣는 batch 수행방식이라는 것이 유일한 차이입니다.</li><li>test 모드에서는 최소한의 출력만을 얻어냅니다.</li><li>이 과정에서 상세 데이터 등이 줄줄이 뽑혀나오면 방해이기 때문입니다.  </li></ul></li><li><p><b>debugging 모드는 문제의 원인을 찾고 수정시 변화를 찾는 환경입니다.</b></p><ul><li>특정 데이터를 tracking하는 코드가 필요하고,</li><li>이해를 돕기 위한 시각화 코드도 함께 필요합니다.</li><li>통상적이라면 필요없을 상세한 출력문도 필요합니다.</li></ul></li><li><p>코드 내부에 각 모드별 기능과 스위치를 탑재합니다.</p><ul><li>코드 첫 부분에 스위치를 넣어서 모드를 선택하도록 합니다.</li><li>모드별로 적용될 변수를 <code>class</code> 등으로 모아둡니다.</li><li>디버깅하다가 주요 변수가 꼬여버리는 것을 막는 안전장치도 됩니다.<br><br><img src="6_pitstop_04.png"><br></li></ul></li></ul><ul><li><p>시각화 등 모드별로 작동할 기능을 <code>if</code> 문으로 제어합니다.</p><ul><li>tracking data가 있다면 <code>class</code> 안에 데이터를 담아줍니다.</li><li><code>class</code> 내에 시각화 종류별 스위치를 탑재하면 통제하기 좋습니다.<br><br><img src="6_pitstop_05.png"><br></li></ul></li><li><p><b>기존 코드를 별로 건드리지 않습니다</b></p><ul><li>기능별 변수와 <code>if</code>문 탑재 정도의 일입니다.</li><li>기존 코드의 주요 부분을 수정하지 않는 단순작업입니다.</li><li>특히 <b>삭제나 변경이 없다는 점</b>에서 오류를 발생시키지 않습니다.</li></ul></li></ul><h3 id="2-Pit-Construction"><a href="#2-Pit-Construction" class="headerlink" title="(2) Pit Construction"></a>(2) Pit Construction</h3><ul><li>이제 코드를 수리할 Pit를 만들 차례입니다.</li><li><b>결과를 실시간으로 보며 interactive하게 조작하기 좋아야 합니다.</b><ul><li>이런 작업은 <a href="https://jupyter.org/"><code>Jupyter Notebook</code></a>이 좋습니다.</li><li>저는 <a href="https://jupyterlab.readthedocs.io/en/stable/getting_started/installation.html"><code>Jupyter Lab</code></a>을 사용했습니다.</li><li>메인 코드를 복사해 넣을 Cell을 가운데 놓고, 위와 아래에 데이터 분석을 위한 코드를 놓습니다.<br><br><img src="6_pitstop_06.png"><br></li></ul></li><li>data analysis용 코드<ul><li><b>데이터를 시각화해주는 코드</b>가 여기에 올 수 있습니다.</li><li>메인 코드에 넣을 수도 있겠지만, 메인 코드의 분량을 최대한 줄여서 본연의 기능에만 집중시키고자 했습니다. 그래야 디버깅이나 기능 추가가 덜 힘드니까요.</li><li>제 경우 eigenvector와 데이터를 함께 시각화하는 코드를 여기 넣었습니다.<br><br><img src="6_pitstop_07.png"><br></li></ul></li><li>data analysis 결과  <ul><li>메인 코드에서 뱉어주는 최소한의 text output엔 핵심적인 결과가 있습니다.</li><li>debugging 모드라면 몇 가지 시각화가 추가적으로 나올 것입니다.</li><li>이 결과와 함께 보기 위해서 결과 부분을 메인 코드 하단에 위치시켰습니다.<br><br><img src="6_pitstop_08.png" alt="debug mode의 histogram출력(위), eigenvector 추가 분석 시각화(아래)"><br></li></ul></li></ul><h3 id="3-Pit-Operation"><a href="#3-Pit-Operation" class="headerlink" title="(3) Pit Operation"></a>(3) Pit Operation</h3><ul><li><p><b>Step 1. 유지보수 요청이 들어온 코드를 주피터 노트북에 붙여넣고 실행합니다.</b></p><ul><li>메인 코드의 첫 부분에 있는 <code>debugmode = 1</code>로 디버깅 모드를 설정하고,</li><li>셀을 실행해서 기존의 결과물을 얻어냅니다.</li><li>풍부해진 시각화와 추가 분석을 통해 들여다봄으로써 오류의 원인을 파악합니다.</li><li>시행착오를 거치며 메인 코드를 수정하고, 버그를 수정합니다.</li></ul></li><li><p><b>Step 2. 원 코드를 버그 수정본으로 교체합니다.</b></p><ul><li>Ctrl+C/V로 가능합니다.</li><li><code>debugmode = 0</code>으로 세팅해서 테스트 모드로 변경합니다.</li><li>다양한 input을 대상으로 batch test를 진행, 디버깅 성공 여부를 판단합니다.</li><li>작성하기에 따라 Pit 자체를 디버깅 보고서로 제출할 수도 있습니다.<br><br><img src="6_pitstop_09.png" alt="엑셀로 정리한 batch test 결과"><br></li></ul></li><li><p><b>Step 3. deploymode로 배포합니다.</b></p><ul><li>디버깅이 흡족하다면, <code>deploymode = 1</code>로 변경 후 코드를 배포합니다.</li><li>파일 입출력에 관련된 많은 설정이 자동으로 변경됩니다<br></li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      
    </item>
    
    <item>
      <title>X-Window on Docker on WSL 2</title>
      <link>https://jehyunlee.github.io/2020/06/10/Python-General-5-wdvx/</link>
      <guid>https://jehyunlee.github.io/2020/06/10/Python-General-5-wdvx/</guid>
      <pubDate>Tue, 09 Jun 2020 21:10:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;5_wdvx_01.png&quot; alt=&quot;MS에 이런 날이 올줄이야&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;References&lt;/b&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/ko-kr/win</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="5_wdvx_01.png" alt="MS에 이런 날이 올줄이야"></p><p><b>References</b></p><blockquote><p><a href="https://docs.microsoft.com/ko-kr/windows/wsl/compare-versions">Microsoft: WSL 2와 WSL 1 비교</a><br><a href="https://docs.microsoft.com/ko-kr/windows/wsl/install-win10">Microsoft: Windows 10에 Linux용 Windows 하위 시스템 설치 가이드</a><br><a href="https://www.docker.com/blog/docker-desktop-wsl-2-best-practices/">docker blog: Docker Desktop: WSL 2 Best practices</a><br><a href="https://discourse.ubuntu.com/t/getting-graphical-applications-to-work-on-wsl2/11868">ubuntu Discourse: Getting graphical applications to work on WSL2</a><br><a href="https://code.visualstudio.com/docs/remote/wsl">Visual Studio Code: Developing in WSL</a><br><a href="https://driz2le.tistory.com/257">홀로 떠나는 여행: docker와 GUI 환경 연결</a></p></blockquote><ul><li>Microsoft에서 출시한 <a href="https://docs.microsoft.com/ko-kr/windows/wsl/install-win10">WSL 2</a>와 <a href="https://www.docker.com/blog/docker-desktop-wsl-2-best-practices/">docker</a>의 궁합이 매우 좋습니다.</li><li>특히 <a href="https://www.docker.com/blog/docker-desktop-wsl-2-best-practices/">WSL 2에 Docker를 설치</a>하면 wsl의 단점을 메워줍니다.</li><li>여기에 VSCode를 끼얹어주면 개발 환경이 상당히 편리해집니다.</li></ul><h3 id="1-WSL-단독-또는-Windows-Docker-사용시-불편한-점"><a href="#1-WSL-단독-또는-Windows-Docker-사용시-불편한-점" class="headerlink" title="1. WSL 단독 또는 Windows + Docker 사용시 불편한 점"></a>1. WSL 단독 또는 Windows + Docker 사용시 불편한 점</h3><ul><li><p>WSL을 2018년 초부터 1년여 사용할 때 불편한 점들이 있었습니다.</p></li><li><p>당시 테스트 버전이던 WSL 2를 설치하고 윈도가 날아간 뒤 도커를 1년 좀 안되게 썼는데, 여기에도 불편한 점들이 있었습니다.<br><br><b>1. WSL이건 docker건 따로 실행해야 합니다 :</b> </p><ul><li>Ubuntu 기반의 개발 환경을 원하는 것이지 Linux 자체를 원한 건 아닙니다.</li></ul><p><b>2. WSL 파일 공유가 불편합니다 :</b> </p><ul><li>윈도에서 WSL로 복사한 파일은 실시간 인식이 되지 않습니다.</li></ul><p><b>3. 옷 위에 옷을 껴입는 느낌입니다 :</b> </p><ul><li>윈도 부팅 → 도커 실행 → 컨테이너 실행으로 이어지는 과정이 번거롭습니다.</li></ul></li></ul><h3 id="2-WSL-Docker-VSCode"><a href="#2-WSL-Docker-VSCode" class="headerlink" title="2. WSL + Docker + VSCode"></a>2. WSL + Docker + VSCode</h3><ul><li>제가 피부로 느끼는 WSL + Docker + VSCode 시스템의 장점은 다음과 같습니다.<br><br><b>1. docker를 따로 실행할 필요가 없습니다 :</b> <ul><li>부팅시 윈도가 docker를 띄우고 vscode가 컨테이너를 불러줍니다.</li></ul><b>2. WSL과의 파일 공유가 편해집니다 :</b> <ul><li>docker의 volume share를 통해 실시간 공유가 됩니다.</li></ul><b>3. 그냥 windows를 쓰는 느낌입니다 :</b> <ul><li>라이브러리 설치 등을 제외하고는 vscode, 탐색기 모두 윈도에서 씁니다.</li></ul></li></ul><p><img src="5_wdvx_03.png" alt="좌 VSCode 우 Jupyter Lab. 제 환경입니다."><br></p><ul><li><p>심지어 <code>docker ps</code> 등의 명령도 윈도 파워셸에서 실행할 정도로 자연스럽습니다.<br><br><img src="5_wdvx_02.png"><br></p></li><li><p>모든 환경이 windows 자체를 쓰는 느낌이 장점이기도 하지만 단점일 때도 있습니다.</p></li><li><p>docker container에서 X-Window를 띄우려면 어디를 손댈지 조금 난감하기 때문입니다.</p></li><li><p>아무 설정을 하지 않으면 아래 메시지 이후 에러가 나고 실행이 되지 않습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QStandardPaths: XDG_RUNTIME_DIR not <span class="built_in">set</span>, defaulting to <span class="string">&#x27;/tmp/runtime-root&#x27;</span></span><br><span class="line">QXcbConnection: Could not connect to display</span><br></pre></td></tr></table></figure></li><li><p>WSL에 설치된 docker에서 X-Window를 띄우려면 약간의 수고가 필요합니다.</p></li></ul><h3 id="2-X-Window-on-Docker-on-WSL-2-설정"><a href="#2-X-Window-on-Docker-on-WSL-2-설정" class="headerlink" title="2. X-Window on Docker on WSL 2 설정"></a>2. X-Window on Docker on WSL 2 설정</h3><ul><li>다음과 같은 순서로 진행합니다.<br></li></ul><p><b>1. (Windows) Xserver 설치 :</b> <a href="https://sourceforge.net/projects/vcxsrv/">VcXsrv</a> 등을 설치하고 실행합니다.<br></p><ul><li>XLaunch의 Extra settings에 나오는 Disable access control을 체크합니다.</li><li><a href="https://mobaxterm.mobatek.net/download.html">mobaXterm</a>을 설치하는 것도 방법입니다.</li><li>mobaXterm은 ssh, sftp, display를 한 곳에서 사용하고 저장할 수 있어 편리합니다.<br></li></ul><p><b>2. (WSL) export DISPLAY :</b> Windows Powershell에서 <code>wsl</code>을 실행해 WSL로 들어갑니다.<br></p><ul><li><code>.bashrc</code>에 DISPLAY 설정을 다음과 같이 추가합니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DISPLAY=$(grep -m 1 nameserver /etc/resolv.conf | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>):0.0</span><br><span class="line"><span class="comment"># Linux Desktop에 설치된 도커라면 이 과정이 필요 없기도 합니다.</span></span><br><span class="line"></span><br><span class="line">xhost +<span class="built_in">local</span>:docker  <span class="comment"># docker에서 실행되는 모든 프로그램을 X-Window와 통신하게 해줍니다.</span></span><br><span class="line">                     <span class="comment"># 제 경우는 이 설정은 동작하지 않은 듯 하나 문제가 없었습니다.</span></span><br><span class="line">                     <span class="comment"># 이 명령을 실행하려면 apt-get install x11-apps 를 먼저 실행해야 합니다.</span></span><br></pre></td></tr></table></figure></li><li><code>source ~/.bashrc</code> 명령으로 설정을 적용합니다.<br><img src="5_wdvx_05.png"><br></li><li>mobaXterm을 설치했다면 mobaxterm에 보이는 IP를 적용해야 합니다.<br><br><img src="5_wdvx_08.png"><br></li></ul><p><b>3. (WSL) Container 띄우기 :</b> X11과 DISPLAY를 공유하도록 실행합니다.<br></p><ul><li><code>-v /tmp/.X11-unix:/tmp/.X11-unix</code>과 <code>-e DISPLAY=$DISPLAY</code>가 핵심입니다.</li><li>윈도와 공유할 폴더를 <code>-v /mnt/c/&#123;로컬디렉토리&#125;:/&#123;wsl디렉토리&#125;</code> 방식으로 추가 지정합니다.</li><li><code>-e DISPLAY=$DISPLAY</code>가 안되면 <code>-e DISPLAY=unix$DISPLAY</code>로 해 봅시다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --name=&#123;컨테이너 이름&#125; -v /tmp/.X11-unix:/tmp/.X11-unix -v /mnt/c/&#123;로컬디렉토리&#125;:/&#123;wsl디렉토리&#125; -e DISPLAY=<span class="variable">$DISPLAY</span> -p 8888:8888 -p 6006:6006 &#123;docker image&#125;</span><br></pre></td></tr></table></figure></li></ul><p><b>4. (Docker) X-Window 확인 :</b> 컨테이너에 들어가서 X-Window를 띄워봅니다.</p><ul><li>간단한 X-Window 앱을 설치하고 실행해봅시다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get update</span><br><span class="line">$ apt-get install x11-apps</span><br><span class="line">$ xeyes</span><br></pre></td></tr></table></figure><img src="5_wdvx_06.png" alt="컨테이너의 Jupyter Lab Terminal에서 띄워봤습니다."></li></ul><h3 id="2-X-Window-on-Docker-on-WSL-2-실행"><a href="#2-X-Window-on-Docker-on-WSL-2-실행" class="headerlink" title="2. X-Window on Docker on WSL 2 실행"></a>2. X-Window on Docker on WSL 2 실행</h3><ul><li>이제 리부팅을 해도 docker에서 X-Window를 띄워볼 수 있습니다.</li><li>Jupyter에서 <code>%matplotlib qt</code>로 새 창에 그래프를 띄운 모습입니다.<br><br><img src="5_wdvx_07.png"><br></li><li>네이버 지도도 firefox에서 잘 떴습니다. GIS 작업도 문제 없겠군요. :)<br><br><img src="5_wdvx_09.png">  </li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/docker/">docker</category>
      
      <category domain="https://jehyunlee.github.io/tags/wsl/">wsl</category>
      
      <category domain="https://jehyunlee.github.io/tags/x-window/">x-window</category>
      
      
    </item>
    
    <item>
      <title>10 TensorFlow Tricks Every ML Practioner Must Know</title>
      <link>https://jehyunlee.github.io/2020/05/22/Python-DL-2-10_TF_skills/</link>
      <guid>https://jehyunlee.github.io/2020/05/22/Python-DL-2-10_TF_skills/</guid>
      <pubDate>Fri, 22 May 2020 01:45:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;본 글은 번역글입니다.&lt;/li&gt;
&lt;li&gt;원 글은 2020년 5월 18일 medium에 발행되었습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;b&gt;원본 주소 :&lt;/b&gt; &lt;a href=&quot;https://towardsdatascie</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>본 글은 번역글입니다.</li><li>원 글은 2020년 5월 18일 medium에 발행되었습니다.</li></ul><blockquote><p><b>원본 주소 :</b> <a href="https://towardsdatascience.com/10-tensorflow-tricks-every-ml-practitioner-must-know-96b860e53c1">https://towardsdatascience.com/10-tensorflow-tricks-every-ml-practitioner-must-know-96b860e53c1</a><br><b>번역 철학 :</b> 매끄럽게 읽으실 수 있는 적절한 의역을 지향합니다.<br><b>전문 용어 :</b> 가급적 <a href='http://taewan.kim/docs/ml_glossary/'>김태완님</a>과 박해선님의 우리말 용어를 사용하고자 하며, 원어를 병기합니다.  </p></blockquote><h3 id="한-줄-요약"><a href="#한-줄-요약" class="headerlink" title="한 줄 요약"></a>한 줄 요약</h3><ul><li>텐서플로2에는 데이터 처리와 모델 커스터마이제이션을 위한 편의기능이 많이 있습니다.</li></ul><p><img src="https://miro.medium.com/max/1400/1*Qo7hRVJkoYBCsZlzMFxEMQ.jpeg" alt="Photo by Author, Logo via [TensorFlow](https://www.tensorflow.org/)"></p><h2 id="머신러닝-실무자라면-알아야-하는-텐서플로-트릭-10가지"><a href="#머신러닝-실무자라면-알아야-하는-텐서플로-트릭-10가지" class="headerlink" title="머신러닝 실무자라면 알아야 하는 텐서플로 트릭 10가지"></a>머신러닝 실무자라면 알아야 하는 텐서플로 트릭 10가지</h2><ul><li>왜 텐서플로는 머신러닝 완결 패키지인가</li></ul><p>텐서플로 2.x은 모델 구축과 텐서플로 사용 전반을 훨씬 간결하게 해 줍니다. TF2에서 새로워진 점은 어떤 것들이 있을까요?</p><ul><li>   Keras와 즉시 실행(eager execution)이 있어 모델 구축이 쉽습니다.</li><li>   어떤 플랫폼에서도 동작하도록 모델을 탄탄하게 배포할 수 있습니다.</li><li>   연구에 강력한 실험을 적용할 수 있습니다.</li><li>   사라진 API를 정리하고 중복을 줄여서 API가 단촐해졌습니다.<br>이번 글에서는 텐서플로 작업을 부드럽게 만들어주고, 코딩을 짧게 해주어 효율성을 높여주는 TF 2.0의 특징 10가지를 텐서플로 API에 속한 함수/클래스들과 함께 살펴보겠습니다.</li></ul><h3 id="1-a-Input-Pipeline-구축에-좋은-tf-data-API"><a href="#1-a-Input-Pipeline-구축에-좋은-tf-data-API" class="headerlink" title="1(a) Input Pipeline 구축에 좋은 tf.data API"></a>1(a) Input Pipeline 구축에 좋은 tf.data API</h3><p>tf. data API는 데이터 파이프라인 구축 및 관련 기능을 제공합니다. 파이프라인을 구축하고, 전처리 함수들을 매핑(mapping)해주고, 데이터셋을 섞거나(shuffle) 배치(batch)로 잘라두는 외에도 많은 기능을 제공합니다.</p><h4 id="텐서-입력-파이프라인-구축"><a href="#텐서-입력-파이프라인-구축" class="headerlink" title="텐서 입력 파이프라인 구축"></a>텐서 입력 파이프라인 구축</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dataset = tf.data.Dataset.from_tensor_slices([8, 3, 0, 8, 2, 1])</span><br><span class="line">&gt;&gt;&gt; iter(dataset).next().numpy()</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h4 id="Batch와-Shuffle"><a href="#Batch와-Shuffle" class="headerlink" title="Batch와 Shuffle"></a>Batch와 Shuffle</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Shuffle</span></span><br><span class="line">&gt;&gt;&gt; dataset = tf.data.Dataset.from_tensor_slices([8, 3, 0, 8, 2, 1]).shuffle(6)</span><br><span class="line">&gt;&gt;&gt; iter(dataset).next().numpy()</span><br><span class="line">0</span><br><span class="line"><span class="comment"># Batch</span></span><br><span class="line">&gt;&gt;&gt; dataset = tf.data.Dataset.from_tensor_slices([8, 3, 0, 8, 2, 1]).batch(2)</span><br><span class="line">&gt;&gt;&gt; iter(dataset).next().numpy()</span><br><span class="line">array([8, 3], dtype=int32)</span><br><span class="line"><span class="comment"># Shuffle and Batch</span></span><br><span class="line">&gt;&gt;&gt; dataset = tf.data.Dataset.from_tensor_slices([8, 3, 0, 8, 2, 1]).shuffle(6).batch(2)</span><br><span class="line">&gt;&gt;&gt; iter(dataset).next().numpy()</span><br><span class="line">array([3, 0], dtype=int32)</span><br></pre></td></tr></table></figure><h4 id="두-데이터셋-묶기-zipping"><a href="#두-데이터셋-묶기-zipping" class="headerlink" title="두 데이터셋 묶기(zipping)"></a>두 데이터셋 묶기(zipping)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dataset0 = tf.data.Dataset.from_tensor_slices([8, 3, 0, 8, 2, 1])</span><br><span class="line">&gt;&gt;&gt; dataset1 = tf.data.Dataset.from_tensor_slices([1, 2, 3, 4, 5, 6])</span><br><span class="line">&gt;&gt;&gt; dataset = tf.data.Dataset.zip((dataset0, dataset1))</span><br><span class="line">&gt;&gt;&gt; iter(dataset).next()</span><br><span class="line">(&lt;tf.Tensor: shape=(), dtype=int32, numpy=8&gt;, &lt;tf.Tensor: shape=(), dtype=int32, numpy=1&gt;)</span><br></pre></td></tr></table></figure><h4 id="외부-함수-mapping"><a href="#외부-함수-mapping" class="headerlink" title="외부 함수 mapping"></a>외부 함수 mapping</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">into_2</span>(<span class="params">num</span>):</span></span><br><span class="line">     <span class="keyword">return</span> num * <span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dataset = tf.data.Dataset.from_tensor_slices([8, 3, 0, 8, 2, 1]).map(into_2)</span><br><span class="line">&gt;&gt;&gt; iter(dataset).next().numpy()</span><br><span class="line">16</span><br></pre></td></tr></table></figure><h3 id="1-b-ImageDataGenerator"><a href="#1-b-ImageDataGenerator" class="headerlink" title="1(b). ImageDataGenerator"></a>1(b). ImageDataGenerator</h3><p>제 의견입니다만 tensorflow.keras API의 가장 좋은 특징 중 하나라고 생각합니다. ImageDataGenerator는 데이터 증폭(data augmentation)과 동시에 batching과 전처리를 수행하는 데이터셋 슬라이스(dataset slice) 생성을 <b>실시간으로 할 수 있습니다.</b></p><blockquote><p>ImageDataGenerator의 데이터 증폭은 기존 데이터에 더 많은 데이터를 추가하는 것이라는 오해가 있습니다. 데이터 증폭의 정의는 이 말이 맞긴 하지만, ImageDataGenerator에서는 훈련 과정의 단계에 따라 역동적으로 데이터셋에 있는 이미지들이 변환됩니다. 따라서 머신러닝 모델은 본 적이 없는 노이즈와 함께 학습됩니다.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">train_datagen = ImageDataGenerator(</span><br><span class="line">        rescale=<span class="number">1.</span>/<span class="number">255</span>,</span><br><span class="line">        shear_range=<span class="number">0.2</span>,</span><br><span class="line">        zoom_range=<span class="number">0.2</span>,</span><br><span class="line">        horizontal_flip=<span class="literal">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>여기에서는 정규화(normalizing)를 위해 리스케일링(rescaling)도 함께 수행되고 있습니다. 다른 파라미터는 데이터 증폭 관련된 것들입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">train_generator = train_datagen.flow_from_directory(</span><br><span class="line">        <span class="string">&#x27;data/train&#x27;</span>,</span><br><span class="line">        target_size=(<span class="number">150</span>, <span class="number">150</span>),</span><br><span class="line">        batch_size=<span class="number">32</span>,</span><br><span class="line">        class_mode=<span class="string">&#x27;binary&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>실시간 데이터 수급을 위해 디렉토리를 지정합니다. 데이터프레임에도 똑같이 적용될 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">train_generator = flow_from_dataframe(</span><br><span class="line">    dataframe,</span><br><span class="line">    x_col=<span class="string">&#x27;filename&#x27;</span>,</span><br><span class="line">    y_col=<span class="string">&#x27;class&#x27;</span>,</span><br><span class="line">    class_mode=<span class="string">&#x27;categorical&#x27;</span>,</span><br><span class="line">    batch_size=<span class="number">32</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>$$x _ col$$에 이미지의 전체 경로를 정의하고, $$y _ col$$에 분류할 레이블 열을 지정합니다.<br>머신러닝 모델에는 생성기가 직접 연결될 수 있습니다. 다만 이 때, $$steps _ per _ epoch$$ 파라미터가 $$number _ of _ samples$$//$$batch _ size$$로 지정되어야 합니다.</p><h3 id="2-tf-image를-활용한-데이터-증폭"><a href="#2-tf-image를-활용한-데이터-증폭" class="headerlink" title="2. tf.image를 활용한 데이터 증폭"></a>2. tf.image를 활용한 데이터 증폭</h3><p>데이터 증폭은 꼭 필요합니다. 데이터가 부족할 때 데이터를 바꾸며 이를 별도의 데이터포인트로 다루면 적은 수의 데이터로도 효과적으로 훈련시킬 수 있습니다.</p><p>tf.image API 는 이미지를 변환시키는 도구를 여럿 가지고 있습니다. 이렇게 변환된 이미지는 앞서 언급한 tf.data API를 통한 데이터 증폭에 사용될 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flipped = tf.image.flip_left_right(image)</span><br><span class="line">visualise(image, flipped)</span><br></pre></td></tr></table></figure><p><img src="https://miro.medium.com/max/1400/1*4r3ORe9aGUj6oZuAi3LMhA.png" alt="실행결과"><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">saturated = tf.image.adjust_saturation(image, <span class="number">5</span>)</span><br><span class="line">visualise(image, saturated)</span><br></pre></td></tr></table></figure><p><img src="https://miro.medium.com/max/1400/1*956iNTt7nZJqwWqGJ7rNvQ.png" alt="실행결과"><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rotated = tf.image.rot90(image)</span><br><span class="line">visualise(image, rotated)</span><br></pre></td></tr></table></figure><p><img src="https://miro.medium.com/max/1322/1*Q0vRv6oXMH55WcyQ1dMRFg.png" alt="실행결과"><br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cropped = tf.image.central_crop(image, central_fraction=<span class="number">0.5</span>)</span><br><span class="line">visualise(image, cropped)</span><br></pre></td></tr></table></figure><p><img src="https://miro.medium.com/max/1400/1*LQAhaU_inaWIBjruwpKEtw.png" alt="실행결과"><br></p><h3 id="3-텐서플로-데이터셋"><a href="#3-텐서플로-데이터셋" class="headerlink" title="3. 텐서플로 데이터셋"></a>3. 텐서플로 데이터셋</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tensorflow-datasets</span><br></pre></td></tr></table></figure><p>텐서플로가 모아둔, 매우 잘 알려진 여러 분야의 데이터셋을 한 방에 가지고 올 수 있는 매우 유용한 라이브러리입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow_datasets <span class="keyword">as</span> tfds</span><br><span class="line"></span><br><span class="line">mnist_data = tfds.load(<span class="string">&quot;mnist&quot;</span>)</span><br><span class="line">mnist_train, mnist_test = mnist_data[<span class="string">&quot;train&quot;</span>], mnist_data[<span class="string">&quot;test&quot;</span>]</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">isinstance</span>(mnist_train, tf.data.Dataset)</span><br></pre></td></tr></table></figure><p>tensorflow-dataset에서 제공하는 데이터셋의 상세 목록은 공식 문서의 <a href="https://www.tensorflow.org/datasets/catalog/overview">데이터셋 페이지</a>에서 볼 수 있습니다.</p><blockquote><p>오디오, 이미지, 이미지 분류, 객체 인식, 정형, 요약, 문서, 번역, 동영상 등이 제공됩니다.</p></blockquote><h3 id="4-사전학습-모델을-활용한-전이학습"><a href="#4-사전학습-모델을-활용한-전이학습" class="headerlink" title="4. 사전학습 모델을 활용한 전이학습"></a>4. 사전학습 모델을 활용한 전이학습</h3><p>전이학습은 머신러닝의 샛별이며, 그만큼 중요합니다. 누군가가 충분한(예. 일반인이 접하기 어려운 다수의 고가 GPU) 자원을 이용해 학습해둔 벤치마크 모델을 다시 학습하는 건 가능 하지도 않고 도움도 되지 않습니다. 전이학습은 이런 상황에 좋습니다. 사전학습 모델을 주어진 사례에 재사용하거나 다른 사례에 확장해서 적용할 수 있습니다.<br>텐서플로는 당면 과제에 적용하기 좋도록 벤치마크 사전학습 모델을 제공합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">base_model = tf.keras.applications.MobileNetV2(</span><br><span class="line">    input_shape=IMG_SHAPE,</span><br><span class="line">    include_top=<span class="literal">False</span>,</span><br><span class="line">    weights=<span class="string">&#x27;imagenet&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>여기 있는 $$base _ model$$은 추가 레이어나 다른 모델로 쉽게 확장이 가능합니다. 예를 들면,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model = tf.keras.Sequential([</span><br><span class="line">    base_model,</span><br><span class="line">    global_average_layer,</span><br><span class="line">    prediction_layer</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>다른 사전학습 모델 목록이나 tf.keras.applications의 모듈에 대해서는 <a href="https://www.tensorflow.org/api_docs/python/tf/keras/applications">문서 페이지</a>를 참고하세요.</p><h3 id="5-에스티메이터-Estimators"><a href="#5-에스티메이터-Estimators" class="headerlink" title="5. 에스티메이터(Estimators)"></a>5. 에스티메이터(Estimators)</h3><blockquote><p>에스티메이터는 전체 모델에 대한 텐서플로의 하이레벨 표현이며, 쉬운 스케일링과 비동기 훈련을 위해 설계되었다 – <a href="https://www.tensorflow.org/tutorials/estimator/premade">텐서플로 문서</a></p></blockquote><p>사전제작된 에스티메이터는 매우 높은 수준으로 추상화된 모델을 제공하여, 여러분들은 복잡한 하위 레벨에 대해선 마음을 놓고 모델 훈련에만 집중할 수 있습니다. 예를 들면,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">linear_est = tf.estimator.LinearClassifier(</span><br><span class="line">    feature_columns=feature_columns</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">linear_est.train(train_input_fn)</span><br><span class="line">result = linear_est.evaluate(eval_input_fn)</span><br></pre></td></tr></table></figure><p>위 예제는 tf.estimator를 이용해 에스티메이터를 구축하고 훈련하기가 얼마나 쉬운지를 보여줍니다.<br>에스티메이터는 맞춤형으로 만들 수 있습니다.<br>텐서플로에는 LinearRegressor, BoostedTreesClassifier 등과 같은 사전제작된 에스티메이터가 많이 있습니다. 전체 에스티메이터에 대한 상세한 설명은 <a href="https://www.tensorflow.org/api_docs/python/tf/estimator">텐서플로 문서</a>에서 보실 수 있습니다.</p><h3 id="6-맞춤형-레이어-Custom-Layers"><a href="#6-맞춤형-레이어-Custom-Layers" class="headerlink" title="6. 맞춤형 레이어(Custom Layers)"></a>6. 맞춤형 레이어(Custom Layers)</h3><p>신경망에는 여러 종류의 심층 네트워크 모델이 있다고 알려져 있습니다. 텐서플로에는 Dense, LSTM처럼 미리 정의된 레이어들이 있습니다. 하지만 더 복잡한 아키텍쳐에서는 레이어의 논리적 동작이 기본 레이어보다 훨씬 복잡합니다. 이럴 때를 대비해서, 텐서플로는 맞춤형 레이어 구축을 허용합니다. tf.keras.layers.Layer 클래스를 상속받아 만들 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomDense</span>(<span class="params">tf.keras.layers.Layer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_outputs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(CustomDense, self).__init__()</span><br><span class="line">        self.num_outputs = num_outputs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, input_shape</span>):</span></span><br><span class="line">        self.kernel = self.add_weight(</span><br><span class="line">            <span class="string">&quot;kernel&quot;</span>,</span><br><span class="line">            shape=[<span class="built_in">int</span>(input_shape[-<span class="number">1</span>]),</span><br><span class="line">            self.num_outputs]</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> tf.matmul(<span class="built_in">input</span>, self.kernel)</span><br></pre></td></tr></table></figure><p><a href="https://www.tensorflow.org/tutorials/customization/custom_layers">문서</a>에 기술된 바와 같이, 사용자 본인의 레이어를 구현하는 가장 좋은 방법은 tf.keras.Layer를 확장해서 구현하는 것입니다.</p><ol><li>   _ _$$init$$_ _: 입력과 무관한 초기화를 여기에 넣으세요</li><li>   $$build$$ : 입력 텐서의 모양(shape)을 받아서 할 수 있는 나머지 초기화를 여기에서 합니다.</li><li>   $$call$$ : 순방향 연산(forward computation)을 합니다.<br>커널 초기화를 _ _$$init$$_ _ 자체에서 구현할 수 있지만, build에서 구현하는 것이 더 좋습니다. 그렇지 않으면 매번 레이어 인스턴스를 생성할 때마다 input_shape을 명시해야 하기 때문입니다.</li></ol><h3 id="7-맞춤형-훈련-Custom-Training"><a href="#7-맞춤형-훈련-Custom-Training" class="headerlink" title="7. 맞춤형 훈련(Custom Training)"></a>7. 맞춤형 훈련(Custom Training)</h3><p>tf.keras의 Sequential 과 Model API를 사용하면 모델을 쉽게 훈련할 수 있습니다. 그러나 복잡한 모델을 훈련시키는 시간 대부분은 맞춤형 손실함수(custom loss functions)가 사용됩니다. 게다가, 모델 훈련은 기본값이랑 다른 경우도 있습니다 (예를 들어 다른 모델 요소에 그레이디언트를 다르게 적용하는 경우가 있습니다)<br>텐서플로의 자동미분을 이용하면 그레이디언트를 효과적으로 계산할 수 있는데, 이는 맞춤형 훈련 과정을 정의할 때 사용할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">model, inputs, outputs, learning_rate</span>):</span></span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> t:</span><br><span class="line">        <span class="comment"># Computing Losses from Model Prediction</span></span><br><span class="line">        current_loss = loss(outputs, model(inputs))</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># Gradients for Trainable Variables with Obtained Losses</span></span><br><span class="line">    dW, db = t.gradient(current_loss, [model.W, model.b])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Applying Gradients to Weights</span></span><br><span class="line">    model.W.assign_sub(learning_rate * dW)</span><br><span class="line">    model.b.assign_sub(learning_rate * db)</span><br></pre></td></tr></table></figure><p>이렇게 하면 사례별로 걸맞게 설정된 훈련을 여러 에포크(epoch) 반복할 수 있습니다.</p><h3 id="8-체크포인트-Checkpoints"><a href="#8-체크포인트-Checkpoints" class="headerlink" title="8. 체크포인트(Checkpoints)"></a>8. 체크포인트(Checkpoints)</h3><p>텐서플로 모델은 두 가지 방법으로 저장할 수 있습니다.</p><p>  <b>1.    SavedModel :</b> 모델의 전체 상태를 파라미터와 함께 저장합니다. 소스코드와 무관합니다.<br>  <b>2.    Chekpoints</b></p><p>체크포인트는 모델에 사용된 파라미터의 정확한 값들을 저장합니다. Sequential API나 Model API로 작성된 모델은 SavedModel 형식으로만 저장할 수 있습니다.</p><p>그러나, 맞춤형 모델이라면 체크포인트가 필요합니다.</p><blockquote><p>체크포인트는 모델에서 정의된 계산이 어떻게 진행되는지에 대한 정보를 가지고 있지 않기 때문에, 파라미터만 가져오는 코스와 함께 사용될 때만 유용합니다.</p></blockquote><ul><li><b>체크포인트 저장</b><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">checkpoint_path = “save_path”</span><br><span class="line"></span><br><span class="line"><span class="comment"># Defining a Checkpoint</span></span><br><span class="line">ckpt = tf.train.Checkpoint(model=model, optimizer=optimizer)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating a CheckpointManager Object</span></span><br><span class="line">ckpt_manager = tf.train.CheckpointManager(ckpt, checkpoint_path, max_to_keep=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Saving a Model</span></span><br><span class="line">ckpt_manager.save()</span><br></pre></td></tr></table></figure></li></ul><ul><li><b>체크포인트 불러오기</b><br>텐서플로는 방향 그래프(directed graph)를 객체가 로딩되는 지점부터 가로지르며 변수와 체크포인트 값들을 이름이 붙은 엣지(named edge)와 매칭합니다.<br><img src="https://miro.medium.com/max/1400/1*rMqi-aL9mGFFWgbk5zw6UQ.png" alt="모델 복구 의존성 그래프 [문서](https://www.tensorflow.org/guide/checkpoint)"></li></ul><h3 id="9-케라스-튜너-Keras-Tuner"><a href="#9-케라스-튜너-Keras-Tuner" class="headerlink" title="9. 케라스 튜너(Keras Tuner)"></a>9. 케라스 튜너(Keras Tuner)</h3><p>텐서플로의 신무기입니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install keras-tuner</span><br></pre></td></tr></table></figure><p>하이퍼파라미터 튜닝, 또는 하이퍼튜닝은 머신러닝 모델 성능을 최적화하는 단계입니다. 하이퍼파라미터는 특성 공학(feature engineering)과 전처리 이후 모델의 성능을 결정짓는 인자입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># model_builder is a function that builds a model and returns it</span></span><br><span class="line">tuner = kt.Hyperband(</span><br><span class="line">    model_builder,</span><br><span class="line">    objective=<span class="string">&#x27;val_accuracy&#x27;</span>, </span><br><span class="line">    max_epochs=<span class="number">10</span>,</span><br><span class="line">    factor=<span class="number">3</span>,</span><br><span class="line">    directory=<span class="string">&#x27;my_dir&#x27;</span>,</span><br><span class="line">    project_name=<span class="string">&#x27;intro_to_kt&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>HyperBand와 더불어 BayesianOptimization과 RandomSearch를 튜닝에 사용할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tuner.search(</span><br><span class="line">    img_train, label_train, </span><br><span class="line">    epochs = <span class="number">10</span>, </span><br><span class="line">    validation_data=(img_test,label_test), </span><br><span class="line">    callbacks=[ClearTrainingOutput()]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the optimal hyperparameters</span></span><br><span class="line">best_hps = tuner.get_best_hyperparameters(num_trials=<span class="number">1</span>)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>이어서 최적화된 하이퍼파라미터로 모델을 훈련할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">model = tuner.hypermodel.build(best_hps)</span><br><span class="line">model.fit(</span><br><span class="line">    img_train, </span><br><span class="line">    label_train, </span><br><span class="line">    epochs=<span class="number">10</span>, </span><br><span class="line">    validation_data=(img_test, label_test)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="11-분산훈련-Distributed-Training"><a href="#11-분산훈련-Distributed-Training" class="headerlink" title="11. 분산훈련(Distributed Training)"></a>11. 분산훈련(Distributed Training)</h3><p>여러분에게 여러 대의 GPU가 있고 여기에 대한 분산 훈련을 최적화하고 싶으시다면 텐서플로의 다양한 분산 훈련 전략을 통해서 GPU 사용과 GPU 훈련 시간을 최적화 할 수 있습니다.</p><p>tf.distribute.MirroredStrategy는 가장 일반적인 전략입니다. 어떻게 작동하는지 알아볼까요? 문서에 이렇게 나와있습니다.</p><ul><li>모든 변수와 모델의 복사본을 만듭니다.</li><li>입력이 복사본들에 균등하게 나누어집니다.</li><li>각각의 복사본들이 받은 입력에 대해 손실(loss)과 그레이디언트를 계산합니다.</li><li>모든 복사본 간에 그레이디언트가 동기화되고 더해집니다.</li><li>동기화가 끝나면, 각 복사본들의 변수 복사본에 같은 방식으로 업데이트를 합니다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">strategy = tf.distribute.MirroredStrategy()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> strategy.scope():</span><br><span class="line">    model = tf.keras.Sequential([</span><br><span class="line">        tf.keras.layers.Conv2D(</span><br><span class="line">            <span class="number">32</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>,  input_shape=(<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br><span class="line">        ),</span><br><span class="line">        tf.keras.layers.MaxPooling2D(),</span><br><span class="line">        tf.keras.layers.Flatten(),</span><br><span class="line">        tf.keras.layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">        tf.keras.layers.Dense(<span class="number">10</span>)</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    model.<span class="built_in">compile</span>(</span><br><span class="line">        loss=<span class="string">&quot;sparse_categorical_crossentropy&quot;</span>,</span><br><span class="line">        optimizer=<span class="string">&quot;adam&quot;</span>,</span><br><span class="line">        metrics=[<span class="string">&#x27;accuracy&#x27;</span>]</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>다른 맞춤형 훈련에 대해서는 문서를 참고하세요.</p><h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><p>텐서플로는 머신러닝 파이프라인의 거의 모든 구성요소를 구축하기에 충분합니다.아래 튜토리얼에서 얻어갈 것은, 텐서플로에서 제공하는 다양한 API에 대한 소개 및 어떻게 사용하는지에 대한 퀵 가이드입니다.</p><p><a href="https://github.com/rojagtap/tensorflow_tutorials">여기</a>에 GitHub 코드 저장소 링크가 있습니다. 포크해보세요.</p><h3 id="참고문헌"><a href="#참고문헌" class="headerlink" title="참고문헌"></a>참고문헌</h3><p>본 가이드에 사용된 코드들은 공식 텐서플로 문서를 참조했습니다.</p><p><a href="https://www.tensorflow.org/tutorials"><b>Tutorials | TensorFlow Core</b></a></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Deep-Learning/">Deep Learning</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/tensorflow/">tensorflow</category>
      
      <category domain="https://jehyunlee.github.io/tags/deep-learning/">deep learning</category>
      
      <category domain="https://jehyunlee.github.io/tags/translation/">translation</category>
      
      
    </item>
    
    <item>
      <title>3. Threshold on channels</title>
      <link>https://jehyunlee.github.io/2020/04/20/ImageJ-cookbook-3-ChannelThreshold/</link>
      <guid>https://jehyunlee.github.io/2020/04/20/ImageJ-cookbook-3-ChannelThreshold/</guid>
      <pubDate>Sun, 19 Apr 2020 22:20:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;b&gt;Reference&lt;/b&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://wiki.cmci.info/documents/120206pyip_cooking/python_imagej_cookbook&quot;&gt;Python + ImageJ,</description>
        
      
      
      
      <content:encoded><![CDATA[<p><b>Reference</b></p><blockquote><p><a href="http://wiki.cmci.info/documents/120206pyip_cooking/python_imagej_cookbook">Python + ImageJ, Fiji Cookbook: Channel Merge</a><br><a href="https://imagej.nih.gov/ij/developer/api/ij/process/ImageProcessor.html">Class ImageProcessor</a><br><a href="https://javadoc.scijava.org/ImageJ1/ij/process/ColorProcessor.html#toFloat(int,%20ij.process.FloatProcessor">Class ColorProcessor</a></p></blockquote><ul><li>color image의 RGB channel마다 다른 threshold를 적용해 이미지 색조를 수정하겠습니다.</li><li>전체 코드는 <a href="ChannelThreshold.py">여기에서 받을 수 있습니다</a>.</li></ul><h2 id="1-Color-Threshold-GUI"><a href="#1-Color-Threshold-GUI" class="headerlink" title="1. Color Threshold (GUI)"></a>1. Color Threshold (GUI)</h2><blockquote><p><a href="https://chrisk91.me/2016/10/05/Hands-on-Color-models-and-ImageJ.html">Hands on - color models and ImageJ</a></p></blockquote><ul><li>ImageJ는 이미지의 특정 channel을 추출하여 수정할 수 있습니다. </li><li>여러 색의 개체가 한 이미지에 있고, 색상 등으로 이미지를 분석하는 것이 유리할 때가 있습니다.</li><li>아래 그림의 어두운 세포를 추출해보겠습니다. (<a href="https://commons.wikimedia.org/wiki/File:Chronic_lymphocytic_leukemia.jpg">원본 다운로드</a>)<br><br><img src="3_cth_2.png" alt="Chronic lymphocytic leukemia"></li></ul><h3 id="1-1-이미지-채널-분할"><a href="#1-1-이미지-채널-분할" class="headerlink" title="1.1. 이미지 채널 분할"></a>1.1. 이미지 채널 분할</h3><ul><li>위 예제 이미지를 다운받아 <b>Image &gt; Properties…</b>로 확인해봅니다.</li><li>channel이 1개, slice가 1개임을 확인할 수 있습니다.<br><br><img src="3_cth_3.png"></li></ul><h4 id="1-1-1-RGB"><a href="#1-1-1-RGB" class="headerlink" title="1.1.1. RGB"></a>1.1.1. RGB</h4><ul><li>RGB 색상별 조작을 하기 위해 별도의 채널로 만들어줍니다.</li><li>제목 그대로 컬러 이미지를 Red, Green, Blue image stack으로 만듭니다.<br><b>Image &gt; Type &gt; RGB Stack</b><br><br><img src="3_cth_4.png"></li></ul><ul><li>image 윈도 아래 있는 슬라이드를 옮기며 어떤 채널이 효과적일지 봅시다.</li><li>원본의 어두운 세포와 주변의 다른 세포들간 대조(contrast)가 크면 분리하기 좋습니다.</li><li>Blue channel은 세포별 구분이 잘 되지 않지만, red는 눈에 크게 뜨입니다.<ul><li>찾으려는 cell은 보라색이라 blue가 구분이 잘 되어야 할 듯 한데 red, green에서 차이가 납니다.</li><li>전반적으로 우리가 찾는 cell을 <b>제외</b>한 전역에 red, green이 깔려 있기 때문입니다.</li></ul></li></ul><h4 id="1-1-2-HSV-HSB"><a href="#1-1-2-HSV-HSB" class="headerlink" title="1.1.2. HSV(HSB)"></a>1.1.2. HSV(HSB)</h4><ul><li>이미지를 RGB channel 외에 다른 방식으로도 분할할 수 있습니다.</li><li>원본 이미지에 <b>Image &gt; Type &gt; HSB Stack</b>을 지정한 후 채널 분할을 수행하면 Hue (색상), Saturation (채도), Brightness (or Value. 명도)로 구분되는 채널이 얻어집니다.<br><br><img src="3_cth_5.png"></li></ul><h4 id="1-1-3-이미지-채널-분할-LAB"><a href="#1-1-3-이미지-채널-분할-LAB" class="headerlink" title="1.1.3. 이미지 채널 분할: LAB"></a>1.1.3. 이미지 채널 분할: LAB</h4><blockquote><p><a href="https://en.wikipedia.org/wiki/CIELAB_color_space">Wikipedia: CIELAB</a><br><a href="https://jehyunlee.github.io/2020/03/13/Python-DS-5-matplotlib_colormap2/">Pega Devlog: Matplotlib Colormap (2)</a></p></blockquote><ul><li>내친 김에 LAB 방식으로도 분할해 봅시다.</li><li>우리가 집중하고자 하는 세포가 가장 잘 드러나는 것이 목적이니 후보는 많을 수록 좋습니다.<br><b>Image &gt; Type &gt; Lab Stack</b><br><br><img src="3_cth_6.png"></li></ul><h3 id="1-2-채널을-이미지로-저장"><a href="#1-2-채널을-이미지로-저장" class="headerlink" title="1.2. 채널을 이미지로 저장"></a>1.2. 채널을 이미지로 저장</h3><ul><li><b>Image &gt; Stacks &gt; Stacks to Images</b> 를 통해 분할한 채널을 개별 이미지로 저장할 수 있습니다.</li></ul><h3 id="1-3-채널-병합"><a href="#1-3-채널-병합" class="headerlink" title="1.3. 채널 병합"></a>1.3. 채널 병합</h3><ul><li>분할된 채널은 다음과 같은 두 가지 방법으로 병합될 수 있습니다.</li></ul><ol><li><b>Image &gt; Color &gt; Stack to RGB</b> : 분할된 이미지가 사라집니다.</li><li><b>Image &gt; Type &gt; RGB Color</b></li></ol><ul><li><b>1번 방식</b>은 채널 분할 방식에 관계없이 정상적인 이미지로 병합됩니다.<br>그러나 <b>2번 방식</b>은 RGB 외의 HSV나 LAB 방식엔 통용되지 않으니 주의가 필요합니다.</li><li>단, 지금 수행하고자 하는 분석은 채널 병합을 하지 않아도 됩니다.</li></ul><h2 id="2-Color-Threshold-GUI"><a href="#2-Color-Threshold-GUI" class="headerlink" title="2. Color Threshold (GUI)"></a>2. Color Threshold (GUI)</h2><blockquote><p><a href="https://imagej.nih.gov/ij/docs/guide/146-28.html">ImageJ User Guide: Color Threshold…</a></p></blockquote><ul><li>Color Threshold를 통해 색상을 기준으로 개체를 선택할 수 있습니다.</li><li>앞서 LAB 방식의 $a^*$에서 어두운 cell이 잘 분리되었으니 이를 활용해봅시다.</li><li><b>Image &gt; Adjust &gt; Color Threshold…</b>를 실행하고 다음과 같이 조정해 봅니다.<br><ul><li>$$ L^* $$ : 0<del>203, $$a^* $$: 153</del>255, $$b^* $$: 0~255<br><br><img src="3_cth_7.png"></li></ul></li></ul><ul><li>버튼별 기능은 다음과 같습니다.<ul><li><b>Pass : </b> 체크시 thresholds 내부(band-pass), 해제시 외부(band-reject) 선택.</li><li><b>Thresholding Method : </b>Threshold 방법 16가지 선택</li><li><b>Threshold Color : </b>선택영역 표시 (Red, Black, White, Black&amp;White)</li><li><b>Color space : </b>HSB, RGB, CIE Lab or YUV</li><li><b>Dark background : </b>체크시 밝은 부분 선택, 해제시 어두운 부분 선택</li><li><b>Original : </b>원본 이미지 복구 및 버퍼 업데이트</li><li><b>Filtered : </b>필터링 결과(RGB) 보여주기. </li><li><b>Select : </b>필터링 결과로 ROI 생성. <b>Process &gt; Binary &gt; Options…</b> 설정을 따름.</li><li><b>Sample : </b>(experimental) 사용자 정의 ROI에 맞춰 Thresholding 수행</li><li><b>Stack : </b>(만약 있다면) 다른 slice에 현재 설정 적용.</li><li><b>Macro : </b>현재 세팅을 Macro에 저장. <b>Plugins &gt; Macros &gt; Record</b> 실행시에만 작동.</li><li><b>Help : </b>빌트인 도움말 창 열기.</li></ul></li></ul><h2 id="3-Create-Selection-GUI"><a href="#3-Create-Selection-GUI" class="headerlink" title="3. Create Selection (GUI)"></a>3. Create Selection (GUI)</h2><blockquote><p><a href="https://imagej.nih.gov/ij/docs/guide/146-10.html">ImageJ User Guide: Manipulating ROIs</a><br><a href="https://imagej.nih.gov/ij/docs/guide/146-30.html">ImageJ Particle Analysis</a></p></blockquote><h3 id="3-1-선택영역-다듬기"><a href="#3-1-선택영역-다듬기" class="headerlink" title="3.1. 선택영역 다듬기"></a>3.1. 선택영역 다듬기</h3><ul><li>일부 particle내부에는 hole이 있고, 선택하지 않을 작은 점 단위도 있습니다.</li><li><b>Edit &gt; Selection &gt; Enlarge…</b>에서 6 px과 -6 px을 번갈아 적용합니다.</li><li>positive value를 선택하면 hole이 메워지고, negative로 외곽선을 원상복구합니다.<br><br><img src="3_cth_9.png"></li></ul><h3 id="3-2-선택영역-분석"><a href="#3-2-선택영역-분석" class="headerlink" title="3.2. 선택영역 분석"></a>3.2. 선택영역 분석</h3><ul><li><b>Select</b>로 threshold를 ROI로 변경합니다.</li><li><b>Analysis &gt; Set Measurements…</b>에서 <b>Area</b>와 <b>Centroid</b>를 선택합니다.</li></ul><ul><li><b>Analysis &gt; Analyze Particles…</b>로 cell의 면적과 위치를 분석합니다.<ul><li>가로세로 4 x 4 미만의 pixel은 noise로 간주합니다: size의 최소값에 16을 넣습니다.</li><li>분석된 세포와 결과를 매칭하기 위해 <b>Show:</b>에서 <b>Overlay</b>를 선택합니다.</li></ul></li></ul><ul><li>분석 결과 이미지와 표가 동시에 출력됩니다.<br><br><img src="3_cth_8.png"></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/ImageJ/">ImageJ</category>
      
      <category domain="https://jehyunlee.github.io/categories/ImageJ/Cookbook/">Cookbook</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/imagej/">imagej</category>
      
      <category domain="https://jehyunlee.github.io/tags/cookbook/">cookbook</category>
      
      <category domain="https://jehyunlee.github.io/tags/channel-threshold/">channel threshold</category>
      
      
    </item>
    
    <item>
      <title>Google Map, Naver Map URL 만들기</title>
      <link>https://jehyunlee.github.io/2020/04/15/GIS-Python-1-GoogleMapNaverMap/</link>
      <guid>https://jehyunlee.github.io/2020/04/15/GIS-Python-1-GoogleMapNaverMap/</guid>
      <pubDate>Wed, 15 Apr 2020 08:11:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;b&gt;References&lt;/b&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.google.com/maps&quot;&gt;Google Maps&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://map.naver.com/v5/?c=14165</description>
        
      
      
      
      <content:encoded><![CDATA[<p><b>References</b></p><blockquote><p><a href="https://www.google.com/maps">Google Maps</a><br><a href="https://map.naver.com/v5/?c=14165606.1351249,4367543.5483238,15,0,0,0,dh">네이버 지도</a></p></blockquote><ul><li>지리데이터를 분석하다 보면 웹기반 지도서비스가 필요할 때가 있습니다.</li><li>API를 사용해서 notebook 상에서 띄워볼 수도 있지만 전체 기능이 필요하기도 합니다.</li></ul><ul><li>이럴 때는 웹브라우저를 켜고 구글 지도나 네이버 지도를 들어가 검색을 합니다.<ul><li>주소를 알면 간단하겠지만 위경도 좌표밖에 모른다면 많이 성가십니다. </li><li>이 과정을 자동화 해보겠습니다.</li></ul></li></ul><h2 id="1-지도-URL-만들기"><a href="#1-지도-URL-만들기" class="headerlink" title="1. 지도 URL 만들기"></a>1. 지도 URL 만들기</h2><h3 id="1-1-Google-Map"><a href="#1-1-Google-Map" class="headerlink" title="1.1. Google Map"></a>1.1. Google Map</h3><ul><li>구글 지도의 URL은 <code>https://google.co.kr/maps/@&#123;위도&#125;,&#123;경도&#125;,&#123;배율&#125;z</code>형식입니다.</li><li>아래와 같이 간단한 함수를 만들어 위도, 경도, 배율을 URL로 바꿀 수 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_google_map</span>(<span class="params">lat: <span class="built_in">float</span>, lon: <span class="built_in">float</span>, mag: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;https://google.co.kr/maps/@<span class="subst">&#123;lat&#125;</span>,<span class="subst">&#123;lon&#125;</span>,<span class="subst">&#123;mag&#125;</span>z&quot;</span></span><br></pre></td></tr></table></figure><img src="1_gnmap_2.PNG" alt="https://google.co.kr/maps/@36.2736711443984,127.473926291928,18z"></li></ul><h3 id="1-2-네이버-지도"><a href="#1-2-네이버-지도" class="headerlink" title="1.2. 네이버 지도"></a>1.2. 네이버 지도</h3><blockquote><p><a href="https://pyproj4.github.io/pyproj/stable/">pyproj Documentation</a></p></blockquote><ul><li>네이버 지도의 URL은 <code>http://map.naver.com/v5/search?c=&#123;x좌표&#125;,&#123;y좌표&#125;,&#123;배율&#125;,0,0,0,dh</code>형식입니다.<ul><li>네이버 지도는 위도와 경도 대신 환산된 x, y 좌표를 받습니다.</li><li>네이버 지도 v5 기준으로 <code>EPSG:3857</code>좌표계를 사용하므로 환산 과정이 필요합니다.</li></ul></li></ul><ul><li><code>pyproj</code>의 <code>Proj</code>로 기준 좌표계를 설정하고 <code>transform</code>으로 변환을 수행합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyproj <span class="keyword">import</span> Proj, transform</span><br><span class="line"></span><br><span class="line"><span class="comment"># navermap</span></span><br><span class="line">proj_NAVER = Proj(init=<span class="string">&#x27;epsg:3857&#x27;</span>)</span><br><span class="line"><span class="comment"># WGS1984</span></span><br><span class="line">proj_WGS1984 = Proj(init=<span class="string">&#x27;epsg:4326&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_naver_map</span>(<span class="params">lat: <span class="built_in">float</span>, lon: <span class="built_in">float</span>, mag: <span class="built_in">int</span></span>):</span></span><br><span class="line">    x, y = transform(proj_WGS1984, proj_NAVER, lon, lat)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;http://map.naver.com/v5/search?c=<span class="subst">&#123;x&#125;</span>,<span class="subst">&#123;y&#125;</span>,<span class="subst">&#123;mag&#125;</span>,0,0,0,dh&quot;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>URL 마지막에 <code>0,0,0,</code>이라는 숫자가 있는데 각 자리의 의미는 다음과 같습니다.</li><li>첫번째와 두번째 숫자는 의미가 없고, <b>세번째</b> 숫자가 <b>지도 타입</b>을 결정합니다.<br>0: 일반 지도<br>  <img src="1_gnmap_1.PNG" alt="https://map.naver.com/v5/?c=14190332.5642367,4338343.7349721,18,0,0,0,dh"><br>1: 위성 지도<br>  <img src="1_gnmap_3.PNG" alt="https://map.naver.com/v5/?c=14190332.5642367,4338343.7349721,18,0,0,1,dh"><br>2: 위성지도 + 건물명, 도로명, 번지<br>  <img src="1_gnmap_4.PNG" alt="https://map.naver.com/v5/?c=14190332.5642367,4338343.7349721,18,0,0,2,dh"><br>3: 지형지도 + 건물명, 도로명, 번지<br>  <img src="1_gnmap_5.PNG" alt="https://map.naver.com/v5/?c=14190332.5642367,4338343.7349721,18,0,0,3,dh"></li></ul><h2 id="2-Pandas-Dataframe에-적용하기"><a href="#2-Pandas-Dataframe에-적용하기" class="headerlink" title="2. Pandas Dataframe에 적용하기"></a>2. Pandas Dataframe에 적용하기</h2><ul><li><code>pandas.DataFrame</code>이나 <code>geopandas.geoDataFrame</code>에 <code>.apply()</code>를 적용해서 구글 지도와 네이버 지도의 URL을 담을 수 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;googlemap&#x27;</span>] = df.apply(<span class="keyword">lambda</span> x: create_google_map(x[<span class="string">&#x27;lat&#x27;</span>], x[<span class="string">&#x27;lon&#x27;</span>]), axis=<span class="number">1</span>)</span><br><span class="line">df[<span class="string">&#x27;navermap&#x27;</span>] = df.apply(<span class="keyword">lambda</span> x: create_naver_map(x[<span class="string">&#x27;lat&#x27;</span>], x[<span class="string">&#x27;lon&#x27;</span>]), axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><img src="1_gnmap_6.PNG"></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/GIS/">GIS</category>
      
      <category domain="https://jehyunlee.github.io/categories/GIS/Python/">Python</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/gis/">gis</category>
      
      <category domain="https://jehyunlee.github.io/tags/google-map/">google map</category>
      
      <category domain="https://jehyunlee.github.io/tags/naver-map/">naver map</category>
      
      
    </item>
    
    <item>
      <title>Raster Data Sampling on Polygons</title>
      <link>https://jehyunlee.github.io/2020/04/09/GIS-QGIS-1-RasterZonalAnalysis/</link>
      <guid>https://jehyunlee.github.io/2020/04/09/GIS-QGIS-1-RasterZonalAnalysis/</guid>
      <pubDate>Thu, 09 Apr 2020 01:43:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;b&gt;References&lt;/b&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://qgis.org/ko/site/&quot;&gt;QGIS&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/GeoTIFF&quot;&gt;wik</description>
        
      
      
      
      <content:encoded><![CDATA[<p><b>References</b></p><blockquote><p><a href="https://qgis.org/ko/site/">QGIS</a><br><a href="https://en.wikipedia.org/wiki/GeoTIFF">wikipedia: GeoTIFF</a><br><a href="https://en.wikipedia.org/wiki/Shapefile">wikipedia: Shapefile</a><br><a href="https://www.qgistutorials.com/en/docs/sampling_raster_data.html">Sampling Raster Data using Points or Polygons</a></p></blockquote><ul><li><a href="https://qgis.org/ko/site/">QGIS</a>에서 geotiff 등 raster file을 shape file에 투영하는 방법을 정리합니다.</li><li>사용한 QGIS의 버전은 <code>3.4.13-Madeira</code> 입니다.</li></ul><h3 id="1-Load-Data-raster-file-and-shapefile"><a href="#1-Load-Data-raster-file-and-shapefile" class="headerlink" title="1. Load Data (raster file and shapefile)"></a>1. Load Data (raster file and shapefile)</h3><ul><li>먼저 raster data를 불러옵니다.</li><li><code>Layer &gt; Add Raster Layer...</code>를 이용해도 되고, 탐색기에서 끌어와도 됩니다.<br><br><img src="1_rza_1.PNG" alt="raster file"></li><li>이번에는 건물 데이터를 불러옵니다.  </li><li>마찬가지로 <code>Layer &gt; Add Vector Layer...</code>를 이용해도 되고, 탐색기에서 끌어와도 됩니다.<br><br><img src="1_rza_2.PNG" alt="shapefile">  </li></ul><ul><li>참고로, 예제로 사용한 건물은 영화 레지던트 이블로도 유명해진 대전정부청사입니다.<br><br><img src="1_rza_3.jpg">  </li></ul><h3 id="2-Data-Analysis"><a href="#2-Data-Analysis" class="headerlink" title="2. Data Analysis"></a>2. Data Analysis</h3><ul><li>raster file의 데이터를 shapefile의 feature에 투영하겠습니다.</li><li>우측 상단의 톱니바퀴 모양을 클릭해서 <b>[공간 처리 툴박스]</b>를 실행합니다.</li><li>검색창에 <b>zonal statistics</b> 또는 <b>구역 통계</b>을 입력하여 검색합니다.<br><br><img src="1_rza_4.PNG" alt="클릭하면 커집니다"></li></ul><ul><li><b>래스터 레이어</b>에 아까 불렀던 raster file, <b>벡터 레이어</b>에 shapefile을 입력합니다.</li><li><b>산출 열 접두어</b>에 결과물에 붙을 접두어를 입력 후, <b>계산할 통계</b>에서 계산할 항목을 선택합니다.<br><img src="1_rza_5.PNG" alt="클릭하면 커집니다"></li></ul><ul><li><b>확인</b>을 누르면 다소의 시간이 소요된 후 다시 구역 통계 화면으로 돌아옵니다.<br></li></ul><h3 id="3-Data-Verification"><a href="#3-Data-Verification" class="headerlink" title="3. Data Verification"></a>3. Data Verification</h3><ul><li>계산된 데이터는 shapefile에 새 컬럼의 형태로 포함되어 있습니다.</li><li><b>레이어</b>의 shapefile에서 우클릭으로 <b>속성 테이블 열기</b>를 통해 추가된 데이터를 확인할 수 있습니다.<br><img src="1_rza_6.PNG" alt="클릭하면 커집니다"></li></ul><ul><li>속성 테이블에 접두어로 입력한 <code>proj_</code>와 분석을 수행한 항목이 컬럼명으로 지정되어 있습니다.<br><img src="1_rza_7.PNG"></li></ul><h3 id="4-Data-Export"><a href="#4-Data-Export" class="headerlink" title="4. Data Export"></a>4. Data Export</h3><ul><li><code>내보내기 &gt; 객체를 다른 이름으로 저장 &gt; </code>에서 <code>.xlsx</code>를 선택하면 엑셀 파일로 내보낼 수 있습니다.</li><li>간혹 한글이 깨진 채로 나갈 때가 있는데, 인코딩 옵션을 조정하여 해결할 수 있습니다.<br><img src="1_rza_8.png" alt="여기를 고칩니다"></li><li>기본값(<b>system</b>)을 <b>UTF-8</b>로 바꿔주면 한글이 잘 나옵니다.<br><img src="1_rza_9.PNG"></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/GIS/">GIS</category>
      
      <category domain="https://jehyunlee.github.io/categories/GIS/QGIS/">QGIS</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/gis/">gis</category>
      
      <category domain="https://jehyunlee.github.io/tags/polygon/">polygon</category>
      
      <category domain="https://jehyunlee.github.io/tags/raster/">raster</category>
      
      <category domain="https://jehyunlee.github.io/tags/qgis/">qgis</category>
      
      <category domain="https://jehyunlee.github.io/tags/vector/">vector</category>
      
      <category domain="https://jehyunlee.github.io/tags/data-sampling/">data sampling</category>
      
      
    </item>
    
    <item>
      <title>Ubuntu Desktop @Chrome Remote Desktop</title>
      <link>https://jehyunlee.github.io/2020/04/08/Python-General-4-ChromeRemoteDesktopLinux/</link>
      <guid>https://jehyunlee.github.io/2020/04/08/Python-General-4-ChromeRemoteDesktopLinux/</guid>
      <pubDate>Wed, 08 Apr 2020 04:38:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;b&gt;References&lt;/b&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@vsimon/how-to-install-chrome-remote-desktop-on-ubuntu-18-04-52d99980d8</description>
        
      
      
      
      <content:encoded><![CDATA[<p><b>References</b></p><blockquote><p><a href="https://medium.com/@vsimon/how-to-install-chrome-remote-desktop-on-ubuntu-18-04-52d99980d83e">How to Install Chrome Remote Desktop on Ubuntu 18.04</a></p></blockquote><ul><li>Linux 시스템에 접속해서 일을 할 때 port 접속이나 ssh 방식을 많이 사용합니다.<ul><li>그러나 Linux의 GUI를 활용해야 하거나, port나 ssh가 막힌 경우가 있습니다.</li><li>이 때 chrome remote desktop이 답이 될 수 있습니다.</li></ul></li></ul><ul><li>chrome remote desktop Linux 설치는 위 링크를 참고해 주시기 바랍니다.<ul><li>설치 후 외부에서 접속하면 아래와 같은 화면이 나옵니다.</li></ul></li></ul><p><img src="4_crm_1.png" alt="어쩌라고"></p><h2 id="Ubuntu-Desktop-가져오기"><a href="#Ubuntu-Desktop-가져오기" class="headerlink" title="Ubuntu Desktop 가져오기"></a>Ubuntu Desktop 가져오기</h2><ul><li>작업하던 Ubuntu Desktop을 그대로 가져오고자 합니다.<ol><li>작동중인 chrome remote desktop을 멈추고,</li><li><code>/opt/google/chrome-remote-desktop/chrome-remote-desktop</code> 파일을 수정하고,</li><li>다시 chrome remote desktop을 실행해야 합니다.</li></ol></li></ul><h3 id="1-chrome-remote-desktop-정지"><a href="#1-chrome-remote-desktop-정지" class="headerlink" title="1. chrome remote desktop 정지"></a>1. <b>chrome remote desktop 정지</b></h3><ul><li>작업 위치로 이동해서 정지시키고, 파일을 백업합니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /opt/google/chrome-remote-desktop/</span><br><span class="line">$ chrome-remote-desktop --stop</span><br><span class="line">$ cp chrome-remote-desktop chrome-remote-desktop.org</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-remote-desktop-실행-및-설정파일-수정"><a href="#2-remote-desktop-실행-및-설정파일-수정" class="headerlink" title="2. remote desktop 실행 및 설정파일 수정"></a>2. remote desktop 실행 및 설정파일 수정</h3><ul><li><code>vi</code>나 <code>gedit</code>등으로 <code>/opt/google/chrome-remote-desktop/chrome-remote-desktop</code>파일을 엽니다.</li></ul><h4 id="2-1-화면-크기를-나에게-맞게-변경"><a href="#2-1-화면-크기를-나에게-맞게-변경" class="headerlink" title="2-1. 화면 크기를 나에게 맞게 변경"></a>2-1. <b>화면 크기를 나에게 맞게 변경</b></h4><ul><li><code>DEFAULT_SIZES</code>부분을 찾아서 아래와 같이 수정합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_SIZES = <span class="string">&quot;1920x1080&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-DISPLAY-번호-변경"><a href="#2-2-DISPLAY-번호-변경" class="headerlink" title="2-2. DISPLAY 번호 변경"></a>2-2. <b>DISPLAY 번호 변경</b></h4><ul><li><code>FIRST_X_DISPLAY_NUMBER</code>부분을 찾아서 0으로 수정합니다 (18.04는 1).<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FIRST_X_DISPLAY_NUMBER = <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-추가-DISPLAY를-찾지-않도록-변경"><a href="#2-3-추가-DISPLAY를-찾지-않도록-변경" class="headerlink" title="2-3. 추가 DISPLAY를 찾지 않도록 변경"></a>2-3. <b>추가 DISPLAY를 찾지 않도록 변경</b></h4><ul><li><code>while os.path.exists</code>를 찾아서 아래 줄까지 주석처리합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># while os.path.exists(X_LOCK_FILE_TEMPLATE % display):</span></span><br><span class="line"><span class="comment">#  display += 1</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-4-X-session을-새로-띄우지-않고-기존-것을-사용하도록-변경"><a href="#2-4-X-session을-새로-띄우지-않고-기존-것을-사용하도록-변경" class="headerlink" title="2-4. X session을 새로 띄우지 않고 기존 것을 사용하도록 변경"></a>2-4. <b>X session을 새로 띄우지 않고 기존 것을 사용하도록 변경</b></h4><ul><li><code>self._launch_x_server(x_args)</code>과 아랫줄의 <code>self._launch_x_session()</code>를 주석처리합니다.</li><li>그리고 하단에 x_server와 x_session을 론칭할 두 줄을 추가합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># self._launch_x_server(x_args)</span></span><br><span class="line"><span class="comment"># self._launch_x_session()</span></span><br><span class="line">display=self.get_unused_display_number()</span><br><span class="line">self.child_env[\<span class="string">&quot;DISPLAY\&quot;]=\&quot;:%d\&quot; % display</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-start-chrome-remote-desktop"><a href="#3-start-chrome-remote-desktop" class="headerlink" title="3. start chrome remote desktop"></a>3. <b>start chrome remote desktop</b></h3><ul><li>다시 chrome remote desktop을 시작합니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chrome-remote-desktop --start</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-한-번에-다운로드"><a href="#4-한-번에-다운로드" class="headerlink" title="4. 한 번에 다운로드"></a>4. 한 번에 다운로드</h3><ul><li><p>긴장한 손으로 하나씩 고치는 것도 일입니다. 한번에 끝냅시다.</p><ul><li><p>위 절차를 자동으로 수행하는 script는 <a href="chrome_remote_desktop_monkeypatching.sh">여기에서 다운로드 가능</a>합니다.</p></li><li><p><code>sudo</code> 권한이 필요합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chrome_remote_desktop_monkeypatching.sh</span><br></pre></td></tr></table></figure></li><li><p>변경이 반영된 <code>chrome-remote-desktop</code>파일은 <a href="chrome-remote-desktop">여기에서 다운로드 할 수 있습니다</a>.</p></li></ul></li></ul><ul><li>마지막 단계, <code>chrome-remote-desktop --start</code>만 추가로 해 주면 됩니다.<br><br><img src="4_crm_2.png" alt="짜잔"><ul><li>띄워놓은 firefox가 잘 보입니다.</li></ul></li></ul><h3 id="추가-Ubuntu-20-04-업데이트-2021-02-16"><a href="#추가-Ubuntu-20-04-업데이트-2021-02-16" class="headerlink" title="[추가] Ubuntu 20.04 업데이트 (2021.02.16)"></a>[추가] Ubuntu 20.04 업데이트 (2021.02.16)</h3><ul><li>업데이트 이후 잘 되던 monkeypatching이 안되더군요.<ul><li>chrome-remote-desktop 기본 파일 구조가 바뀌었습니다.</li><li>변경을 반영한 버전을 추가합니다.</li><li><code>chrome-remote-desktop</code>파일: <a href="chrome-remote-desktop_20.04">다운로드 후 파일명 변경 필요</a></li><li>monkeypatching 스크립트 파일: <a href="chrome_remote_desktop_monkeypatching_20.04.sh">다운로드</a></li></ul></li></ul><h3 id="추가-Ubuntu-20-04-무한로그인-버그"><a href="#추가-Ubuntu-20-04-무한로그인-버그" class="headerlink" title="[추가] Ubuntu 20.04 무한로그인 버그(?)"></a>[추가] Ubuntu 20.04 무한로그인 버그(?)</h3><blockquote><p>[이번에도 어김없이 발생한 우분투 무한 로그인 ubuntu 20.04]<a href="https://likecode.tistory.com/310">https://likecode.tistory.com/310</a>)<br><a href="https://medium.com/@satyabratbhol/how-to-get-rid-of-login-screen-loop-in-ubuntu-feead4cb2302">How to get rid of Login Screen Loop in Ubuntu ?</a></p></blockquote><ul><li>우분투 20.04를 설치하고 위 파일을 적용했더니, 무한 로그인 버그가 발생했다.</li><li>아래 방법을 따라 수정할 수 있으니 겁먹지 말자.</li></ul><p><b>1. tty로 들어간다.</b></p><ul><li><code>Ctrl</code> + <code>Alt</code> + <code>F2</code>를 누른다.</li><li><code>F2</code> 대신 <code>F1</code>~`F6`까지 모두 가능하다.</li></ul><p><b>2. lightdm을 삭제 후 설치한다.</b></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge lightdm <span class="comment">#lightdm이 설치되지 않았다고 해도 이상해하지 말자.</span></span><br><span class="line">sudo apt-get install lightdm</span><br><span class="line">sudo dpkg-reconfigure lightdm</span><br></pre></td></tr></table></figure><ul><li>이 때 gdm3와 lightdm을 선택하라는 창이 뜨는데 lightdm을 선택한다.</li></ul><p><b>3. 재부팅한다.</b></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/chrome-remote-desktop/">chrome remote desktop</category>
      
      <category domain="https://jehyunlee.github.io/tags/linux/">linux</category>
      
      
    </item>
    
  </channel>
</rss>
