<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Pega Devlog</title>
    <link>https://jehyunlee.github.io/</link>
    
    <atom:link href="https://jehyunlee.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Pega&#39;s Development log for myself and others</description>
    <pubDate>Tue, 21 Jun 2022 22:19:22 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Scheduling without CRON</title>
      <link>https://jehyunlee.github.io/2022/06/22/Python-General-10-schedule_no_cron/</link>
      <guid>https://jehyunlee.github.io/2022/06/22/Python-General-10-schedule_no_cron/</guid>
      <pubDate>Tue, 21 Jun 2022 20:50:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;윈도에서 반복 작업은 작업 스케줄러를 사용합니다.&lt;/li&gt;
&lt;li&gt;리눅스에서는 cron을 사용합니다.&lt;/li&gt;
&lt;li&gt;그런데 cron을 사용할 수 없어서 다른 방법을 찾았습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-crontab&quot;&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>윈도에서 반복 작업은 작업 스케줄러를 사용합니다.</li><li>리눅스에서는 cron을 사용합니다.</li><li>그런데 cron을 사용할 수 없어서 다른 방법을 찾았습니다.</li></ul><h1 id="1-crontab"><a href="#1-crontab" class="headerlink" title="1. crontab"></a>1. crontab</h1><blockquote><p><a href="https://en.wikipedia.org/wiki/Cron">wikipedia: cron</a><br><a href="https://ojava.tistory.com/154">O! JAVA: [Linux]crontab 설정 및 로그 확인</a></p></blockquote><ul><li>Unix 계열에서 주기적으로 수행될 작업을 등록하여 실행하는 도구입니다.</li><li>1975년에 AT&amp;T Bell 연구소에서 만들어졌습니다.</li><li>여러 분들이 사용법을 잘 정리하셨으니 여기에는 간단하게만 정리합니다.</li><li>cron을 설정하려면 crontab(cron table)에 등록하거나 등록된 내용을 수정합니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -l    <span class="comment"># 등록 작업 리스트 출력</span></span><br><span class="line">$ crontab -e    <span class="comment"># 등록 작업 편집</span></span><br><span class="line">$ crontab -d    <span class="comment"># 등록 작업 삭제</span></span><br><span class="line">$ crontab -r    <span class="comment"># 현재 사용자가 등록한 crontab 전체 삭제</span></span><br></pre></td></tr></table></figure><p></li><li>이와 같이 crontab을 설정하면, 데몬을 재시작해야 적용됩니다.</li><li><code>restart</code>로 재시작할 수 있고, <code>stop</code>후 <code>start</code>를 할 수도 있습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">$ service cron restart    <span class="comment"># 재시작</span></span><br><span class="line">$ service cron stop       <span class="comment"># 현재 cron 중지</span></span><br><span class="line">$ service cron start      <span class="comment"># cron 시작</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS</span></span><br><span class="line">$ service crond restart   <span class="comment"># 재시작</span></span><br><span class="line">$ service crond stop      <span class="comment"># 현재 cron 중지</span></span><br><span class="line">$ service crond start     <span class="comment"># cron 시작</span></span><br></pre></td></tr></table></figure><p></li><li>cron이 잘 실행되는지는 log 파일을 모니터링하면 알 수 있습니다.</li><li><code>tail -f</code>를 사용하면 실시간으로 파일이 업데이트되는 모습을 볼 수 있습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">$ tail -f /var/<span class="built_in">log</span>/syslog | grep CRON</span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS</span></span><br><span class="line">$ tail -f /var/<span class="built_in">log</span>/cron</span><br></pre></td></tr></table></figure></li></ul><h1 id="2-shell-script"><a href="#2-shell-script" class="headerlink" title="2. shell script"></a>2. shell script</h1><blockquote><p><a href="https://coderwall.com/p/eilosa/scheduling-jobs-in-unix-without-cron">Coderwall: Scheduling jobs in UNIX without cron</a><br><a href="https://wikidocs.net/29981">while 루프</a></p></blockquote><ul><li><p>약간의 불행을 겪고 있습니다.</p></li><li><p>cron을 어떻게 조작해도 오류가 발생하고, 작업 스케줄링이 되지 않습니다.<br><img src="Python-General-10-schedule_no_cron_1.png" alt="PAM은 왜..."><br></p></li><li><p>오류를 해결하고자 구글링을 한 결과 여러 시도를 찾았습니다.</p></li><li><p><a href="https://coderwall.com/p/eilosa/scheduling-jobs-in-unix-without-cron">shell script를 사용</a>해서 작업을 할 수 있더군요.</p></li><li><p><code>while do</code>만 사용해서 더 간단한 반복 코드를 작성했습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>;<span class="comment"># 무한 반복</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> `date`<span class="comment"># 실행 코드. 파이썬 실행이라면 `date` 대신 `python 파일명.py`</span></span><br><span class="line">sleep 10<span class="comment"># 10초 대기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>실행 결과: 10초마다 시간이 출력됩니다.<br><img src="Python-General-10-schedule_no_cron_3.png"><br></p></li></ul><ul><li><code>nohup</code>과 <code>&amp;</code>를 붙여 백그라운드 실행을 하면 다른 작업을 할 수 있습니다.</li><li>이 때 화면 출력(standard output)은 기본적으로 nohup.out에 기록됩니다.<br><img src="Python-General-10-schedule_no_cron_4.png"><br></li></ul><h1 id="3-nohup-task-관리"><a href="#3-nohup-task-관리" class="headerlink" title="3. nohup task 관리"></a>3. nohup task 관리</h1><ul><li><p>nohup으로 던져진 작업은 터미널 창을 닫아도 유지됩니다.</p></li><li><p>자칫하면 무한 반복에 빠질 수 있습니다. <code>kill</code>명령을 사용하기 위해서라도 PID를 알아야 합니다.</p></li><li><p>아래 명령으로 현재 실행중인 nohup 작업의 PID를 알 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep nohup</span><br></pre></td></tr></table></figure></li><li><p>하지만 더 좋은 것은 작업을 시작할 때 PID를 기록하는 것입니다.</p></li><li><p>여러 nohup작업을 관리하려면 각각의 PID를 정리할 필요가 있기 때문입니다.</p></li><li><p>nohup을 다음과 같이 실행해서 기록할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup script파일.sh &gt; 로그파일.<span class="built_in">log</span> 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="built_in">echo</span> $! &gt; PID파일.txt</span><br></pre></td></tr></table></figure></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/shell-script/">shell script</category>
      
      <category domain="https://jehyunlee.github.io/tags/job-schedule/">job schedule</category>
      
      
    </item>
    
    <item>
      <title>데이터 분할과 교차 검증</title>
      <link>https://jehyunlee.github.io/2022/06/15/Python-DS-104-kierlecture3/</link>
      <guid>https://jehyunlee.github.io/2022/06/15/Python-DS-104-kierlecture3/</guid>
      <pubDate>Wed, 15 Jun 2022 00:46:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;한국에너지기술연구원 AI 학습조직&lt;/b&gt;에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.&lt;ul&gt;
&lt;li&gt;scikit-learn 기능 중 데이터를 class 비율대로 분류하는 stratified K fold를 소개하고,&lt;/</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b>한국에너지기술연구원 AI 학습조직</b>에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.<ul><li>scikit-learn 기능 중 데이터를 class 비율대로 분류하는 stratified K fold를 소개하고,</li><li>모든 데이터를 학습과 검증에 활용하는 cross validation을 다룹니다.</li><li><a href="220614_%EC%9D%B4%EC%A0%9C%ED%98%84_KIERML_2202_bestmodel.pdf">강의 자료는 여기에서 다운받으실 수 있습니다</a></li></ul></li></ul><ul><li><p>발표 영상 : (<a href="https://youtu.be/JX6tSOaUKuI">Youtube Link</a>)<br></p></li><li><p>실습 코드 : (<a href="https://bit.ly/3QdGwGq">https://bit.ly/3QdGwGq</a>)<br></p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/JX6tSOaUKuI" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <h3 id="Cross-Validation-set-generator"><a href="#Cross-Validation-set-generator" class="headerlink" title="Cross Validation set generator"></a>Cross Validation set generator</h3><ul><li><p><code>cross_val_score</code>와 <code>cross_val_predict</code>에 사전에 만든 dataset을 넣을 수 있습니다.</p></li><li><p>training set과 validation set의 index를 출력하는 generator를 사용하면 됩니다.</p></li><li><p>발표 영상에는 없지만 해당 코드를 추가합니다.</p></li><li><p>먼저, <code>cross_val_score</code>예시입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 사전에 분할한 cross validation set 사용</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_train_valid</span>(<span class="params">idx_trains, idx_vals</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(idx_trains) == <span class="built_in">len</span>(idx_vals) <span class="comment"># train data index와 validation data index가 다르면 중단</span></span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count &lt; <span class="built_in">len</span>(idx_trains):</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> idx_trains[count-<span class="number">1</span>], idx_vals[count-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">idx_cv = generate_train_valid(idx_trains, idx_vals) <span class="comment"># CV set generator</span></span><br><span class="line">-cross_val_score(model1, X, y, cv=idx_cv, scoring=<span class="string">&quot;neg_root_mean_squared_error&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([290.47491999, 332.31676581, 268.35748775, 304.48637819,</span><br><span class="line">       262.42934634])</span><br></pre></td></tr></table></figure></li><li><p><code>cross_val_predict</code>예시입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_predict</span><br><span class="line"></span><br><span class="line"><span class="comment"># y_pred_cv = cross_val_predict(model1, X, y, cv=5)</span></span><br><span class="line">idx_cv = generate_train_valid(idx_trains, idx_vals)  <span class="comment"># CV set generator</span></span><br><span class="line">y_pred_cv = cross_val_predict(model1, X, y, cv=idx_cv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization and print</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.scatter(y, y_pred_cv, c=<span class="string">&quot;gray&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;true&quot;</span>, color=<span class="string">&quot;gray&quot;</span>, labelpad=<span class="number">12</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;predict&quot;</span>, color=<span class="string">&quot;gray&quot;</span>, labelpad=<span class="number">12</span>)</span><br><span class="line">mean_squared_error(y, y_pred_cv, squared=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">292.76401468664585</span><br></pre></td></tr></table></figure><p><img src="104_kierlecture3_01.png"><br></p></li></ul><p>* 바쁜 연구원 일정 속에 변동이 있겠지만, 최대한 일정을 지켜보고자 합니다.<p><img src="thumbnail_012.PNG" alt="학습조직 일정"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/machine-learning/">machine learning</category>
      
      <category domain="https://jehyunlee.github.io/tags/KIER/">KIER</category>
      
      <category domain="https://jehyunlee.github.io/tags/data-split/">data split</category>
      
      <category domain="https://jehyunlee.github.io/tags/validation/">validation</category>
      
      
    </item>
    
    <item>
      <title>skorch callbacks (3) ML Pipeline</title>
      <link>https://jehyunlee.github.io/2022/06/09/Python-DL-10-skorch_callback3/</link>
      <guid>https://jehyunlee.github.io/2022/06/09/Python-DL-10-skorch_callback3/</guid>
      <pubDate>Thu, 09 Jun 2022 10:50:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;PyTorch는 현재 가장 인기있는 딥러닝 라이브러리 중 하나입니다.&lt;/li&gt;
&lt;li&gt;학습 세부 사항을 지정하기 위해 Callback으로 다양한 기능을 지원합니다.&lt;/li&gt;
&lt;li&gt;skorch는 PyTorch를 scikit-learn과</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>PyTorch는 현재 가장 인기있는 딥러닝 라이브러리 중 하나입니다.</li><li>학습 세부 사항을 지정하기 위해 Callback으로 다양한 기능을 지원합니다.</li><li>skorch는 PyTorch를 scikit-learn과 함께 사용할 수 있게 해 줍니다.</li><li>skorch도 PyTorch callback을 이용할 수 있습니다.</li></ul><ul><li>글이 길어 세 개로 나눕니다. </li><li>세 번째로, skorch를 사용해 ML Pipeline을 완성합니다.</li><li>여러 callback으로 자세한 설정을 반영합니다.</li></ul><h2 id="3-2-skorch"><a href="#3-2-skorch" class="headerlink" title="3.2. skorch"></a>3.2. skorch</h2><blockquote><p><a href="https://bit.ly/3xxznt8">Colab code: skorch callbacks</a></p></blockquote><ul><li>Colab에는 skorch가 기본으로 설치되어 있지 않습니다.</li><li>간단한 명령으로 skorch를 설치합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!pip install skorch</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-1-preprocessor-포함-pipeline-작성"><a href="#3-2-1-preprocessor-포함-pipeline-작성" class="headerlink" title="3.2.1. preprocessor 포함 pipeline 작성"></a>3.2.1. preprocessor 포함 pipeline 작성</h3><blockquote><p><a href="https://skorch.readthedocs.io/en/stable/regressor.html">skorch: skorch.regressor</a></p></blockquote><ul><li>앞에서 만든 <code>get_preprocessor()</code>함수는 전처리 Pipeline을 출력합니다.</li><li>Pipeline을 연장해 이 뒤에 PyTorch로 만든 Neural Network를 덧붙입니다.</li><li>우리가 푸는 문제는 펭귄의 체중을 구하는 <b>regression</b>문제입니다.</li></ul><ul><li><p>skorch에서 제공하는 <a href="https://skorch.readthedocs.io/en/stable/regressor.html"><code>NeuralNetRegressor()</code></a>로 PyTorch 신경망을 감쌉니다.</p></li><li><p>loss function, optimizer 등은 <code>NeuralNetRegressor()</code> 안에 <code>criterion</code>, <code>optimizer</code> 등의 매개변수를 사용해 입력합니다.</p></li><li><p><code>optimizer=optim.Adam</code>으로 Adam을 선택했습니다. </p></li><li><p>PyTorch에서 Adam()안에 들어가던 매개변수 <code>lr=1e-3</code>은 <code>optimizer__lr=1e-3</code>으로 바뀌어 들어갑니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> skorch</span><br><span class="line"><span class="keyword">from</span> skorch <span class="keyword">import</span> NeuralNetRegressor</span><br><span class="line"></span><br><span class="line"><span class="comment"># skorch로 PyTorch neural network wrapping</span></span><br><span class="line">net_sk = NeuralNetRegressor(Net(), device=device, verbose=<span class="number">1</span>,</span><br><span class="line">                            criterion=RMSELoss,         <span class="comment"># loss function</span></span><br><span class="line">                            optimizer=optim.Adam,       <span class="comment"># optimizer</span></span><br><span class="line">                            optimizer__lr=<span class="number">1e-3</span>)         <span class="comment"># learning rate of the optimizer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># training</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">300</span>):</span><br><span class="line">    net_sk.fit(X_train_np, y_train.astype(np.float32).values.reshape(-<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><ul><li>실행 결과 : 너무 길어서 out of memory 오류가 뜰 수 있습니다. 침착하게 새로 고침을 누르시면 됩니다.</li><li>또는, <code>verbose=1</code>을 <code>verbose=0</code>으로 바꾸시는 것도 방법입니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">... (생략) ...</span><br><span class="line"></span><br><span class="line">     10      271.1115      286.5908  0.0111</span><br><span class="line">Re-initializing module.</span><br><span class="line">Re-initializing criterion.</span><br><span class="line">Re-initializing optimizer.</span><br><span class="line">  epoch    train_loss    valid_loss     dur</span><br><span class="line">-------  ------------  ------------  ------</span><br><span class="line">      1      272.8632      286.3571  0.0108</span><br><span class="line">      2      267.6815      285.4084  0.0145</span><br><span class="line">      3      268.0632      284.9375  0.0106</span><br><span class="line">      4      269.3830      284.9683  0.0104</span><br><span class="line">      5      270.7425      285.2378  0.0101</span><br><span class="line">      6      271.6377      285.5552  0.0108</span><br><span class="line">      7      271.9493      285.8589  0.0082</span><br><span class="line">      8      271.8214      286.1465  0.0080</span><br><span class="line">      9      271.4798      286.4032  0.0087</span><br><span class="line">     10      271.1165      286.5942  0.0088</span><br></pre></td></tr></table></figure></li></ul></li><li><p><b>학습이 <code>model.fit()</code>으로 잘 됩니다.</b></p></li><li><p><code>NeuralNetRegressor</code>로 한 번 감싼 것 만으로 scikit-learn API를 사용할 수 있게 되었습니다.</p></li><li><p><code>X_train</code>대신 전처리를 거친 <code>X_train_np</code>를 입력했습니다.</p></li><li><p><code>y_train</code>대신으로는 <code>y_train.astype(np.float32).values.reshape(-1, 1)</code>이 들어갔습니다.</p></li><li><p>pandas Series에서 데이터 타입을 바꾸고, 값을 추출해서, shape을 바꾼 것입니다.</p></li></ul><ul><li><b>예측도 <code>model.forward()</code> 대신 <code>model.predict()</code>로 진행합니다.</b><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prediction</span></span><br><span class="line">y_pred_train = net_sk.predict(X_train_np)</span><br><span class="line">y_pred_val = net_sk.predict(X_val_np)</span><br><span class="line">y_pred_test = net_sk.predict(X_test_np)</span><br><span class="line"></span><br><span class="line"><span class="comment"># parity plot</span></span><br><span class="line">plot_parity3(net_sk, Xs=[X_train_np, X_val_np, X_test_np])</span><br></pre></td></tr></table></figure><img src="10_sc_01.png"><br></li></ul><h3 id="3-2-2-ML-pipeline-작성"><a href="#3-2-2-ML-pipeline-작성" class="headerlink" title="3.2.2. ML pipeline 작성"></a>3.2.2. ML pipeline 작성</h3><blockquote><p><a href="https://skorch.readthedocs.io/en/stable/callbacks.html?highlight=input_dim#skorch.callbacks.InputShapeSetter">skorch: skorch.callbacks.InputShapeSetter</a><br><a href="https://stackoverflow.com/questions/60005715/how-to-pass-input-dim-from-fit-method-to-skorch-wrapper/60170023#60170023">stackoverflow: How to pass input dim from fit method to skorch wrapper?</a></p></blockquote><ul><li>앞에서 만든 전처리기, <code>get_preprocessor()</code>를 포함하는 Pipeline을 만듭니다.</li><li><code>method</code>매개변수로 neural network 뿐 아니라 linear regression, random forest를 선택할 수 있게 합니다.</li></ul><ul><li><p>Neural network는 이들 방법들과 달리 <b>input dimension이 중요</b>합니다. </p></li><li><p>신경망 구조를 만들 때 필요한 변수이기 때문입니다.</p></li><li><p>callback은 여러 설정을 지정할 수 있는 방법입니다. <code>InputShapeSetter</code>를 callback에 기본값으로 박아 넣습니다.</p></li><li><p>그 외에 여러 keyword arguments를 입력할 수 있도록 <b><code>**kwargs</code></b>를 <code>NeuralNetRegressor()</code>에 추가합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># machine learning models</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line"></span><br><span class="line"><span class="comment"># embedding pytorch model in scikit-learn Pipeline</span></span><br><span class="line"><span class="keyword">from</span> skorch <span class="keyword">import</span> NeuralNetRegressor</span><br><span class="line"><span class="keyword">from</span> skorch.helper <span class="keyword">import</span> predefined_split</span><br><span class="line"><span class="keyword">from</span> skorch.callbacks <span class="keyword">import</span> Callback</span><br><span class="line"></span><br><span class="line"><span class="comment"># dynamic input size of the PyTorch module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputShapeSetter</span>(<span class="params">Callback</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_train_begin</span>(<span class="params">self, net, X, y</span>):</span></span><br><span class="line">        net.set_params(module__ninput=X.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_model</span>(<span class="params">method=<span class="string">&quot;lr&quot;</span>, device=device, cols_cat=cols_cat, cols_num=cols_num, degree=<span class="number">1</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">              callbacks=[InputShapeSetter(<span class="params"></span>)], **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">&quot;lr&quot;</span>:</span><br><span class="line">        ml = LinearRegression(fit_intercept=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&quot;rf&quot;</span>:</span><br><span class="line">        ml = RandomForestRegressor(random_state=rng)</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&quot;nn&quot;</span>:</span><br><span class="line">        ml = NeuralNetRegressor(Net(), device=device, callbacks=callbacks, **kwargs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;# &#x27;method&#x27; should be in [&#x27;lr&#x27;, &#x27;rf&#x27;, &#x27;nn&#x27;].&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    preprocessor = get_preprocessor(cols_cat=cols_cat, cols_num=cols_num, degree=degree)</span><br><span class="line">    model = Pipeline([(<span class="string">&quot;preprocessor&quot;</span>, preprocessor), </span><br><span class="line">                      (<span class="string">&quot;ml&quot;</span>, ml)])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure></li><li><p>이제 <code>get_model()</code>을 사용해 ML pipeline을 제작할 수 있습니다.</p></li><li><p><code>method</code>에 입력하는 값에 따라 선형 회귀, 앙상블 트리, 신경망을 선택할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = get_model(<span class="string">&quot;nn&quot;</span>, max_epochs=epochs, verbose=<span class="number">1</span>, criterion=RMSELoss, optimizer=optim.Adam, optimizer__lr = <span class="number">1e-3</span>)</span><br><span class="line">model</span><br></pre></td></tr></table></figure><p><img src="10_sc_02.png"><br></p></li><li><p>웬만한 매개변수는 모두 <code>NeuralNetRegressor()</code>에 들어갑니다.</p></li><li><p>어떤 매개변수들이 있는지 출력해서 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model[<span class="string">&quot;ml&quot;</span>].get_params()</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;_kwargs&#x27;</span>: &#123;<span class="string">&#x27;optimizer__lr&#x27;</span>: 0.001&#125;,</span><br><span class="line"> <span class="string">&#x27;batch_size&#x27;</span>: 128,</span><br><span class="line"> <span class="string">&#x27;callbacks&#x27;</span>: [&lt;__main__.InputShapeSetter at 0x7f4911406cd0&gt;],</span><br><span class="line"> <span class="string">&#x27;callbacks__epoch_timer&#x27;</span>: &lt;skorch.callbacks.logging.EpochTimer at 0x7f49745b2a50&gt;,</span><br><span class="line"> <span class="string">&#x27;callbacks__print_log&#x27;</span>: &lt;skorch.callbacks.logging.PrintLog at 0x7f49701261d0&gt;,</span><br><span class="line"> <span class="string">&#x27;callbacks__print_log__floatfmt&#x27;</span>: <span class="string">&#x27;.4f&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;callbacks__print_log__keys_ignored&#x27;</span>: None,</span><br><span class="line"> <span class="string">&#x27;callbacks__print_log__sink&#x27;</span>: &lt;<span class="keyword">function</span> <span class="built_in">print</span>&gt;,</span><br><span class="line"> <span class="string">&#x27;callbacks__print_log__stralign&#x27;</span>: <span class="string">&#x27;right&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;callbacks__print_log__tablefmt&#x27;</span>: <span class="string">&#x27;simple&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;callbacks__train_loss&#x27;</span>: &lt;skorch.callbacks.scoring.PassthroughScoring at 0x7f49745b2450&gt;,</span><br><span class="line"> <span class="string">&#x27;callbacks__train_loss__lower_is_better&#x27;</span>: True,</span><br><span class="line"> <span class="string">&#x27;callbacks__train_loss__name&#x27;</span>: <span class="string">&#x27;train_loss&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;callbacks__train_loss__on_train&#x27;</span>: True,</span><br><span class="line"> <span class="string">&#x27;callbacks__valid_loss&#x27;</span>: &lt;skorch.callbacks.scoring.PassthroughScoring at 0x7f49745b24d0&gt;,</span><br><span class="line"> <span class="string">&#x27;callbacks__valid_loss__lower_is_better&#x27;</span>: True,</span><br><span class="line"> <span class="string">&#x27;callbacks__valid_loss__name&#x27;</span>: <span class="string">&#x27;valid_loss&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;callbacks__valid_loss__on_train&#x27;</span>: False,</span><br><span class="line"> <span class="string">&#x27;criterion&#x27;</span>: __main__.RMSELoss,</span><br><span class="line"> <span class="string">&#x27;dataset&#x27;</span>: skorch.dataset.Dataset,</span><br><span class="line"> <span class="string">&#x27;device&#x27;</span>: <span class="string">&#x27;cuda:0&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;iterator_train&#x27;</span>: torch.utils.data.dataloader.DataLoader,</span><br><span class="line"> <span class="string">&#x27;iterator_valid&#x27;</span>: torch.utils.data.dataloader.DataLoader,</span><br><span class="line"> <span class="string">&#x27;lr&#x27;</span>: 0.01,</span><br><span class="line"> <span class="string">&#x27;max_epochs&#x27;</span>: 1000,</span><br><span class="line"> <span class="string">&#x27;module&#x27;</span>: Net(</span><br><span class="line">   (layer0): Linear(in_features=12, out_features=16, bias=True)</span><br><span class="line">   (layer1): Linear(in_features=16, out_features=16, bias=True)</span><br><span class="line">   (layer2): Linear(in_features=16, out_features=12, bias=True)</span><br><span class="line">   (layer3): Linear(in_features=12, out_features=8, bias=True)</span><br><span class="line">   (layer4): Linear(in_features=8, out_features=1, bias=True)</span><br><span class="line">   (activation): ReLU()</span><br><span class="line"> ),</span><br><span class="line"> <span class="string">&#x27;optimizer&#x27;</span>: torch.optim.adam.Adam,</span><br><span class="line"> <span class="string">&#x27;optimizer__lr&#x27;</span>: 0.001,</span><br><span class="line"> <span class="string">&#x27;predict_nonlinearity&#x27;</span>: <span class="string">&#x27;auto&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;train_split&#x27;</span>: &lt;skorch.dataset.ValidSplit object at 0x7f497434cc90&gt;,</span><br><span class="line"> <span class="string">&#x27;verbose&#x27;</span>: 1,</span><br><span class="line"> <span class="string">&#x27;warm_start&#x27;</span>: False&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-2-3-train-and-validate-self"><a href="#3-2-3-train-and-validate-self" class="headerlink" title="3.2.3. train and validate (self)"></a>3.2.3. train and validate (self)</h3><blockquote><p><a href="https://skorch.readthedocs.io/en/stable/user/neuralnet.html#train-split">skorch: NeuralNet#train_split</a></p></blockquote><ul><li><p>X_train과 y_train만 사용해서 학습시킵니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.fit(X_train, y_train.values.reshape(-<span class="number">1</span>, <span class="number">1</span>).astype(np.float32))</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Re-initializing module because the following parameters were re-set: module__ninput.</span><br><span class="line">Re-initializing criterion.</span><br><span class="line">Re-initializing optimizer.</span><br><span class="line">  epoch    train_loss    valid_loss     dur</span><br><span class="line">-------  ------------  ------------  ------</span><br><span class="line">      1     4280.8532     4388.5093  0.0188</span><br><span class="line">      2     4280.8443     4388.4990  0.0129</span><br><span class="line">      </span><br><span class="line">      ... (생략) ...</span><br><span class="line">      </span><br><span class="line">    998      295.5285      270.6504  0.0106</span><br><span class="line">    999      295.5276      270.6288  0.0153</span><br><span class="line">   1000      295.5247      270.6030  0.0102</span><br></pre></td></tr></table></figure></li></ul></li><li><p>validation set을 입력하지 않았음에도 valid_loss가 출력됩니다.</p></li><li><p><b>train data의 20%를 validation set으로 따로 떼어 놓기 때문입니다.</b></p></li><li><p><a href="https://jehyunlee.github.io/2022/06/09/Python-DL-8-skorch_callback/">맨 처음</a> 전체 데이터의 60%만 train set으로 지정했습니다.</p></li><li><p>여기서 다시 80%만 학습에 투입되었으니 <b>총 48%.</b> 반도 안되는 데이터로 학습한 셈입니다.</p></li><li><p><code>train_split=None</code>을 입력하면 모든 데이터를 다 학습에 투입하지만 validation 결과가 출력되지 않습니다.</p></li></ul><ul><li><p><b>learning curve</b>는 신경망에서 <b><code>.history</code></b> 속성을 추출해 확인할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">history = model[<span class="string">&quot;ml&quot;</span>].history</span><br><span class="line">train_loss = history[:, <span class="string">&quot;train_loss&quot;</span>]</span><br><span class="line">valid_loss = history[:, <span class="string">&quot;valid_loss&quot;</span>]</span><br><span class="line"></span><br><span class="line">plot_epoch(train_loss, valid_loss)</span><br></pre></td></tr></table></figure><p><img src="10_sc_03.png"><br></p></li><li><p>학습도 정상적으로 이루어졌습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot_parity3(model)</span><br></pre></td></tr></table></figure><p><img src="10_sc_04.png"><br></p></li></ul><h3 id="3-2-4-train-and-validate-predefined-validation-set"><a href="#3-2-4-train-and-validate-predefined-validation-set" class="headerlink" title="3.2.4. train and validate (predefined validation set)"></a>3.2.4. train and validate (predefined validation set)</h3><blockquote><p><a href="https://skorch.readthedocs.io/en/stable/dataset.html">skorch: skorch.dataset.Dataset</a></p></blockquote><ul><li><p>먼저 준비한 validation set을 사용하려면 <code>train_split</code>에 validation set을 입력합니다.</p></li><li><p>validation set은 skorch의 <a href="https://skorch.readthedocs.io/en/stable/dataset.html"><code>Dataset</code></a>을 사용해 만듭니다.</p></li><li><p>내친 김에 y data도 ML Pipeline에 만들기 좋은 형태, 즉 float32, (-1, 1) shape으로 변경해서 모아놓습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skorch.dataset <span class="keyword">import</span> Dataset</span><br><span class="line"></span><br><span class="line"><span class="comment"># ys (numpy)</span></span><br><span class="line">y_train_np = y_train.values.reshape(-<span class="number">1</span>, <span class="number">1</span>).astype(np.float32)</span><br><span class="line">y_val_np = y_val.values.reshape(-<span class="number">1</span>, <span class="number">1</span>).astype(np.float32)</span><br><span class="line">y_test_np = y_test.values.reshape(-<span class="number">1</span>, <span class="number">1</span>).astype(np.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># predefined validation set</span></span><br><span class="line">preprocessor = get_preprocessor()</span><br><span class="line">X_val_pp = preprocessor.fit(X_train).transform(X_val)</span><br><span class="line">valid_dataset = Dataset(X_val_pp, y_val_np)</span><br><span class="line"></span><br><span class="line"><span class="comment"># model training</span></span><br><span class="line">model = get_model(<span class="string">&quot;nn&quot;</span>, max_epochs=epochs, verbose=<span class="number">1</span>, criterion=RMSELoss, optimizer=optim.Adam, optimizer__lr = <span class="number">1e-3</span>,</span><br><span class="line">                  <span class="comment"># predefined validataion set</span></span><br><span class="line">                  train_split=predefined_split(valid_dataset))  </span><br><span class="line">model.fit(X_train, y_train_np)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Re-initializing module because the following parameters were re-set: module__ninput.</span><br><span class="line">Re-initializing criterion.</span><br><span class="line">Re-initializing optimizer.</span><br><span class="line">  epoch    train_loss    valid_loss     dur</span><br><span class="line">-------  ------------  ------------  ------</span><br><span class="line">      1     4302.1941     4250.5781  0.0160</span><br><span class="line">      2     4302.1851     4250.5693  0.0175</span><br><span class="line">      </span><br><span class="line">      ... (생략) ...</span><br><span class="line">      </span><br><span class="line">    998      280.9618      267.7317  0.0121</span><br><span class="line">    999      280.9596      267.7302  0.0122</span><br><span class="line">   1000      280.9580      267.7280  0.0141</span><br></pre></td></tr></table></figure></li></ul></li><li><p><b>learning curve</b>를 확인합니다.</p></li><li><p>여기서 얻은 learning curve를 reference로 사용하겠습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">history = model[<span class="string">&quot;ml&quot;</span>].history</span><br><span class="line">train_loss_0 = history[:, <span class="string">&quot;train_loss&quot;</span>]</span><br><span class="line">valid_loss_0 = history[:, <span class="string">&quot;valid_loss&quot;</span>]</span><br><span class="line"></span><br><span class="line">plot_epoch(train_loss_0, valid_loss_0)</span><br></pre></td></tr></table></figure><p><img src="10_sc_05.png"><br></p></li><li><p><b>parity plot</b>도 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot_parity3(model)</span><br></pre></td></tr></table></figure><p><img src="10_sc_06.png"><br></p></li></ul><h3 id="3-2-5-learning-rate-scheduler"><a href="#3-2-5-learning-rate-scheduler" class="headerlink" title="3.2.5. learning rate scheduler"></a>3.2.5. learning rate scheduler</h3><blockquote><p><a href="https://skorch.readthedocs.io/en/stable/user/callbacks.html#learning-rate-schedulers">skorch: Learning rate schedulers</a><br><a href="https://jehyunlee.github.io/2020/03/28/Python-DL-3-1cycle-learning-rate-policy/">Pega Devlog: Fast.ai의 fit_one_cycle 방법론 이해</a></p></blockquote><ul><li><p>callbacks에 learning late scheduler를 추가해 learning rate를 조정할 수 있습니다.</p></li><li><p>input dimension 조정을 위해 <b>callbacks 기본값으로 InputShapeSetter()가 들어가 있습니다.</b></p></li><li><p>이를 삭제하지 않도록 유의하면서 learning rate scheduler를 추가합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skorch.callbacks <span class="keyword">import</span> LRScheduler</span><br><span class="line"></span><br><span class="line">model = get_model(<span class="string">&quot;nn&quot;</span>, max_epochs=epochs, verbose=<span class="number">1</span>, criterion=RMSELoss, optimizer=optim.Adam, optimizer__lr = <span class="number">1e-3</span>,</span><br><span class="line">                  train_split=predefined_split(valid_dataset),               <span class="comment"># predefined validataion set                </span></span><br><span class="line">                  callbacks=[<span class="comment"># input dimension setter</span></span><br><span class="line">                             (<span class="string">&quot;input_shape_setter&quot;</span>, InputShapeSetter()),</span><br><span class="line">                             </span><br><span class="line">                             <span class="comment"># LR scheduler</span></span><br><span class="line">                             (<span class="string">&quot;lr_scheduler&quot;</span>, LRScheduler(policy=OneCycleLR, <span class="comment"># LR scheduler</span></span><br><span class="line">                                                         max_lr=<span class="number">0.1</span>,</span><br><span class="line">                                                         total_steps=epochs))])</span><br><span class="line">model.fit(X_train, y_train_np)</span><br></pre></td></tr></table></figure></li><li><p>학습 과정은 생략하고 learning curve를 비교해서 봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ax = plot_epoch(train_loss_0, valid_loss_0)</span><br><span class="line">lines = ax.lines</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    line.set_alpha(<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">history = model[<span class="string">&quot;ml&quot;</span>].history</span><br><span class="line">train_loss = history[:, <span class="string">&quot;train_loss&quot;</span>]</span><br><span class="line">valid_loss = history[:, <span class="string">&quot;valid_loss&quot;</span>]</span><br><span class="line"></span><br><span class="line">ax = plot_epoch(train_loss, valid_loss, ax=ax)</span><br><span class="line">handles, labels = ax.get_legend_handles_labels()</span><br><span class="line">ax.legend(handles=handles, labels=labels, ncol=<span class="number">2</span>, title=<span class="string">&quot;base      OneCycleLR&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="10_sc_07.png"><br></p></li><li><p>learning rate scheduler가 적용되어 학습 양상이 바뀌었습니다.</p></li><li><p>parity plot도 여전히 좋습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot_parity3(model)</span><br></pre></td></tr></table></figure><p><img src="10_sc_08.png"><br></p></li></ul><h3 id="3-2-6-early-stopping"><a href="#3-2-6-early-stopping" class="headerlink" title="3.2.6. early stopping"></a>3.2.6. early stopping</h3><blockquote><p><a href="https://skorch.readthedocs.io/en/stable/callbacks.html#skorch.callbacks.EarlyStopping">skorch: skorch.callbacks.EarlyStopping</a></p></blockquote><ul><li><p>불필요하게 학습을 길게 하는 경향을 줄이고자 early stopping을 적용합니다.</p></li><li><p><code>EarlyStopping()</code>을 callbacks에 추가하고 기준을 설정합니다.</p></li><li><p>valid_loss가 20번 줄어들지 않으면 학습을 중단하도록 <code>monitor=&quot;valid_loss&quot;</code>, <code>patience=20</code>을 설정했습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skorch.callbacks <span class="keyword">import</span> EarlyStopping</span><br><span class="line"></span><br><span class="line">model = get_model(<span class="string">&quot;nn&quot;</span>, max_epochs=epochs, verbose=<span class="number">1</span>, criterion=RMSELoss, optimizer=optim.Adam, optimizer__lr = <span class="number">1e-3</span>,</span><br><span class="line">                  train_split=predefined_split(valid_dataset),               <span class="comment"># predefined validataion set        </span></span><br><span class="line"></span><br><span class="line">                  callbacks=[<span class="comment"># input dimension setter</span></span><br><span class="line">                             (<span class="string">&quot;input_shape_setter&quot;</span>, InputShapeSetter()),</span><br><span class="line"></span><br><span class="line">                             <span class="comment"># LR scheduler</span></span><br><span class="line">                             (<span class="string">&quot;lr_scheduler&quot;</span>, LRScheduler(policy=OneCycleLR, </span><br><span class="line">                                                         max_lr=<span class="number">0.1</span>,</span><br><span class="line">                                                         total_steps=epochs)),</span><br><span class="line"></span><br><span class="line">                             <span class="comment"># early stopping</span></span><br><span class="line">                             (<span class="string">&quot;early_stopping&quot;</span>, EarlyStopping(monitor=<span class="string">&quot;valid_loss&quot;</span>,</span><br><span class="line">                                                              patience=<span class="number">20</span>))])</span><br><span class="line">model.fit(X_train, y_train.values.reshape(-<span class="number">1</span>, <span class="number">1</span>).astype(np.float32))</span><br></pre></td></tr></table></figure></li><li><p><b>learning curve</b>를 비교합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ax = plot_epoch(train_loss_0, valid_loss_0)</span><br><span class="line">lines = ax.lines</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    line.set_alpha(<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">history = model[<span class="string">&quot;ml&quot;</span>].history</span><br><span class="line">train_loss = history[:, <span class="string">&quot;train_loss&quot;</span>]</span><br><span class="line">valid_loss = history[:, <span class="string">&quot;valid_loss&quot;</span>]</span><br><span class="line"></span><br><span class="line">ax = plot_epoch(train_loss, valid_loss, ax=ax)</span><br><span class="line">handles, labels = ax.get_legend_handles_labels()</span><br><span class="line">ax.legend(handles=handles, labels=labels, ncol=<span class="number">2</span>, title=<span class="string">&quot;base      LRS+ES&quot;</span>)</span><br><span class="line">ax.set_xlim(<span class="number">0</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><p><img src="10_sc_09.png"><br></p></li><li><p>parity plot도 정상적입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot_parity3(model)</span><br></pre></td></tr></table></figure><p><img src="10_sc_10.png"><br></p></li></ul><h3 id="3-2-7-Saving-and-Loading-manual"><a href="#3-2-7-Saving-and-Loading-manual" class="headerlink" title="3.2.7. Saving and Loading (manual)"></a>3.2.7. Saving and Loading (manual)</h3><blockquote><p><a href="https://skorch.readthedocs.io/en/stable/user/save_load.html">skorch: Saving and Loading</a></p></blockquote><ul><li><p>모델 파라미터를 pickle 형식으로 저장하고 불러올 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># save parameters</span></span><br><span class="line">model[<span class="string">&quot;ml&quot;</span>].save_params(f_params=<span class="string">&quot;nn_params.pkl&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>모델을 새로 만들면 paramter를 불러오기 전에 초기화하는 과정이 필요합니다.</p></li><li><p><code>.initialize()</code>를 사용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># load parameters</span></span><br><span class="line">model_new = get_model(method=<span class="string">&quot;nn&quot;</span>)</span><br><span class="line">model_new[<span class="string">&quot;ml&quot;</span>].initialize()</span><br><span class="line">model_new[<span class="string">&quot;ml&quot;</span>].load_params(f_params=<span class="string">&quot;nn_params.pkl&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>새로 만든 모델에 parameter를 불러와서 적용합니다.</p></li><li><p>단, 신경망 parameter에만 해당하는 상황이므로 preprocessor는 기존 모델의 preprocessor를 사용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># check reproducibility</span></span><br><span class="line">y_pred_train = model_new[<span class="string">&quot;ml&quot;</span>].predict(model[<span class="string">&quot;preprocessor&quot;</span>].transform(X_train))</span><br><span class="line">y_pred_val = model_new[<span class="string">&quot;ml&quot;</span>].predict(model[<span class="string">&quot;preprocessor&quot;</span>].transform(X_val))</span><br><span class="line">y_pred_test = model_new[<span class="string">&quot;ml&quot;</span>].predict(model[<span class="string">&quot;preprocessor&quot;</span>].transform(X_test))</span><br><span class="line"></span><br><span class="line">plot_parity3(model_new, preds=[y_pred_train, y_pred_val, y_pred_test])</span><br></pre></td></tr></table></figure><p><img src="10_sc_11.png"></p></li><li><p>학습을 하지 않았음에도 parity plot이 똑같이 재현되었습니다.</p></li></ul><h3 id="3-2-8-Saving-and-Loading-callbacks"><a href="#3-2-8-Saving-and-Loading-callbacks" class="headerlink" title="3.2.8. Saving and Loading (callbacks)"></a>3.2.8. Saving and Loading (callbacks)</h3><blockquote><p><a href="https://skorch.readthedocs.io/en/stable/user/save_load.html#using-callbacks">skorch: Saving and Loading Using Callbacks</a></p></blockquote><ul><li><p>callback을 이용하면 valid loss가 줄어들때마다 저장할 수 있습니다.</p></li><li><p>valid loss가 줄어들때마다 저장하는 <code>cp</code>와 epoch마다 저장하는 <code>train_end_cp</code>를 동시에 지정합니다.</p></li><li><p><code>exp1</code> 폴더를 만들어 여기에 함께 저장하도록 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skorch.callbacks <span class="keyword">import</span> Checkpoint, TrainEndCheckpoint</span><br><span class="line"></span><br><span class="line"><span class="comment"># save the model parameters, optimizer, and history</span></span><br><span class="line">cp = Checkpoint(dirname=<span class="string">&#x27;exp1&#x27;</span>)</span><br><span class="line">train_end_cp = TrainEndCheckpoint(dirname=<span class="string">&#x27;exp1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">model = get_model(<span class="string">&quot;nn&quot;</span>, max_epochs=epochs, verbose=<span class="number">1</span>, criterion=RMSELoss, optimizer=optim.Adam, optimizer__lr = <span class="number">1e-3</span>,</span><br><span class="line">                  train_split=predefined_split(valid_dataset),                               </span><br><span class="line"></span><br><span class="line">                  callbacks=[<span class="comment"># input dimension setter</span></span><br><span class="line">                             (<span class="string">&quot;input_shape_setter&quot;</span>, InputShapeSetter()),</span><br><span class="line"></span><br><span class="line">                             <span class="comment"># LR scheduler</span></span><br><span class="line">                             (<span class="string">&quot;lr_scheduler&quot;</span>, LRScheduler(policy=OneCycleLR, </span><br><span class="line">                                                         max_lr=<span class="number">0.1</span>,</span><br><span class="line">                                                         total_steps=epochs)),</span><br><span class="line"></span><br><span class="line">                             <span class="comment"># early stopping</span></span><br><span class="line">                             (<span class="string">&quot;early_stopping&quot;</span>, EarlyStopping(monitor=<span class="string">&quot;valid_loss&quot;</span>,</span><br><span class="line">                                                              patience=<span class="number">20</span>)),</span><br><span class="line">                             </span><br><span class="line">                             <span class="comment"># Checkpoints</span></span><br><span class="line">                             (<span class="string">&quot;checkpoint&quot;</span>, cp),</span><br><span class="line">                             (<span class="string">&quot;train_end_checkpoint&quot;</span>, train_end_cp)</span><br><span class="line">                             ])</span><br><span class="line">model.fit(X_train, y_train.values.reshape(-<span class="number">1</span>, <span class="number">1</span>).astype(np.float32))</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Re-initializing module because the following parameters were re-set: module__ninput.</span><br><span class="line">Re-initializing criterion.</span><br><span class="line">Re-initializing optimizer.</span><br><span class="line">  epoch    train_loss    valid_loss    cp      lr     dur</span><br><span class="line">-------  ------------  ------------  ----  ------  ------</span><br><span class="line">      1     4301.9097     4250.2661     +  0.0040  0.0093</span><br><span class="line">      2     4301.8677     4250.2241     +  0.0040  0.0107</span><br><span class="line">      3     4301.8278     4250.1914     +  0.0040  0.0083</span><br><span class="line">      4     4301.7949     4250.1577     +  0.0040  0.0111</span><br><span class="line">      </span><br><span class="line">      ... (생략) ...</span><br><span class="line">      </span><br><span class="line">     96      294.3520      265.7108        0.0260  0.0112</span><br><span class="line">     97      296.6454      273.7495        0.0264  0.0098</span><br><span class="line">     98      290.3884      289.0570        0.0268  0.0071</span><br><span class="line">     99      289.6089      273.4566        0.0273  0.0093</span><br><span class="line">    100      284.6194      261.8893     +  0.0277  0.0092</span><br><span class="line">    101      290.8631      262.4448        0.0281  0.0107</span><br><span class="line">    102      289.3116      275.2869        0.0286  0.0077</span><br><span class="line">    103      286.5198      278.3972        0.0290  0.0075</span><br><span class="line">    104      283.5437      266.5125        0.0295  0.0106</span><br></pre></td></tr></table></figure></li></ul></li><li><p><b>cp</b>라는 열이 하나 생겼고, 여기 +가 붙은 곳들이 있습니다.</p></li><li><p>valid_loss가 기존 기록보다 작아진 지점입니다.</p></li></ul><ul><li><p>History도 파일에서 불러와서 그립니다.</p></li><li><p>부를 때는 <code>skorch.history.History</code>를 사용합니다.</p></li><li><p>세 개의 learning curve를 겹쳐 그리느라 코드가 다소 복잡해졌습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skorch.history <span class="keyword">import</span> History</span><br><span class="line"></span><br><span class="line"><span class="comment"># base plot</span></span><br><span class="line">ax = plot_epoch(train_loss_0, valid_loss_0)</span><br><span class="line">lines = ax.lines</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    line.set_alpha(<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># history</span></span><br><span class="line">history = History().from_file(<span class="string">&quot;./exp1/history.json&quot;</span>)</span><br><span class="line">train_loss = history[:, <span class="string">&quot;train_loss&quot;</span>]</span><br><span class="line">valid_loss = history[:, <span class="string">&quot;valid_loss&quot;</span>]</span><br><span class="line">ax = plot_epoch(train_loss, valid_loss, ax=ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># event_cp : cp == True</span></span><br><span class="line">epoch = history[:, <span class="string">&quot;epoch&quot;</span>]</span><br><span class="line">event_cp = history[:, <span class="string">&quot;event_cp&quot;</span>]</span><br><span class="line">df_cp = pd.DataFrame(&#123;<span class="string">&quot;epoch&quot;</span>:epoch, <span class="string">&quot;event_cp&quot;</span>:event_cp, <span class="string">&quot;train_loss&quot;</span>:train_loss, <span class="string">&quot;valid_loss&quot;</span>:valid_loss&#125;)</span><br><span class="line">df_cp = df_cp.loc[df_cp[<span class="string">&quot;event_cp&quot;</span>]==<span class="literal">True</span>]</span><br><span class="line"></span><br><span class="line">ax.scatter(df_cp[<span class="string">&quot;epoch&quot;</span>], df_cp[<span class="string">&quot;train_loss&quot;</span>], fc=c_train, alpha=<span class="number">0.5</span>, label=<span class="string">&quot;train_cp&quot;</span>)</span><br><span class="line">ax.scatter(df_cp[<span class="string">&quot;epoch&quot;</span>], df_cp[<span class="string">&quot;valid_loss&quot;</span>], fc=c_val, alpha=<span class="number">0.5</span>, label=<span class="string">&quot;valid_cp&quot;</span>)</span><br><span class="line"></span><br><span class="line">ax.legend(ncol=<span class="number">3</span>, title=<span class="string">&quot;base      LRS+ES           checkpoint&quot;</span>, loc=<span class="string">&quot;center right&quot;</span>)</span><br><span class="line">ax.set_xlim(<span class="number">0</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><p><img src="10_sc_12.png"><br></p></li><li><p>희미하게 그려진 것은 skorch에 validation set을 사용한 base line입니다.</p></li><li><p>그리고 Learning Rate Scheduler와 Early Stopping을 적용한 것을 LRS + ES로 표기했습니다.</p></li><li><p>앞에서와 같이 학습이 훨씬 빨리 끝났습니다.</p></li><li><p>그리고 이 중 <b>checkpoint가 적용된 것</b>을 scatter plot으로 표현했습니다.</p></li><li><p>one-cycle-fit의 영향으로 learning curve가 요동치는 와중에서도 train과 valid에서 단조 감소하는 모습만이 기록되었습니다.</p></li></ul><h3 id="3-2-9-valid-loss가-가장-적었던-checkpoint-불러서-learning-rate-낮추기"><a href="#3-2-9-valid-loss가-가장-적었던-checkpoint-불러서-learning-rate-낮추기" class="headerlink" title="3.2.9. valid loss가 가장 적었던 checkpoint 불러서 learning rate 낮추기"></a>3.2.9. valid loss가 가장 적었던 checkpoint 불러서 learning rate 낮추기</h3><blockquote><p><a href="https://skorch.readthedocs.io/en/stable/callbacks.html#skorch.callbacks.LoadInitState">skorch: skorch.callbacks.LoadInitState</a></p></blockquote><ul><li><p>각 checkpoint에서는 history 외에도 criterion, optimizer, parameter 등의 상태를 저장합니다.</p></li><li><p>Colab 왼쪽의 폴더 모양을 클릭해 저장한 파일을 확인하면 볼 수 있습니다.<br><br><img src="10_sc_13.png"><br></p></li><li><p>학습이 과하게 진행되어 overfitting이 되면 지나가버린 과거의 최적점이 아쉽습니다.</p></li><li><p>지나친 최적점을 불러와서 훨씬 낮은 learning rate로 살살 학습시키면 더 좋을 것 같습니다.</p></li></ul><ul><li>이 때 skorch에서 제공하는 <a href="https://skorch.readthedocs.io/en/stable/callbacks.html#skorch.callbacks.LoadInitState">LoadInitState</a>를 사용할 수 있습니다.</li><li><code>cp = Checkpoint()</code>로 저장된 위치를 지정하고,</li><li><code>load_state = LoadInitState(cp)</code>로 불러와 상태를 불러옵니다.</li><li>마지막으로 <code>callbacks</code>에 <code>cp</code>와 <code>load_state</code>를 추가합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skorch.callbacks <span class="keyword">import</span> LoadInitState</span><br><span class="line"></span><br><span class="line">cp = Checkpoint(dirname=<span class="string">&#x27;exp1&#x27;</span>)</span><br><span class="line">load_state = LoadInitState(cp)</span><br><span class="line"></span><br><span class="line">model = get_model(<span class="string">&quot;nn&quot;</span>, max_epochs=epochs, verbose=<span class="number">1</span>, criterion=RMSELoss, optimizer=optim.Adam, </span><br><span class="line">                  <span class="comment"># learning rate 조정</span></span><br><span class="line">                  optimizer__lr = <span class="number">1e-5</span>,</span><br><span class="line"></span><br><span class="line">                  <span class="comment"># predefined validataion set</span></span><br><span class="line">                  train_split=predefined_split(valid_dataset),                               </span><br><span class="line"></span><br><span class="line">                  callbacks=[<span class="comment"># input dimension setter</span></span><br><span class="line">                             (<span class="string">&quot;input_shape_setter&quot;</span>, InputShapeSetter()),</span><br><span class="line"></span><br><span class="line">                             <span class="comment"># early stopping</span></span><br><span class="line">                             (<span class="string">&quot;early_stopping&quot;</span>, EarlyStopping(monitor=<span class="string">&quot;valid_loss&quot;</span>,</span><br><span class="line">                                                              patience=<span class="number">100</span>)),</span><br><span class="line">                             </span><br><span class="line">                             <span class="comment"># Checkpoints</span></span><br><span class="line">                             (<span class="string">&quot;checkpoint&quot;</span>, cp),</span><br><span class="line">                             (<span class="string">&quot;load_initial_state&quot;</span>, load_state)</span><br><span class="line">                             ])</span><br><span class="line">model.fit(X_train, y_train.values.reshape(-<span class="number">1</span>, <span class="number">1</span>).astype(np.float32))</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-10-Saving-and-Loading-model-itself"><a href="#3-2-10-Saving-and-Loading-model-itself" class="headerlink" title="3.2.10. Saving and Loading (model itself)"></a>3.2.10. Saving and Loading (model itself)</h3><ul><li><p>모델 전체를 저장할 때는 pickle을 권장하고 있습니다.</p></li><li><p><code>pickle.dump()</code>와 <code>pickle.load()</code>를 사용해 모델을 읽고 씁니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># saving</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;skorch_dl.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    pickle.dump(model, f)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># loading</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;skorch_dl.pkl&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    model_pkl = pickle.load(f)</span><br></pre></td></tr></table></figure></li><li><p>저장한 모델을 불러오면서 이름을 model_pkl로 바꿨습니다.</p></li><li><p>이 모델의 parity plot을 그려서 잘 저장되었고 불러졌는지 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># check reproducibility</span></span><br><span class="line">plot_parity3(model=model_pkl)</span><br></pre></td></tr></table></figure><p><img src="10_sc_14.png"><br></p></li><li><p>추가 학습 없이도 원래의 성능이 확인되었습니다.</p></li></ul><h1 id="4-정리-skorch-ML-pipeline"><a href="#4-정리-skorch-ML-pipeline" class="headerlink" title="4. 정리 : skorch ML pipeline"></a>4. 정리 : skorch ML pipeline</h1><ul><li>이제까지 세 편의 글에 걸쳐 데이터를 정리한 후,</li><li><b>scikit-learn preprocessor</b>를 만들고,</li><li><b>PyTorch neural network</b>를 구축한 후,</li><li><b>skorch로 이들을 엮은 뒤 callbacks로 여러 옵션을 뿌렸습니다.</b></li></ul><ul><li>최종적으로 사용한 코드가 여기 저기 흩뿌려져 있어 활용이 어려울 듯도 싶습니다.</li><li>skorch ML pipeline 코드를 아래에 정리합니다.</li><li><b>목적은 Ctrl+C/V</b>와 약간의 수정으로 사용하는 것입니다.</li></ul><h2 id="4-1-skorch-ML-pipeline"><a href="#4-1-skorch-ML-pipeline" class="headerlink" title="4.1. skorch ML pipeline"></a>4.1. skorch ML pipeline</h2><ul><li><p>scikit-learn preprocessor</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># preprocessors</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> FunctionTransformer</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"></span><br><span class="line"><span class="comment"># pipeline</span></span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.compose <span class="keyword">import</span> ColumnTransformer</span><br><span class="line"><span class="keyword">from</span> sklearn.base <span class="keyword">import</span> BaseEstimator, TransformerMixin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Preprocessings for Categorical and Numerical features</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_concat</span>(<span class="params">cols_cat=cols_cat, cols_num=cols_num, degree=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="comment"># categorical features: one-hot encoding</span></span><br><span class="line">    cat_features = cols_cat</span><br><span class="line">    cat_transformer = OneHotEncoder(sparse=<span class="literal">False</span>, handle_unknown=<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># numerical features: standard scaling &amp; polynomial features</span></span><br><span class="line">    num_features = cols_num</span><br><span class="line">    num_transformer = Pipeline(steps=[(<span class="string">&quot;polynomial&quot;</span>, PolynomialFeatures(degree=degree)),</span><br><span class="line">                                      (<span class="string">&quot;scaler&quot;</span>, StandardScaler())])</span><br><span class="line">    </span><br><span class="line">    numcat = ColumnTransformer(transformers=[(<span class="string">&quot;categorical&quot;</span>, cat_transformer, cat_features),</span><br><span class="line">                                          (<span class="string">&quot;numerical&quot;</span>, num_transformer, num_features)])</span><br><span class="line">    <span class="keyword">return</span> numcat</span><br><span class="line"></span><br><span class="line"><span class="comment"># Float64 to Float32 for PyTorch</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FloatTransformer</span>(<span class="params">BaseEstimator, TransformerMixin</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span>(<span class="params">self, X, y=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.array(X, dtype=np.float32)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># preprocessing Pipeline</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_preprocessor</span>(<span class="params">cols_cat=cols_cat, cols_num=cols_num, degree=<span class="number">1</span></span>):</span></span><br><span class="line">    concat = get_concat(cols_cat=cols_cat, cols_num=cols_num, degree=degree)</span><br><span class="line">    ft = FloatTransformer()</span><br><span class="line"></span><br><span class="line">    pipeline= Pipeline(steps=[(<span class="string">&quot;concat&quot;</span>, concat), </span><br><span class="line">                              (<span class="string">&quot;float64to32&quot;</span>, ft)])</span><br><span class="line">    <span class="keyword">return</span> pipeline</span><br></pre></td></tr></table></figure></li><li><p>PyTorch Neural Network</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># neural network: ninput(12)-16-16-12-8-1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ninput=<span class="number">12</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.layer0 = nn.Linear(ninput, <span class="number">16</span>)</span><br><span class="line">        self.layer1 = nn.Linear(<span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">        self.layer2 = nn.Linear(<span class="number">16</span>, <span class="number">12</span>)</span><br><span class="line">        self.layer3 = nn.Linear(<span class="number">12</span>, <span class="number">8</span>)</span><br><span class="line">        self.layer4 = nn.Linear(<span class="number">8</span>, <span class="number">1</span>)</span><br><span class="line">        self.activation = nn.ReLU()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.activation(self.layer0(x))</span><br><span class="line">        x = self.activation(self.layer1(x))</span><br><span class="line">        x = self.activation(self.layer2(x))</span><br><span class="line">        x = self.activation(self.layer3(x))</span><br><span class="line">        x = self.layer4(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># loss: RMSE</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RMSELoss</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, eps=<span class="number">1e-6</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.mse = nn.MSELoss()</span><br><span class="line">        self.eps = eps</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, true, pred</span>):</span></span><br><span class="line">        loss = torch.sqrt(self.mse(true, pred) + self.eps)</span><br><span class="line">        <span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure></li><li><p>skorch ML Pipeline</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># machine learning models</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line"></span><br><span class="line"><span class="comment"># embedding pytorch model in scikit-learn Pipeline</span></span><br><span class="line"><span class="keyword">from</span> skorch <span class="keyword">import</span> NeuralNetRegressor</span><br><span class="line"><span class="keyword">from</span> skorch.helper <span class="keyword">import</span> predefined_split</span><br><span class="line"></span><br><span class="line"><span class="comment"># callbacks</span></span><br><span class="line"><span class="keyword">from</span> skorch.callbacks <span class="keyword">import</span> Callback</span><br><span class="line"><span class="keyword">from</span> skorch.callbacks <span class="keyword">import</span> LRScheduler</span><br><span class="line"><span class="keyword">from</span> skorch.callbacks <span class="keyword">import</span> EarlyStopping</span><br><span class="line"><span class="keyword">from</span> skorch.callbacks <span class="keyword">import</span> Checkpoint, TrainEndCheckpoint</span><br><span class="line"></span><br><span class="line"><span class="comment"># dynamic input size of the PyTorch module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputShapeSetter</span>(<span class="params">Callback</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_train_begin</span>(<span class="params">self, net, X, y</span>):</span></span><br><span class="line">        net.set_params(module__ninput=X.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># save the model parameters, optimizer, and history</span></span><br><span class="line">cp = Checkpoint(dirname=<span class="string">&#x27;exp_test&#x27;</span>)</span><br><span class="line">train_end_cp = TrainEndCheckpoint(dirname=<span class="string">&#x27;exp_test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># skorch ML pipeline</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_model</span>(<span class="params">method=<span class="string">&quot;lr&quot;</span>, device=device, cols_cat=cols_cat, cols_num=cols_num, degree=<span class="number">1</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">              callbacks=[(<span class="params"><span class="string">&quot;input_shape_setter&quot;</span>, InputShapeSetter(<span class="params"></span>)</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">                         (<span class="params"><span class="string">&quot;lr_scheduler&quot;</span>, LRScheduler(<span class="params">policy=OneCycleLR, max_lr=<span class="number">0.1</span>, total_steps=epochs</span>)</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">                         (<span class="params"><span class="string">&quot;early_stopping&quot;</span>, EarlyStopping(<span class="params">monitor=<span class="string">&quot;valid_loss&quot;</span>, patience=<span class="number">20</span></span>)</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">                         (<span class="params"><span class="string">&quot;checkpoint&quot;</span>, cp</span>), (<span class="params"><span class="string">&quot;train_end_checkpoint&quot;</span>, train_end_cp</span>)], </span></span></span><br><span class="line"><span class="params"><span class="function">              **kwargs</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">&quot;lr&quot;</span>:</span><br><span class="line">        ml = LinearRegression(fit_intercept=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&quot;rf&quot;</span>:</span><br><span class="line">        ml = RandomForestRegressor(random_state=rng)</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&quot;nn&quot;</span>:</span><br><span class="line">        ml = NeuralNetRegressor(Net(), device=device, callbacks=callbacks, **kwargs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;# &#x27;method&#x27; should be in [&#x27;lr&#x27;, &#x27;rf&#x27;, &#x27;nn&#x27;].&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    preprocessor = get_preprocessor(cols_cat=cols_cat, cols_num=cols_num, degree=degree)</span><br><span class="line">    model = Pipeline([(<span class="string">&quot;preprocessor&quot;</span>, preprocessor), </span><br><span class="line">                      (<span class="string">&quot;ml&quot;</span>, ml)])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-2-Visualizations"><a href="#4-2-Visualizations" class="headerlink" title="4.2. Visualizations"></a>4.2. Visualizations</h2><ul><li><p>learning curve</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_epoch</span>(<span class="params">history=<span class="literal">None</span>, loss_trains=<span class="literal">None</span>, loss_vals=<span class="literal">None</span>, ax=<span class="literal">None</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">any</span>([history, loss_trains]) == <span class="literal">False</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;# one of &#x27;history&#x27; and &#x27;loss_trains&#x27; has to be used!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ax</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ax == <span class="literal">None</span>:</span><br><span class="line">        fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> loss_trains == <span class="literal">None</span>:</span><br><span class="line">        loss_trains = history[:, <span class="string">&quot;train_loss&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> history != <span class="literal">None</span> <span class="keyword">and</span> loss_vals == <span class="literal">None</span>:</span><br><span class="line">        loss_vals = history[:, <span class="string">&quot;valid_loss&quot;</span>]</span><br><span class="line"></span><br><span class="line">    ax.plot(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(loss_trains)+<span class="number">1</span>)), loss_trains, c=c_train, label=<span class="string">&quot;train&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> loss_vals != <span class="literal">None</span>:</span><br><span class="line">        ax.plot(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(loss_vals)+<span class="number">1</span>)), loss_vals, c=c_val, label=<span class="string">&quot;valid&quot;</span>)</span><br><span class="line">    ax.grid(axis=<span class="string">&quot;y&quot;</span>)</span><br><span class="line">    ax.set_xlabel(<span class="string">&quot;epochs&quot;</span>, fontdict=font_label)</span><br><span class="line">    ax.legend()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ax</span><br></pre></td></tr></table></figure></li><li><p>parity plots</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_parity3</span>(<span class="params">model, target=[<span class="string">&quot;train&quot;</span>, <span class="string">&quot;val&quot;</span>, <span class="string">&quot;test&quot;</span>], figsize=(<span class="params"><span class="number">10</span>, <span class="number">4</span></span>),</span></span></span><br><span class="line"><span class="params"><span class="function">                 Xs=<span class="literal">None</span>, trues=<span class="literal">None</span>, preds=<span class="literal">None</span>, colors=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> Xs:</span><br><span class="line">        Xs = [<span class="built_in">eval</span>(<span class="string">f&quot;X_<span class="subst">&#123;t&#125;</span>&quot;</span>) <span class="keyword">for</span> t <span class="keyword">in</span> target]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> trues:</span><br><span class="line">        trues = [<span class="built_in">eval</span>(<span class="string">f&quot;y_<span class="subst">&#123;t&#125;</span>&quot;</span>) <span class="keyword">for</span> t <span class="keyword">in</span> target]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> preds:</span><br><span class="line">        preds = [model.predict(X) <span class="keyword">for</span> X <span class="keyword">in</span> Xs]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> colors:</span><br><span class="line">        colors = [<span class="built_in">eval</span>(<span class="string">f&quot;c_<span class="subst">&#123;t&#125;</span>&quot;</span>) <span class="keyword">for</span> t <span class="keyword">in</span> target]</span><br><span class="line"></span><br><span class="line">    fig, axs = plt.subplots(ncols=<span class="built_in">len</span>(target), figsize=figsize, constrained_layout=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> ax, true, pred, c, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, trues, preds, colors, titles):</span><br><span class="line">        plot_parity(true, pred, ax=ax, scatter_kws=&#123;<span class="string">&quot;fc&quot;</span>:c, <span class="string">&quot;ec&quot;</span>:c, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>&#125;, title=title)</span><br><span class="line">        <span class="keyword">if</span> ax != axs[<span class="number">0</span>]:</span><br><span class="line">            ax.set_ylabel(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-3-test-run"><a href="#4-3-test-run" class="headerlink" title="4.3. test run"></a>4.3. test run</h2><ul><li><p>정의한 함수들로 예제를 돌려봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># predefined validation set</span></span><br><span class="line">preprocessor = get_preprocessor()</span><br><span class="line">X_val_pp = preprocessor.fit(X_train).transform(X_val)</span><br><span class="line">valid_dataset = Dataset(X_val_pp, y_val_np)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ML pipeline preparation</span></span><br><span class="line">model_test = get_model(<span class="string">&quot;nn&quot;</span>, max_epochs=epochs, verbose=<span class="number">1</span>, criterion=RMSELoss, optimizer=optim.Adam, optimizer__lr = <span class="number">1e-3</span>,</span><br><span class="line">                       train_split=predefined_split(valid_dataset))</span><br><span class="line">model_test.fit(X_train, y_train_np)</span><br><span class="line"></span><br><span class="line"><span class="comment"># learning curve</span></span><br><span class="line">history = History().from_file(<span class="string">&quot;./exp_test/history.json&quot;</span>)</span><br><span class="line">ax = plot_epoch(history)</span><br><span class="line"></span><br><span class="line"><span class="comment"># parity plots</span></span><br><span class="line">plot_parity3(model_test)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Re-initializing module because the following parameters were re-set: module__ninput.</span><br><span class="line">Re-initializing criterion.</span><br><span class="line">Re-initializing optimizer.</span><br><span class="line">  epoch    train_loss    valid_loss    cp      lr     dur</span><br><span class="line">-------  ------------  ------------  ----  ------  ------</span><br><span class="line">      1     4301.9874     4250.3501     +  0.0040  0.0135</span><br><span class="line">      2     4301.9537     4250.3169     +  0.0040  0.0139</span><br><span class="line">      </span><br><span class="line">      ... (생략) ...</span><br><span class="line">      </span><br><span class="line">    110      283.9839      270.7625        0.0322  0.0108</span><br><span class="line">    111      282.3574      270.6689        0.0326  0.0145</span><br><span class="line">Stopping since valid_loss has not improved <span class="keyword">in</span> the last 20 epochs.</span><br></pre></td></tr></table></figure><img src="10_sc_15.png"><br><img src="10_sc_16.png"></li></ul></li><li><p><b>잘 돌아갑니다. :)</b></p></li><li><p>전체를 실행해볼 수 있는 코드는 여기 있습니다: <a href="https://bit.ly/3xxznt8">Notebook</a></p></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Deep-Learning/">Deep Learning</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/pytorch/">pytorch</category>
      
      <category domain="https://jehyunlee.github.io/tags/sklearn/">sklearn</category>
      
      <category domain="https://jehyunlee.github.io/tags/pipeline/">pipeline</category>
      
      <category domain="https://jehyunlee.github.io/tags/neural-network/">neural network</category>
      
      <category domain="https://jehyunlee.github.io/tags/callback/">callback</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      
    </item>
    
    <item>
      <title>skorch callbacks (2) sklearn preprocesing + PyTorch neural network</title>
      <link>https://jehyunlee.github.io/2022/06/09/Python-DL-9-skorch_callback2/</link>
      <guid>https://jehyunlee.github.io/2022/06/09/Python-DL-9-skorch_callback2/</guid>
      <pubDate>Thu, 09 Jun 2022 01:28:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;PyTorch는 현재 가장 인기있는 딥러닝 라이브러리 중 하나입니다.&lt;/li&gt;
&lt;li&gt;학습 세부 사항을 지정하기 위해 Callback으로 다양한 기능을 지원합니다.&lt;/li&gt;
&lt;li&gt;skorch는 PyTorch를 scikit-learn과</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>PyTorch는 현재 가장 인기있는 딥러닝 라이브러리 중 하나입니다.</li><li>학습 세부 사항을 지정하기 위해 Callback으로 다양한 기능을 지원합니다.</li><li>skorch는 PyTorch를 scikit-learn과 함께 사용할 수 있게 해 줍니다.</li><li>skorch도 PyTorch callback을 이용할 수 있습니다.</li></ul><ul><li>글이 길어 세 개로 나눕니다. </li><li>두 번째로, scikit-learn을 사용해 전처리 파이프라인을 구성하고</li><li>PyTorch neural network를 만들어 여기에서 나온 결과물을 학습시킵니다.</li></ul><h1 id="3-Neural-Network"><a href="#3-Neural-Network" class="headerlink" title="3. Neural Network"></a>3. Neural Network</h1><h2 id="3-1-PyTorch"><a href="#3-1-PyTorch" class="headerlink" title="3.1. PyTorch"></a>3.1. PyTorch</h2><blockquote><p><a href="https://bit.ly/3xxznt8">Colab code: skorch callbacks</a></p></blockquote><h3 id="3-1-1-network-and-loss"><a href="#3-1-1-network-and-loss" class="headerlink" title="3.1.1. network and loss"></a>3.1.1. network and loss</h3><blockquote><p><a href="http://alexlenail.me/NN-SVG/index.html">NN-SVG</a></p></blockquote><ul><li>skorch는 scikit-learn Pipeline 안에 PyTorch Neural Network를 담을 수 있게 해줍니다.</li><li>input node 수를 가변적으로 입력받을 수 있는, input-16-16-12-8-1 구조를 설계합니다.</li><li>loss function은 RMSE를 만들어 사용합니다.</li><li>PyTorch에서 MSE를 제공하긴 하지만, 오차의 범위가 직관적으로 보이는 RMSE를 더 선호합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neural network: ninput(12)-16-16-12-8-1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ninput=<span class="number">12</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.layer0 = nn.Linear(ninput, <span class="number">16</span>)</span><br><span class="line">        self.layer1 = nn.Linear(<span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">        self.layer2 = nn.Linear(<span class="number">16</span>, <span class="number">12</span>)</span><br><span class="line">        self.layer3 = nn.Linear(<span class="number">12</span>, <span class="number">8</span>)</span><br><span class="line">        self.layer4 = nn.Linear(<span class="number">8</span>, <span class="number">1</span>)</span><br><span class="line">        self.activation = nn.ReLU()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.activation(self.layer0(x))</span><br><span class="line">        x = self.activation(self.layer1(x))</span><br><span class="line">        x = self.activation(self.layer2(x))</span><br><span class="line">        x = self.activation(self.layer3(x))</span><br><span class="line">        x = self.layer4(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># loss: RMSE</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RMSELoss</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, eps=<span class="number">1e-6</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.mse = nn.MSELoss()</span><br><span class="line">        self.eps = eps</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, true, pred</span>):</span></span><br><span class="line">        loss = torch.sqrt(self.mse(true, pred) + self.eps)</span><br><span class="line">        <span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure><img src="9_sc_01.png" alt="이런 신경망을 만들 준비가 됐습니다. 그림은 NN-SVG로 그렸습니다."></li></ul><h3 id="3-1-2-preprocessor-using-Pipeline"><a href="#3-1-2-preprocessor-using-Pipeline" class="headerlink" title="3.1.2. preprocessor using Pipeline"></a>3.1.2. preprocessor using Pipeline</h3><blockquote><p><a href="https://jehyunlee.github.io/2021/09/29/Python-DL-7-skorch_pipeline/">Pega Devlog: pytorch &amp; sklearn pipeline</a><br><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html">scikit-learn: sklearn.preprocessing.OneHotEncoder</a><br><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.PolynomialFeatures.html">scikit-learn: sklearn.preprocessing.PolynomialFeatures</a><br><a href="https://scikit-learn.org/stable/modules/generated/sklearn.compose.ColumnTransformer.html">scikit-learn: sklearn.compose.ColumnTransformer</a></p></blockquote><ul><li>펭귄 데이터셋에는 <b>categorical feature</b>가 세 개나 있습니다.</li><li><code>species</code>, <code>island</code>, <code>sex</code>에는 숫자가 아닌 문자가 들어있기 때문에 신경망에 투입될 수 없습니다.</li><li>여러 방법을 사용해 숫자로 바꿔주어야 합니다. 여기서는 one-hot-encoder를 사용하기로 합니다.</li></ul><ul><li>한편 <b>numerical feature</b>는 scaling이 필요합니다. </li><li>신경망의 weight를 수렴시키는 gradient descent를 안정적으로 만들기 위해서입니다.</li><li>관련해서는 <a href="https://jehyunlee.github.io/2021/09/29/Python-DL-7-skorch_pipeline/">지난 글</a>에서 언급한 적이 있으니 여기서는 생략합니다.</li><li>다만, <b><a href="https://jehyunlee.github.io/2021/09/29/Python-DL-7-skorch_pipeline/">지난 글</a>보다 파이프라인을 분할해서 구성합니다.</b></li><li>부품이 잘 준비돼있으면 활용성이 높아지기 때문입니다.</li></ul><ul><li><p>categorical feature와 numerical feature에 각기 one-hot-encoding과 scaling을 적용해 합칩니다.</p></li><li><p>numerical feature에는 polymomial feature 생성기를 붙여 교호작용을 고려할 수 있는 장치를 만듭니다.</p></li><li><p>feature 유형에 따라 다른 길을 타고 들어간 데이터는 <code>ColumnTransformer</code>로 결합됩니다.</p></li><li><p>마지막으로, float64 데이터 타입으로 float32로 변환하는 <code>FloatTransformer</code>를 추가합니다.</p></li><li><p><code>OneHotEncoder</code>등에서 생성되는 데이터 타입이 float64인데, PyTorch은 float32만 입력받기 때문입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># preprocessors</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> FunctionTransformer</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"></span><br><span class="line"><span class="comment"># pipeline</span></span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.compose <span class="keyword">import</span> ColumnTransformer</span><br><span class="line"><span class="keyword">from</span> sklearn.base <span class="keyword">import</span> BaseEstimator, TransformerMixin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Preprocessings for Categorical and Numerical features</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_concat</span>(<span class="params">cols_cat=cols_cat, cols_num=cols_num, degree=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="comment"># categorical features: one-hot encoding</span></span><br><span class="line">    cat_features = cols_cat</span><br><span class="line">    cat_transformer = OneHotEncoder(sparse=<span class="literal">False</span>, handle_unknown=<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># numerical features: standard scaling &amp; polynomial features</span></span><br><span class="line">    num_features = cols_num</span><br><span class="line">    num_transformer = Pipeline(steps=[(<span class="string">&quot;polynomial&quot;</span>, PolynomialFeatures(degree=degree)),</span><br><span class="line">                                      (<span class="string">&quot;scaler&quot;</span>, StandardScaler())])</span><br><span class="line">    </span><br><span class="line">    numcat = ColumnTransformer(transformers=[(<span class="string">&quot;categorical&quot;</span>, cat_transformer, cat_features),</span><br><span class="line">                                          (<span class="string">&quot;numerical&quot;</span>, num_transformer, num_features)])</span><br><span class="line">    <span class="keyword">return</span> numcat</span><br><span class="line"></span><br><span class="line"><span class="comment"># Float64 to Float32 for PyTorch</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FloatTransformer</span>(<span class="params">BaseEstimator, TransformerMixin</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span>(<span class="params">self, X, y=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.array(X, dtype=np.float32)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># preprocessing Pipeline</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_preprocessor</span>(<span class="params">cols_cat=cols_cat, cols_num=cols_num, degree=<span class="number">1</span></span>):</span></span><br><span class="line">    concat = get_concat(cols_cat=cols_cat, cols_num=cols_num, degree=degree)</span><br><span class="line">    ft = FloatTransformer()</span><br><span class="line"></span><br><span class="line">    pipeline= Pipeline(steps=[(<span class="string">&quot;concat&quot;</span>, concat), </span><br><span class="line">                              (<span class="string">&quot;float64to32&quot;</span>, ft)])</span><br><span class="line">    <span class="keyword">return</span> pipeline</span><br></pre></td></tr></table></figure></li><li><p>작성한 전처리 파이프라인을 그림으로 출력해 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> set_config</span><br><span class="line">set_config(display=<span class="string">&#x27;diagram&#x27;</span>)</span><br><span class="line"></span><br><span class="line">preprocessor = get_preprocessor()</span><br><span class="line">preprocessor</span><br></pre></td></tr></table></figure><p><img src="9_sc_02.png"><br></p></li><li><p>preprocessor에 train, validation, test용으로 준비한 X 데이터를 투입합니다.</p></li><li><p>preprocessor를 통한 데이터는 <code>numpy.ndarray</code>로 변합니다.</p></li><li><p>PyTorch에 넣기 위해 <code>torch.Tensor</code>로 한번 더 바꿔줍니다.</p></li><li><p>y 데이터는 preprocessor에 넣을 필요가 없으니 <code>torch.Tensor()</code>에만 통과시킵니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Xs</span></span><br><span class="line">X_train_np = preprocessor.fit_transform(X_train)</span><br><span class="line">X_val_np = preprocessor.transform(X_val)</span><br><span class="line">X_test_np = preprocessor.transform(X_test)</span><br><span class="line"></span><br><span class="line">X_train_tensor = torch.Tensor(X_train_np).to(device)</span><br><span class="line">X_val_tensor = torch.Tensor(X_val_np).to(device)</span><br><span class="line">X_test_tensor = torch.Tensor(X_test_np).to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ys</span></span><br><span class="line">y_train_tensor = torch.Tensor(y_train.values).to(device)</span><br><span class="line">y_val_tensor = torch.Tensor(y_val.values).to(device)</span><br><span class="line">y_test_tensor = torch.Tensor(y_test.values).to(device)</span><br></pre></td></tr></table></figure></li><li><p>변환된 데이터의 타입을 확인합니다.</p></li><li><p>preprocessing후, 그리고 <code>torch.Tensor()</code>를 거치며 변하는 모습이 관찰됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Xs</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# dtype of X_train:\t\t<span class="subst">&#123;X_train.dtypes.values&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# dtype of X_train_np:\t\t<span class="subst">&#123;X_train_np.dtype&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# dtype of X_train_tensor:\t<span class="subst">&#123;X_train_tensor.dtype&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ys</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# dtype of y_train:\t\t<span class="subst">&#123;y_train.dtype&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# dtype of y_train_tensor:\t<span class="subst">&#123;y_train_tensor.dtype&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dtype of X_train:[dtype(&#x27;O&#x27;) dtype(&#x27;O&#x27;) dtype(&#x27;float64&#x27;) dtype(&#x27;float64&#x27;) dtype(&#x27;float64&#x27;) dtype(&#x27;O&#x27;)]</span></span><br><span class="line"><span class="comment"># dtype of X_train_np:float32</span></span><br><span class="line"><span class="comment"># dtype of X_train_tensor:torch.float32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dtype of y_train:float64</span></span><br><span class="line"><span class="comment"># dtype of y_train_tensor:torch.float32</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-1-3-training-amp-validation"><a href="#3-1-3-training-amp-validation" class="headerlink" title="3.1.3. training &amp; validation"></a>3.1.3. training &amp; validation</h3><ul><li>neural network와 preprocessor가 준비됐습니다.</li><li>loss_function, optimizer, 최대 epochs를 지정하고,</li><li>한편으로 leanring rate scheduler와 early stopping도 동원합니다.</li><li>train과 validation 함수와 함께 epoch에 따른 loss를 시각화하는 함수도 준비합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.optim.lr_scheduler <span class="keyword">import</span> OneCycleLR</span><br><span class="line"></span><br><span class="line">net = Net().to(device)                      <span class="comment"># Neural Network 생성</span></span><br><span class="line">loss_fn = RMSELoss()                        <span class="comment"># loss function 지정</span></span><br><span class="line">optimizer = optim.Adam(net.parameters(), </span><br><span class="line">                       lr=<span class="number">1e-3</span>)             <span class="comment"># learning rate = 0.001</span></span><br><span class="line">epochs = <span class="number">1000</span>                               <span class="comment"># number of max. epochs</span></span><br><span class="line">onecycle = OneCycleLR(optimizer,            <span class="comment"># learning rate scheduler</span></span><br><span class="line">                     max_lr=<span class="number">0.1</span>, total_steps=epochs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">device, model, epochs, loss_fn, optimizer, X_train, y_train, X_val=<span class="literal">None</span>, y_val=<span class="literal">None</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">          lr_scheduler=<span class="literal">None</span>, early_stopping=<span class="number">1</span>, patience=<span class="number">3</span>, plot=<span class="literal">True</span></span>):</span></span><br><span class="line">    loss_trains = []                            <span class="comment"># train loss </span></span><br><span class="line">    loss_vals = []                              <span class="comment"># validation loss</span></span><br><span class="line">    loss_last = np.inf</span><br><span class="line">    patience_ = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    val = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> X_val != <span class="literal">None</span> <span class="keyword">and</span> y_val != <span class="literal">None</span>:</span><br><span class="line">        val = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(epochs)):</span><br><span class="line">        model.train()                           <span class="comment"># sets the model in training mode</span></span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()                   <span class="comment"># gradient reset</span></span><br><span class="line">        y_pred = model.forward(X_train_tensor)  <span class="comment"># forward propagation</span></span><br><span class="line">        loss_ = loss_fn(y_pred, y_train_tensor.view(-<span class="number">1</span>, <span class="number">1</span>)) <span class="comment"># loss 계산</span></span><br><span class="line">        loss_.backward()                        <span class="comment"># back propagation</span></span><br><span class="line">        optimizer.step()                        <span class="comment"># weight update</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> lr_scheduler:</span><br><span class="line">            lr_scheduler.step()                 <span class="comment"># learning rate scheduler</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        loss = loss_.item()</span><br><span class="line">        loss_trains.append(loss)                <span class="comment"># collect train loss</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># progress message</span></span><br><span class="line">        prog_msg = <span class="string">f&quot;[<span class="subst">&#123;epoch&#125;</span>/<span class="subst">&#123;epochs&#125;</span>] train_loss: <span class="subst">&#123;loss&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># validation</span></span><br><span class="line">        <span class="keyword">if</span> val == <span class="literal">True</span>:</span><br><span class="line">            loss = validate(device, model, loss_fn, X_val, y_val)</span><br><span class="line">            loss_vals.append(loss)          <span class="comment"># collect validation loss</span></span><br><span class="line">            prog_msg += <span class="string">f&quot;,  valid_loss: <span class="subst">&#123;loss&#125;</span>&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> epoch % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(prog_msg)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># early stopping : patience회 이상 loss_val이 감소하지 않을 때</span></span><br><span class="line">        <span class="keyword">if</span> early_stopping &gt; <span class="number">0</span> <span class="keyword">and</span> (loss &gt; loss_last):</span><br><span class="line">            patience_ += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> patience_ &gt;= patience:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;early stopping: <span class="subst">&#123;loss_last&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        loss_last = loss</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> plot:</span><br><span class="line">        <span class="keyword">if</span> val:</span><br><span class="line">            plot_epoch(loss_trains, loss_vals)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            plot_epoch(loss_trains)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate</span>(<span class="params">device, model, loss_fn, X_val, y_val</span>):</span></span><br><span class="line">    model.<span class="built_in">eval</span>()                            <span class="comment"># sets the model in evaluating mode</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():                   <span class="comment"># gradient 계산 없이 진행</span></span><br><span class="line">        y_pred = net.forward(X_val)         <span class="comment"># forward propagation</span></span><br><span class="line">        loss = loss_fn(y_pred, y_val.view(-<span class="number">1</span>, <span class="number">1</span>))       <span class="comment"># loss 계산</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> loss.item()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_epoch</span>(<span class="params">loss_trains, loss_vals=<span class="literal">None</span>, ax=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> ax == <span class="literal">None</span>:</span><br><span class="line">        fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">        </span><br><span class="line">    ax.plot(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(loss_trains)+<span class="number">1</span>)), loss_trains, c=c_train, label=<span class="string">&quot;train&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> loss_vals != <span class="literal">None</span>:</span><br><span class="line">        ax.plot(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(loss_vals)+<span class="number">1</span>)), loss_vals, c=c_val, label=<span class="string">&quot;valid&quot;</span>)</span><br><span class="line">    ax.grid(axis=<span class="string">&quot;y&quot;</span>)</span><br><span class="line">    ax.set_xlabel(<span class="string">&quot;epochs&quot;</span>, fontdict=font_label)</span><br><span class="line">    ax.legend()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ax</span><br><span class="line"></span><br><span class="line">net = train(device, net, epochs, loss_fn, optimizer, X_train_tensor, y_train_tensor, X_val_tensor, y_val_tensor,</span><br><span class="line">            lr_scheduler=<span class="literal">None</span>, early_stopping=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">100% ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 1000/1000 [00:04&lt;00:00, 222.90it/s]</span><br><span class="line">[0/1000] train_loss: 4303.2822265625,  valid_loss: 4250.70068359375</span><br><span class="line">[100/1000] train_loss: 3756.332763671875,  valid_loss: 3660.7578125</span><br><span class="line">[200/1000] train_loss: 361.5039367675781,  valid_loss: 295.07098388671875</span><br><span class="line">[300/1000] train_loss: 289.6954650878906,  valid_loss: 275.11474609375</span><br><span class="line">[400/1000] train_loss: 282.8603210449219,  valid_loss: 271.21929931640625</span><br><span class="line">[500/1000] train_loss: 280.0774230957031,  valid_loss: 271.82470703125</span><br><span class="line">[600/1000] train_loss: 278.8686828613281,  valid_loss: 272.6382141113281</span><br><span class="line">[700/1000] train_loss: 278.05108642578125,  valid_loss: 273.4883728027344</span><br><span class="line">[800/1000] train_loss: 276.9803466796875,  valid_loss: 275.0303039550781</span><br><span class="line">[900/1000] train_loss: 276.1494140625,  valid_loss: 275.9771728515625</span><br></pre></td></tr></table></figure><img src="9_sc_03.png"><br></li></ul></li></ul><h3 id="3-1-4-parity-plot"><a href="#3-1-4-parity-plot" class="headerlink" title="3.1.4. parity plot"></a>3.1.4. parity plot</h3><ul><li>training, valiation, testing set의 학습 결과를 비교하는 함수를 만듭니다.</li><li>참값(<code>true</code>)과 예측값(<code>pred</code>)을 scatter plot으로 그립니다.</li><li>여기에 MAE, RMSE, R2를 동시에 출력하는 함수를 만듭니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.colors <span class="keyword">as</span> colors</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_absolute_error</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_metrics</span>(<span class="params">true, pred</span>):</span></span><br><span class="line">    mae = mean_absolute_error(true, pred)</span><br><span class="line">    rmse = mean_squared_error(true, pred, squared=<span class="literal">False</span>)</span><br><span class="line">    r2 = r2_score(true, pred)</span><br><span class="line">    <span class="keyword">return</span> mae, rmse, r2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_parity</span>(<span class="params">true, pred, kind=<span class="string">&quot;scatter&quot;</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                xlabel=<span class="string">&quot;true&quot;</span>, ylabel=<span class="string">&quot;predict&quot;</span>, title=<span class="string">&quot;&quot;</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                hist2d_kws=<span class="literal">None</span>, scatter_kws=<span class="literal">None</span>, kde_kws=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                equal=<span class="literal">True</span>, metrics=<span class="literal">True</span>, metrics_position=<span class="string">&quot;lower right&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                figsize=(<span class="params"><span class="number">5</span>, <span class="number">5</span></span>), ax=<span class="literal">None</span>, filename=<span class="literal">None</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    fig = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ax:</span><br><span class="line">        fig, ax = plt.subplots(figsize=figsize, constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># data range</span></span><br><span class="line">    val_min = <span class="built_in">min</span>(true.<span class="built_in">min</span>(), pred.<span class="built_in">min</span>())</span><br><span class="line">    val_max = <span class="built_in">max</span>(true.<span class="built_in">max</span>(), pred.<span class="built_in">max</span>())</span><br><span class="line">    data_range = val_max - val_min</span><br><span class="line"></span><br><span class="line">    <span class="comment"># data plot</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;scatter&quot;</span> <span class="keyword">in</span> kind:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> scatter_kws:</span><br><span class="line">            scatter_kws=&#123;<span class="string">&#x27;color&#x27;</span>:<span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;alpha&#x27;</span>:<span class="number">0.5</span>&#125;</span><br><span class="line">        ax.scatter(true, pred, **scatter_kws)</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&quot;hist2d&quot;</span> <span class="keyword">in</span> kind:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hist2d_kws:</span><br><span class="line">            hist2d_kws=&#123;<span class="string">&#x27;cmap&#x27;</span>:<span class="string">&#x27;Greens&#x27;</span>, <span class="string">&#x27;vmin&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;bins&#x27;</span>:<span class="number">30</span>&#125;</span><br><span class="line">        ax.hist2d(true, pred, **hist2d_kws)</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&quot;kde&quot;</span> <span class="keyword">in</span> kind:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> kde_kws:</span><br><span class="line">            kde_kws=&#123;<span class="string">&#x27;cmap&#x27;</span>:<span class="string">&#x27;viridis&#x27;</span>, <span class="string">&#x27;levels&#x27;</span>:<span class="number">5</span>&#125;</span><br><span class="line">        sns.kdeplot(x=true, y=pred, **kde_kws, ax=ax)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># x, y bounds</span></span><br><span class="line">    bounds = (val_min - data_range*<span class="number">0.1</span>, val_max + data_range*<span class="number">0.1</span>)</span><br><span class="line">    ax.set_xlim(bounds)</span><br><span class="line">    ax.set_ylim(bounds)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># x, y ticks, ticklabels</span></span><br><span class="line">    ticks = [<span class="built_in">int</span>(y) <span class="keyword">for</span> y <span class="keyword">in</span> ax.get_yticks() <span class="keyword">if</span> ((<span class="number">100</span>*y)%<span class="number">100</span> == <span class="number">0</span>) <span class="keyword">and</span> (val_min &lt;= y &lt;= val_max)]</span><br><span class="line">    ax.set_xticks(ticks, ticks)</span><br><span class="line">    ax.set_yticks(ticks, ticks)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># grid</span></span><br><span class="line">    ax.grid(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 기준선</span></span><br><span class="line">    ax.plot(bounds, bounds, c=<span class="string">&quot;k&quot;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># x, y label</span></span><br><span class="line">    font_label = &#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>&#125;</span><br><span class="line">    ax.set_xlabel(xlabel, fontdict=font_label, labelpad=<span class="number">12</span>)</span><br><span class="line">    ax.set_ylabel(ylabel, fontdict=font_label, labelpad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># title</span></span><br><span class="line">    font_title = &#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;gray&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;</span><br><span class="line">    ax.set_title(title, fontdict=font_title, pad=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># metrics</span></span><br><span class="line">    <span class="keyword">if</span> metrics:</span><br><span class="line">        rmse = mean_squared_error(true, pred, squared=<span class="literal">False</span>)</span><br><span class="line">        mae = mean_absolute_error(true, pred)</span><br><span class="line">        r2 = r2_score(true, pred)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> metrics_position == <span class="string">&quot;lower right&quot;</span>:</span><br><span class="line">            text_pos_x = <span class="number">0.98</span></span><br><span class="line">            text_pos_y = <span class="number">0.3</span></span><br><span class="line">            ha = <span class="string">&quot;right&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> metrics_position == <span class="string">&quot;upper left&quot;</span>:</span><br><span class="line">            text_pos_x = <span class="number">0.1</span></span><br><span class="line">            text_pos_y = <span class="number">0.9</span></span><br><span class="line">            ha = <span class="string">&quot;left&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            text_pos_x, text_pos_y = metrics_position</span><br><span class="line">            ha = <span class="string">&quot;left&quot;</span></span><br><span class="line"></span><br><span class="line">        ax.text(text_pos_x, text_pos_y, <span class="string">f&quot;RMSE = <span class="subst">&#123;rmse:<span class="number">.3</span>f&#125;</span>&quot;</span>, </span><br><span class="line">                transform=ax.transAxes, fontdict=font_metrics, ha=ha)</span><br><span class="line">        ax.text(text_pos_x, text_pos_y-<span class="number">0.1</span>, <span class="string">f&quot;MAE = <span class="subst">&#123;mae:<span class="number">.3</span>f&#125;</span>&quot;</span>, </span><br><span class="line">                transform=ax.transAxes, fontdict=font_metrics, ha=ha)</span><br><span class="line">        ax.text(text_pos_x, text_pos_y-<span class="number">0.2</span>, <span class="string">f&quot;R2 = <span class="subst">&#123;r2:<span class="number">.3</span>f&#125;</span>&quot;</span>, </span><br><span class="line">                transform=ax.transAxes, fontdict=font_metrics, ha=ha)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 파일로 저장</span></span><br><span class="line">    <span class="keyword">if</span> fig <span class="keyword">and</span> filename:</span><br><span class="line">            fig.savefig(filename)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ax</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-1-5-testing"><a href="#3-1-5-testing" class="headerlink" title="3.1.5. testing"></a>3.1.5. testing</h3><ul><li><p>training set으로 신경망을 학습시키고,</p></li><li><p>validation set으로 학습 현황을 모니터링하며</p></li><li><p>validation set의 성능이 마음에 들지 않을 경우 신경망의 구조나 learning rate와 같은 hyperparameter를 수정하여 성능을 높입니다.</p></li><li><p>이 과정을 거쳤다고 치고, training + validataion set으로 재학습을 시킨 후 testing data로 최종 결과를 얻습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># evaluate training and validataion set</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    y_pred_train = net.forward(X_train_tensor).cpu().numpy().flatten()</span><br><span class="line">    y_pred_val = net.forward(X_val_tensor).cpu().numpy().flatten()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># hyperparameter 업데이트 했다고 치고, training + validataion set으로 refit</span></span><br><span class="line">X_Train_pp = preprocessor.fit_transform(X_Train)</span><br><span class="line">X_Train_tensor = torch.Tensor(X_Train_pp).to(device)</span><br><span class="line">y_Train_tensor = torch.Tensor(y_Train).to(device)</span><br><span class="line"></span><br><span class="line">net = Net().to(device)</span><br><span class="line">loss_fn = RMSELoss()                        <span class="comment"># loss function 지정</span></span><br><span class="line">optimizer = optim.Adam(net.parameters(), </span><br><span class="line">                       lr=<span class="number">1e-3</span>)             <span class="comment"># learning rate = 0.001</span></span><br><span class="line">epochs = <span class="number">1000</span></span><br><span class="line">net = train(device, net, epochs, loss_fn, optimizer, X_Train_tensor, y_Train_tensor, X_val_tensor, y_val_tensor, early_stopping=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">100% ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 1000/1000 [00:04&lt;00:00, 270.43it/s]</span><br><span class="line">[0/1000] train_loss: 4303.0849609375,  valid_loss: 4250.50732421875</span><br><span class="line">[100/1000] train_loss: 4298.97021484375,  valid_loss: 4246.09326171875</span><br><span class="line">[200/1000] train_loss: 3950.37841796875,  valid_loss: 3884.753173828125</span><br><span class="line">[300/1000] train_loss: 606.517822265625,  valid_loss: 669.4122924804688</span><br><span class="line">[400/1000] train_loss: 320.8173828125,  valid_loss: 296.9498291015625</span><br><span class="line">[500/1000] train_loss: 306.0234069824219,  valid_loss: 281.5106506347656</span><br><span class="line">[600/1000] train_loss: 299.0507507324219,  valid_loss: 276.0859375</span><br><span class="line">[700/1000] train_loss: 294.1066589355469,  valid_loss: 272.7406921386719</span><br><span class="line">[800/1000] train_loss: 290.13287353515625,  valid_loss: 270.5881652832031</span><br><span class="line">[900/1000] train_loss: 287.00494384765625,  valid_loss: 269.0577697753906</span><br></pre></td></tr></table></figure><img src="9_sc_04.png"><br></li></ul></li><li><p>testing 결과까지 얻은 후, 최종적으로 parity plot 세 개를 같이 그립니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># evaluate testing set</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    y_pred_test = net.forward(X_test_tensor).cpu().numpy().flatten()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># parity plots</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">trues = [y_train, y_val, y_test]</span><br><span class="line">preds = [y_pred_train, y_pred_val, y_pred_test]</span><br><span class="line">colors = [c_train, c_val, c_test]</span><br><span class="line">titles = [<span class="string">&quot;train&quot;</span>, <span class="string">&quot;validation&quot;</span>, <span class="string">&quot;test&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> ax, true, pred, c, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, trues, preds, colors, titles):</span><br><span class="line">    plot_parity(true, pred, ax=ax, scatter_kws=&#123;<span class="string">&quot;fc&quot;</span>:c, <span class="string">&quot;ec&quot;</span>:c, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>&#125;, title=title)</span><br><span class="line">    <span class="keyword">if</span> ax != axs[<span class="number">0</span>]:</span><br><span class="line">        ax.set_ylabel(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="9_sc_05.png"><br></p></li><li><p>펭귄 체중이 제법 괜찮게 예측되고 있습니다.</p></li><li><p>scikit-learn Pipeline으로 categorical feature와 numerial feature에 적절한 처리를 마친 후, </p></li><li><p>PyTorch로 딥러닝 학습을 잘 시킨 것입니다.</p></li></ul><ul><li>Pipeline으로 전처리 과정을 모두 묶었고, PyTorch 딥러닝을 함수화 했습니다.</li><li>하지만 PyTorch로 따로 넘어가는 과정이 따로 노는 느낌이 듭니다.</li><li>이제 하나로 묶어볼 차례입니다.</li><li>넘어가기 전에, parity plot을 그린 명령도 함수로 정리합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_parity3</span>(<span class="params">model, target=[<span class="string">&quot;train&quot;</span>, <span class="string">&quot;val&quot;</span>, <span class="string">&quot;test&quot;</span>], figsize=(<span class="params"><span class="number">10</span>, <span class="number">4</span></span>),</span></span></span><br><span class="line"><span class="params"><span class="function">                 Xs=<span class="literal">None</span>, trues=<span class="literal">None</span>, preds=<span class="literal">None</span>, colors=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> Xs:</span><br><span class="line">        Xs = [<span class="built_in">eval</span>(<span class="string">f&quot;X_<span class="subst">&#123;t&#125;</span>&quot;</span>) <span class="keyword">for</span> t <span class="keyword">in</span> target]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> trues:</span><br><span class="line">        trues = [<span class="built_in">eval</span>(<span class="string">f&quot;y_<span class="subst">&#123;t&#125;</span>&quot;</span>) <span class="keyword">for</span> t <span class="keyword">in</span> target]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> preds:</span><br><span class="line">        preds = [model.predict(X) <span class="keyword">for</span> X <span class="keyword">in</span> Xs]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> colors:</span><br><span class="line">        colors = [<span class="built_in">eval</span>(<span class="string">f&quot;c_<span class="subst">&#123;t&#125;</span>&quot;</span>) <span class="keyword">for</span> t <span class="keyword">in</span> target]</span><br><span class="line"></span><br><span class="line">    fig, axs = plt.subplots(ncols=<span class="built_in">len</span>(target), figsize=figsize, constrained_layout=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> ax, true, pred, c, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, trues, preds, colors, titles):</span><br><span class="line">        plot_parity(true, pred, ax=ax, scatter_kws=&#123;<span class="string">&quot;fc&quot;</span>:c, <span class="string">&quot;ec&quot;</span>:c, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>&#125;, title=title)</span><br><span class="line">        <span class="keyword">if</span> ax != axs[<span class="number">0</span>]:</span><br><span class="line">            ax.set_ylabel(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Deep-Learning/">Deep Learning</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/pytorch/">pytorch</category>
      
      <category domain="https://jehyunlee.github.io/tags/sklearn/">sklearn</category>
      
      <category domain="https://jehyunlee.github.io/tags/pipeline/">pipeline</category>
      
      <category domain="https://jehyunlee.github.io/tags/neural-network/">neural network</category>
      
      <category domain="https://jehyunlee.github.io/tags/callback/">callback</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      
    </item>
    
    <item>
      <title>skorch callbacks (1) dataset preparation</title>
      <link>https://jehyunlee.github.io/2022/06/09/Python-DL-8-skorch_callback/</link>
      <guid>https://jehyunlee.github.io/2022/06/09/Python-DL-8-skorch_callback/</guid>
      <pubDate>Wed, 08 Jun 2022 21:16:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;PyTorch는 현재 가장 인기있는 딥러닝 라이브러리 중 하나입니다.&lt;/li&gt;
&lt;li&gt;학습 세부 사항을 지정하기 위해 Callback으로 다양한 기능을 지원합니다.&lt;/li&gt;
&lt;li&gt;skorch는 PyTorch를 scikit-learn과</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>PyTorch는 현재 가장 인기있는 딥러닝 라이브러리 중 하나입니다.</li><li>학습 세부 사항을 지정하기 위해 Callback으로 다양한 기능을 지원합니다.</li><li>skorch는 PyTorch를 scikit-learn과 함께 사용할 수 있게 해 줍니다.</li><li>skorch도 PyTorch callback을 이용할 수 있습니다.</li></ul><ul><li>글이 길어 세 개로 나눕니다. </li><li>첫 번째로, 데이터를 준비하는 과정입니다. 분할까지 확인합니다.</li></ul><h1 id="1-환경-설정"><a href="#1-환경-설정" class="headerlink" title="1. 환경 설정"></a>1. 환경 설정</h1><h2 id="1-1-Colab-환경-설정"><a href="#1-1-Colab-환경-설정" class="headerlink" title="1.1. Colab 환경 설정"></a>1.1. Colab 환경 설정</h2><blockquote><p><a href="https://colab.research.google.com/">Google Colaboratory</a><br><a href="https://bit.ly/3xxznt8">Colab code: skorch callbacks</a></p></blockquote><ul><li><p>먼저, Google Colab에 접속하셔서 노트북을 만들고 <b>GPU 사용 설정</b>을 합니다.</p></li><li><p>메뉴에서 <b>[런타임] ▶ [런타임 유형 변경] ▶ [하드웨어 가속기]: GPU 설정</b>을 선택합니다.<br><br><img src="8_sc_02.png"><br></p></li><li><p>간혹 <b>GPU를 할당할 수 없다</b>는 메시지가 나오기도 하지만 <b>GPU 없이 사용</b>을 선택해도 됩니다.</p></li><li><p>데이터셋과 우리가 만들 딥러닝 구조가 깊지 않아 CPU로도 충분히 빠른 결과를 볼 수 있기 때문입니다.<br><br><img src="8_sc_06.png"><br></p></li></ul><ul><li>이 밖에, Colab에서는 크게 두 가지 설정을 합니다.</li><li>Matplotlib 버전을 3.2.2에서 3.5.x로 업그레이드를 하고,</li><li>한글을 쓸 수 있도록 설정을 합니다.<details>  <summary><b>코드 보기/접기</b></summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Step 1. Matplotlib 업그레이드</span></span><br><span class="line">!pip install matplotlib -U </span><br><span class="line">!pip install seaborn -U</span><br><span class="line">!pip install pandas -U</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 2. 한글 설치 및 사용 설정</span></span><br><span class="line">!apt-get -qq install -y fonts-nanum</span><br><span class="line">!fc-cache -fv  </span><br><span class="line">!rm ~/.cache/matplotlib -rf</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 3. 셀 실행 후 런타임 재시작</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Step 4. seaborn 환경 설정</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">sns.set_style(<span class="string">&quot;ticks&quot;</span>)</span><br><span class="line">sns.set_palette(<span class="string">&quot;colorblind&quot;</span>)</span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 5. 한글 글꼴 설정</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>]=[<span class="string">&#x27;NanumGothic&#x27;</span>, <span class="string">&#x27;sans-serif&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 한글 설정 확인</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&quot;한글 테스트&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="8_sc_03.png"></li></ul><h2 id="1-2-필수-라이브러리-amp-시각화-기본-설정"><a href="#1-2-필수-라이브러리-amp-시각화-기본-설정" class="headerlink" title="1.2. 필수 라이브러리 &amp; 시각화 기본 설정"></a>1.2. 필수 라이브러리 &amp; 시각화 기본 설정</h2><ul><li>numpy를 비롯한 필수 라이브러리를 불러옵니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">from</span> tqdm.auto <span class="keyword">import</span> tqdm</span><br></pre></td></tr></table></figure></li></ul><ul><li>시각화 관련 설정도 미리 합니다.</li><li>label과 title 등에 들어갈 font 속성을 미리 설정하고,</li><li>이후 train, validation, test 데이터와 결과 출력 단계에서 사용할 색을 지정합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># font properties</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;mathtext.fontset&quot;</span>] = <span class="string">&quot;cm&quot;</span></span><br><span class="line">font_label = &#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>&#125;</span><br><span class="line">font_title = &#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;k&quot;</span>&#125;</span><br><span class="line">font_metrics = &#123;<span class="string">&#x27;color&#x27;</span>:<span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;fontsize&#x27;</span>:<span class="string">&quot;medium&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># colors</span></span><br><span class="line">c_train = <span class="string">&quot;green&quot;</span></span><br><span class="line">c_val = <span class="string">&quot;orange&quot;</span></span><br><span class="line">c_test = <span class="string">&quot;magenta&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="1-3-PyTorch-사용-준비-amp-Random-Seed"><a href="#1-3-PyTorch-사용-준비-amp-Random-Seed" class="headerlink" title="1.3. PyTorch 사용 준비 &amp; Random Seed"></a>1.3. PyTorch 사용 준비 &amp; Random Seed</h2><blockquote><p><a href="https://scikit-learn.org/stable/common_pitfalls.html">scikit-learn Common pitfalls and recommended practices</a></p></blockquote><ul><li>PyTorch 관련 라이브러리를 불러오고, GPU를 사용할 준비를 합니다.</li><li>일단 당장 필요한 것들만 import해놓고 나중에는 그 때 그 때 필요한 것을 추가로 import할 것입니다.</li><li>GPU를 사용할 수 없는 환경이라면 CPU를 사용하도록 설정됩니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PyTorch 라이브러리</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># GPU 사용 설정</span></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(torch.cuda.device_count()):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;# DEVICE <span class="subst">&#123;i&#125;</span>: <span class="subst">&#123;torch.cuda.get_device_name(i)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;- Memory Usage:&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  Allocated: <span class="subst">&#123;<span class="built_in">round</span>(torch.cuda.memory_allocated(i)/<span class="number">1024</span>**<span class="number">3</span>,<span class="number">1</span>)&#125;</span> GB&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  Cached:    <span class="subst">&#123;<span class="built_in">round</span>(torch.cuda.memory_reserved(i)/<span class="number">1024</span>**<span class="number">3</span>,<span class="number">1</span>)&#125;</span> GB\n&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;# GPU is not available&quot;</span>)</span><br><span class="line">    </span><br><span class="line">device = <span class="string">&#x27;cuda:0&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>실행 결과: GPU로 <b>Tesla T4</b>가 할당되었습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DEVICE 0: Tesla T4</span></span><br><span class="line">- Memory Usage:</span><br><span class="line">  Allocated: 0.0 GB</span><br><span class="line">  Cached:    0.0 GB</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>Random Seed도 미리 설정합니다. </li><li>재현성을 결정하는 <a href="https://scikit-learn.org/stable/common_pitfalls.html">생각보다 중요한 단계</a>이므로 주의깊게 챙깁니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">0</span>)</span><br><span class="line">torch.manual_seed(<span class="number">0</span>)</span><br><span class="line">torch.cuda.manual_seed(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li></ul><h1 id="2-Data"><a href="#2-Data" class="headerlink" title="2. Data"></a>2. Data</h1><p><img src="8_sc_01.png"></p><blockquote><p><a href="https://rpubs.com/julianlavila/penguins">penguins dataset</a><br><a href="https://bit.ly/3xxznt8">Colab code: skorch callbacks</a></p></blockquote><ul><li>펭귄의 종<code>species</code>, 서식지<code>island</code>, 성별<code>sex</code>을 비롯해</li><li>세 가지 신체 치수<code>bill length</code>, <code>bill depth</code>, <code>flipper length</code>로 체중<code>body_mass</code>을 예측하는 문제를 풀어보겠습니다.</li><li>이번에는 GPU를 사용하는 법을 포함하여 Colab에서 실행합니다.</li></ul><h2 id="2-1-Dataset-불러오기"><a href="#2-1-Dataset-불러오기" class="headerlink" title="2.1. Dataset 불러오기"></a>2.1. Dataset 불러오기</h2><ul><li>seaborn에 내장된 데이터를 사용합니다.</li><li>결측치를 미리 제거합니다.</li><li>여기서는 생략했지만 <b>실전에서는 결측치, 중복치, 이상치를 모두 따져봐야 합니다!</b><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_peng = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)  <span class="comment"># 펭귄 데이터셋</span></span><br><span class="line">df_peng = df_peng.dropna()              <span class="comment"># 결측치 제거</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2-X-y-분할-y-body-mass-g"><a href="#2-2-X-y-분할-y-body-mass-g" class="headerlink" title="2.2. $X$, $y$ 분할: $y$ = body_mass_g"></a>2.2. $X$, $y$ 분할: $y$ = <code>body_mass_g</code></h2><ul><li>문제에 맞게 펭귄 체중을 $y$로 놓고 데이터를 분할합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = df_peng[<span class="string">&quot;body_mass_g&quot;</span>]</span><br><span class="line">X = df_peng.drop(<span class="string">&quot;body_mass_g&quot;</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-3-training-validataion-testing-set-분할"><a href="#2-3-training-validataion-testing-set-분할" class="headerlink" title="2.3. training, validataion, testing set 분할"></a>2.3. training, validataion, testing set 분할</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html">scikit-learn: sklearn.model_selection.train_test_split</a></p></blockquote><ul><li><p>훈련, 검증, 시험에 쓰일 데이터를 각기 3:1:1로 분할합니다.</p></li><li><p>scikit-learn의 <a href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html"><code>train_test_split</code></a>기능을 사용하는데, 두 덩어리로만 나눌 수 있으므로 두 번에 걸쳐 나누어줍니다.</p></li><li><p>먼저 Train : test를 4:1로 나누고, 다시 Train을 train : val = 3:1로 나눕니다.</p></li><li><p><code>random_state=rng</code>를 넣어서 재현성을 확보하는 것을 잊지 맙시다.</p></li><li><p><code>_train</code>, <code>_val</code>, <code>_test</code>가 붙은 세 가지 목적의 $X$, $y$ 데이터셋이 마련되었습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">X_Train, X_test, y_Train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=rng, </span><br><span class="line">                                                    stratify=X[[<span class="string">&quot;species&quot;</span>, <span class="string">&quot;island&quot;</span>, <span class="string">&quot;sex&quot;</span>]])</span><br><span class="line">X_train, X_val, y_train, y_val = train_test_split(X_Train, y_Train, test_size=<span class="number">0.25</span>, random_state=rng, </span><br><span class="line">                                                    stratify=X_Train[[<span class="string">&quot;species&quot;</span>, <span class="string">&quot;island&quot;</span>, <span class="string">&quot;sex&quot;</span>]])</span><br></pre></td></tr></table></figure></li><li><p><code>stratify</code> 매개변수에 <code>[[&quot;species&quot;, &quot;island&quot;, &quot;sex&quot;]]</code>를 넣어 층화 추출을 구현했습니다.</p></li><li><p><b>층화 추출은 데이터를 분할할 때 categorical data의 class비율을 반영해 나누는 것을 의미합니다.</b></p></li><li><p>특정 class가 한 쪽에 쏠려 너무 많거나 적어지는 현상을 방지합니다.</p></li><li><p><b>categorical features`</b>가 잘 분할되었는지 살펴봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">cols_cat = [<span class="string">&quot;species&quot;</span>, <span class="string">&quot;island&quot;</span>, <span class="string">&quot;sex&quot;</span>]</span><br><span class="line">df_tmp = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, (X, col) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>([X_train, X_val, X_test], [<span class="string">&quot;train&quot;</span>, <span class="string">&quot;valid&quot;</span>, <span class="string">&quot;test&quot;</span>])):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(df_tmp, <span class="built_in">int</span>):</span><br><span class="line">        df_tmp = pd.DataFrame(X[cols_cat].value_counts(), columns=[col]).sort_index()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        df_tmp = pd.concat([df_tmp, pd.DataFrame(X[cols_cat].value_counts(), columns=[col]).sort_index()], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">df_tmp.plot.barh(ax=ax, color=&#123;<span class="string">&quot;train&quot;</span>:c_train, <span class="string">&quot;valid&quot;</span>:c_val, <span class="string">&quot;test&quot;</span>:c_test&#125;).invert_yaxis()</span><br></pre></td></tr></table></figure><p><img src="8_sc_04.png"><br></p></li></ul><ul><li>y축 눈금에 species, island, sex 조합이 나열되어 있습니다.</li><li>모든 섬에 살고 있는 Adelie 펭귄과 Dream에만 살고 있는 Chinstrap, Biscoe에만 살고 있는 Gentoo 펭귄이 보입니다.</li><li>각 조합에서 valid와 test가 거의 비슷하고 train은 이들의 3배입니다. </li><li>3:1:1로 골고루 잘 나뉘었습니다.</li></ul><ul><li><p>이번에는 <b>numerical features</b> <code>bill_length_mm</code>, <code>bill_depth_mm</code>, <code>flipper_length_mm</code>, <code>body_mass_g</code>분포를 살핍니다.</p></li><li><p>KDE plot을 통해서 전반적인 분포를 대략적으로 비교합니다.</p></li><li><p>$X$에 3개의 numerical feature가 있고 $y$에 하나가 있습니다. 한데 모아 보여줍니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(ncols=<span class="number">2</span>, nrows=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">cols_num = [<span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, <span class="string">&quot;flipper_length_mm&quot;</span>]</span><br><span class="line">axs = axes.ravel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># numerical X features</span></span><br><span class="line"><span class="keyword">for</span> ax, col <span class="keyword">in</span> <span class="built_in">zip</span>(axes.ravel(), cols_num):</span><br><span class="line">    <span class="keyword">for</span> X, c <span class="keyword">in</span> <span class="built_in">zip</span>([X_train, X_val, X_test], [c_train, c_val, c_test]):</span><br><span class="line">        sns.kdeplot(x=col, data=X, ax=ax, fill=<span class="literal">True</span>, alpha=<span class="number">0.3</span>, color=c)</span><br><span class="line">        ax.set_ylabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># y feature</span></span><br><span class="line"><span class="keyword">for</span> y, c <span class="keyword">in</span> <span class="built_in">zip</span>([y_train, y_val, y_test], [c_train, c_val, c_test]):</span><br><span class="line">    sns.kdeplot(y, ax=axes[<span class="number">1</span>, <span class="number">1</span>], fill=<span class="literal">True</span>, alpha=<span class="number">0.3</span>, color=c)</span><br><span class="line">    axes[<span class="number">1</span>, <span class="number">1</span>].set_ylabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">axes[<span class="number">0</span>, <span class="number">1</span>].legend(handles=axes[<span class="number">1</span>, <span class="number">1</span>].collections, labels=[<span class="string">&quot;train&quot;</span>, <span class="string">&quot;valid&quot;</span>, <span class="string">&quot;test&quot;</span>],</span><br><span class="line">                  loc=<span class="string">&quot;upper left&quot;</span>, bbox_to_anchor=(<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p><img src="8_sc_05.png"><br></p></li><li><p>training, validation, testing set에 모든 변수가 비슷하게 분포하여 크게 치우친 면이 없습니다.</p></li><li><p>이정도 되면 웬만큼 믿고 학습에 투입할 수 있을 듯 합니다.</p></li><li><p>$X$와 $y$간의 상관관계만 있다면 좋은 성능을 얻을 수 있을 것입니다.</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Deep-Learning/">Deep Learning</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/pytorch/">pytorch</category>
      
      <category domain="https://jehyunlee.github.io/tags/sklearn/">sklearn</category>
      
      <category domain="https://jehyunlee.github.io/tags/pipeline/">pipeline</category>
      
      <category domain="https://jehyunlee.github.io/tags/neural-network/">neural network</category>
      
      <category domain="https://jehyunlee.github.io/tags/callback/">callback</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      
    </item>
    
    <item>
      <title>seaborn regplot vs lmplot</title>
      <link>https://jehyunlee.github.io/2022/06/06/Python-DS-103-snsreglmplot/</link>
      <guid>https://jehyunlee.github.io/2022/06/06/Python-DS-103-snsreglmplot/</guid>
      <pubDate>Mon, 06 Jun 2022 09:51:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;seaborn에는 regplot이라는 기능이 있습니다.&lt;/li&gt;
&lt;li&gt;산점도, 회귀선, 신뢰 구간을 동시에 표현해주는 강력한 기능입니다.&lt;/li&gt;
&lt;li&gt;그리고 같은 결과를 출력하는 lmplot이 있습니다. 같은 점과 다른 점을 확인</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>seaborn에는 regplot이라는 기능이 있습니다.</li><li>산점도, 회귀선, 신뢰 구간을 동시에 표현해주는 강력한 기능입니다.</li><li>그리고 같은 결과를 출력하는 lmplot이 있습니다. 같은 점과 다른 점을 확인합니다.</li></ul><h1 id="1-seaborn-regplot"><a href="#1-seaborn-regplot" class="headerlink" title="1. seaborn regplot"></a>1. seaborn regplot</h1><blockquote><p><a href="https://seaborn.pydata.org/generated/seaborn.regplot.html">seaborn.regplot</a></p></blockquote><ul><li>seaborn에는 <code>regplot</code> 함수가 있습니다.</li><li><b>scatter plot, regression line, confidence band를 한 번에 그리는 기능</b>입니다.</li><li>따로 그리려면 매우 손이 많이 가기 때문에, seaborn이 Matplotlib보다 우월한 점을 말할 때 빠지지 않는 기능입니다.</li></ul><h2 id="1-1-예제-데이터"><a href="#1-1-예제-데이터" class="headerlink" title="1.1. 예제 데이터"></a>1.1. 예제 데이터</h2><ul><li>예제 데이터를 사용해서 직접 그려보겠습니다.</li><li>seaborn에 내장된 penguins dataset을 사용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 시각화 설정</span></span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line">sns.set_style(<span class="string">&quot;ticks&quot;</span>)</span><br><span class="line">sns.set_palette(<span class="string">&quot;colorblind&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 예제 데이터 불러오기</span></span><br><span class="line">df_peng = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)</span><br><span class="line">df_peng.head()</span><br></pre></td></tr></table></figure><img src="103_snsreglmplot_11.png"><br></li></ul><h2 id="1-2-sns-regplot"><a href="#1-2-sns-regplot" class="headerlink" title="1.2. sns.regplot()"></a>1.2. <code>sns.regplot()</code></h2><ul><li><p>seaborn의 다른 명령어들이 그렇듯 <b><code>sns.regplot</code>도 한 줄로 실행</b>합니다.</p></li><li><p>그림이 담길 Figure와 Axes를 Matplotlib으로 만들고 이 안에 regplot을 담습니다.</p></li><li><p>그림을 파일로 저장할 때는 Figure 객체 fig에 <b><code>fig.savefig()</code></b> 명령을 내립니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">sns.regplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, ax=ax)</span><br><span class="line"></span><br><span class="line">fig.savefig(<span class="string">&quot;103_snsreglmplot_01.png&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="103_snsreglmplot_01.png"><br></p></li><li><p><code>x</code>와 <code>y</code>에 각기 x, y축에 놓일 데이터를,</p></li><li><p><code>data</code>에 x와 y가 담긴 dataset을 입력합니다.</p></li><li><p>마지막으로 <code>ax</code>에 regplot이 들어갈 Axes 이름을 입력했습니다.</p></li></ul><h2 id="1-3-scatter-kws"><a href="#1-3-scatter-kws" class="headerlink" title="1.3. scatter_kws"></a>1.3. <code>scatter_kws</code></h2><ul><li>scatter plot의 속성을 지정할 때 <code>scatter_kws</code> 매개변수를 사용합니다.</li><li>dictionary 형식으로 scatter 객체의 속성 이름과 값을 key와 value로 만들어 넣습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">sns.regplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, ax=ax,</span><br><span class="line">            scatter_kws=&#123;<span class="string">&quot;fc&quot;</span>:<span class="string">&quot;b&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;b&quot;</span>, <span class="string">&quot;s&quot;</span>:<span class="number">100</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.3</span>&#125;)</span><br><span class="line"></span><br><span class="line">fig.savefig(<span class="string">&quot;103_snsreglmplot_02.png&quot;</span>)</span><br></pre></td></tr></table></figure><img src="103_snsreglmplot_02.png"><br></li></ul><h2 id="1-4-line-kws"><a href="#1-4-line-kws" class="headerlink" title="1.4. line_kws"></a>1.4. <code>line_kws</code></h2><ul><li>scatter 속성을 <code>scatter_kws</code>로 조정했듯,</li><li>line 속성은 <code>line_kws</code>로 조정합니다.</li><li>line width, line style, alpha를 설정할 수 있습니다.</li><li>다만 line과 confidence band의 색은 별도의 매개변수 <code>color</code>로 조정해야 합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">sns.regplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, ax=ax,</span><br><span class="line">            scatter_kws=&#123;<span class="string">&quot;fc&quot;</span>:<span class="string">&quot;b&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;b&quot;</span>, <span class="string">&quot;s&quot;</span>:<span class="number">100</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.3</span>&#125;,</span><br><span class="line">            color=<span class="string">&quot;r&quot;</span>, line_kws=&#123;<span class="string">&quot;lw&quot;</span>:<span class="number">3</span>, <span class="string">&quot;ls&quot;</span>:<span class="string">&quot;--&quot;</span>,<span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>&#125;)</span><br><span class="line"></span><br><span class="line">fig.savefig(<span class="string">&quot;103_snsreglmplot_03.png&quot;</span>)</span><br></pre></td></tr></table></figure><img src="103_snsreglmplot_03.png"><br></li></ul><h2 id="1-5-confidence-band"><a href="#1-5-confidence-band" class="headerlink" title="1.5. confidence band"></a>1.5. confidence band</h2><ul><li>confidence band 속성을 제어하기 위해서는 객체를 추출하고 속성을 개별 제어해야 합니다.</li><li>regplot이 그려지는 Axes의 세 번째 객체가 confidence band입니다. </li><li>첫 번째와 두 번째 객체는 scatter plot, regression line입니다.</li></ul><ul><li><code>ax.get_children()[2]</code>로 confidence band를 추출하고,</li><li><code>.set()</code> 메소드로 속성을 제어합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">sns.regplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, ax=ax,</span><br><span class="line">            scatter_kws=&#123;<span class="string">&quot;fc&quot;</span>:<span class="string">&quot;b&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;b&quot;</span>, <span class="string">&quot;s&quot;</span>:<span class="number">100</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.3</span>&#125;,</span><br><span class="line">            color=<span class="string">&quot;r&quot;</span>, line_kws=&#123;<span class="string">&quot;lw&quot;</span>:<span class="number">3</span>, <span class="string">&quot;ls&quot;</span>:<span class="string">&quot;--&quot;</span>,<span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>&#125;)</span><br><span class="line"></span><br><span class="line">ci = ax.get_children()[<span class="number">2</span>]                   <span class="comment"># confidence band 추출</span></span><br><span class="line">ci.<span class="built_in">set</span>(fc=<span class="string">&quot;yellow&quot;</span>, ec=<span class="string">&quot;orange&quot;</span>, alpha=<span class="number">0.8</span>) <span class="comment"># face &amp; edge color, alpha 조정</span></span><br><span class="line"></span><br><span class="line">fig.savefig(<span class="string">&quot;103_snsreglmplot_04.png&quot;</span>)</span><br></pre></td></tr></table></figure><img src="103_snsreglmplot_04.png"><br></li></ul><h2 id="1-6-sns-regplot-amp-hue"><a href="#1-6-sns-regplot-amp-hue" class="headerlink" title="1.6. sns.regplot &amp; hue"></a>1.6. <code>sns.regplot</code> &amp; <code>hue</code></h2><blockquote><p><a href="https://www.britannica.com/topic/Simpsons-paradox">Brinnica: Simpson’s paradox</a></p></blockquote><ul><li><p>seaborn의 여러 함수에는 <code>hue</code> 매개변수가 있습니다.</p></li><li><p>categorical feature의 class별로 다른 색이나 style을 적용해 구분하도록 해 줍니다.</p></li><li><p>그러나 불행히도 <b><code>sns.regplot</code>에는 <code>hue</code>매개변수가 없습니다.</b></p></li><li><p>예를 들어 species별로 다른 색과 회귀선으로 표현하려면 for loop 등으로 반복해 그림을 그려야 합니다.</p></li><li><p>Axes 두 개를 마련해 왼쪽에 전체를, 오른쪽에 species별로 hue를 수동으로 구현한 그림을 그립니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>, </span><br><span class="line">                        sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># (A) 전체 시각화</span></span><br><span class="line">sns.regplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, ax=axs[<span class="number">0</span>], color=<span class="string">&quot;k&quot;</span>,</span><br><span class="line">            scatter_kws=&#123;<span class="string">&quot;fc&quot;</span>:<span class="string">&quot;lightgray&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;s&quot;</span>:<span class="number">50</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (B) species별 그룹 시각화</span></span><br><span class="line">peng_species = df_peng[<span class="string">&quot;species&quot;</span>].unique()  <span class="comment"># 펭귄 데이터셋 중 species 종류 추출</span></span><br><span class="line"><span class="keyword">for</span> species <span class="keyword">in</span> peng_species:</span><br><span class="line">    df_s = df_peng.loc[df_peng[<span class="string">&quot;species&quot;</span>] == species]   <span class="comment"># species별 펭귄 데이터 추출</span></span><br><span class="line">    sns.regplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_s, ax=axs[<span class="number">1</span>], label=species,</span><br><span class="line">                scatter_kws=&#123;<span class="string">&quot;s&quot;</span>:<span class="number">50</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>&#125;)</span><br><span class="line">   </span><br><span class="line">    axs[<span class="number">1</span>].legend(loc=<span class="string">&quot;center left&quot;</span>, bbox_to_anchor=[<span class="number">1</span>, <span class="number">0.5</span>], frameon=<span class="literal">False</span>)</span><br><span class="line">    axs[<span class="number">1</span>].set_ylabel(<span class="string">&quot; \n&quot;</span>)                    <span class="comment"># gridspec_kw를 사용하지 않고 Axes 간격 띄우기</span></span><br><span class="line">    </span><br><span class="line">fig.savefig(<span class="string">&quot;103_snsreglmplot_05.png&quot;</span>)    </span><br></pre></td></tr></table></figure><p><img src="103_snsreglmplot_05.png"><br></p></li><li><p>전체와 부분의 경향이 다른 것을 <b><a href="https://www.britannica.com/topic/Simpsons-paradox">심슨의 역설(Simpson’s paradox)</a></b>이라 합니다.</p></li><li><p>펭귄 데이터셋 중 부리 길이(bill_length_mm)와 부리 폭(bill_depth_mm)에서 심슨의 역설이 관찰되었습니다.</p></li><li><p>생각보다 매우 흔한 일이지만 분석의 결론을 완전히 바꾸는 일입니다. </p></li><li><p>데이터를 분석할 때 분할(segmentation)에 주의를 기울여야 하는 이유입니다.</p></li></ul><ul><li><code>sns.regplot()</code>에는 <code>hue</code> 기능이 없어서 for loop을 불편하게 돌려야만 했습니다.</li><li>그러나 우리의 seaborn은 같은 기능을 하는 다른 함수로 <code>hue</code>를 제공합니다. </li><li><code>sns.lmplot()</code>이라는 이름입니다.</li></ul><h1 id="2-seaborn-lmplot"><a href="#2-seaborn-lmplot" class="headerlink" title="2. seaborn lmplot"></a>2. seaborn lmplot</h1><blockquote><p><a href="https://seaborn.pydata.org/generated/seaborn.lmplot.html">seaborn lmplot</a></p></blockquote><h2 id="2-1-sns-lmplot"><a href="#2-1-sns-lmplot" class="headerlink" title="2.1. sns.lmplot()"></a>2.1. <code>sns.lmplot()</code></h2><ul><li><p>seaborn lmplot은 본질적으로 regplot과 동일합니다. 내부에서 <code>sns.regplot()</code>을 호출하기 때문입니다.</p></li><li><p>그러나 <b><code>sns.regplot()</code>이 Axes-level function인 반면 <code>sns.lmplot()</code>은 Figure-level function</b>이라는 가장 큰 차이가 있습니다.</p></li><li><p>간단하게 그려서 확인해 보겠습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g = sns.lmplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, hue=<span class="string">&quot;species&quot;</span>, </span><br><span class="line">               height=<span class="number">5</span>, aspect=<span class="number">1</span>,</span><br><span class="line">               scatter_kws=&#123;<span class="string">&quot;s&quot;</span>:<span class="number">50</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>&#125;)</span><br><span class="line"></span><br><span class="line">fig = g.fig</span><br><span class="line">fig.savefig(<span class="string">&quot;103_snsreglmplot_06.png&quot;</span>)    </span><br></pre></td></tr></table></figure><p><img src="103_snsreglmplot_06.png"><br></p></li><li><p><code>sns.regplot</code>과 문법이 동일하면서도 <code>hue</code>가 적용된 plot이 한 줄로 그려졌습니다.</p></li><li><p>그러나 이 명령을 이용해 심슨의 역설을 그리려다가는 이런 일이 벌어집니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Axes 두 개 생성</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>, </span><br><span class="line">                        sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 전체 시각화</span></span><br><span class="line">sns.regplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, ax=axs[<span class="number">0</span>], color=<span class="string">&quot;k&quot;</span>,</span><br><span class="line">            scatter_kws=&#123;<span class="string">&quot;fc&quot;</span>:<span class="string">&quot;lightgray&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;s&quot;</span>:<span class="number">50</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sns.lmplot() 실행</span></span><br><span class="line">sns.lmplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, hue=<span class="string">&quot;species&quot;</span>,            </span><br><span class="line">           scatter_kws=&#123;<span class="string">&quot;s&quot;</span>:<span class="number">50</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>&#125;)</span><br></pre></td></tr></table></figure><p><img src="103_snsreglmplot_07.png"><br></p></li><li><p><code>sns.lmplot()</code>의 결과물이 미리 만들어 둔 Axes에 들어가지 않습니다.</p></li><li><p>이는 <code>sns.lmplot()</code>이 Figure-level function으로, Figure보다 상위에 있는 Grid라는 객체를 생성하기 때문입니다.</p></li><li><p>그렇기 때문에, 파일을 저장하기 위해서 figure 객체에 <code>g.fig</code>로 접근하는 과정이 필요합니다.</p></li></ul><h2 id="2-2-col-amp-row"><a href="#2-2-col-amp-row" class="headerlink" title="2.2. col &amp; row"></a>2.2. <code>col</code> &amp; <code>row</code></h2><ul><li><b>Figure-level function의 장점</b>은 따로 있습니다.</li><li><b>categorical feature의 class를 FacetGrid로 쉽게 구현할 수 있다는 것</b>입니다.</li><li><code>col</code>과 <code>row</code>에 열과 행을 나눌 categorical feature 이름을 입력합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g = sns.lmplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, </span><br><span class="line">           col=<span class="string">&quot;species&quot;</span>, row=<span class="string">&quot;sex&quot;</span>,                          <span class="comment"># species와 sex로 데이터 분할</span></span><br><span class="line">           truncate=<span class="literal">False</span>, scatter_kws=&#123;<span class="string">&quot;s&quot;</span>:<span class="number">50</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>&#125;) <span class="comment"># sns.regplot() 사용 매개변수 적용</span></span><br><span class="line"></span><br><span class="line">fig = g.fig</span><br><span class="line">fig.savefig(<span class="string">&quot;103_snsreglmplot_08.png&quot;</span>)    </span><br></pre></td></tr></table></figure><img src="103_snsreglmplot_08.png"><br></li></ul><ul><li>데이터가 sex와 species에 따라 나뉘어 그려졌습니다.</li></ul><h2 id="2-3-Figure-level-function-Axes-level-function"><a href="#2-3-Figure-level-function-Axes-level-function" class="headerlink" title="2.3. Figure-level function + Axes-level function"></a>2.3. Figure-level function + Axes-level function</h2><ul><li>Figure-level function의 결과물은 Axes에 들어갈 수 없지만,</li><li>Axes-level function의 결과물은 Figure-level function의 결과물에 들어갈 수 있습니다.</li><li><code>sns.lmplot()</code>으로 만들어진 FacetGrid에서 Axes를 추출해 <code>sns.regplot()</code>을 적용합니다.</li><li><code>sns.regplot()</code>으로 전체 데이터 범위를, <code>sns.lmplot()</code>으로 개별 데이터를 표현하는 식입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">g = sns.lmplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>,       <span class="comment"># sns.lmplot 생성 FacetGrid 출력</span></span><br><span class="line">               data=df_peng, </span><br><span class="line">               col=<span class="string">&quot;species&quot;</span>, row=<span class="string">&quot;sex&quot;</span>,                    <span class="comment"># species와 sex로 데이터 분할</span></span><br><span class="line">               scatter_kws=&#123;<span class="string">&quot;s&quot;</span>:<span class="number">50</span>&#125;)</span><br><span class="line">  </span><br><span class="line">axes = g.axes               <span class="comment"># FacetGrid에서 Axes 추출</span></span><br><span class="line"><span class="keyword">for</span> ax <span class="keyword">in</span> axes.ravel():     <span class="comment"># Axes 순회, 전체 데이터를 배경으로 표현</span></span><br><span class="line">    sns.regplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, </span><br><span class="line">                fit_reg=<span class="literal">False</span>, </span><br><span class="line">                scatter_kws=&#123;<span class="string">&quot;fc&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;none&quot;</span>, <span class="string">&quot;s&quot;</span>:<span class="number">50</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.3</span>&#125;, ax=ax)</span><br><span class="line"></span><br><span class="line">fig = g.fig</span><br><span class="line">fig.tight_layout()</span><br><span class="line">fig.savefig(<span class="string">&quot;103_snsreglmplot_09.png&quot;</span>)    </span><br></pre></td></tr></table></figure><img src="103_snsreglmplot_09.png"><br></li></ul><h2 id="2-4-sns-lmplot-결과마다-다른-색"><a href="#2-4-sns-lmplot-결과마다-다른-색" class="headerlink" title="2.4. sns.lmplot()결과마다 다른 색"></a>2.4. <code>sns.lmplot()</code>결과마다 다른 색</h2><ul><li><p><code>sns.lmplot()</code>에는 hue로 나뉘는 데이터에 적용하기 위한 <code>palette</code>매개변수가 있습니다.</p></li><li><p>그러나 Facet별로 다르게 들어간 데이터에는 <code>palette</code>매개변수가 적용되지 않습니다.</p></li><li><p><code>color</code>매개변수도 존재하지 않기 때문에, 개별 객체를 접근해야 합니다.</p></li><li><p>matplotlib 기능을 이용해 hue, lightness, saturation을 조정하는 <code>modify_hls()</code> 함수를 먼저 만듭니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.colors <span class="keyword">as</span> mcolors</span><br><span class="line"><span class="keyword">import</span> colorsys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify_hls</span>(<span class="params">c, dh=<span class="number">0</span>, dl=<span class="number">0</span>, ds=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(c, <span class="built_in">str</span>):</span><br><span class="line">        c = mcolors.to_rgb(c)</span><br><span class="line">    </span><br><span class="line">    h, l, s = colorsys.rgb_to_hls(*c)</span><br><span class="line">    h = h + dh</span><br><span class="line">    l = <span class="built_in">max</span>(<span class="built_in">min</span>(l + dl, <span class="number">1</span>), <span class="number">0</span>)</span><br><span class="line">    s = <span class="built_in">max</span>(<span class="built_in">min</span>(s + ds, <span class="number">1</span>), <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> colorsys.hls_to_rgb(h, l, s)</span><br></pre></td></tr></table></figure></li><li><p>위 Axes 순회 코드에 Axes마다 다른 facecolor와 edgecolor를 적용하는 코드를 추가합니다.</p></li><li><p>species에 따라서는 CN을 적용하고 (C0, C1, C2)</p></li><li><p>sex에 따라서는 hue를 5% 옮긴 색을 입힙니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">g = sns.lmplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>,       <span class="comment"># sns.lmplot 생성 FacetGrid 출력</span></span><br><span class="line">               data=df_peng, </span><br><span class="line">               col=<span class="string">&quot;species&quot;</span>, row=<span class="string">&quot;sex&quot;</span>,                    <span class="comment"># species와 sex로 데이터 분할</span></span><br><span class="line">               scatter_kws=&#123;<span class="string">&quot;s&quot;</span>:<span class="number">50</span>&#125;)</span><br><span class="line"></span><br><span class="line">axes = g.axes               <span class="comment"># FacetGrid에서 Axes 추출</span></span><br><span class="line"><span class="keyword">for</span> i, ax <span class="keyword">in</span> <span class="built_in">enumerate</span>(axes.ravel()):     <span class="comment"># Axes 순회, 전체 데이터를 배경으로 표현</span></span><br><span class="line">    scatter, reg, cb = ax.get_children()[:<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">2</span>:</span><br><span class="line">        i -= <span class="number">3</span></span><br><span class="line">        dh = -<span class="number">0.05</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dh = <span class="number">0</span></span><br><span class="line">    scatter.<span class="built_in">set</span>(fc=modify_hls(<span class="string">f&quot;C<span class="subst">&#123;i&#125;</span>&quot;</span>, dl=<span class="number">0.3</span>, dh=dh), ec=modify_hls(<span class="string">f&quot;C<span class="subst">&#123;i&#125;</span>&quot;</span>, dh=dh), alpha=<span class="number">1</span>)</span><br><span class="line">    reg.set_color(modify_hls(<span class="string">f&quot;C<span class="subst">&#123;i&#125;</span>&quot;</span>, dh=dh))</span><br><span class="line">    cb.<span class="built_in">set</span>(fc=modify_hls(<span class="string">f&quot;C<span class="subst">&#123;i&#125;</span>&quot;</span>, dl=<span class="number">0.3</span>, dh=dh), ec=modify_hls(<span class="string">f&quot;C<span class="subst">&#123;i&#125;</span>&quot;</span>, dh=dh))</span><br><span class="line">    sns.regplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, </span><br><span class="line">                fit_reg=<span class="literal">False</span>, </span><br><span class="line">                scatter_kws=&#123;<span class="string">&quot;fc&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;none&quot;</span>, <span class="string">&quot;s&quot;</span>:<span class="number">50</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.3</span>&#125;, ax=ax)</span><br><span class="line">    title = ax.get_title()</span><br><span class="line">    ax.set_title(title, color=modify_hls(<span class="string">f&quot;C<span class="subst">&#123;i&#125;</span>&quot;</span>, dh=dh))</span><br><span class="line">    </span><br><span class="line">fig = g.fig</span><br><span class="line">fig.tight_layout()</span><br><span class="line">fig.savefig(<span class="string">&quot;103_snsreglmplot_10.png&quot;</span>)    </span><br></pre></td></tr></table></figure><p><img src="103_snsreglmplot_10.png"><br></p></li></ul><h1 id="3-결론"><a href="#3-결론" class="headerlink" title="3. 결론"></a>3. 결론</h1><ul><li>seaborn의 Figure-level function은 매우 유용하지만 Grid를 출력하는 속성은 종종 간과됩니다.</li><li>seaborn을 사용할 때 발생하는 에러의 대부분이 바로 이 Grid입니다.</li><li>그리고 이 Grid가 Axes-level과 Figure-level을 결정짓는 가장 큰 차이입니다.</li><li>seaborn을 잘 사용하고자 한다면 주의깊게 살펴볼 필요가 있습니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/regplot/">regplot</category>
      
      <category domain="https://jehyunlee.github.io/tags/lmplot/">lmplot</category>
      
      
    </item>
    
    <item>
      <title>short discussions on KDE plot</title>
      <link>https://jehyunlee.github.io/2022/05/27/Python-DS-102-kdeplot/</link>
      <guid>https://jehyunlee.github.io/2022/05/27/Python-DS-102-kdeplot/</guid>
      <pubDate>Thu, 26 May 2022 23:51:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;경향신문과 언더스코어가 공동으로 조사한 ‘부모찬스’기사가 실렸습니다.&lt;/li&gt;
&lt;li&gt;기사 내용과 별개로, 이 기사에 활용된 KDE plot에 대해 여러 분들이 여러 의견을 표했습니다.&lt;/li&gt;
&lt;li&gt;KDE plot의 특징과 한계를 </description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>경향신문과 언더스코어가 공동으로 조사한 ‘부모찬스’기사가 실렸습니다.</li><li>기사 내용과 별개로, 이 기사에 활용된 KDE plot에 대해 여러 분들이 여러 의견을 표했습니다.</li><li>KDE plot의 특징과 한계를 살펴봅니다.</li></ul><blockquote><p><a href="http://underscore.kr/">언더스코어</a><br><a href="https://www.khan.co.kr/national/national-general/article/202205250600005">경향신문: 두 얼굴의 공정(1) 조국과 정호영, 누가 더 ‘불공정’합니까?</a><br><a href="https://youtu.be/5DzcKpgUva4">경향신문: 정치 성향에 따라 부모찬스에 들이댄 ‘공정 잣대’는 달랐다</a></p></blockquote><h1 id="1-시작"><a href="#1-시작" class="headerlink" title="1. 시작"></a>1. 시작</h1><ul><li>현대 대한민국의 가장 큰 화두 중 하나는 <b>공정</b>입니다.</li><li>기회의 공정, 결과의 공정, 또는 떨어질 때 떨어지더라도 이유라도 알자는 의미의 공정.</li><li>여러 면에서 여러 의미로 공정이 오르내리고 있으며 그 중 하나는 <b>부모찬스</b>입니다.</li><li><a href="https://www.khan.co.kr/national/national-general/article/202205250600005">경향신문</a>과 <a href="http://underscore.kr/">언더스코어</a>에서 의미있는 분석을 시도하고 있습니다.<br><br><img src="102_kdeplot_06.png"><br></li></ul><h1 id="2-KDE-plot"><a href="#2-KDE-plot" class="headerlink" title="2. KDE plot"></a>2. KDE plot</h1><blockquote><p><a href="https://en.wikipedia.org/wiki/Kernel_density_estimation">Kernel Density Estimation</a></p></blockquote><ul><li>설문 결과 분포를 표현하기 위해 기사에 사용된 이와 같은 시각화 기법을 <b>KDE plot</b>이라고 합니다.</li><li><b>Kernel Density Plot</b>의 약자이며, 히스토그램의 단점을 보완하기 위해 제안된 방식입니다.</li><li>히스토그램이 구간별 데이터 수를 bar plot으로 표현하는 방식이라면 KDE plot은 각 데이터로 밀도 분포를 추정하여 합산하는 방식입니다.<br><br><img src="102_kdeplot_07.png" alt="wikipedia, Kernel density estimation"><br></li></ul><h1 id="3-seaborn-histogram-vs-kdeplot"><a href="#3-seaborn-histogram-vs-kdeplot" class="headerlink" title="3. seaborn histogram vs kdeplot"></a>3. seaborn histogram vs kdeplot</h1><blockquote><p><a href="https://jehyunlee.github.io/2020/09/07/Python-DS-30-mpl_dists/">Pega Devlog: Ridgeline Plot</a><br><a href="https://seaborn.pydata.org/generated/seaborn.kdeplot.html">seaborn: kdeplot</a><br><a href="https://seaborn.pydata.org/generated/seaborn.histplot.html">seaborn: histplot</a></p></blockquote><ul><li><a href="https://jehyunlee.github.io/2020/09/07/Python-DS-30-mpl_dists/">Matplotlib과 scipy를 함께 사용해서 구현할 수도 있으나</a> </li><li><a href="https://seaborn.pydata.org/generated/seaborn.kdeplot.html">seaborn을 사용하면 간편하게 표현할 수 있습니다.</a></li><li>코드로 직접 seaborn histogram과 함께 비교해봅니다.<br></li></ul><h2 id="3-1-예제-데이터"><a href="#3-1-예제-데이터" class="headerlink" title="3.1. 예제 데이터"></a>3.1. 예제 데이터</h2><ul><li>seaborn에서 제공하는 Penguins dataset을 사용합니다.</li><li>펭귄들의 체중 데이터를 그림으로 그려보겠습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">sns.set_style(<span class="string">&quot;ticks&quot;</span>)</span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line">sns.set_palette(<span class="string">&quot;colorblind&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># penguins dataset 불러오기</span></span><br><span class="line">df_peng = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)</span><br><span class="line">df_peng.head(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><img src="102_kdeplot_08.png"></li></ul><h2 id="3-2-histogram-vs-KDE-plot"><a href="#3-2-histogram-vs-KDE-plot" class="headerlink" title="3.2. histogram vs KDE plot"></a>3.2. histogram vs KDE plot</h2><ul><li><p>histogram과 KDE plot을 차례로 그려 비교합니다.</p></li><li><p>histogram은 구간(bins) 수에 따라 모양이 변합니다.</p></li><li><p>이 글은 KDE plot의 특징에 집중하기 위해 코드 설명은 생략합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Circle</span><br><span class="line"></span><br><span class="line">vmin, vmax = df_peng[<span class="string">&quot;body_mass_g&quot;</span>].<span class="built_in">min</span>(), df_peng[<span class="string">&quot;body_mass_g&quot;</span>].<span class="built_in">max</span>() </span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">10</span>, <span class="number">3.5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, ax <span class="keyword">in</span> <span class="built_in">enumerate</span>(axs, <span class="number">1</span>):</span><br><span class="line">    sns.histplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, bins=<span class="number">10</span>*i, ax=ax)</span><br><span class="line">    ax.set_title(<span class="string">f&quot;bins=<span class="subst">&#123;<span class="number">10</span>*i&#125;</span>&quot;</span>, pad=<span class="number">12</span>, color=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    ymin, ymax = ax.get_ylim()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># changes</span></span><br><span class="line">    circle0 = Circle((<span class="number">0.5</span>, <span class="number">0.5</span>), <span class="number">0.17</span>, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;r&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>, transform=ax.transAxes)</span><br><span class="line">    circle1 = Circle((<span class="number">0.8</span>, <span class="number">0.27</span>), <span class="number">0.17</span>, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;r&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>, transform=ax.transAxes)</span><br><span class="line">    ax.add_patch(circle0)</span><br><span class="line">    ax.add_patch(circle1)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># data min, max</span></span><br><span class="line">    ax.axvline(vmin, c=<span class="string">&quot;orange&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">    ax.axvline(vmax, c=<span class="string">&quot;orange&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p><img src="102_kdeplot_01.png"><br></p></li><li><p>같은 데이터를 10, 20, 30개의 구간을 가진 histogram으로 표현했습니다.</p></li><li><p>bins 수가 늘어날 수록 보이지 않던 봉우리들이 보입니다. (붉은 원)</p></li><li><p>그런데 한편으로 bins 수를 데이터 수만큼 늘리는 경우를 생각하면, 그림이 별 의미가 없어질 것입니다.</p></li><li><p><b>y축 범위</b>에서 bins가 증가할수록 최대 count가 적어지는 것을 볼 수 있습니다.</p></li><li><p>바구니의 범위가 좁아지니 데이터가 덜 담기는 것이 당연합니다.</p></li></ul><ul><li><p>같은 데이터를 KDE plot으로 그립니다.</p></li><li><p><code>seaborn.kdeplot</code>에서는 Kernel size를 bw_adjust라는 매개변수로 조절할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">10</span>, <span class="number">3.5</span>), constrained_layout=<span class="literal">True</span>, </span><br><span class="line">                        sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, ax <span class="keyword">in</span> <span class="built_in">enumerate</span>(axs, <span class="number">1</span>):</span><br><span class="line">    sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, bw_adjust=i**<span class="number">2</span>/<span class="number">4</span>, fill=<span class="literal">True</span>, ax=ax)</span><br><span class="line">    ax.set_title(<span class="string">f&quot;bw_adjust=<span class="subst">&#123;i**<span class="number">2</span>/<span class="number">4</span>:<span class="number">.3</span>f&#125;</span>&quot;</span>, pad=<span class="number">12</span>, color=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    ymin, ymax = ax.get_ylim()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># changes</span></span><br><span class="line">    circle0 = Circle((<span class="number">0.5</span>, <span class="number">0.5</span>), <span class="number">0.1</span>, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;r&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>, transform=ax.transAxes)</span><br><span class="line">    circle1 = Circle((<span class="number">0.62</span>, <span class="number">0.3</span>), <span class="number">0.1</span>, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;r&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>, transform=ax.transAxes)</span><br><span class="line">    ax.add_patch(circle0)</span><br><span class="line">    ax.add_patch(circle1)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># data min, max</span></span><br><span class="line">    ax.axvline(vmin, c=<span class="string">&quot;orange&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">    ax.axvline(vmax, c=<span class="string">&quot;orange&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p><img src="102_kdeplot_02.png"><br></p></li><li><p><code>sharex=True</code>와 <code>sharey=True</code>로 그래프의 x와 y 범위를 통일시켰습니다.</p></li><li><p>bw_adjust가 커질수록 아이스크림이 녹듯 높이가 낮아지고 옆으로 퍼지는 모습이 보입니다.</p></li><li><p>붉은 원으로 표시한 <b>디테일도 점점 사라집니다.</b></p></li><li><p>또한, 오렌지색 선으로 표시한 데이터의 하한선과 상한선을 점점 더 많이 넘어가고 있습니다.</p></li></ul><ul><li><b>데이터 범위를 넘어선다</b>는 것이 KDE plot의 가장 큰 특징입니다.</li><li><b>제한된 데이터로 수집되지 않은 범위까지 추정을 해줄 수 있는 장점</b>으로 작용함과 동시에</li><li><b>존재할 수 없는 데이터를 생성하는 단점</b>으로 작용합니다. (ex. 나이 분포를 그리면 0보다 작은 범위가 생깁니다)</li><li><b>처음에 인용한 기사에서도 1~5점으로 조사했지만 1점이 안 되는 데이터와 5점이 넘는 데이터가 추정되었습니다.</b></li></ul><h2 id="3-3-KDE-plot-기본"><a href="#3-3-KDE-plot-기본" class="headerlink" title="3.3. KDE plot 기본"></a>3.3. KDE plot 기본</h2><ul><li>KDE plot의 특징을 조금 더 알아보겠습니다. </li><li>먼저, <b>밀도 분포</b>라는 개념을 사용하기 때문에 <b>전체 넓이는 1로 조정됩니다.</b><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, ax <span class="keyword">in</span> <span class="built_in">enumerate</span>(axs):</span><br><span class="line">    area = Polygon(axs[<span class="number">0</span>].collections[<span class="number">0</span>].get_paths()[<span class="number">0</span>].vertices).area</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;# area of KDE plot at axs[<span class="subst">&#123;i&#125;</span>] = <span class="subst">&#123;area:<span class="number">.3</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># area of KDE plot at axs[0]= 1.000</span></span><br><span class="line"><span class="comment"># area of KDE plot at axs[1]= 1.000</span></span><br><span class="line"><span class="comment"># area of KDE plot at axs[2]= 1.000</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>seaborn KDE plot 기능을 조금 더 알아봅니다.</p></li><li><p>펭귄 데이터셋에는 Adelie, Chinstrap, Gentoo 펭귄이 있습니다.</p></li><li><p>전체와 함께 이들 각각의 분포를 함께 살펴봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, fill=<span class="literal">True</span>, ax=ax, ec=<span class="string">&quot;gray&quot;</span>, fc=<span class="string">&quot;w&quot;</span>)</span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, fill=<span class="literal">True</span>, hue=<span class="string">&quot;species&quot;</span>, ax=ax)</span><br><span class="line"></span><br><span class="line">xmin, xmax = ax.get_xlim()</span><br><span class="line"></span><br><span class="line"><span class="comment"># legend</span></span><br><span class="line">handles = ax.get_children()[:<span class="number">4</span>]</span><br><span class="line">labels = [<span class="string">&quot;all species&quot;</span>, <span class="string">&quot;Adelie&quot;</span>, <span class="string">&quot;Chinstrap&quot;</span>, <span class="string">&quot;Gentoo&quot;</span>]</span><br><span class="line">ax.legend(handles=handles, labels=labels)</span><br></pre></td></tr></table></figure><p><img src="102_kdeplot_03.png"><br></p></li><li><p>세 종이 다른 분포를 보이며 겹쳐 그려져 있습니다.</p></li><li><p><b>Adelie 펭귄의 분포 일부가 전체의 합보다 높게 그려져 있습니다.</b></p></li><li><p>여기에서도 <b>KDE plot이 정량적으로 부정확할 수 있음을 알 수 있습니다.</b></p></li><li><p>이렇게 나누어 그리면 각각의 넓이가 데이터 비율만큼 표현됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">areas = []</span><br><span class="line"><span class="keyword">for</span> i, (p, label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(ax.get_children()[:<span class="number">4</span>], labels)):</span><br><span class="line">    area = Polygon(p.get_paths()[<span class="number">0</span>].vertices).area</span><br><span class="line">    areas.append(area)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;# area of KDE plot: <span class="subst">&#123;label&#125;</span> = <span class="subst">&#123;area:<span class="number">.3</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># area of KDE plot: all species = 1.000</span></span><br><span class="line"><span class="comment"># area of KDE plot: Adelie = 0.360</span></span><br><span class="line"><span class="comment"># area of KDE plot: Chinstrap = 0.199</span></span><br><span class="line"><span class="comment"># area of KDE plot: Gentoo = 0.441</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-4-데이터-범위-밖-잘라내기"><a href="#3-4-데이터-범위-밖-잘라내기" class="headerlink" title="3.4. 데이터 범위 밖 잘라내기"></a>3.4. 데이터 범위 밖 잘라내기</h2><ul><li>데이터 범위를 벗어나 그려지는 문제를 해결하기 위한 방법으로 <code>cut</code> 매개변수를 제시하고 있습니다.</li><li>smoothing bandwidth에 곱해지는 상수로 기본값은 3입니다.</li><li>크기를 줄이면 적어지는데, <code>cut=0</code>을 입력하면 입력된 데이터 범위까지만 끊습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, fill=<span class="literal">True</span>, ax=ax, ec=<span class="string">&quot;gray&quot;</span>, fc=<span class="string">&quot;w&quot;</span>, cut=<span class="number">0</span>)</span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, fill=<span class="literal">True</span>, hue=<span class="string">&quot;species&quot;</span>, ax=ax, cut=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlim(xmin, xmax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># legend</span></span><br><span class="line">handles = ax.get_children()[:<span class="number">4</span>]</span><br><span class="line">labels = [<span class="string">&quot;all species&quot;</span>, <span class="string">&quot;Adelie&quot;</span>, <span class="string">&quot;Chinstrap&quot;</span>, <span class="string">&quot;Gentoo&quot;</span>]</span><br><span class="line">ax.legend(handles=handles, labels=labels)</span><br></pre></td></tr></table></figure><img src="102_kdeplot_04.png"><br></li></ul><h2 id="3-5-가능한-데이터-범위-밖-잘라내기"><a href="#3-5-가능한-데이터-범위-밖-잘라내기" class="headerlink" title="3.5. 가능한 데이터 범위 밖 잘라내기"></a>3.5. 가능한 데이터 범위 밖 잘라내기</h2><ul><li>수집된 데이터가 가능한 데이터의 일부인 경우가 많습니다.</li><li>이 때 데이터 값으로 끊으면 이 또한 왜곡이 될 수 있기 때문에, 특정 범위를 지정할 수 있습니다.</li><li><code>clip</code>이라는 이름의 매개변수를 사용합니다. 여기서는 <b>2500 ~ 6500 범위</b>로 잘랐습니다. </li><li><code>cut</code>에 비해 덜 잘렸고, 이 범위 안에 있는 Chinstrap과 Gentoo의 오른쪽, 그리고 Adelie의 왼쪽은 전혀 잘리지 않았습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, fill=<span class="literal">True</span>, ax=ax, ec=<span class="string">&quot;gray&quot;</span>, fc=<span class="string">&quot;w&quot;</span>, clip=(<span class="number">2500</span>, <span class="number">6500</span>))</span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, fill=<span class="literal">True</span>, hue=<span class="string">&quot;species&quot;</span>, ax=ax, clip=(<span class="number">2500</span>, <span class="number">6500</span>))</span><br><span class="line"></span><br><span class="line">ax.set_xlim(xmin, xmax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># legend</span></span><br><span class="line">handles = ax.get_children()[:<span class="number">4</span>]</span><br><span class="line">labels = [<span class="string">&quot;all species&quot;</span>, <span class="string">&quot;Adelie&quot;</span>, <span class="string">&quot;Chinstrap&quot;</span>, <span class="string">&quot;Gentoo&quot;</span>]</span><br><span class="line">ax.legend(handles=handles, labels=labels)</span><br></pre></td></tr></table></figure><img src="102_kdeplot_09.png"><br></li></ul><h2 id="3-6-자른-이후의-넓이-확인"><a href="#3-6-자른-이후의-넓이-확인" class="headerlink" title="3.6. 자른 이후의 넓이 확인"></a>3.6. 자른 이후의 넓이 확인</h2><ul><li><p>KDE plot은 밀도 함수이기 때문에 넓이 = 1로 설정된다고 했습니다.</p></li><li><p>그렇지만 <code>cut</code>이나 <code>clip</code>을 적용하면 잘리는 만큼 넓이가 작아집니다.</p></li><li><p><code>cut</code> 적용 전과 뒤를 겹쳐서 확인합니다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># without cut=0</span></span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, fill=<span class="literal">True</span>, ax=ax, ec=<span class="string">&quot;gray&quot;</span>, fc=<span class="string">&quot;w&quot;</span>)</span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, fill=<span class="literal">True</span>, hue=<span class="string">&quot;species&quot;</span>, ax=ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># with cut=0</span></span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, fill=<span class="literal">True</span>, ax=ax, lw=<span class="number">3</span>, ec=<span class="string">&quot;k&quot;</span>, fc=<span class="string">&quot;#FFFFFF00&quot;</span>, cut=<span class="number">0</span>)</span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, fill=<span class="literal">True</span>, hue=<span class="string">&quot;species&quot;</span>, ax=ax, </span><br><span class="line">            cut=<span class="number">0</span>, lw=<span class="number">3</span>, palette=[<span class="string">&quot;b&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;g&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># legend</span></span><br><span class="line">handles = ax.get_children()[:<span class="number">4</span>]</span><br><span class="line">labels = [<span class="string">&quot;all species&quot;</span>, <span class="string">&quot;Adelie&quot;</span>, <span class="string">&quot;Chinstrap&quot;</span>, <span class="string">&quot;Gentoo&quot;</span>]</span><br><span class="line">ax.legend(handles=handles, labels=labels)</span><br></pre></td></tr></table></figure><p><img src="102_kdeplot_05.png"><br></p></li><li><p><code>cut</code>이 적용된 그림은 그저 좌우가 잘릴 뿐임을 알 수 있습니다.</p></li><li><p>그렇다면 넓이도 줄어들 것입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, (p, label, a) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(ax.get_children()[<span class="number">4</span>:<span class="number">8</span>], labels, areas)):</span><br><span class="line">    area = Polygon(p.get_paths()[<span class="number">0</span>].vertices).area</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;# area of KDE plot: <span class="subst">&#123;label&#125;</span> = <span class="subst">&#123;area:<span class="number">.3</span>f&#125;</span> (cf. <span class="subst">&#123;a:<span class="number">.3</span>f&#125;</span>)&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># area of KDE plot: all species = 0.986 (cf. 1.000)</span></span><br><span class="line"><span class="comment"># area of KDE plot: Adelie = 0.353 (cf. 0.360)</span></span><br><span class="line"><span class="comment"># area of KDE plot: Chinstrap = 0.195 (cf. 0.199)</span></span><br><span class="line"><span class="comment"># area of KDE plot: Gentoo = 0.423 (cf. 0.441)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>잘려지는 넓이가 보상되지 않고 있습니다.</p></li><li><p>데이터에 따라, 그리고 수집하는 숫자의 범위에 따라 얼마가 잘려질지는 알 수 없습니다.</p></li><li><p>기사에 나온 그림처럼 분포가 한쪽 끝에 치우쳐 있다면 훨씬 많이 잘려나갈 것입니다.</p></li><li><p>보완 알고리즘을 구현하려 해도 생각보다 복잡합니다. 단순하게 비율을 곱하는 것으로는 부족합니다.</p></li></ul><h1 id="4-결론"><a href="#4-결론" class="headerlink" title="4. 결론"></a>4. 결론</h1><ul><li>KDE plot은 매끈한 곡선으로 이루어져 보기 좋고 겹쳐 그리기 좋아 많이 사용됩니다.</li><li>그러나 확인했듯 단점이 적지 않습니다.</li><li>KDE plot은 참고용으로만 사용하고, 실제 결론은 통계적 분석으로 냅시다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/kdeplot/">kdeplot</category>
      
      
    </item>
    
    <item>
      <title>머신 러닝 파이프라인</title>
      <link>https://jehyunlee.github.io/2022/05/24/Python-DS-101-kierlecture2/</link>
      <guid>https://jehyunlee.github.io/2022/05/24/Python-DS-101-kierlecture2/</guid>
      <pubDate>Tue, 24 May 2022 09:20:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;한국에너지기술연구원 AI 학습조직&lt;/b&gt;에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.&lt;ul&gt;
&lt;li&gt;scikit-learn 기능 중 데이터 전처리와 머신 러닝을 안정적으로 수행할 수 있는 파이프라인을 소개합니다.&lt;/l</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b>한국에너지기술연구원 AI 학습조직</b>에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.<ul><li>scikit-learn 기능 중 데이터 전처리와 머신 러닝을 안정적으로 수행할 수 있는 파이프라인을 소개합니다.</li><li>one-hot encoding과 standard scaling도 그냥 하면 안 됩니다. </li><li>train set으로 학습해서 test set에 적용해야 합니다.</li><li>feature importance는 permutation importance로 확인합시다.</li><li><a href="220524_%EC%9D%B4%EC%A0%9C%ED%98%84_KIERML_2201_pipeline.pdf">강의 자료는 여기에서 다운받으실 수 있습니다</a></li></ul></li></ul><ul><li><p>발표 영상 : (<a href="https://youtu.be/xcSaOtM2PeY">Youtube Link</a>)<br></p></li><li><p>실습 코드 : (<a href="https://bit.ly/3MOtZr6">https://bit.ly/3MOtZr6</a>)<br></p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/xcSaOtM2PeY" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p>* 바쁜 연구원 일정 속에 변동이 있겠지만, 최대한 일정을 지켜보고자 합니다.<p><img src="thumbnail_012.PNG" alt="학습조직 일정"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/pipeline/">pipeline</category>
      
      <category domain="https://jehyunlee.github.io/tags/machine-learning/">machine learning</category>
      
      <category domain="https://jehyunlee.github.io/tags/KIER/">KIER</category>
      
      
    </item>
    
    <item>
      <title>머신 러닝 기본 개념</title>
      <link>https://jehyunlee.github.io/2022/04/26/Python-DS-100-kierlecture1/</link>
      <guid>https://jehyunlee.github.io/2022/04/26/Python-DS-100-kierlecture1/</guid>
      <pubDate>Tue, 26 Apr 2022 12:13:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;한국에너지기술연구원 AI 학습조직&lt;/b&gt;에서는 2022년 한 해동안 머신러닝 진도를 나가기로 했습니다.&lt;ul&gt;
&lt;li&gt;scikit-learn을 중심으로 머신러닝 실습을 할 예정입니다.&lt;/li&gt;
&lt;li&gt;코드를 만지기 전 기본 개념을</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b>한국에너지기술연구원 AI 학습조직</b>에서는 2022년 한 해동안 머신러닝 진도를 나가기로 했습니다.<ul><li>scikit-learn을 중심으로 머신러닝 실습을 할 예정입니다.</li><li>코드를 만지기 전 기본 개념을 전달드리는 강의를 진행했습니다.</li><li><a href="220426_%EC%9D%B4%EC%A0%9C%ED%98%84_%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90_blog.pdf">강의 자료는 여기에서 다운받으실 수 있습니다</a></li></ul></li></ul><ul><li>발표 영상입니다 (<a href="https://youtu.be/Q4ue1G9G4kw">Youtube Link</a>)<br></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/Q4ue1G9G4kw" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <ul><li>바쁜 연구원 일정 속에 변동이 있겠지만, 최대한 일정을 지켜보고자 합니다.</li></ul><p><img src="thumbnail_012.PNG" alt="학습조직 일정"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/machine-learning/">machine learning</category>
      
      <category domain="https://jehyunlee.github.io/tags/KIER/">KIER</category>
      
      
    </item>
    
    <item>
      <title>reliability of Covid-19 self test kit</title>
      <link>https://jehyunlee.github.io/2022/04/23/Python-DS-99-covidprec/</link>
      <guid>https://jehyunlee.github.io/2022/04/23/Python-DS-99-covidprec/</guid>
      <pubDate>Sat, 23 Apr 2022 12:51:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;코로나-19 자가진단키트에서 두 줄이 떴습니다.&lt;/li&gt;
&lt;li&gt;올 게 왔나 싶으면서도, 이거 얼마나 믿을만한지 몹시 궁금했습니다.&lt;/li&gt;
&lt;li&gt;선별진료소 결과를 기다리며 분류 기초를 복습합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>코로나-19 자가진단키트에서 두 줄이 떴습니다.</li><li>올 게 왔나 싶으면서도, 이거 얼마나 믿을만한지 몹시 궁금했습니다.</li><li>선별진료소 결과를 기다리며 분류 기초를 복습합니다.</li></ul><h1 id="1-사건의-발단"><a href="#1-사건의-발단" class="headerlink" title="1. 사건의 발단"></a>1. 사건의 발단</h1><blockquote><p><a href="https://blog.naver.com/kfdazzang/222640236513">식품의약품안전처: 자가진단키트 양성예측도 76%</a><br><a href="https://www.khan.co.kr/national/health-welfare/article/202202080845011">경향신문: 자가검사키트, 민감도 특이도는 뭐고 양성예측도는 또 뭔가요?</a></p></blockquote><p><img src="99_cp_02.jpg"><br></p><ul><li><b>3일 전,</b> 안녕하시냐고 묻는 안녕하지 못한 내용의 문자가 왔다.</li><li>업무 효율화 관련해서 자주 뵙던 분이 걸렸단다. 문자로 안부를 여쭈니 다행히 괜찮다고 하신다.</li><li>바닷가에서 학회 발표를 준비하다 말고 10여분 차를 달려 읍내에 갔다.</li><li>병원에서 신속항원검사 음성확인서를 받았지만 기분 탓인지 목이 아프다.<br></li></ul><p><img src="99_cp_01.PNG" alt="잘 보면 보입니다."><br></p><ul><li>그리고 오늘, <b>자가진단키트에 매우 희미하지만 두 줄이 떴다.</b></li><li>주말 저녁이라 신속항원검사를 할 동네 병원은 모두 닫았고, 시청 선별진료소에서 검사를 했다.</li><li><b>“두 줄 맞습니다. 이쪽에서 검사받으세요. 결과는 내일 아침 9시 전에 나옵니다.”</b></li></ul><ul><li><p>훨씬 정확하다는 PCR 검사가 나오겠지만 <b>자가진단키트의 신뢰도가 궁금해졌다.</b></p></li><li><p><b>민감도<code>sensitivity</code> 90%</b>, <b>특이도<code>specificity</code> 99%</b>. </p></li><li><p>그런데 <b>양성예측도<code>positive predictive value (PPV)</code> 76%</b>.</p></li><li><p>내 밥벌이이고, 비슷한 문제를 몇 번이나 손계산으로 풀었는데도 왜 이런지 헷갈린다.</p></li><li><p>그래서 얼마나 잘 맞는 거냐는 기자의 마음이 이해가 간다.<br><br><img src="99_cp_03.PNG"><br></p></li><li><p>기자는 <b>“공식은 모르겠고”</b>라고 해도 되지만 난 그러면 안 된다.</p></li><li><p>당사자가 된 이상 최선을 다해 정리해보자.</p></li><li><p>지금처럼 이 문제에 진심인 적이 없다.</p></li></ul><h1 id="2-복잡한-분류-예측"><a href="#2-복잡한-분류-예측" class="headerlink" title="2. 복잡한 분류 예측"></a>2. 복잡한 분류 예측</h1><blockquote><p><a href="https://3months.tistory.com/318">쉽게 이해하는 특이도, 민감도, 양성 예측도</a><br><a href="https://en.wikipedia.org/wiki/Sensitivity_and_specificity">wikipedia: sensitivity and specificity</a></p></blockquote><ul><li>분류 예측 문제는 모델링보다 평가가 훨씬 복잡하다.</li><li>단순히 맞다/틀리다로 끝나는게 아니기 때문이다.</li></ul><ul><li>어떤 마을 1000명 중 100명이 폐암에 걸렸고, 이들이 병원에서 진단을 받는다고 하자.</li><li>진단 기기나 의사의 판단이 100% 정확하지 않기 때문에 <b>오진이 발생한다</b>.</li><li><b>병이 없는데 환자 진단을 받기도 하고</b>, <b>환자에게 정상이라고 하기도 한다</b>.<br><br><img src="99_cp_04.PNG"><br></li></ul><h2 id="2-1-전지적-의사-시점"><a href="#2-1-전지적-의사-시점" class="headerlink" title="2.1. 전지적 의사 시점"></a>2.1. 전지적 의사 시점</h2><ul><li>여기서 <b>진단을 잘 했다</b>는 둘로 나뉜다.</li><li><b>(1) 환자를 환자라고 하는 경우 : 민감도</b> = $\dfrac{90}{90+10} = 90$%</li><li><b>(2) 비환자를 비환자라고 하는 경우 : 특이도</b> = $\dfrac{800}{800+100} = 89$%</li><li>둘 다 준수하다.</li></ul><h2 id="2-2-환자의-시점"><a href="#2-2-환자의-시점" class="headerlink" title="2.2. 환자의 시점"></a>2.2. 환자의 시점</h2><ul><li>하지만 환자의 입장은 조금 다르다. <b>본인이 받은 진단의 신뢰도</b>가 중요하다.</li><li><b>(1) 양성(암) 진단을 받은 경우 : 양성 예측도</b> = $\dfrac{90}{90+100} = 47$%</li><li><b>(2) 음성(정상) 진단을 받은 경우 : 음성 예측도</b> = $\dfrac{800}{800+10} = 99$%</li><li>음성 예측도는 매우 높지만 양성 예측도가 크게 낮다. 데이터가 1:9로 불균일하기 때문이다. </li><li><b>귀찮은 의사가 대충 음성이라고 해도 맞출 확률이 90%인 것이다.</b></li></ul><h1 id="3-코로나-19"><a href="#3-코로나-19" class="headerlink" title="3. 코로나-19"></a>3. 코로나-19</h1><blockquote><p><a href="https://coronaboard.kr/">코로나-19 실시간 현황판</a><br><a href="https://jumin.mois.go.kr/">행정안전부: 주민등록 인구 통계</a><br><a href="https://www.hani.co.kr/arti/society/health/1029592.html">한겨레: ‘가짜양성’ 넷 중 하나… 자가키트 양성 뒤 PCR 음성 23.9%</a></p></blockquote><h2 id="3-1-자가진단키트-검사자-시점"><a href="#3-1-자가진단키트-검사자-시점" class="headerlink" title="3.1. 자가진단키트 검사자 시점"></a>3.1. 자가진단키트 검사자 시점</h2><ul><li>자가진단키트의 민감도와 특이도는 각기 90%와 99%.</li><li>그리고 2022.04.23. 현재 우리 나라의 누적 확진자는 <b>16,830,469명</b></li><li>우리 나라의 <b>총 인구는 51,610,695명</b> 고려시 <b>확진자 비율은 32.6%.</b></li><li>신속항원검사와 PCR로 <b>최종 검증이 된다 가정</b>하고 종합하면 다음과 같은 그림이 그려진다.<br></li></ul><p><img src="99_cp_05.PNG"><br></p><ul><li>PCR보다 <b>자가진단키트가 확진자를 3%가량 덜 잡아내고 있으며</b>,</li><li>(1) 양성(확진) 진단을 받은 경우 : 양성 예측도</b> = $\dfrac{29.3}{29.3 + 0.7} = 97.7$%</li><li>(2) 음성(미확진) 진단을 받은 경우 : 음성 예측도</b> = $\dfrac{66.7}{66.7 + 3.3} = 95.3$%</li><li><b>생각보다 자가진단키트가 믿을만 하다</b>는 결론인데,</li><li>한때 <a href="https://www.hani.co.kr/arti/society/health/1029592.html">자가키트의 신뢰성 문제</a>가 언론에 보도된 때는 2월 5일로 <b>오미크론이 본격적으로 유행하기 전</b>이었다. <br></li></ul><p><img src="99_cp_06.PNG"><br></p><ul><li>앞서 양성예측도 76% 계산시 전국민의 3%가 감염되었다는 것을 가정한 것에 비해 10배 가량 많기 때문에 <b>데이터 불균형에 의한 문제가 해소</b>되었다고 볼 수 있다.</li></ul><h2 id="3-2-유병률-영향"><a href="#3-2-유병률-영향" class="headerlink" title="3.2. 유병률 영향"></a>3.2. 유병률 영향</h2><ul><li>양성 예측도와 음성 예측도 모두 전국민 중 얼마나 병에 걸렸냐는 <b>유병률<code>prevalence</code></b>의 영향을 받는다.</li><li>수식으로 표현하면 다음과 같다.<br></li></ul><p>$$양성예측도 PPV = \frac{민감도 \cdot 유병률}{민감도 \cdot 유병률 + (1- 특이도) \cdot (1 - 유병률)}$$</p><br><p>$$음성예측도 NPV = \frac{특이도 \cdot (1-유병률)}{특이도 \cdot (1-유병률) + (1-민감도) \cdot 유병률}$$</p><ul><li>자가진단키트 기준인 <b>민감도 90%</b>와 <b>특이도 99%</b>를 넣고 그림을 그리면 이렇다.</li><li>데이터 불균형 문제가 해결되어 두 예측도가 모두 높은 상황임을 알 수 있다.</li></ul><p><img src="99_cp_07.PNG"><br></p><h2 id="3-3-민감도와-특이도-영향력"><a href="#3-3-민감도와-특이도-영향력" class="headerlink" title="3.3. 민감도와 특이도 영향력"></a>3.3. 민감도와 특이도 영향력</h2><ul><li><p>자가진단키트가 불량이거나 검사 방법이 제대로 이루어지지 않은 경우, </p></li><li><p><b>민감도와 특이도가 기대치에 미치지 못할 수 있다</b>.</p></li><li><p>특이도를 99%로 고정하고 민감도를 50%까지 떨어트리면 <b>양성예측도는 별 차이가 없는 반면 음성예측도가 80%까지 감소한다</b>.<br><br><img src="99_cp_08.PNG"><br></p></li><li><p>거꾸로, 민감도를 90%로 고정하고 특이도만 60%까지 떨어트리면 <b>양성예측도가 50% 수준으로 감소한다</b>. <br><br><img src="99_cp_09.PNG"><br></p></li><li><p>공장에서 제품이 제대로 나온다는 가정 하에, <b>올바른 검사 방법</b>이 가장 중요한 요소일지도 모른다.</p></li></ul><h1 id="4-결론"><a href="#4-결론" class="headerlink" title="4. 결론"></a>4. 결론</h1><ul><li><b>검사를 제대로 했다는 전제 하에,</b></li><li>즉 자가진단키트가 실제로 민감도 90%와 특이도 99%를 발휘한다는 전제 하에 상당히 믿을 만한 수준이다.</li><li>많은 분들이 코로나-19에 걸리지 않고 무사히 이 시기를 지나가기를 바란다.</li></ul><h1 id="5-에필로그"><a href="#5-에필로그" class="headerlink" title="5. 에필로그"></a>5. 에필로그</h1><blockquote><p><a href="https://www.docdocdoc.co.kr/news/articleView.html?idxno=2009532">청년의사: 신속항원진단키트로 입원 전 코로나 검사했더니 민감도 17.5%</a><br><a href="https://www.docdocdoc.co.kr/news/articleView.html?idxno=2022211&utm_source=dable">청년의사: 이비인후과 전문의 60% ‘자가검사키트 정확도 절반 이하’ 우려</a><br><a href="https://www.chosun.com/national/welfare-medical/2022/03/14/CZG6DUQLFJHLVHQ6QRRGUPFQDE/">조선일보: 신속항원검사 11%는 음성을 양성으로 판정</a></p></blockquote><ul><li><b>PCR 검사 결과 음성.</b></li><li>결론적으로 <b>위양성(False Positive)</b>이었다.<br></li></ul><p><img src="99_cp_10.jpg"><br></p><ul><li>자가진단키트의 신뢰성에 대해 지속적으로 의문이 제기되고 있다.</li><li><b>민감도 문제가 특히 심각하다고 하다.</b> <br></li></ul><p><img src="99_cp_12.png" alt="청년의사: 2022.04.22. 기사"><br></p><ul><li>잘 찌른 자가진단키트와 유사할 <b>신속항원검사가 음성을 양성으로 판정하는 비율이 11%라고 한다.</b></li><li>내가 이 11%에 들었던 것 같다.</li><li>결론이 무엇이건, 확률이 어쨌건, 모두 건강하자.<br></li></ul><p><img src="99_cp_13.png" alt="조선일보: 2022.03.14. 기사"><br></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/statistics/">statistics</category>
      
      <category domain="https://jehyunlee.github.io/tags/classification/">classification</category>
      
      
    </item>
    
    <item>
      <title>ridge-map</title>
      <link>https://jehyunlee.github.io/2022/04/17/Python-DS-98-ridgemap/</link>
      <guid>https://jehyunlee.github.io/2022/04/17/Python-DS-98-ridgemap/</guid>
      <pubDate>Sat, 16 Apr 2022 20:12:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;지형을 중첩된 line plot으로 그리는 ridgemap 라이브러리를 소개합니다.&lt;/li&gt;
&lt;li&gt;Matplotlib 생태계의 일원으로 쉽게 사용할 수 있습니다.&lt;/li&gt;
&lt;li&gt;소스 코드를 조금 고쳐줄 필요가 있습니다.&lt;/li&gt;
&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>지형을 중첩된 line plot으로 그리는 ridgemap 라이브러리를 소개합니다.</li><li>Matplotlib 생태계의 일원으로 쉽게 사용할 수 있습니다.</li><li>소스 코드를 조금 고쳐줄 필요가 있습니다.</li></ul><h1 id="1-ridge-map"><a href="#1-ridge-map" class="headerlink" title="1. ridge-map"></a>1. ridge-map</h1><blockquote><p><a href="https://pypi.org/project/ridge-map/">pypi: ridge-map/</a></p></blockquote><ul><li>설명 대신 그림을 한 장 보여드리겠습니다.</li></ul><p><img src="98_ridgemap_01.png"><br></p><ul><li><p>아름다운 산악 지형의 풍경이 고전적인 느낌으로 그려져 있습니다.</p></li><li><p>이 그림은 ridge-map 라이브러리를 사용해서 그린 것으로, 코드는 다음과 같습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rm = RidgeMap((<span class="number">11.098251</span>,<span class="number">47.264786</span>,<span class="number">11.695633</span>,<span class="number">47.453630</span>))</span><br><span class="line">values = rm.get_elevation_data(num_lines=<span class="number">150</span>)</span><br><span class="line">values=rm.preprocess(</span><br><span class="line">    values=values,</span><br><span class="line">    lake_flatness=<span class="number">2</span>,</span><br><span class="line">    water_ntile=<span class="number">10</span>,</span><br><span class="line">    vertical_ratio=<span class="number">240</span>)</span><br><span class="line">rm.plot_map(values=values,</span><br><span class="line">            label=<span class="string">&#x27;Karwendelgebirge&#x27;</span>,</span><br><span class="line">            label_y=<span class="number">0.1</span>,</span><br><span class="line">            label_x=<span class="number">0.55</span>,</span><br><span class="line">            label_size=<span class="number">40</span>,</span><br><span class="line">            linewidth=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>별다른 설명이 없이도 대강 감이 오는 코드입니다.</p></li></ul><h1 id="2-ridge-map-설치"><a href="#2-ridge-map-설치" class="headerlink" title="2. ridge-map 설치"></a>2. ridge-map 설치</h1><blockquote><p><a href="https://github.com/ColCarroll/ridge_map/pull/34">ridge-map issue: Google font</a></p></blockquote><ul><li><p>설치는 어렵지 않습니다. pypi에서 다음 명령을 실행하면 간단히 이루어집니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install ridge_map</span><br></pre></td></tr></table></figure></li><li><p>하지만 약간의 문제가 있습니다.</p></li><li><p>기본적으로 사용하는 google font 경로가 바뀌면서 오류가 발생합니다.</p></li><li><p>이 때문에 <b>소스 코드 일부를 수정해야 합니다.</b></p></li></ul><ul><li>파이썬이 설치된 경로를 찾아 <code>파이썬설치경로/site-packages/ridge_map/ridge_map.py</code>를 수정합니다.</li><li>32번째 줄 <code>github_url</code>부분을 다음과 같이 바꿉니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github_url=<span class="string">&quot;https://github.com/google/fonts/blob/5c3d8ef085f3084db38936d0dcd39a567dbc1e01/ofl/cinzel/static/Cinzel-Regular.ttf?raw=true&quot;</span>, <span class="comment"># pylint: disable=line-too-long</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="3-지도-그리기"><a href="#3-지도-그리기" class="headerlink" title="3. 지도 그리기"></a>3. 지도 그리기</h1><ul><li>rige-map으로 지도를 그릴 수 있습니다.</li><li>지도를 그릴 때 필요한 첫 번째 요소는 <b>경도</b>와 <b>위도</b>입니다.</li><li><b>왼쪽 아래</b>와 <b>오른쪽 위</b>지점의 경도와 위도를 <b><code>Ridgemap()</code></b>에 차례로 입력합니다.</li><li>구글 지도에서 쉽게 위도와 경도를 확인할 수 있습니다.</li></ul><p><img src="98_ridgemap_02.png"><br></p><ul><li>구글 지도에서 한 지점을 클릭하면 빨간 마커가 생깁니다.</li><li>주소창 맨 오른쪽 끝에 숫자 두 개가 숨어 있습니다.</li><li>앞에서부터 해당 지점의 <b>위도</b>와 <b>경도</b>이므로 순서를 바꾸어 입력해야 합니다.</li></ul><h2 id="3-1-서울-지도"><a href="#3-1-서울-지도" class="headerlink" title="3.1. 서울 지도"></a>3.1. 서울 지도</h2><ul><li>서울의 좌표를 입력합니다.</li><li>구글 지도에서 대략 <code>(126.8403339,37.4157432,127.1661446,37.7104195)</code>로 입력했습니다.</li><li><code>rm.plot_map()</code>은 Matplotlib Axes 객체를 반환합니다.</li><li>이를 ax라는 이름으로 받아 <code>fig = ax.figure</code>로 Figure 객체를 추출하고,</li><li><code>fig.tight_layout()</code>로 여백을 줄이고 <code>fig.savefig()</code>로 파일로 저장합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rm = RidgeMap((<span class="number">126.8403339</span>,<span class="number">37.4157432</span>,<span class="number">127.1661446</span>,<span class="number">37.7104195</span>))</span><br><span class="line">values = rm.get_elevation_data(num_lines=<span class="number">150</span>)</span><br><span class="line">values=rm.preprocess(</span><br><span class="line">    values=values,</span><br><span class="line">    lake_flatness=<span class="number">2</span>,</span><br><span class="line">    water_ntile=<span class="number">10</span>,</span><br><span class="line">    vertical_ratio=<span class="number">100</span>)</span><br><span class="line">ax = rm.plot_map(values=values,</span><br><span class="line">            label=<span class="string">&#x27;Seoul, Korea&#x27;</span>,</span><br><span class="line">            label_y=<span class="number">0.1</span>,</span><br><span class="line">            label_x=<span class="number">0.7</span>,</span><br><span class="line">            label_size=<span class="number">40</span>,</span><br><span class="line">            linewidth=<span class="number">1.2</span>)</span><br><span class="line"></span><br><span class="line">fig = ax.figure</span><br><span class="line">fig.tight_layout()</span><br><span class="line">fig.savefig(<span class="string">&quot;98_ridgemap_03.png&quot;</span>)</span><br></pre></td></tr></table></figure><img src="98_ridgemap_03.png"><br></li></ul><h2 id="3-2-서울-지도-고도"><a href="#3-2-서울-지도-고도" class="headerlink" title="3.2. 서울 지도 + 고도"></a>3.2. 서울 지도 + 고도</h2><ul><li><p>선에 색을 입혀 고도를 표현할 수 있습니다.</p></li><li><p>위 코드의 <code>rm.plot_map()</code>에 두 줄을 추가합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kind=<span class="string">&quot;elevation&quot;</span>,</span><br><span class="line">line_color=plt.get_cmap(<span class="string">&#x27;gist_earth&#x27;</span>),</span><br></pre></td></tr></table></figure><p><img src="98_ridgemap_04.png"><br></p></li><li><p>북한산과 관악산이 잘 드러납니다.</p></li></ul><h2 id="3-3-Matplotlib-Axes-삽입"><a href="#3-3-Matplotlib-Axes-삽입" class="headerlink" title="3.3. Matplotlib Axes 삽입"></a>3.3. Matplotlib Axes 삽입</h2><ul><li><code>rm.plot_map()</code>은 Matplotlib Axes를 출력합니다.</li><li>따라서 Matplotlib에서 만들어둔 Figure와 Axes를 사용한 연출이 가능합니다.</li><li><code>rm.plot_map()</code> 안에 <code>ax=</code>매개변수를 삽입해서 출력 지점을 지정합니다.</li><li>서울, 대전, 목포, 제주 4개 지역을 한번에 표현합니다.</li><li>축적이 맞지 않음은 유의해야 합니다.</li></ul><ul><li><code>FontManager</code>로 글꼴을 바꿀 수 있습니다.</li><li>적절한 글꼴을 골라 경로를 지정하고, <code>Ridgemap()</code>에 <code>font=font.prop</code>을 추가합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ridge_map <span class="keyword">import</span> FontManager</span><br><span class="line">font = FontManager(<span class="string">&#x27;https://github.com/google/fonts/blob/main/ofl/arsenal/Arsenal-Bold.ttf?raw=true&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(ncols=<span class="number">2</span>, nrows=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">seoul = (<span class="number">126.8403339</span>, <span class="number">37.4157432</span>, <span class="number">127.1661446</span>, <span class="number">37.7104195</span>)</span><br><span class="line">daejeon = (<span class="number">127.2614837</span>, <span class="number">36.2194529</span>, <span class="number">127.6025534</span>, <span class="number">36.5002879</span>)</span><br><span class="line">mokpo = (<span class="number">126.3071108</span>, <span class="number">34.6873927</span>, <span class="number">126.5647852</span>, <span class="number">34.9315327</span>)</span><br><span class="line">jeju = (<span class="number">126.1623888</span>, <span class="number">33.1179613</span>, <span class="number">126.9962384</span>, <span class="number">33.7520832</span>)</span><br><span class="line"></span><br><span class="line">places = [seoul, daejeon, mokpo, jeju]</span><br><span class="line">names = [<span class="string">&quot;Seoul&quot;</span>, <span class="string">&quot;Daejeon&quot;</span>, <span class="string">&quot;Mokpo&quot;</span>, <span class="string">&quot;Jeju&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> place, name, ax <span class="keyword">in</span> <span class="built_in">zip</span>(places, names, axes.ravel()):</span><br><span class="line">    rm = RidgeMap(place, font=font.prop)</span><br><span class="line">    values = rm.get_elevation_data(num_lines=<span class="number">150</span>)</span><br><span class="line">    values=rm.preprocess(</span><br><span class="line">        values=values,</span><br><span class="line">        lake_flatness=<span class="number">2</span>,</span><br><span class="line">        water_ntile=<span class="number">10</span>,</span><br><span class="line">        vertical_ratio=<span class="number">100</span>)</span><br><span class="line">    rm.plot_map(values=values,</span><br><span class="line">                label=<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>, Korea&#x27;</span>,</span><br><span class="line">                label_y=<span class="number">0.1</span>,</span><br><span class="line">                label_x=<span class="number">0.45</span>,</span><br><span class="line">                label_size=<span class="number">20</span>,</span><br><span class="line">                linewidth=<span class="number">1.2</span>,</span><br><span class="line">                background_color=<span class="string">&quot;w&quot;</span>,</span><br><span class="line">                kind=<span class="string">&quot;elevation&quot;</span>,</span><br><span class="line">                line_color=plt.get_cmap(<span class="string">&#x27;gist_earth&#x27;</span>),</span><br><span class="line">                ax=ax)</span><br><span class="line">    </span><br><span class="line">fig = ax.figure</span><br><span class="line">fig.tight_layout()</span><br><span class="line">fig.savefig(<span class="string">&quot;98_ridgemap_05.png&quot;</span>)</span><br></pre></td></tr></table></figure><img src="98_ridgemap_05.png"><br></li></ul><h1 id="4-데이터"><a href="#4-데이터" class="headerlink" title="4. 데이터"></a>4. 데이터</h1><blockquote><p><a href="https://www2.jpl.nasa.gov/srtm/">NASA: Shuttle Radar Topography Mision (SRTM)</a></p></blockquote><ul><li>해발고도 데이터는 2000년에 수집된 NASA의 SRTM을 사용합니다.</li><li>1 arc-second 단위로, 약 30m 수준의 해상도를 보유하고 있습니다.</li><li>단 북위 60도와 남위 60도를 넘어서는 지역은 데이터가 없습니다.<br><br><img src="98_ridgemap_06.gif"><br></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/gis/">gis</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/ridge-map/">ridge-map</category>
      
      
    </item>
    
    <item>
      <title>AI를 하고 싶은 C-level의 흔한 실수들</title>
      <link>https://jehyunlee.github.io/2022/03/28/Python-DS-97-ceo_mistakes/</link>
      <guid>https://jehyunlee.github.io/2022/03/28/Python-DS-97-ceo_mistakes/</guid>
      <pubDate>Sun, 27 Mar 2022 17:13:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;&lt;a href=&quot;https://www.innopolis.or.kr/mps&quot;&gt;연구개발특구(innopolis)&lt;/a&gt;&lt;/b&gt;에서 CEO 대상 AI 인사이트 교육 발표를 했습니다. (22.03.24.)&lt;ul&gt;
&lt;li&gt;공지된 제목은 &lt;b</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b><a href="https://www.innopolis.or.kr/mps">연구개발특구(innopolis)</a></b>에서 CEO 대상 AI 인사이트 교육 발표를 했습니다. (22.03.24.)<ul><li>공지된 제목은 <b>데이터, 다이아몬드 또는 진흙</b>이었습니다만</li><li>제 앞에서 발표하신 고우영 님의 발표를 보고 연장선상에서 바꿨습니다.</li><li>수정된 제목은 <b>AI를 하고 싶은 C-level의 흔한 실수들</b>입니다.</li></ul></li></ul><ul><li>발표 영상입니다 (<a href="https://youtu.be/mcIU5Fk-pFo">Youtube Link</a>)<br></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/mcIU5Fk-pFo" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <ul><li><b>AI는 회사를 운영하는 방식을 바꾸는 일</b>이기 때문에 굵직한 의사 결정이 많이 필요합니다.<ul><li>“갖다쓰면 되겠지”, “남들도 한다는데”라는 마인드로는 실패할 확률이 매우 큽니다.</li><li>실무자가 필요로 하는 것이 무엇인지, 왜인지, 진짜인지를 알기 위해서라도 공부하셔야 합니다.</li><li>전 직장의 경험담을 위주로 구성했습니다. </li><li>전달력을 위해 여러 사례를 합치기도 했고 나누기도 했습니다. 이 점을 참고해 주시면 좋겠습니다.</li></ul></li></ul><p><img src="poster.jpg" alt="연구개발특구 행사 공지"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/AI-Frenz/">AI Frenz</category>
      
      <category domain="https://jehyunlee.github.io/tags/C-level/">C-level</category>
      
      
    </item>
    
    <item>
      <title>joinstyle &amp; capstyle</title>
      <link>https://jehyunlee.github.io/2022/01/24/Python-DS-96-joinstyle/</link>
      <guid>https://jehyunlee.github.io/2022/01/24/Python-DS-96-joinstyle/</guid>
      <pubDate>Sun, 23 Jan 2022 22:25:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;오늘은 매우 사소한 글입니다.&lt;/li&gt;
&lt;li&gt;Matplotlib에서 그려지는 선의 꼭지점과 끝점 표현입니다.&lt;/li&gt;
&lt;li&gt;사소하지만 신경을 거스르는 일을 해결합시다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-motivation-Pie</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>오늘은 매우 사소한 글입니다.</li><li>Matplotlib에서 그려지는 선의 꼭지점과 끝점 표현입니다.</li><li>사소하지만 신경을 거스르는 일을 해결합시다.</li></ul><h1 id="1-motivation-Pie-chart"><a href="#1-motivation-Pie-chart" class="headerlink" title="1. motivation: Pie chart"></a>1. motivation: Pie chart</h1><ul><li><p>다른 그림에 비해 자주 그리는 그림은 아닙니다.</p></li><li><p>그런 만큼 손에 익히기 쉽지 않은데, 정리를 한번 하겠습니다.</p></li><li><p>아보카도, 바나나, 체리 판매량이 각기 40, 70, 10이라고 하고,</p></li><li><p>상대적인 판매량을 그림으로 그린다고 칩시다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 판매량</span></span><br><span class="line">data = [<span class="number">40</span>, <span class="number">70</span>, <span class="number">10</span>]</span><br><span class="line"><span class="comment"># 레이블</span></span><br><span class="line">labels = [<span class="string">&quot;Abocado&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>]</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">12</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (A) 색과 글자 설정</span></span><br><span class="line">axs[<span class="number">0</span>].pie(data, labels=labels, labeldistance=<span class="number">0.7</span>, </span><br><span class="line">           colors=[<span class="string">&quot;g&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;r&quot;</span>],</span><br><span class="line">           textprops=&#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;fontsize&quot;</span>:<span class="string">&quot;14&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>, <span class="string">&quot;ha&quot;</span>:<span class="string">&quot;center&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (B) 부채꼴에 윤곽선 추가</span></span><br><span class="line">axs[<span class="number">1</span>].pie(data, labels=labels, labeldistance=<span class="number">0.7</span>, </span><br><span class="line">           colors=[<span class="string">&quot;g&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;r&quot;</span>], </span><br><span class="line">           textprops=&#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;fontsize&quot;</span>:<span class="string">&quot;14&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>, <span class="string">&quot;ha&quot;</span>:<span class="string">&quot;center&quot;</span>&#125;,</span><br><span class="line">           wedgeprops=&#123;<span class="string">&quot;ec&quot;</span>:<span class="string">&quot;w&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (C) 부채꼴 윤곽선 두껍게</span></span><br><span class="line">axs[<span class="number">2</span>].pie(data, labels=labels, labeldistance=<span class="number">0.7</span>, </span><br><span class="line">           colors=[<span class="string">&quot;g&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;r&quot;</span>], </span><br><span class="line">           textprops=&#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;fontsize&quot;</span>:<span class="string">&quot;14&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>, <span class="string">&quot;ha&quot;</span>:<span class="string">&quot;center&quot;</span>&#125;,</span><br><span class="line">           wedgeprops=&#123;<span class="string">&quot;ec&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;lw&quot;</span>:<span class="number">6</span>&#125;)</span><br><span class="line"></span><br><span class="line">titles = [<span class="string">&quot;(A)&quot;</span>, <span class="string">&quot;(B): (A) + wedgeprops&quot;</span>, <span class="string">&quot;(C): (B) + lw&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> title, ax <span class="keyword">in</span> <span class="built_in">zip</span>(titles, axs):</span><br><span class="line">    ax.set_title(title, fontsize=<span class="number">16</span>)</span><br><span class="line">    ax.set_aspect(<span class="number">1</span>)    </span><br></pre></td></tr></table></figure><p><img src="96_joinstyle_01.png"><br></p></li><li><p><code>colors</code> 매개변수로 색을 조정하고 <code>textprops</code> 매개변수로 글꼴만 좀 조정한 것이 (A)입니다.</p></li><li><p>(B)는 부채꼴에 경계선을 넣어서 틈을 살짝 벌렸습니다. <code>wedgeprops</code>를 사용합니다.</p></li><li><p>만들고 보니 좀 두꺼우면 좋겠다는 생각이 듭니다. <code>wedgeprops</code>에 <code>lw</code>를 넣어 line width를 두껍게 했습니다.</p></li></ul><ul><li>그런데 <b>cherry가 banana를 찌르고 있습니다.</b></li><li>사소하다면 사소한건데, 영 성가십니다. </li><li><b>원인을 파악하고 제거합시다.</b></li></ul><h1 id="2-별-그리기"><a href="#2-별-그리기" class="headerlink" title="2. 별 그리기"></a>2. 별 그리기</h1><ul><li>문제를 일반화하기 위해 별을 그리고 이 그림을 바꿔봅니다.</li><li><a href="https://jehyunlee.github.io/2021/12/28/Python-DS-94-rougier02/">지난 글</a>에서 다룬 <code>Path</code>와 <code>PathPatch</code>를 사용합니다.</li></ul><h2 id="2-1-별-만들기"><a href="#2-1-별-만들기" class="headerlink" title="2.1. 별 만들기"></a>2.1. 별 만들기</h2><ul><li><p>오각형 기반으로 별을 만들겠습니다.</p></li><li><p>어릴 때부터 별을 그리라면 이렇게 그렸죠. :)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.path <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> PathPatch</span><br><span class="line"></span><br><span class="line">xs = [np.cos(<span class="number">2</span>*np.pi*x/<span class="number">5</span> + <span class="number">0.5</span>*np.pi) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">ys = [np.sin(<span class="number">2</span>*np.pi*x/<span class="number">5</span> + <span class="number">0.5</span>*np.pi) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">ps = np.array(<span class="built_in">list</span>(<span class="built_in">zip</span>(xs, ys)))    </span><br><span class="line">ps</span><br></pre></td></tr></table></figure></li><li><p>실행 결과: 다섯 지점의 좌표를 만들었습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array([[ 6.12323400e-17,  1.00000000e+00],</span><br><span class="line">       [-9.51056516e-01,  3.09016994e-01],</span><br><span class="line">       [-5.87785252e-01, -8.09016994e-01],</span><br><span class="line">       [ 5.87785252e-01, -8.09016994e-01],</span><br><span class="line">       [ 9.51056516e-01,  3.09016994e-01]])</span><br></pre></td></tr></table></figure></li><li><p>이제 점따라 이어서 별을 그립니다.</p></li><li><p>어릴 때 그리던 그 순서대로 점 번호를 찍습니다.</p></li><li><p>마지막에 원점으로 돌아가는 것까지 잊지 말아야 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps_star = ps[[<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>]]</span><br><span class="line">ps_star</span><br></pre></td></tr></table></figure></li><li><p>실행 결과: 순서대로 점이 배열됩니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array([[ 6.12323400e-17,  1.00000000e+00],</span><br><span class="line">       [-5.87785252e-01, -8.09016994e-01],</span><br><span class="line">       [ 9.51056516e-01,  3.09016994e-01],</span><br><span class="line">       [-9.51056516e-01,  3.09016994e-01],</span><br><span class="line">       [ 5.87785252e-01, -8.09016994e-01],</span><br><span class="line">       [ 6.12323400e-17,  1.00000000e+00]])</span><br></pre></td></tr></table></figure></li><li><p><code>Path</code>와 <code>PathPatch</code>를 차례대로 적용해서 별을 그립니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">path_star = Path(ps_star)</span><br><span class="line">patch_star = PathPatch(path_star, fc=<span class="string">&quot;yellow&quot;</span>, ec=<span class="string">&quot;k&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">4</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.add_artist(patch_star)</span><br><span class="line">ax.set_xlim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">ax.set_ylim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br></pre></td></tr></table></figure><p><img src="96_joinstyle_02.png"><br></p></li><li><p>맘에 듭니다.</p></li><li><p>선을 굵게 합시다. PathPatch에 <code>lw</code> 매개변수를 추가합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">path_star = Path(ps_star)</span><br><span class="line">patch_star = PathPatch(path_star, fc=<span class="string">&quot;yellow&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, lw=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">4</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.add_artist(patch_star)</span><br><span class="line">ax.set_xlim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">ax.set_ylim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br></pre></td></tr></table></figure><p><img src="96_joinstyle_03.png"><br></p></li><li><p>시작점이자 끝점인 맨 위가 부러진 듯 보입니다.</p></li><li><p>끝점(caps)과 중간점(joints) 표현 방식이 달라서 그렇습니다.</p></li><li><p>일단 저 끝점을 중간점으로 만들어서 일관성을 줍시다.</p></li><li><p>한 포인트 더 붙이면 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ps_star = ps[[<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>]]  <span class="comment"># 맨 마지막에 2 추가</span></span><br><span class="line">path_star = Path(ps_star)</span><br><span class="line">patch_star = PathPatch(path_star, fc=<span class="string">&quot;yellow&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, lw=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">4</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.add_artist(patch_star)</span><br><span class="line">ax.set_xlim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">ax.set_ylim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br></pre></td></tr></table></figure><p><img src="96_joinstyle_04.png"><br></p></li></ul><h2 id="2-2-joinstyle"><a href="#2-2-joinstyle" class="headerlink" title="2.2. joinstyle"></a>2.2. <code>joinstyle</code></h2><blockquote><p><a href="https://matplotlib.org/stable/api/_enums_api.html?highlight=joinstyle#matplotlib._enums.JoinStyle">matplotlib._enums.Joinstyle</a></p></blockquote><ul><li><p>Matplotlib에서 꺾은선 그래프처럼 여러 선이 꺾이는 관절 표현은 <code>joinstyle</code> 매개변수로 결정합니다.</p></li><li><p><code>miter</code>, <code>round</code>, <code>bevel</code> 세 가지의 선택지가 있습니다.<br><br><img src="joinstyle.webp"><br></p></li><li><p>우리 별 그림에 이 셋을 적용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">joinstyles = [<span class="string">&quot;miter&quot;</span>, <span class="string">&quot;round&quot;</span>, <span class="string">&quot;bevel&quot;</span>]</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">12</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> js, ax <span class="keyword">in</span> <span class="built_in">zip</span>(joinstyles, axs):</span><br><span class="line">    patch_star = PathPatch(path_star, fc=<span class="string">&quot;yellow&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, lw=<span class="number">10</span>, joinstyle=js)</span><br><span class="line">    ax.add_artist(patch_star)</span><br><span class="line">    ax.set_xlim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">    ax.set_ylim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br></pre></td></tr></table></figure><p><img src="96_joinstyle_05.png"><br></p></li><li><p>왼쪽부터 <b>뾰족</b>, <b>둥글</b>, <b>판판</b>입니다.</p></li><li><p>기본값은 뾰족한 <code>miter</code>로 각도가 작을수록 먼 곳까지 꼭지점이 연장된다는 특징이 있습니다.</p></li><li><p>맨 위 pie chart 예제에서도 체리 판매량이 다른 둘보다 적어 꼭지점이 바나나를 찔렀습니다.</p></li><li><p><b><code>round</code>나 <code>bevel</code>을 사용하면 그럴 일이 없을 겁니다.</b> </p></li></ul><h1 id="3-원-그리기"><a href="#3-원-그리기" class="headerlink" title="3. 원 그리기"></a>3. 원 그리기</h1><ul><li>이번에는 조금 다른 예제를 확인합니다.</li><li>시작과 끝이 동일한 원을 점선으로 표현해서 짧은 선을 많이 그립니다.</li></ul><h2 id="3-1-원-만들기"><a href="#3-1-원-만들기" class="headerlink" title="3.1. 원 만들기"></a>3.1. 원 만들기</h2><ul><li>이번엔 <code>PathPatch</code>말고 <code>Circle</code>을 사용합니다.</li><li><code>Circle</code>로 원을 만들고 <code>add_artist()</code>로 붙입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Circle</span><br><span class="line"></span><br><span class="line">circle = Circle((<span class="number">0</span>, <span class="number">0</span>), <span class="number">1</span>, ls=<span class="string">&quot;:&quot;</span>, fc=<span class="string">&quot;beige&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, lw=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">4</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.add_artist(circle)</span><br><span class="line">ax.set_xlim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">ax.set_ylim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br></pre></td></tr></table></figure><img src="96_joinstyle_06.png"><br></li></ul><h2 id="3-2-joinstyle-capstyle"><a href="#3-2-joinstyle-capstyle" class="headerlink" title="3.2. joinstyle? capstyle!"></a>3.2. <code>joinstyle</code>? <code>capstyle</code>!</h2><ul><li><p>별 그림과 똑같이 joinstyle을 적용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">12</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j, ax <span class="keyword">in</span> <span class="built_in">zip</span>(joinstyles, axs):</span><br><span class="line">    circle = Circle((<span class="number">0</span>, <span class="number">0</span>), <span class="number">1</span>, ls=<span class="string">&quot;:&quot;</span>, fc=<span class="string">&quot;beige&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, lw=<span class="number">10</span>, joinstyle=j)</span><br><span class="line">    ax.add_artist(circle)</span><br><span class="line">    ax.set_xlim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">    ax.set_ylim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br></pre></td></tr></table></figure><p><img src="96_joinstyle_07.png"><br></p></li><li><p>별 그림과는 달리 변화가 없습니다.</p></li><li><p><b><code>joinstyle</code>은 선이 꺾이는 부분에 적용되는 매개변수</b>입니다.</p></li><li><p>원은 꺾이는 점이 없고 점선도 꺾인 곳이 없기에 아무런 변화가 없습니다.</p></li></ul><ul><li><p><b>선 끝에는 <code>capstyle</code>이 적용됩니다.</b></p></li><li><p>선택지는 <code>joinstyle</code>처럼 세 개지만 이름이 다릅니다.</p></li><li><p><code>butt</code>, <code>round</code>, <code>projecting</code>입니다.<br><br><img src="capstyle.webp"><br></p></li><li><p>확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">capstyles = [<span class="string">&quot;butt&quot;</span>, <span class="string">&quot;round&quot;</span>, <span class="string">&quot;projecting&quot;</span>]</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">12</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cs, ax <span class="keyword">in</span> <span class="built_in">zip</span>(capstyles, axs):</span><br><span class="line">    circle = Circle((<span class="number">0</span>, <span class="number">0</span>), <span class="number">1</span>, ls=<span class="string">&quot;:&quot;</span>, fc=<span class="string">&quot;beige&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, lw=<span class="number">10</span>, capstyle=cs)</span><br><span class="line">    ax.add_artist(circle)</span><br><span class="line">    ax.set_xlim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">    ax.set_ylim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br></pre></td></tr></table></figure><p><img src="96_joinstyle_08.png"><br></p></li><li><p>이제 차이가 보입니다.</p></li><li><p>joinstyle과 capstyle을 함께 표현합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">12</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> js, cs, ax <span class="keyword">in</span> <span class="built_in">zip</span>(joinstyles, capstyles, axs):</span><br><span class="line">    circle = Circle((<span class="number">0</span>, <span class="number">0</span>), <span class="number">1</span>, ls=<span class="string">&quot;:&quot;</span>, fc=<span class="string">&quot;beige&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, lw=<span class="number">10</span>, capstyle=cs)</span><br><span class="line">    ax.add_artist(circle)</span><br><span class="line">    patch_star = PathPatch(path_star, fc=<span class="string">&quot;yellow&quot;</span>, ec=<span class="string">&quot;r&quot;</span>, lw=<span class="number">10</span>, joinstyle=js)</span><br><span class="line">    ax.add_artist(patch_star)</span><br><span class="line">    ax.set_xlim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">    ax.set_ylim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">    ax.set_title(<span class="string">f&quot;joinstyle= &#x27;<span class="subst">&#123;js&#125;</span>&#x27;\ncapstype= &#x27;<span class="subst">&#123;cs&#125;</span>&#x27;&quot;</span>, pad=<span class="number">12</span>, fontsize=<span class="string">&quot;xx-large&quot;</span>)</span><br><span class="line">    ax.set_xticks([])</span><br><span class="line">    ax.set_yticks([])</span><br><span class="line">    ax.set_aspect(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="96_joinstyle_09.png"><br></p></li></ul><h1 id="4-다시-Pie-chart"><a href="#4-다시-Pie-chart" class="headerlink" title="4. 다시 Pie chart"></a>4. 다시 Pie chart</h1><ul><li><p>애초 우리 목적은 Pie chart였습니다.</p></li><li><p>맨 위 코드에 <code>joinstyle</code>만 <code>round</code>로 적용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="number">40</span>, <span class="number">70</span>, <span class="number">10</span>]</span><br><span class="line">labels = [<span class="string">&quot;Abocado&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>]</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">4</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.pie(data, labels=labels, labeldistance=<span class="number">0.7</span>, </span><br><span class="line">       colors=[<span class="string">&quot;g&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;r&quot;</span>], </span><br><span class="line">       textprops=&#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;fontsize&quot;</span>:<span class="string">&quot;14&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>, <span class="string">&quot;ha&quot;</span>:<span class="string">&quot;center&quot;</span>&#125;,</span><br><span class="line">       wedgeprops=&#123;<span class="string">&quot;ec&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;lw&quot;</span>:<span class="number">6</span>, <span class="string">&quot;joinstyle&quot;</span>:<span class="string">&quot;round&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">ax.set_aspect(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="96_joinstyle_10.png"><br></p></li><li><p><b>짜잔. 이제 깔끔합니다.</b></p></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/joinstyle/">joinstyle</category>
      
      <category domain="https://jehyunlee.github.io/tags/capstyle/">capstyle</category>
      
      
    </item>
    
    <item>
      <title>gravity</title>
      <link>https://jehyunlee.github.io/2022/01/13/Python-Physics-1-gravity/</link>
      <guid>https://jehyunlee.github.io/2022/01/13/Python-Physics-1-gravity/</guid>
      <pubDate>Thu, 13 Jan 2022 12:25:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;파이썬은 과학과 공학을 구현하기 좋습니다.&lt;/li&gt;
&lt;li&gt;간단한 몇 개의 코드로 방정식을 구현하고,&lt;/li&gt;
&lt;li&gt;시각화 기법을 사용해 우리 눈으로 봅니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-만유인력&quot;&gt;&lt;a href=&quot;#1-만유</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>파이썬은 과학과 공학을 구현하기 좋습니다.</li><li>간단한 몇 개의 코드로 방정식을 구현하고,</li><li>시각화 기법을 사용해 우리 눈으로 봅니다.</li></ul><h1 id="1-만유인력"><a href="#1-만유인력" class="headerlink" title="1. 만유인력"></a>1. 만유인력</h1><blockquote><p><a href="https://en.wikipedia.org/wiki/Gravity">wikipedia: gravity</a></p></blockquote><ul><li>질량이 있는 물체끼리는 끌어당기는 힘이 있습니다. <b>만유인력</b>이라고 합니다.</li><li>뉴턴이 발견한 것으로 유명하고, 중력파는 우주의 비밀을 여는 열쇠가 됩니다.</li><li>두 물체의 질량이 $m_1$, $m_2$, 거리가 $r$일 때 다음과 같은 방정식으로 표현됩니다.</li></ul><p>$$F = G\frac{m_1 m_2}{r^2}$$</p><ul><li>$G$는 중력 상수라고 하며 값은 $6.67 \times 10^{-11} [\textrm{m} \cdot \textrm{kg}^{-1}\textrm{s}^{-2}]$ 입니다.</li></ul><h1 id="2-자유-낙하"><a href="#2-자유-낙하" class="headerlink" title="2. 자유 낙하"></a>2. 자유 낙하</h1><ul><li>만유 인력을 일상의 물건들에서 느끼기엔 너무 미미하지만 지구나 태양이라면 이야기가 달라집니다.</li><li>위 식의 $m_2$에 지구의 질량을 넣고 $r$에 지구 반지름을 넣으면 <b>지구의 중력</b>이 됩니다.</li></ul><p>$$F = mg$$ </p><ul><li>중학교때 배운 식으로 정리되며, <b>중력 가속도</b> $g = 9.8 [\textrm{m} \cdot \textrm{s}^{-2}]$ 입니다.</li><li>간단히 물체의 자유 낙하를 시뮬레이션 합니다.</li></ul><h2 id="2-1-python-setting"><a href="#2-1-python-setting" class="headerlink" title="2.1. python setting"></a>2.1. python setting</h2><ul><li>기본 라이브러리를 불러오고 물체의 질량 등을 설정합니다.</li><li>연속적인 시간을 0.01초 단위로 끊어서 자유낙하를 모사하려고 합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 기본 라이브러리</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.set_style(<span class="string">&quot;white&quot;</span>)</span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 물체 </span></span><br><span class="line">mass = <span class="number">1</span>                     <span class="comment"># 질량 [kg] </span></span><br><span class="line">position = np.array([<span class="number">0</span>, <span class="number">10</span>]) <span class="comment"># x, y 위치 [m]</span></span><br><span class="line">v = np.array([<span class="number">0</span>, <span class="number">0</span>])         <span class="comment"># x, y 방향 초기 속도 [m/s]</span></span><br><span class="line">t = <span class="number">0</span>                        <span class="comment"># 초기 시간 [s]</span></span><br><span class="line">dt = <span class="number">0.01</span>                    <span class="comment"># 시간 단위 [s]</span></span><br><span class="line">g = np.array([<span class="number">0</span>, -<span class="number">9.8</span>])      <span class="comment"># 중력 가속도 [m/s]</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2-자유-낙하-시뮬레이션"><a href="#2-2-자유-낙하-시뮬레이션" class="headerlink" title="2.2. 자유 낙하 시뮬레이션"></a>2.2. 자유 낙하 시뮬레이션</h2><ul><li>지상 높이 10미터에서 땅에 떨어지는 시간을 살펴봅니다.</li><li>중학교에서 배우는 아래 공식에 $a$ 대신 $g$를 넣습니다.</li></ul><p>$$s = v_0 t + \frac{1}{2}at^2$$</p><ul><li><p>땅을 뚫고 들어가는 상황은 가정하지 않습니다.</p></li><li><p>초기 위치로 가정한 position의 y좌표 &gt; 0일 때만 계산합니다.</p></li><li><p>걸리는 <b>시간</b>은 <code>ts</code>리스트, 위치는 <code>positions</code>에 모읍니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 시뮬레이션</span></span><br><span class="line">ts = []</span><br><span class="line">positions = []</span><br><span class="line"><span class="keyword">while</span> position[<span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">    ts.append(t)</span><br><span class="line">    positions.append(position)</span><br><span class="line"></span><br><span class="line">    position = position + v*t + <span class="number">0.5</span> * g * t**<span class="number">2</span></span><br><span class="line">    t += dt</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 시각화</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">8</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">directions = [<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i, (ax, direction) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(axs, directions)):</span><br><span class="line">    ax.scatter(ts, np.array(positions)[:,i], alpha=<span class="number">0.3</span>, c=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">    ax.set_xlabel(<span class="string">&quot;time (s)&quot;</span>)</span><br><span class="line">    ax.set_title(<span class="string">f&quot;<span class="subst">&#123;direction&#125;</span> position (m)&quot;</span>, pad=<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p><img src="1_gravity_01.png"><br></p></li><li><p>좌우로 흔들릴 일은 없으므로 x position은 그대로</p></li><li><p>중력에 의해 떨어지기만 하므로 y position만 변화합니다.</p></li></ul><h2 id="2-3-자유-낙하-애니메이션"><a href="#2-3-자유-낙하-애니메이션" class="headerlink" title="2.3. 자유 낙하 애니메이션"></a>2.3. 자유 낙하 애니메이션</h2><ul><li><p>좀 재밌게 만들어 봅시다.</p></li><li><p>matplotlib의 애니메이션 기능을 이용해서 만들 수 있습니다.</p></li><li><p>물체의 위치를 표현할 scatter plot과 시간을 표현할 text를 내용만 비우고 만든 뒤에,</p></li><li><p>time step마다 각각의 데이터만 업데이트하는 방식을 사용했습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> animation</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">4</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">scatter, = ax.plot([], [], marker=<span class="string">&quot;o&quot;</span>, mfc=<span class="string">&quot;b&quot;</span>, mec=<span class="string">&quot;w&quot;</span>)</span><br><span class="line">time_text = ax.text(<span class="number">0.5</span>, <span class="number">0.9</span>, <span class="string">f&quot;&quot;</span>, transform=ax.transAxes, ha=<span class="string">&quot;center&quot;</span>)</span><br><span class="line"></span><br><span class="line">ax.set_ylim(<span class="number">0</span>, <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updatefig</span>(<span class="params">i</span>):</span>       </span><br><span class="line">    scatter.set_data(positions[i][<span class="number">0</span>], positions[i][<span class="number">1</span>])</span><br><span class="line">    time_text.set_text(<span class="string">f&quot;t = <span class="subst">&#123;ts[i]:<span class="number">.03</span>f&#125;</span> sec.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> fig,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ani = animation.FuncAnimation(fig, updatefig, interval=<span class="number">100</span>, blit=<span class="literal">True</span>, repeat=<span class="literal">False</span>, frames=<span class="built_in">len</span>(ts))</span><br><span class="line">ani.save(<span class="string">&quot;1_gravity_02.gif&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="1_gravity_02.gif"><br></p></li><li><p><code>ani.save()</code>명령으로 파일로 저장했습니다.</p></li><li><p>주피터 노트북이나 Google Colab에서 다음 코드를 사용하면 interactive animation을 얻을 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> HTML</span><br><span class="line">HTML(ani.to_jshtml())</span><br></pre></td></tr></table></figure><p><img src="1_gravity_11.gif"><br></p></li></ul><h1 id="3-움직이는-두-개의-물체"><a href="#3-움직이는-두-개의-물체" class="headerlink" title="3. 움직이는 두 개의 물체"></a>3. 움직이는 두 개의 물체</h1><h2 id="3-1-class로-물체-생성"><a href="#3-1-class로-물체-생성" class="headerlink" title="3.1. class로 물체 생성"></a>3.1. class로 물체 생성</h2><ul><li><p><b>지구 vs 물체</b> 대신 <b>물체 vs 물체</b> 구도가 되면 조금 복잡해집니다.</p></li><li><p>지구는 너무나 거대하기 때문에 상수로 놓을 수 있었지만 물체는 변수입니다.</p></li><li><p>서로 힘을 주고 받을 때 위치와 속도가 변합니다.</p></li><li><p>물체마다 받는 힘과 이로 인한 위치 변화 등을 계산합시다. <b>class</b>가 편합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Particle</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, mass, pos, v, fix=<span class="literal">False</span></span>):</span></span><br><span class="line">        self.mass = mass <span class="comment"># scalar  # 질량. scalar</span></span><br><span class="line">        self.pos = np.array(pos)   <span class="comment"># 위치 (x, y) 2D vector </span></span><br><span class="line">        self.v = np.array(v)       <span class="comment"># 속도 (x, y) 2D vector</span></span><br><span class="line">        self.a = np.array([<span class="number">0</span>,<span class="number">0</span>])   <span class="comment"># 가속도 (x, y) 2D vector</span></span><br><span class="line">        self.fix = fix             <span class="comment"># 고정 여부. True or False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, force</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.fix:           <span class="comment"># 고정이 되어 있지 않을 때만 데이터 업데이트</span></span><br><span class="line">            self.a = force/self.mass</span><br><span class="line">            self.pos = self.pos + (self.v * dt) + (<span class="number">0.5</span>*self.a * dt**<span class="number">2</span>)</span><br><span class="line">            self.v = self.v + self.a * dt</span><br></pre></td></tr></table></figure></li><li><p>이제 물체를 class로 정의할 준비가 되었습니다.</p></li><li><p>물체를 입자라는 뜻의 Particle로 부르겠습니다.</p></li><li><p>각각의 질량, 위치, 속도를 정하고 생성합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P1_mass, P2_mass = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">P1_pos, P2_pos = [<span class="number">1</span>, <span class="number">1</span>], [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">P1_v, P2_v = [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">P1 = Particle(P1_mass, P1_pos, P1_v)</span><br><span class="line">P2 = Particle(P2_mass, P2_pos, P2_v)</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-2-중력-계산-함수"><a href="#3-2-중력-계산-함수" class="headerlink" title="3.2. 중력 계산 함수"></a>3.2. 중력 계산 함수</h2><ul><li>물체들 간의 인력을 계산할 함수를 만듭니다.</li><li>맨 위의 방정식을 옮깁니다.</li><li>방정식에 따르면 거리가 너무 가까울 때 만유인력이 무한대로 증가하는 문제가 있습니다.</li><li><b>특정 거리<code>dist_cr</code> 미만으로 오면 인력을 0으로 강제</b>해서 관성으로만 움직이게 합니다.</li></ul><ul><li>만유인력 상수가 너무 작아서 임의로 크게 키웠습니다.</li><li>여기에 걸맞게 질량이 아주 커다란 천체들의 움직임이라고 생각할 수 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_force</span>(<span class="params">P_self, P_other, k=<span class="number">1</span>, dist_cr = <span class="number">0.02</span></span>):</span></span><br><span class="line">    pos_self = P_self.pos</span><br><span class="line">    pos_other = P_other.pos</span><br><span class="line">    rel_vec = pos_other - pos_self</span><br><span class="line">    dist = np.linalg.norm(rel_vec)    </span><br><span class="line"></span><br><span class="line">    mass_self = P_self.mass</span><br><span class="line">    mass_other = P_other.mass</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dist &lt; dist_cr:</span><br><span class="line">        force = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> rel_vec <span class="comment"># [0, 0]</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        force = k*mass_self*mass_other/ dist**<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> force * rel_vec/dist</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-3-두-물체간의-만유인력"><a href="#3-3-두-물체간의-만유인력" class="headerlink" title="3.3. 두 물체간의 만유인력"></a>3.3. 두 물체간의 만유인력</h2><ul><li><p>150번 iteration하면서 시간, 위치, 속도, 힘을 차례로 뽑아내며 업데이트합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">iter_max = <span class="number">150</span></span><br><span class="line"></span><br><span class="line">ts = []                  <span class="comment"># 시간</span></span><br><span class="line">P1_pos, P2_pos = [], []  <span class="comment"># 시간별 위치</span></span><br><span class="line">P1_v, P2_v = [], []      <span class="comment"># 시간별 속도</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iter_max):</span><br><span class="line">    <span class="comment"># time update</span></span><br><span class="line">    ts.append(i*dt)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># position update</span></span><br><span class="line">    P1_pos.append(P1.pos)</span><br><span class="line">    P2_pos.append(P2.pos)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># velocity update</span></span><br><span class="line">    P1_v.append(P1.v)</span><br><span class="line">    P2_v.append(P2.v)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># calculate force</span></span><br><span class="line">    P1_force = calc_force(P1, P2, k=<span class="number">10</span>)</span><br><span class="line">    P2_force = calc_force(P2, P1, k=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># update</span></span><br><span class="line">    P1.update(P1_force)</span><br><span class="line">    P2.update(P2_force)</span><br></pre></td></tr></table></figure></li><li><p>어떻게 움직였나 한번 봅시다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">P1_pos = np.array(P1_pos)</span><br><span class="line">P2_pos = np.array(P2_pos)</span><br><span class="line"></span><br><span class="line">plt.plot(P1_pos[:, <span class="number">0</span>], P1_pos[:, <span class="number">1</span>], <span class="string">&quot;o-&quot;</span>, label=<span class="string">&quot;P1&quot;</span>)</span><br><span class="line">plt.plot(P2_pos[:, <span class="number">0</span>], P2_pos[:, <span class="number">1</span>], <span class="string">&quot;o-&quot;</span>, label=<span class="string">&quot;P2&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;position&quot;</span>, pad=<span class="number">12</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure><p><img src="1_gravity_03.png"></p></li><li><p><b>뭔가 이상합니다.</b></p></li><li><p>시작점은 P1이 [1, 1], P2가 [-1, -1]이었습니다.</p></li><li><p>서로 끌어당기다가 한가운데인 [0, 0]에서 만나야 할 것 같은데 한참을 더 지나갑니다.</p></li><li><p>x방향 속도를 그려봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(np.array(P1_v)[:, <span class="number">0</span>], <span class="string">&quot;o-&quot;</span>, label=<span class="string">&quot;P1&quot;</span>)</span><br><span class="line">plt.plot(np.array(P2_v)[:, <span class="number">0</span>], <span class="string">&quot;o-&quot;</span>, label=<span class="string">&quot;P2&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;x-directional velocity (m/s&quot;</span>, pad=<span class="number">12</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure><p><img src="1_gravity_04.png"></p></li><li><p>120번째 step 부근에서 속도가 크게 빨라졌다가 감소하지만 부호는 바뀌지 않습니다.</p></li><li><p>원점을 지나 힘이 거꾸로 작용해도 관성에 의해 서로를 지나쳤고, </p></li><li><p>이 때 작용하는 힘은 다시 불러오기엔 역부족인 듯 합니다.</p></li></ul><h2 id="3-4-동영상-제작-함수"><a href="#3-4-동영상-제작-함수" class="headerlink" title="3.4. 동영상 제작 함수"></a>3.4. 동영상 제작 함수</h2><ul><li><p>동영상으로 확실하게 살펴봅니다.</p></li><li><p>왠지 앞으로 동영상을 자주 만들 것 같습니다.</p></li><li><p>N개의 입자를 다룰 수 있도록 앞의 코드를 일반화합니다.</p></li><li><p><b>질량에 따라 입자의 크기와 색이 바뀌도록</b> 설정을 해두고,</p></li><li><p><b>컬러맵을 사용해서 입자마다 다른 색을 두르도록</b>합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cmap = plt.get_cmap(<span class="string">&quot;tab10&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_animation</span>(<span class="params">Ps, Ps_pos, ts, title, legend=<span class="literal">True</span></span>):</span></span><br><span class="line">    fig, ax = plt.subplots(figsize=(<span class="number">4</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    mfcs = [<span class="string">&quot;k&quot;</span> <span class="keyword">if</span> P.mass &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;w&quot;</span> <span class="keyword">for</span> P <span class="keyword">in</span> Ps]</span><br><span class="line">    mss = [<span class="number">12</span>*np.sqrt(<span class="built_in">abs</span>(P.mass)) <span class="keyword">for</span> P <span class="keyword">in</span> Ps]</span><br><span class="line">    plots = [ax.plot([], [], marker=<span class="string">&quot;o&quot;</span>, mfc=mfc, mec=cmap(j/<span class="number">10</span>), mew=<span class="number">3</span>, ms=ms, label=<span class="string">f&quot;P<span class="subst">&#123;j+<span class="number">1</span>&#125;</span>&quot;</span>) </span><br><span class="line">             <span class="keyword">for</span> j, (P_pos, mfc, ms) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(Ps_pos, mfcs, mss))]</span><br><span class="line">    time_text = ax.text(<span class="number">0.5</span>, <span class="number">0.9</span>, <span class="string">f&quot;&quot;</span>, transform=ax.transAxes, ha=<span class="string">&quot;center&quot;</span>)</span><br><span class="line">    title = ax.set_title(title, pad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">    ax.set_xlim(-<span class="number">1.1</span>, <span class="number">1.1</span>)</span><br><span class="line">    ax.set_ylim(-<span class="number">1.1</span>, <span class="number">1.1</span>)</span><br><span class="line">    <span class="keyword">if</span> legend:</span><br><span class="line">        ax.legend(loc=<span class="string">&quot;lower right&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updatefig</span>(<span class="params">i</span>):</span></span><br><span class="line">        [plot[<span class="number">0</span>].set_data(P_pos[i][<span class="number">0</span>], P_pos[i][<span class="number">1</span>]) <span class="keyword">for</span> plot, P_pos <span class="keyword">in</span> <span class="built_in">zip</span>(plots, Ps_pos)]       </span><br><span class="line">        time_text.set_text(<span class="string">f&quot;t = <span class="subst">&#123;ts[i]:<span class="number">.03</span>f&#125;</span> sec.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> fig,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ani = animation.FuncAnimation(fig, updatefig, interval=<span class="number">100</span>, blit=<span class="literal">True</span>, repeat=<span class="literal">False</span>, frames=<span class="built_in">len</span>(ts))</span><br><span class="line">    <span class="keyword">return</span> ani</span><br></pre></td></tr></table></figure></li><li><p>아까 데이터를 다시 넣어 애니메이션을 만듭니다.</p></li><li><p><b>서로를 지나쳐간 뒤에 속도가 줄어드는 모습</b>이 관찰됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ani = gen_animation([P1, P2], [P1_pos, P2_pos], ts, <span class="string">&quot;position in xy coordinate&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="1_gravity_05.gif"><br></p></li></ul><h1 id="4-고정된-물체와-움직이는-물체"><a href="#4-고정된-물체와-움직이는-물체" class="headerlink" title="4. 고정된 물체와 움직이는 물체"></a>4. 고정된 물체와 움직이는 물체</h1><h2 id="4-1-N개의-물체-사이-만유인력"><a href="#4-1-N개의-물체-사이-만유인력" class="headerlink" title="4.1. N개의 물체 사이 만유인력"></a>4.1. N개의 물체 사이 만유인력</h2><ul><li>이제 우리는 만유인력을 계산하고 그릴 수 있습니다.</li><li>N개의 물체를 그리는 함수를 만들었으니, <b>N개의 물체 사이 힘을 계산하는 함수</b>도 만듭시다.</li><li>2중 for loop을 사용해서 모든 입자간의 인력을 계산하여 총 합을 구합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_force</span>(<span class="params">Ps, k=<span class="number">10</span>, iter_max=<span class="number">150</span></span>):</span></span><br><span class="line">    Ps_pos = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> Ps:</span><br><span class="line">        Ps_pos.append([])</span><br><span class="line"></span><br><span class="line">    ts = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iter_max):</span><br><span class="line">        <span class="comment"># time update</span></span><br><span class="line">        ts.append(i*dt)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># position update</span></span><br><span class="line">        <span class="keyword">for</span> P, P_pos <span class="keyword">in</span> <span class="built_in">zip</span>(Ps, Ps_pos):</span><br><span class="line">            P_pos.append(P.pos)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># calculate force</span></span><br><span class="line">        P_splits = [[P, <span class="built_in">list</span>(<span class="built_in">set</span>(Ps) - <span class="built_in">set</span>([P]))] <span class="keyword">for</span> P <span class="keyword">in</span> Ps]</span><br><span class="line">        <span class="keyword">for</span> j, (P_self, P_others) <span class="keyword">in</span> <span class="built_in">enumerate</span>(P_splits):</span><br><span class="line">            P_self_force = np.array([<span class="number">0.0</span>, <span class="number">0.0</span>])</span><br><span class="line">            <span class="keyword">for</span> P_other <span class="keyword">in</span> P_others:</span><br><span class="line">                P_self_force += calc_force(P_self, P_other, k=k)</span><br><span class="line">            <span class="comment"># update force</span></span><br><span class="line">            P_self.update(P_self_force)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ps, Ps_pos, ts</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-2-고정된-물체와-던져진-물체"><a href="#4-2-고정된-물체와-던져진-물체" class="headerlink" title="4.2. 고정된 물체와 던져진 물체"></a>4.2. 고정된 물체와 던져진 물체</h2><ul><li><p>1번 물체 P1은 원점 [0,0]에 고정하고</p></li><li><p>2번 물체 P2는 [0, 0.7]에서 $-x$방향으로 던집니다.</p></li><li><p><b>P2의 속도에 따른 궤적 변화</b>를 살펴봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 물체 정의</span></span><br><span class="line">P1_mass, P2_mass = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">P1_pos, P2_pos = [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0.7</span>]</span><br><span class="line">P1_v, P2_v = [<span class="number">0</span>, <span class="number">0</span>], [-<span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line">P1_fix, P2_fix = <span class="literal">True</span>, <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">P1 = Particle(P1_mass, P1_pos, P1_v, P1_fix)</span><br><span class="line">P2 = Particle(P2_mass, P2_pos, P2_v, P2_fix)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 만유인력 계산, 시각화</span></span><br><span class="line">Ps = [P1, P2]</span><br><span class="line">Ps, Ps_pos, ts = run_force(Ps, k=<span class="number">10</span>, iter_max=<span class="number">150</span>)</span><br><span class="line">ani = gen_animation(Ps, Ps_pos, ts, <span class="string">&quot;position in xy coordinate&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="1_gravity_06.gif"><br></p></li><li><p><b>SF영화에서 많이 본 듯한 모습</b>이 관찰됩니다.</p></li><li><p>중앙의 P1을 축으로 빙 돌아 자신이 온 방향으로 나갑니다.</p></li></ul><ul><li>이번엔 P2를 조금 빠르게 던집니다.</li><li>나머진 가만히 두고 position 초기화, velocity 재설정만 추가합니다.</li><li>만유인력과 원심력이 같아지는 속도에서는 물체가 지표면에서 추락하지 않고 궤도를 그립니다.</li><li>우리가 사용한 질량 등을 넣으면 다음과 같이 정리됩니다.</li></ul><p>$$ v = \sqrt{\frac{km_1}{r}} = 3.8 [\textrm{m}/\textrm{s}]$$</p><ul><li><p>이를 <b>제1 우주 속도</b>라고 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 시작점과 속도 재설정</span></span><br><span class="line">P1_pos, P2_pos = [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0.7</span>]</span><br><span class="line">P1_v, P2_v = [<span class="number">0</span>, <span class="number">0</span>], [-<span class="number">3.8</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">P1 = Particle(P1_mass, P1_pos, P1_v, P1_fix)</span><br><span class="line">P2 = Particle(P2_mass, P2_pos, P2_v, P2_fix)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 만유인력 계산, 시각화</span></span><br><span class="line">Ps = [P1, P2]</span><br><span class="line">Ps, Ps_pos, ts = run_force(Ps, k=<span class="number">10</span>, iter_max=<span class="number">150</span>)</span><br><span class="line">ani = gen_animation(Ps, Ps_pos, ts, <span class="string">&quot;position in xy coordinate&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="1_gravity_07.gif"><br></p></li><li><p>쪼개진 시간과 유효숫자 등의 차이로 원궤도에서는 다소 어긋났습니다.</p></li><li><p>하지만 <b>전반적으로 원을 그리며 제 자리로 옵니다.</b></p></li></ul><ul><li><b>더 빠르면?</b> 말할 것도 없습니다.</li><li>도망가 버립니다.</li><li>속도를 $5 [\textrm{m}/\textrm{s}]$로 빠르게 했을 때 그림입니다.<br><br><img src="1_gravity_08.gif"><br></li></ul><h1 id="5-마이너스-질량"><a href="#5-마이너스-질량" class="headerlink" title="5. 마이너스 질량"></a>5. 마이너스 질량</h1><ul><li><p>실제로는 불가능하지만 코드에는 마이너스 질량을 넣을 수 있습니다.</p></li><li><p><b>10배 무거운 마이너스 질량의 벽</b>을 뚫을 수 있나 봅시다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">P0_mass, P1_mass, P2_mass, P3_mass, P4_mass = <span class="number">1</span>, -<span class="number">10</span>, -<span class="number">10</span>, -<span class="number">10</span>, -<span class="number">10</span></span><br><span class="line">P0_pos, P1_pos, P2_pos, P3_pos, P4_pos = [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0.7</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0.7</span>], [-<span class="number">0.7</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">0.7</span>]</span><br><span class="line">P0_v, P1_v, P2_v, P3_v, P4_v = [<span class="number">3</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">P0_fix, P1_fix, P2_fix, P3_fix, P4_fix = <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">P0 = Particle(P0_mass, P0_pos, P0_v, P0_fix)</span><br><span class="line">P1 = Particle(P1_mass, P1_pos, P1_v, P1_fix)</span><br><span class="line">P2 = Particle(P2_mass, P2_pos, P2_v, P2_fix)</span><br><span class="line">P3 = Particle(P3_mass, P3_pos, P3_v, P3_fix)</span><br><span class="line">P4 = Particle(P4_mass, P4_pos, P4_v, P4_fix)</span><br><span class="line"></span><br><span class="line">Ps = [P0, P1, P2, P3, P4]</span><br><span class="line">Ps, Ps_pos, ts = run_force(Ps, k=<span class="number">10</span>, iter_max=<span class="number">50</span>)</span><br><span class="line">ani = gen_animation(Ps, Ps_pos, ts, <span class="string">&quot;position in xy coordinate&quot;</span>, legend=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="1_gravity_09.gif"><br></p></li><li><p>$(3, 1) [\textrm{m}/\textrm{s}]$로는 부족합니다. 못 나갑니다.</p></li><li><p>$(5, 2) [\textrm{m}/\textrm{s}]$는 어떨까요?<br><br><img src="1_gravity_10.gif"><br></p></li><li><p>몸부림 끝에 탈출에 성공합니다.</p></li></ul><h1 id="6-정전기력"><a href="#6-정전기력" class="headerlink" title="6. 정전기력"></a>6. 정전기력</h1><ul><li>만유인력 방정식은 <b>정전기력<code>electrostatic force</code>과 매우 비슷합니다.</b></li><li>전하 $q_1$과 $q_2$를 가진 전하 두 개가 거리 $r$만큼 멀리 있다면 이들 사이에는 아래 힘이 작용합니다.</li></ul><p>$$F = k\frac{q_1 q_2}{r^2}$$</p><ul><li><p>상수 $k$는 $8.99 \times 10^9 [N \cdot m^2 \cdot C^{-2}]$ 입니다.</p></li><li><p>일반적으로 만유인력보다 훨씬 강하기 때문에 우리 일상에서 자주 볼 수 있습니다.<br><br><img src="1_gravity_12.gif" alt="전설이 되어버린 일렉트릭 정화: EXID"><br></p></li><li><p>정전기력은 부호가 다르면 끌어당기고 부호가 같면 밀칩니다.</p></li><li><p>위에서 마이너스 질량을 사용한 예시는 같은 부호의 정전기력 시각화로 볼 수도 있습니다.</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Physics/">Physics</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/numpy/">numpy</category>
      
      
    </item>
    
    <item>
      <title>colorsys - Conversions between Color Systems</title>
      <link>https://jehyunlee.github.io/2022/01/04/Python-DS-95-tiger/</link>
      <guid>https://jehyunlee.github.io/2022/01/04/Python-DS-95-tiger/</guid>
      <pubDate>Mon, 03 Jan 2022 22:25:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;이미지를 처리하는 파이썬 라이브러리는 많습니다.&lt;/li&gt;
&lt;li&gt;가장 잘 알려진 opencv와 pillow를 비롯해서 matplotlib도 이미지 처리를 합니다.&lt;/li&gt;
&lt;li&gt;colorsys라는 파이썬 기본 라이브러리가 있습니다.&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>이미지를 처리하는 파이썬 라이브러리는 많습니다.</li><li>가장 잘 알려진 opencv와 pillow를 비롯해서 matplotlib도 이미지 처리를 합니다.</li><li>colorsys라는 파이썬 기본 라이브러리가 있습니다.</li><li>색 공간을 변환하는 라이브러리인데, 이것만 잘 써도 할 수 있는 게 많습니다.</li></ul><h1 id="1-예제-이미지"><a href="#1-예제-이미지" class="headerlink" title="1. 예제 이미지"></a>1. 예제 이미지</h1><blockquote><p><a href="https://commons.wikimedia.org/wiki/File:Siberischer_tiger_de_edit02.jpg">wikimedia commons: Siberischer tiger de dedit02.jpg</a></p></blockquote><ul><li>예제로 사용할 이미지를 가져옵니다.</li><li>호랑이 해이니 호랑이 사진을 사용해 보겠습니다.</li><li>저작권 걱정이 없는 <a href="https://commons.wikimedia.org/wiki/File:Siberischer_tiger_de_edit02.jpg">wikimedia</a>에서 사진을 내려받아 <code>tiger.jpg</code>라고 저장합니다.</li></ul><p><img src="tiger_8.png"><br></p><h1 id="2-Python에서-읽기"><a href="#2-Python에서-읽기" class="headerlink" title="2. Python에서 읽기"></a>2. Python에서 읽기</h1><ul><li><p>먼저 기본 라이브러리를 부르고</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure></li><li><p>이미지를 불러옵니다.</p></li><li><p><code>plt.imread()</code>명령으로 읽은 이미지는 numpy array로 저장됩니다.</p></li><li><p><code>.shape</code>으로 dimension을 확인하면 1200 x 1600 x 3입니다.</p></li><li><p>세로 1200, 가로 1600의 3차원(RGB) 이미지입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img_org = plt.imread(<span class="string">&quot;tiger.jpg&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(img_org.shape)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">8</span>, <span class="number">6</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.imshow(img_org)</span><br><span class="line">ax.set_xticks([])</span><br><span class="line">ax.set_yticks([])</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1200, 1600, 3)</span><br></pre></td></tr></table></figure><p><img src="tiger_1.png"><br></p></li></ul><h1 id="3-CIELab-color-space"><a href="#3-CIELab-color-space" class="headerlink" title="3. CIELab color space"></a>3. CIELab color space</h1><blockquote><p><a href="https://colorspacious.readthedocs.io/en/latest/">colorspacious</a><br><a href="https://jehyunlee.github.io/2021/03/22/Python-DS-63-mpl_colors_qualitative/">Pega Devlog: 색의 속성에 대한 단어들</a></p></blockquote><ul><li><p>사람이 인지하는 밝은 정도, 즉 <b>휘도(luminance)</b>를 파악합니다.</p></li><li><p>그림을 구성하는 RGB를 [colorspacious] 라이브러리의 <code>cspace_converter</code>를 사용해 <b>CIELab 색공간으로 변환</b>합니다.</p></li><li><p>CIELab 색공간의 첫번째 채널이 <b>$L^*$</b>, 즉 휘도입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># convert to CIELab</span></span><br><span class="line"><span class="keyword">from</span> colorspacious <span class="keyword">import</span> cspace_converter</span><br><span class="line"></span><br><span class="line">img_lab = cspace_converter(<span class="string">&quot;sRGB1&quot;</span>, <span class="string">&quot;CAM02-UCS&quot;</span>)(img_org/<span class="number">255</span>)</span><br><span class="line"><span class="built_in">print</span>(img_lab.shape)</span><br><span class="line">img_L = img_lab[:,:,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">8</span>, <span class="number">6</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.imshow(img_L, cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">ax.set_xticks([])</span><br><span class="line">ax.set_yticks([])</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1200, 1600, 3)</span><br></pre></td></tr></table></figure><p><img src="tiger_2.png"><br></p></li><li><p>흑백 사진으로 변환되었습니다.</p></li><li><p>여기 보이는 회색조가 우리 눈이 느끼는 밝기입니다.</p></li></ul><h1 id="4-HLS-color-space"><a href="#4-HLS-color-space" class="headerlink" title="4. HLS color space"></a>4. HLS color space</h1><blockquote><p><a href="https://en.wikipedia.org/wiki/HSL_and_HSV">wikipedia: HSL and HSV</a><br><a href="https://docs.python.org/3/library/colorsys.html">python colorsys</a></p></blockquote><ul><li><p>HSV (hue, saturation, value) 색공간과 더불어 HSL, 또는 HLS 색 공간이 사용됩니다.</p></li><li><p>색상(hue)과 명도(lightness), 채도(saturation)를 따로 조정할 수 있다는 장점이 있습니다.<br><br><img src="tiger_9.png"><br></p></li><li><p>python에 기본으로 내장된 <b><code>colorsys</code> 라이브러리는 색 공간 변환에 충실합니다.</b></p></li><li><p>RGB, YIQ, HLS, HSV 공간을 오가는 기능을 간단하게 제공합니다.</p></li><li><p>호랑이 이미지를 HLS 공간으로 바꾸어 hue, lightness, saturation 분포를 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> colorsys</span><br><span class="line"></span><br><span class="line">img_hls = np.array([colorsys.rgb_to_hls(*c) <span class="keyword">for</span> c <span class="keyword">in</span> (img_org/<span class="number">255</span>).reshape((<span class="number">1600</span>*<span class="number">1200</span>, <span class="number">3</span>))]).T</span><br><span class="line"><span class="built_in">print</span>(img_hls.shape)</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">8</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, (title, ax) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>([<span class="string">&quot;hue&quot;</span>, <span class="string">&quot;lightness&quot;</span>, <span class="string">&quot;saturation&quot;</span>], axs)):</span><br><span class="line">    sns.histplot(img_hls[i], kde=<span class="literal">True</span>, bins=np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">21</span>), ax=ax)</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;xx-large&quot;</span>, pad=<span class="number">8</span>)</span><br></pre></td></tr></table></figure><p><img src="tiger_3.png"><br></p></li><li><p>lightness를 보면 어두운 부분이 많은 것 같고,</p></li><li><p>saturation을 보면 원색에 가까운 비중이 상당히 높습니다.</p></li><li><p><b>hue가 좀 독특한데, 왼쪽에 몰려 있습니다.</b></p></li><li><p>잘못 처리한 것이 아닌지, hue의 숫자가 의미하는 색을 출력합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hue check</span></span><br><span class="line">hues = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">21</span>)[:<span class="number">20</span>]</span><br><span class="line">rgbs = <span class="built_in">list</span>(<span class="built_in">map</span>(colorsys.hls_to_rgb, *np.array([[h, <span class="number">0.5</span>, <span class="number">1</span>] <span class="keyword">for</span> h <span class="keyword">in</span> hues]).T))</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(ncols=<span class="number">10</span>, nrows=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> ax, rgb, hue <span class="keyword">in</span> <span class="built_in">zip</span>(axes.ravel(), rgbs, hues):</span><br><span class="line">    ax.set_facecolor(rgb)</span><br><span class="line">    ax.set_xticks([])</span><br><span class="line">    ax.set_yticks([])</span><br><span class="line">    ax.set_xlabel(<span class="string">f&quot;<span class="subst">&#123;hue:<span class="number">.2</span>f&#125;</span>&quot;</span>, fontsize=<span class="string">&quot;x-large&quot;</span>, labelpad=<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p><img src="tiger_4.png"><br></p></li><li><p>히스토그램에서 hue가 몰려 있는 0.25 아래 부분은 빨강, 주황, 노랑, 연두입니다.</p></li><li><p><b>호랑이와 들판을 이루고 있는 색</b>입니다. 그럴 만 하네요. 정상입니다. :)</p></li><li><p>호랑이 그림에서 hue, lightness, saturation이 어떻게 분포하고 있는지를 봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">8</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, (title, ax) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>([<span class="string">&quot;hue&quot;</span>, <span class="string">&quot;lightness&quot;</span>, <span class="string">&quot;saturation&quot;</span>], axs)):</span><br><span class="line">    vmax = <span class="number">0.3</span> <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    im = ax.imshow(img_hls[i].reshape(<span class="number">1200</span>, <span class="number">1600</span>), cmap=<span class="string">&quot;rainbow&quot;</span>, vmin=<span class="number">0</span>, vmax=vmax)</span><br><span class="line">    plt.colorbar(im, orientation=<span class="string">&quot;horizontal&quot;</span>, ax=ax)</span><br><span class="line">    ax.set_xticks([])</span><br><span class="line">    ax.set_yticks([])</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;xx-large&quot;</span>, pad=<span class="number">8</span>)</span><br></pre></td></tr></table></figure><p><img src="tiger_5.png"><br></p></li><li><p>hue만 범위를 0-0.3으로 그리고 나머지는 0-1로 그렸습니다.</p></li><li><p>범위를 쉽게 파악하고자 의도적으로 rainbow colormap을 사용했습니다.</p></li><li><p><b>배경과 호랑이는 hue와 lightness로 쉽게 구분됩니다.</b></p></li><li><p>배경 일부에 호랑이와 hue가 같은 구간이 있는데 <b>lightness를 섞으면 같이 구분할 수 있습니다.</b></p></li></ul><ul><li><p>lightness threshold를 0.4로 고정하고</p></li><li><p>hue threshold (<code>h_th</code>)를 0.1~0.3으로 바꾸면서 호랑이 선택 범위를 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tiger selection</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"></span><br><span class="line">img_hls_tiger = deepcopy(img_hls)</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">8</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">h_ths = [<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>]</span><br><span class="line"><span class="keyword">for</span> h_th, ax <span class="keyword">in</span> <span class="built_in">zip</span>(h_ths, axs):</span><br><span class="line">    chk_tiger = np.where((img_hls[<span class="number">0</span>] &lt; h_th) &amp; (img_hls[<span class="number">1</span>] &gt; <span class="number">0.4</span>), <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    ax.imshow(chk_tiger.reshape(<span class="number">1200</span>, <span class="number">1600</span>), cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    ax.set_xticks([])</span><br><span class="line">    ax.set_yticks([])</span><br><span class="line">    ax.set_title(<span class="string">f&quot;<span class="subst">&#123;h_th&#125;</span>&quot;</span>, fontsize=<span class="string">&quot;xx-large&quot;</span>, pad=<span class="number">8</span>)</span><br></pre></td></tr></table></figure><p><img src="tiger_6.png"><br></p></li><li><p>다른 데는 비슷한데 <b>호랑이 이마와 왼쪽 뺨</b>에서 차이가 보입니다.</p></li><li><p>0.3으로 올리면 얼굴은 검은 줄무늬를 제외하고 거의 선택이 되고 배경으로 넘어가지 않네요.</p></li><li><p>hue threshold를 0.3으로 설정합니다.</p></li></ul><ul><li><p>1600 x 1200개의 픽셀 중 hue는 0.3 미만, lightness는 0.4 초과하는 범위를 잡습니다.</p></li><li><p>호랑이 얼굴의 명도는 올리고 채도는 낮춰서 <b>하얀 장로 호랑이 느낌</b>이 들도록 바꿉니다.</p></li><li><p><del>사실 올해가 검은 호랑이 해라 검게 하고 싶었는데 어떻게 해도 안예쁘더군요.</del></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">idx_tiger = np.where((img_hls[<span class="number">0</span>] &lt; <span class="number">0.3</span>) &amp; (img_hls[<span class="number">1</span>] &gt; <span class="number">0.4</span>))[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> idx_tiger:</span><br><span class="line">    img_hls_tiger[<span class="number">1</span>, idx] = <span class="built_in">min</span>(img_hls_tiger[<span class="number">1</span>, idx]+<span class="number">0.6</span>, <span class="number">1</span>)</span><br><span class="line">    img_hls_tiger[<span class="number">2</span>, idx] = <span class="built_in">max</span>(img_hls_tiger[<span class="number">2</span>, idx]-<span class="number">0.6</span>, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">img_rgb_tiger = np.array([colorsys.hls_to_rgb(*c) <span class="keyword">for</span> c <span class="keyword">in</span> img_hls_tiger.T])</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">8</span>, <span class="number">6</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.imshow(img_rgb_tiger.reshape(<span class="number">1200</span>, <span class="number">1600</span>, <span class="number">3</span>))</span><br><span class="line">ax.set_xticks([])</span><br><span class="line">ax.set_yticks([])</span><br></pre></td></tr></table></figure><p><img src="tiger_7.png"><br></p></li><li><p><b>호랑이 해 모두 새해 복 많이 받으시기 바랍니다.</b></p></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/colorsys/">colorsys</category>
      
      
    </item>
    
    <item>
      <title>Sci Vis) 2. In a Far Distance Galaxy</title>
      <link>https://jehyunlee.github.io/2021/12/28/Python-DS-94-rougier02/</link>
      <guid>https://jehyunlee.github.io/2021/12/28/Python-DS-94-rougier02/</guid>
      <pubDate>Mon, 27 Dec 2021 15:50:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Scientific Visualization: Python + Matplotlib&lt;/strong&gt; 책에는 최고 수준의 시각화 기술이 담겼습니다.&lt;/li&gt;
&lt;li&gt;높은 수준에 비해 설명이 다소 짧아 초심자에게 어려워 보였습</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><strong>Scientific Visualization: Python + Matplotlib</strong> 책에는 최고 수준의 시각화 기술이 담겼습니다.</li><li>높은 수준에 비해 설명이 다소 짧아 초심자에게 어려워 보였습니다.</li><li>저자인 Nicolas P. Rougier 박사님의 허가 하에 일부를 해설합니다.</li><li>이 시리즈는 해외 독자를 위해 영어를 회색 상자 안에 병기합니다.</li></ul><style>    .en {        background-color: #EEEEEE;        padding: 0px;        margin-top: 0px;        margin-bottom: 0px;        margin-left: 0px;        margin-right: 0px;    }</style><div class="en" bgcolor="#AAAAAA"><ul><li> <b>Scientific Visualization: Python + Matplotlib</b> contains cutting-edge visualization skills and examples of Matplotlib and Python.  </li><li> Despite its high quality content, relatively short explanations in the book may prevent the readers from fully grasping all of its contents.  </li><li> With the permission of the author, Dr. Nicolas P. Rougier, I'll try to help the beginners understand the more complex concepts within the book by providing explanations and commentary where needed.  </li><li> This series will be posted in <b>English</b> as well as Korean, for international readers.  </ul></div><p><blockquote><p><b>영어 감수:</b> <a href="mailto:jsleeindex@gmail.com">EY한영회계법인 이지수 시니어</a></p></blockquote><blockquote><p><a href="https://github.com/rougier/scientific-visualization-book">Scientific Visualization: Python + Matplotlib</a><br><a href="https://github.com/rougier">github: Nicolas P. Rougier</a></p></blockquote><p><img src="92_rougier01_13.png"><br></p><h1 id="1-Star-Wars-text"><a href="#1-Star-Wars-text" class="headerlink" title="1. Star Wars text"></a>1. Star Wars text</h1><blockquote><p><a href="https://github.com/jehyunlee/scientific-visualization-book/blob/master/code/typography/text-starwars.py">text-starwars.py</a></p></blockquote><p><img src="text-starwars_org.png"><br></p><ul><li>이번에 살펴볼 그림은 영화 스타워즈의 도입부처럼 글자들이 무한 원점을 향해 소멸하는 모양입니다.</li><li>글자의 크기 뿐 아니라 색상도 점차 희미해져가는 모습입니다.</li></ul><div class="en"><ul><li> This time we are going to plot lines of texts vanishing towards the point at infinity, like the lines of texts at the beginning of a Star Wars movie.</li><li> Not only does the size of the font diminish as the text approach infinity, the opacity of the text also diminish. </li></ul></div><h1 id="2-prerequisites"><a href="#2-prerequisites" class="headerlink" title="2. prerequisites"></a>2. prerequisites</h1><ul><li>이번 코드는 딱 하나의 기술만 알면 됩니다.</li><li>바로 <b>어떻게 글자의 형상을 변환하는지</b>입니다.</li><li>원본 코드를 이해하기 위해서 예제 코드를 먼저 봅시다.</li></ul><div class="en"><ul><li> We have only one skill to learn:</li><li> <b>How to transform shapes of the letters.</b></li><li> Let's take a look at the example codes to understand the Nicolas's.</li></ul></div><h2 id="2-1-import-libraries"><a href="#2-1-import-libraries" class="headerlink" title="2.1. import libraries"></a>2.1. import libraries</h2><ul><li>기본 라이브러리와 함께 <b>텍스트 형상을 제어할 라이브러리</b>를 불러옵니다.</li><li>text를 Path로 만드는 <code>TextPath</code>와 Path를 Patch로 만드는 <code>PathPatch</code>를 불러옵니다.</li></ul><div class="en"><ul><li> We need to import <b>text shape control libraries</b> as well as basic ones.</li><li> <b><code>TextPath</code></b> to convert text to Path object and <b><code>PathPatch</code></b> to turn Path into Patch is imported.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.textpath <span class="keyword">import</span> TextPath</span><br><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> PathPatch</span><br></pre></td></tr></table></figure><h2 id="2-2-prepare-an-example-text"><a href="#2-2-prepare-an-example-text" class="headerlink" title="2.2. prepare an example text"></a>2.2. prepare an example text</h2><ul><li>복잡한 수식으로 이루어진 예제 텍스트를 준비합니다.</li><li>Matplotlib의 <code>Axes.text()</code>명령으로 한 가운데 큼지막하게 넣습니다.</li></ul><div class="en"><ul><li> An example text made up of complicated mathematics equation is prepared.</li><li> The text is placed at the center of the figure with <code>Axes.text()</code> function of Matplotlib.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">eq = <span class="string">r&quot;$\left[\sum_&#123;n=1&#125;^\infty\frac&#123;-e^&#123;i\pi&#125;&#125;&#123;2^n&#125;\right]$!&quot;</span></span><br><span class="line">txt = ax.text(<span class="number">0.5</span>, <span class="number">0.5</span>, eq, ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>, fontsize=<span class="number">90</span>)</span><br></pre></td></tr></table></figure><p><img src="94_rougier02_01.png"><br></p><h2 id="2-3-Text-to-Path"><a href="#2-3-Text-to-Path" class="headerlink" title="2.3. Text to Path"></a>2.3. <code>Text</code> to <code>Path</code></h2><blockquote><p><a href="https://matplotlib.org/stable/api/textpath_api.html">matplotlib.textpath</a></p></blockquote><ul><li><code>Text</code> 객체를 <code>Path</code>객체로 바꿉니다.</li><li><code>Path</code> 객체는 일종의 다각형으로 <b>꼭지점(vertices)과 모서리(edges), 그리고 구성 형상(codes)으로 이루어져 있습니다</b>.</li><li><code>Path</code> 객체로 변환하고 vertices를 추출해서 좌표를 확인합니다.</li></ul><div class="en"><ul><li> It's time to convert <code>Text</code> object into <code>Path</code> object.</li><li> <code>Path</code> object is consisted of <b>points(vertices), lines(edges) and shapes(codes)</b>.</li><li> We will be able to check the coordinates of the vertices after conversion by extracting vertices.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eq_path = TextPath((<span class="number">0</span>, <span class="number">0</span>), eq, size=<span class="number">90</span>) </span><br><span class="line"><span class="comment"># (0, 0)  : no offset</span></span><br><span class="line"><span class="comment"># size=90 : font size in points</span></span><br><span class="line"></span><br><span class="line">V = eq_path.vertices</span><br><span class="line">xmin, xmax = V[:, <span class="number">0</span>].<span class="built_in">min</span>(), V[:, <span class="number">0</span>].<span class="built_in">max</span>()</span><br><span class="line">ymin, ymax = V[:, <span class="number">1</span>].<span class="built_in">min</span>(), V[:, <span class="number">1</span>].<span class="built_in">max</span>()</span><br><span class="line"><span class="built_in">print</span>(xmin, xmax, ymin, ymax)</span><br></pre></td></tr></table></figure><ul><li><p>실행 결과:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.5 420.0953767578125 -86.41370141006101 140.0</span><br></pre></td></tr></table></figure></li><li><p>위 그림 눈금에 보이는 것보다 크기가 훨씬 큽니다.</p></li><li><p>화면의 눈금은 아무렇게나 적힌 값이고 치수는 points 단위입니다.</p></li></ul><div class="en"><ul><li> It is much larger than values seen from the ticks.</li><li> It should be noted that the tick labels are arbitrary, and the unit of dimension is points.</li></ul></div><ul><li>이제 <code>Path</code> 객체를 그림에 붙여봅니다.</li><li><code>Path</code>를 <code>Patch</code>로 변환한 뒤 <code>Axes.add_artist()</code>명령으로 붙입니다.</li><li>추출한 vertices를 함께 그려 비교합니다.</li></ul><div class="en"><ul><li> Let's put <code>Path</code> object onto the Axes.</li><li> <code>Path</code> is going to be turned into <code>Patch</code> object, then pasted by <code>Axes.add_artist()</code> function.</li><li> The vertices extracted from the <code>TextPath</code> will be drawn together for comparison.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.transforms <span class="keyword">import</span> IdentityTransform</span><br><span class="line"></span><br><span class="line"><span class="comment"># patch creation. IndentityTransform() does nothing.</span></span><br><span class="line">eq_patch = PathPatch(eq_path, ec=<span class="string">&quot;k&quot;</span>, fc=<span class="string">&quot;w&quot;</span>, transform=IdentityTransform())</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># text (original)</span></span><br><span class="line">ax.text(<span class="number">0.5</span>, <span class="number">0.5</span>, eq, ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>, fontsize=<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># vertices from Path</span></span><br><span class="line">ax.plot(V[:, <span class="number">0</span>], V[:, <span class="number">1</span>], <span class="string">&quot;o-&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Patch</span></span><br><span class="line">ax.add_artist(eq_patch)</span><br></pre></td></tr></table></figure><p><img src="94_rougier02_02.png"><br></p><ul><li><b>뭔가 잘못된 것 같아 보입니다.</b></li><li>Text, Path vertices와 Patch의 크기와 위치가 맞지 않습니다.</li><li>각기 원점의 정의와 화면에 표시되는 크기 기준이 달라서 그렇습니다.</li></ul><div class="en"><ul><li> <b>It seems something went wrong.</b></li><li> The sizes and locations of the Text, Path vertices and Patch are not coincide.</li><li> It's because of the mismatches of definitions on origin and size.</li></ul></div><h2 id="2-4-apply-offset"><a href="#2-4-apply-offset" class="headerlink" title="2.4. apply offset"></a>2.4. apply offset</h2><ul><li>위치 조정을 위해 <b>offset 설정</b>이 필요하며 다음과 같은 과정을 거쳐 진행됩니다.<br> ① <code>AuxTransformBox</code> 객체 생성<br> ② <code>AuxTransformBox</code>에 <code>Patch</code> 추가<br> ③ <b>offset</b> 지정<br> ④ <code>Matplotlib.Axes</code>에 <code>add_artist()</code>로 <code>AuxTransformBox</code> 객체 추가</li></ul><div class="en"><ul><li> <b>Setting offset</b> is required to adjust position.</li>   ① create <code>AuxTransformBox</code> object<br>   ② Add <code>Patch</code> on <code>AuxTransformBox</code><br>   ③ apply <b>offset</b><br>   ④ Add <code>AuxTransformBox</code> on <code>Matplotlib.Axes</code> using <code>add_artist()</code><br></ul></div><ul><li>③ 없이 Patch를 붙이면 다음과 같습니다.</li></ul><div class="en"><ul><li> At first, let's take a look without ③ applying offset.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.offsetbox <span class="keyword">import</span> AuxTransformBox</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">eq_patch = PathPatch(eq_path, ec=<span class="string">&quot;k&quot;</span>, fc=<span class="string">&quot;w&quot;</span>, transform=IdentityTransform())</span><br><span class="line">offsetbox = AuxTransformBox(IdentityTransform()) <span class="comment"># ①</span></span><br><span class="line">offsetbox.add_artist(eq_patch) <span class="comment"># ②</span></span><br><span class="line"></span><br><span class="line">ax.add_artist(offsetbox) <span class="comment"># ④</span></span><br></pre></td></tr></table></figure><p><img src="94_rougier02_04.png"><br></p><ul><li>이제 ③ <b>offset</b> 지정을 추가합니다.</li></ul><div class="en"><ul><li> Now we apply offset(③).</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">eq_patch = PathPatch(eq_path, ec=<span class="string">&quot;k&quot;</span>, fc=<span class="string">&quot;w&quot;</span>, transform=IdentityTransform())</span><br><span class="line">offsetbox = AuxTransformBox(IdentityTransform()) <span class="comment"># ①</span></span><br><span class="line">offsetbox.add_artist(eq_patch) <span class="comment"># ②</span></span><br><span class="line">offsetbox.set_offset((<span class="number">120</span>, <span class="number">48</span>)) <span class="comment"># ③</span></span><br><span class="line">ax.add_artist(offsetbox) <span class="comment"># ④</span></span><br></pre></td></tr></table></figure><p><img src="94_rougier02_05.png"><br></p><h2 id="2-5-manipulate-coordinates"><a href="#2-5-manipulate-coordinates" class="headerlink" title="2.5. manipulate coordinates"></a>2.5. manipulate coordinates</h2><ul><li>방금 우리는 <code>set_offset()</code>을 이용해서 Patch의 위치를 변경했습니다.</li><li>하지만 vertex 좌표를 조정하고 Path를 재구성해서 위치를 변경할 수도 있습니다.</li></ul><div class="en"><ul><li> We modified position of the Patch by applying <code>set_offset()</code>.</li><li> But there is another way - manipulating vertices coordinates and reconstructing Path.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.path <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="comment"># path from text</span></span><br><span class="line">eq_path = TextPath((<span class="number">0.5</span>, <span class="number">0.5</span>), eq, size=<span class="number">90</span>)</span><br><span class="line">Vc = eq_path.vertices  <span class="comment"># vertices coordinates</span></span><br><span class="line">codes = eq_path.codes  <span class="comment"># codes: Path parts</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ranges of coordinates</span></span><br><span class="line">xcmin, xcmax = Vc[:, <span class="number">0</span>].<span class="built_in">min</span>(), Vc[:, <span class="number">0</span>].<span class="built_in">max</span>()</span><br><span class="line">ycmin, ycmax = Vc[:, <span class="number">1</span>].<span class="built_in">min</span>(), Vc[:, <span class="number">1</span>].<span class="built_in">max</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;before centering: [<span class="subst">&#123;xcmin:<span class="number">.2</span>f&#125;</span>, <span class="subst">&#123;xcmax:<span class="number">.2</span>f&#125;</span>, <span class="subst">&#123;ycmin:<span class="number">.2</span>f&#125;</span>, <span class="subst">&#123;ycmax:<span class="number">.2</span>f&#125;</span>]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># X centering</span></span><br><span class="line">Px = Vc[:, <span class="number">0</span>] - (xcmax + xcmin)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Y centering</span></span><br><span class="line">Py = Vc[:, <span class="number">1</span>] - (ycmax + ycmin)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># coordinates check: centering</span></span><br><span class="line">xpmin, xpmax = Px.<span class="built_in">min</span>(), Px.<span class="built_in">max</span>()</span><br><span class="line">ypmin, ypmax = Py.<span class="built_in">min</span>(), Py.<span class="built_in">max</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;after centering: [<span class="subst">&#123;xpmin:<span class="number">.2</span>f&#125;</span>, <span class="subst">&#123;xpmax:<span class="number">.2</span>f&#125;</span>, <span class="subst">&#123;ypmin:<span class="number">.2</span>f&#125;</span>, <span class="subst">&#123;ypmax:<span class="number">.2</span>f&#125;</span>]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create new Path</span></span><br><span class="line">path_new = Path(np.array([Px, Py]).T, codes=codes)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># convert Path to Patch</span></span><br><span class="line">patch = PathPatch(path_new, facecolor=<span class="string">&quot;w&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, zorder=<span class="number">2</span>) </span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">ax.plot(Px, Py, <span class="string">&quot;o-&quot;</span>)  <span class="comment"># Path vetices</span></span><br><span class="line">ax.add_artist(patch)   <span class="comment"># Patch from Path</span></span><br><span class="line">ax.set_xlim((-<span class="number">250</span>, <span class="number">250</span>))</span><br><span class="line">ax.set_ylim((-<span class="number">150</span>, <span class="number">150</span>))</span><br></pre></td></tr></table></figure><ul><li>실행 결과: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before centering: [0.50, 420.10, -86.41, 140.00]</span><br><span class="line">after centering: [-209.80, 209.80, -113.21, 113.21]</span><br></pre></td></tr></table></figure></li></ul><p><img src="94_rougier02_06.png"><br></p><ul><li>Path vertices와 재구성한 Path를 겹쳐 그려보니 정확히 일치합니다. </li><li>Patch에는 없는 선이 Path vertices에 보입니다. <b>개별 다각형에 대한 정보가 없어서 그렇습니다.</b> </li><li><b><code>Path()</code> 실행시 <b><code>codes</code></b>를 추가함으로써 구분</b>되었습니다.</li></ul><div class="en"><ul><li> Reconstructed Path and Path vertices are prefectly overlapped.</li><li> Some lines that weren’t visible on the Patch can be seen on Path vertices. This is due to the <b>absence of information on individual polygons.</b></li><li> <codes>codes</codes> <b>is applied to distinguish each polygon parts.</b></li></ul></div><ul><li><b>꼭지점 좌표를 수정해서 Path를 재구성할 수 있다</b>는 말은 여러 <b>변형을 가할 수 있다</b>는 뜻입니다.</li><li>아래 부분은 늘리고 위 부분을 좁히면 그림을 앞으로 기울인 듯한 효과가 납니다.</li><li><b>스타워즈 오프닝</b>이 이렇게 시작합니다.</li></ul><div class="en"><ul><li> Since <b>the Path can be reconstructed after vertex coordinates modification, other transformation can be applied.</b></li><li> If we stretch the bottom and shrink the top, the figure seems to be tilted forward.</li><li> This is how the <b>Star Wars intro crawl</b> starts.</li></ul></div>&#123;% youtube tGsKzZtRwxw %&#125;<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># path from text</span></span><br><span class="line">eq_path = TextPath((<span class="number">0.5</span>, <span class="number">0.5</span>), eq, size=<span class="number">90</span>)</span><br><span class="line">Vc = eq_path.vertices</span><br><span class="line">codes = eq_path.codes</span><br><span class="line">xcmin, xcmax = Vc[:, <span class="number">0</span>].<span class="built_in">min</span>(), Vc[:, <span class="number">0</span>].<span class="built_in">max</span>()</span><br><span class="line">ycmin, ycmax = Vc[:, <span class="number">1</span>].<span class="built_in">min</span>(), Vc[:, <span class="number">1</span>].<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># X centering</span></span><br><span class="line">Px = Vc[:, <span class="number">0</span>] - (xcmax + xcmin)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Y centering</span></span><br><span class="line">Py = Vc[:, <span class="number">1</span>] - (ycmax + ycmin)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># X rescaling &lt;-- here!</span></span><br><span class="line">xfactor = <span class="number">0.002</span></span><br><span class="line">Px *= <span class="number">1</span> - (Py * xfactor)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create new Path</span></span><br><span class="line">path_new = Path(np.array([Px, Py]).T, codes=codes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># convert Path to Patch</span></span><br><span class="line">patch = PathPatch(path_new, facecolor=<span class="string">&quot;w&quot;</span>, ec=<span class="string">&quot;k&quot;</span>) </span><br></pre></td></tr></table></figure><p><img src="94_rougier02_07.png"><br></p><ul><li><b>이미지를 몇 겹으로 쌓은 효과</b>를 낼 수도 있습니다.</li><li>Patch를 y 축 방향으로 조금씩 움직이면서 색을 점점 밝게 입혀 보겠습니다.</li></ul><div class="en"><ul><li> We can <b>stack different layers of images on top of each other.</b></li><li> We will move The Patch along the y-axis a little bit, and apply brighter colors on it as it moves.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">ax.set_xlim((-<span class="number">250</span>, <span class="number">250</span>))</span><br><span class="line">ax.set_ylim((-<span class="number">150</span>, <span class="number">180</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    eq_path = TextPath((<span class="number">0.5</span>, <span class="number">0.5</span>), eq, size=<span class="number">90</span>)</span><br><span class="line">    Vc = eq_path.vertices</span><br><span class="line">    codes = eq_path.codes</span><br><span class="line">    xcmin, xcmax = Vc[:, <span class="number">0</span>].<span class="built_in">min</span>(), Vc[:, <span class="number">0</span>].<span class="built_in">max</span>()</span><br><span class="line">    ycmin, ycmax = Vc[:, <span class="number">1</span>].<span class="built_in">min</span>(), Vc[:, <span class="number">1</span>].<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># X centering</span></span><br><span class="line">    Px = Vc[:, <span class="number">0</span>] - (xcmax + xcmin)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Y centering</span></span><br><span class="line">    Py = Vc[:, <span class="number">1</span>] - (ycmax + ycmin)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># X rescaling</span></span><br><span class="line">    xfactor = <span class="number">0.002</span></span><br><span class="line">    Px *= <span class="number">1</span> - (Py * xfactor)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Y shifting</span></span><br><span class="line">    Py += i * <span class="number">15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># create new Path</span></span><br><span class="line">    path_new = Path(np.array([Px, Py]).T, codes=codes)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># convert Path to Patch</span></span><br><span class="line">    patch = PathPatch(path_new, facecolor=<span class="string">f&quot;<span class="subst">&#123;i*<span class="number">0.4</span>&#125;</span>&quot;</span>, ec=<span class="string">&quot;k&quot;</span>) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ax.add_artist(patch)</span><br></pre></td></tr></table></figure><p><img src="94_rougier02_08.png"><br></p><h1 id="3-In-Far-Distance-Galaxy"><a href="#3-In-Far-Distance-Galaxy" class="headerlink" title="3. In Far Distance Galaxy"></a>3. In Far Distance Galaxy</h1><ul><li><b>Zen of Python을 스타워즈 스타일로 변형합니다.</b></li><li>한 줄씩 읽어서 Patch로 바꾸어 점점 흐리게 기울인 듯 변형합니다.</li></ul><div class="en"><ul><li> <b>Zen of Python is going to be transformed to Star-Wars crawl style.</b></li><li> It will be transformed to tilted Patch line by line, and dimmed gradually.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">text = [</span><br><span class="line">    <span class="string">&quot;Beautiful is better than ugly.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Explicit is better than implicit.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Simple is better than complex.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Complex is better than complicated.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Flat is better than nested.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sparse is better than dense.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Readability counts.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># enlarged by 2 x 2</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">8.5</span>, <span class="number">4</span>))</span><br><span class="line">ax = fig.add_axes([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], aspect=<span class="number">1</span>, xlim=[-<span class="number">40</span>, <span class="number">40</span>], ylim=[-<span class="number">1</span>, <span class="number">25</span>])</span><br><span class="line">ax.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line"></span><br><span class="line">y = <span class="number">0</span></span><br><span class="line">size = <span class="number">6</span></span><br><span class="line">xfactor = <span class="number">1</span> / <span class="number">50</span></span><br><span class="line">yfactor = <span class="number">1</span> / <span class="number">120</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(text[::-<span class="number">1</span>]):</span><br><span class="line">    path = TextPath((<span class="number">0</span>, <span class="number">0</span>), line, size=size)</span><br><span class="line">    V = path.vertices</span><br><span class="line">    codes = path.codes</span><br><span class="line">    xmin, xmax = V[:, <span class="number">0</span>].<span class="built_in">min</span>(), V[:, <span class="number">0</span>].<span class="built_in">max</span>()</span><br><span class="line">    ymin, ymax = V[:, <span class="number">1</span>].<span class="built_in">min</span>(), V[:, <span class="number">1</span>].<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># X centering</span></span><br><span class="line">    Px = V[:, <span class="number">0</span>] - (xmax + xmin) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Moving whole text at y coordinates</span></span><br><span class="line">    Py = V[:, <span class="number">1</span>] + y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Rescaling along y</span></span><br><span class="line">    Py *= <span class="number">1</span> - (Py * yfactor)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Rescaling along x</span></span><br><span class="line">    Px *= <span class="number">1</span> - (Py * xfactor)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Update interlines</span></span><br><span class="line">    y += size * (<span class="number">1</span> - ymin * yfactor)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># create new Path</span></span><br><span class="line">    path_new = Path(np.array([Px, Py]).T, codes=codes)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># convert Path to Patch</span></span><br><span class="line">    patch = PathPatch(path_new, facecolor=<span class="string">&quot;%.2f&quot;</span> % (i / <span class="number">10</span>), linewidth=<span class="number">0</span>, clip_on=<span class="literal">False</span>)</span><br><span class="line">    ax.add_artist(patch)</span><br></pre></td></tr></table></figure><p><img src="text-starwars_org.png"><br></p><ul><li><b>스타워즈 원본에 가깝도록 색을 노랗게 바꿔보겠습니다.</b></li><li>Nicolas의 원본처럼 맨 앞을 선명하게 하고 뒤로 갈수록 어둡게 만듭니다.</li><li>Python의 기본 라이브러리인 <code>colorsys</code>를 사용해 RGB 색공간을 HLS 공간으로 바꾸어 밝기만 조정합니다.</li></ul><div class="en"><ul><li> <b>Additionally, we are going to paint it in yellow color, closer to the original Star Wars intro.</b></li><li> Nicolas's idea - clear in front and dim far above - will be maintained.</li><li> <code>colorsys</code>, a default library of Python will be used to control lightness in HLS space, instaed of RGB color space.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">8.5</span>, <span class="number">4</span>), facecolor=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">ax = fig.add_axes([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], aspect=<span class="number">1</span>, xlim=[-<span class="number">40</span>, <span class="number">40</span>], ylim=[-<span class="number">1</span>, <span class="number">25</span>])</span><br><span class="line">ax.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line"></span><br><span class="line">y = <span class="number">0</span></span><br><span class="line">size = <span class="number">6</span></span><br><span class="line">xfactor = <span class="number">1</span> / <span class="number">50</span></span><br><span class="line">yfactor = <span class="number">1</span> / <span class="number">120</span></span><br><span class="line">c = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>) <span class="comment"># yellow</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(text[::-<span class="number">1</span>]):</span><br><span class="line">    path = TextPath((<span class="number">0</span>, <span class="number">0</span>), line, size=size)</span><br><span class="line">    V = path.vertices</span><br><span class="line">    codes = path.codes</span><br><span class="line">    xmin, xmax = V[:, <span class="number">0</span>].<span class="built_in">min</span>(), V[:, <span class="number">0</span>].<span class="built_in">max</span>()</span><br><span class="line">    ymin, ymax = V[:, <span class="number">1</span>].<span class="built_in">min</span>(), V[:, <span class="number">1</span>].<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># New Path</span></span><br><span class="line">    <span class="comment"># X centering</span></span><br><span class="line">    Px = V[:, <span class="number">0</span>] - (xmax + xmin) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Moving whole text at y coordinates</span></span><br><span class="line">    Py = V[:, <span class="number">1</span>] + y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Rescaling along y</span></span><br><span class="line">    Py *= <span class="number">1</span> - (Py * yfactor)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Rescaling along x</span></span><br><span class="line">    Px *= <span class="number">1</span> - (Py * xfactor)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Update interlines</span></span><br><span class="line">    y += size * (<span class="number">1</span> - ymin * yfactor)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># new path</span></span><br><span class="line">    path_new = Path(np.array([Px, Py]).T, codes=codes)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Display</span></span><br><span class="line">    hls = <span class="built_in">list</span>(colorsys.rgb_to_hls(*c))</span><br><span class="line">    hls[<span class="number">1</span>] -= <span class="number">0.07</span> * i</span><br><span class="line">    rgb = colorsys.hls_to_rgb(*hls)</span><br><span class="line">    patch = PathPatch(path_new, facecolor=rgb, edgecolor=<span class="string">&quot;none&quot;</span>, linewidth=<span class="number">0</span>, clip_on=<span class="literal">False</span>)</span><br><span class="line">    ax.add_artist(patch)</span><br></pre></td></tr></table></figure><p><img src="text-starwars.png"><br></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/Nicolas-P-Rougier/">Nicolas P. Rougier</category>
      
      
    </item>
    
    <item>
      <title>사례로 들여다보는 데이터 시각화 Q&amp;A</title>
      <link>https://jehyunlee.github.io/2021/12/04/Python-DS-93-nia_datavis_qa/</link>
      <guid>https://jehyunlee.github.io/2021/12/04/Python-DS-93-nia_datavis_qa/</guid>
      <pubDate>Sat, 04 Dec 2021 06:07:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;한국지능정보사회진흥원(NIA)&lt;/b&gt;에서 또 다른 기회를 주셨습니다. (21.12.03.)&lt;ul&gt;
&lt;li&gt;데이터 시각화를 잘 하는 방법에 대한 개괄적인 발표였습니다.&lt;/li&gt;
&lt;li&gt;발표를 녹화하지 않아 동영상은 제공이 불가합니다</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b>한국지능정보사회진흥원(NIA)</b>에서 또 다른 기회를 주셨습니다. (21.12.03.)<ul><li>데이터 시각화를 잘 하는 방법에 대한 개괄적인 발표였습니다.</li><li>발표를 녹화하지 않아 동영상은 제공이 불가합니다.</li><li><b><a href="https://kr.object.gov-ncloudstorage.com/open-bucket/boards/1638517226205-211203_NIA_%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EA%B0%81%ED%99%94-%EC%95%95%EC%B6%95%EB%90%A8.pdf">발표자료는 여기에서 다운로드</a></b>받으실 수 있습니다.</li></ul></li></ul><ul><li><b>사전 질문이 매우 많았습니다.</b><ul><li>NIA에서 일차 추려주셨는데도 수를 세어보니 <b>56개</b>더군요.</li><li>많은 분들의 관심에 감사드리며, 한편으로는 제한된 시간에 답을 충분히 드리지 못해 죄송스럽습니다.</li></ul></li></ul><ul><li>아쉬운 대로 본 블로그를 통해 답변을 정리해 드립니다.<ul><li>제가 모든 것을 충분히 알지 못합니다. 이 점을 감안하시고 제 의견이라고 들어주시면 감사하겠습니다.</li><li>본 글을 작성하면서 <b>질문을 다시 분류하고 묶었으며 받은 질문 텍스트를 그대로 사용했습니다.</b></li><li><b>비슷한 질문도 많이 주셨습니다.</b> 이들은 한 번에 묶어서 답변을 드립니다.</li></ul></li></ul><p><img src="93_nia_datavis_qa.png"><br></p><style>    .en {        background-color: #EEEEFF;        padding: 0px;        margin-top: 0px;        margin-bottom: 0px;        margin-left: 0px;        margin-right: 0px;    }</style><h3 id="1-사례"><a href="#1-사례" class="headerlink" title="1. 사례"></a>1. 사례</h3><li><b>1-1. 에기원에서 진행하는 데이터분석 사례 중 인사이트 도출이 잘 된 예시들은?</b></li> <li><b>1-2. Output을 활용, 분석하여 outcome을 도출, 계량 할 수 있을지?</b></li>    <details><summary>답변 보기/접기</summary><div class="en"><li>데이터 담당자로서 연구부서 분들의 데이터를 받아 시각화를 수행하며 협업을 진행하고 있습니다.</li><li>그러나 아쉽게도 많은 해당 업무들이 논문 출판 및 실증 진행중이라 먼저 보여드리기 어렵습니다.</li><li>모쪼록 양해 바랍니다.</li><p><li><a href="https://www.nature.com/articles/s41598-021-83315-9.pdf"><b>논문으로 출판된 사례</b></a>를 하나 말씀드리면 다음과 같습니다.</li>  <li>3가지 인자가 2가지 특성에 미치는 영향을 살펴본 연구입니다.</li> <li>EDA나 머신러닝 모델링 만으로는 설명이 충분치 않던 상황입니다.</li><li><b>1,000개의 시뮬레이션 데이터</b>로 믿을 만한 머신러닝 모델을 만든 후, 이 모델을 이용해 <b>42,875개</b>의 가상 데이터를 만든 뒤 <b>이들의 연관성을 3D contour 두 개</b>로 시각화하여 간결하게 설명하고 리뷰어를 이해시킬 수 있었습니다.</li><img src="93_nia_datavis_qa_14.png"></div></details><p><li><b>1-3. CFD 해석 데이타도 데이터 시각화 가능한가요?</b></li>    <details><summary>답변 보기/접기</summary><div class="en"><li>네. 가능합니다.</li><li>일반적으로 CFD(유체열역학) 해석 데이터라고 하면 온도나 유량, 유속을 컬러맵으로 나타낸 것을 말합니다.</li><li>CFD라는 단어를 사용하신 시점에서 이 것을 모르고 계시지는 않을 것 같습니다.</li><img src="https://scanscot.com/web/wp-content/uploads/2014/09/Abaqus_cfd_valve_anim.gif"><p><li>저희 연구원 내 다른 부서 분께서 모델별로 도출된 CFD 데이터를 추출하여 추가 해석을 수행한 경험이 있습니다.</li><li>실증 진행중이라 보안상 자세한 내용은 말씀드리지 못했지만 관련 기술은 아래 글에 정리했습니다.</li>  <li><a href="https://jehyunlee.github.io/2021/07/10/Python-DS-80-mpl3d2/"><b>2가지 인자를 바꾸어가며 최적의 조건을 찾고 확인하는 연구였습니다 (링크)</b></a></li> <img src="https://jehyunlee.github.io/2021/07/10/Python-DS-80-mpl3d2/mpl3d_scatter.gif"></div></details><p><li><b>1-4. 한국에서의 성공사례</b></li> <li><b>1-5. 데이터 시각화의 중요성이 드러나는 사례가 궁금합니다</b></li> <li><b>1-6. 데이터 시각화를 통해 문제를 해결하신 사례가 궁금합니다</b></li> <li><b>1-7. 독창적인 생각을 통해서 데이터 분석을 성공적으로 해낸 사례</b></li> <li><b>1-8. 가장 임팩트 있었던 시각화 사례가 있으셨을까요?</b></li>     <details><summary>답변 보기/접기</summary><div class="en""><li>데이터 분석에 기반하여 기사를 쓰고 사회에 영향력을 미치는 분들이 있습니다. </li> <li>데이터 저널리즘이라고 하고, 많은 분들이 좋은 기사를 쓰고 계십니다: <a href="http://datajournalismawards.kr/">http://datajournalismawards.kr/</a></li><li>데이터의 효과적 전달과 올바른 쓰임을 가장 진지하게 고민하시는 분들이시니 둘러보기를 권합니다.</li>  </div><img src="93_nia_datavis_qa_01.png"></details><p><h3 id="2-고충"><a href="#2-고충" class="headerlink" title="2. 고충"></a>2. 고충</h3><li><b>2-1. 데이터 시각화는 의사결정을 도와주는 도구로 알고 있습니다. 아무리 좋은 도구를 가지고 있어도(데이터를 잘 뽑고 시각화를 잘해도) 본래의 목적인 의사결정이 그에 못지 않게 이상한 방향(이럴거면 뭐하러 시각화했나 하는 방향)으로 이뤄지는 경우도 있나요? 있다면 빈도와 사례도 부탁 드립니다.</b></li>     <details><summary>답변 보기/접기</summary><div class="en""><li>흔히 <b>답정너</b>라고 말하는 상황에 답답함을 느끼시는 듯 합니다.</li><li>데이터 분석을 하는 분이라면 상당히 자주 겪는 일이 아닌가 싶네요. </li><li>회사마다 사람마다 다르겠지만 제 경험상 50% 정도 저런 일이 있는 것 같습니다.</li>    <li>하지만 의견이 받아들여지지 않았다고 상대방이 답을 정해놨다고 보기는 힘들 수 있습니다.</li>  <li>분석에 동원된 <b>데이터는 전체 업무의 일부</b>이기 때문에 더 넓게 봐야 하는 의사결정자는 다른 결정을 내릴 수 있습니다.</li>  <li>예를 들어, 데이터에 드러나지 않는 <b>가격 협상력</b>을 유지하기 위해 당장 약간의 손해를 안고 더 비싼 업체를 일부 활용하기도 합니다.</li>  <li>데이터 분석 결과 기각 사유가 더 넓은 시야와 고민이 아니라면 더 좋은 곳을 찾아 떠날 수도 있을 것입니다.</li>  </div><img src="93_nia_datavis_qa_02.png"></details><p> <h3 id="3-시각화-공부와-교육"><a href="#3-시각화-공부와-교육" class="headerlink" title="3. 시각화 공부와 교육"></a>3. 시각화 공부와 교육</h3><li><b>3-1. 적절한 시각화를 선택하는 기준은 무엇인가요?</b></li><li><b>3-2. 데이터시각화 입문하기위한 좋은 학습콘텐츠나 서적 부탁드립니다!</b></li><li><b>3-3. 데이터 시각화는 어떤점을 표현해야 시각회에 극대화를 시킬 수 있을까요?</b></li><li><b>3-4. 데이터 시각화를 구현할 때 고려사항을 설명해주셨으면 좋겠습니다.</b></li>    <li><b>3-5. 많은 시각화 예시와 시각화시 어떤 관점으로 보는게 가장 효율적이고 데이터에 대한 특성별 시각화 방안이 궁금합니다.</b></li><li><b>3-6. 시각화의 구조를 심리학적 상황별 기능별로 한분야를 택해서 설명 부탁드립니다.</b></li><li><b>3-7. 데이터 시각화를 잘 구성하기 위한 머리속의 구상(예., 데이터 구성/논리적 연결/표현 등은 어떻게?)은 어떤 자세(설계, 개발)를 가져야 할까요?</b></li><li><b>3-8. 데이터 시각화를 활용하기 위해 일반인이 길러야 할 능력은 무엇일까? (ex 엑셀)</b></li><li><b>3-9. 데이터 종류에 따른 시각화 방법이 다른데 주로 어떤 기준으로 결정하나요?</b></li><li><b>3-10. 요새 각 카테고리별 비중에 대한 데이터를 많이 다루면서 항상 고민이 되는 부분이 있는데요, 보통 비율을 표현할때 파이차트 혹은 누적막대차트를 사용하게 됩니다. 단순히 한 시점에 대해서는 저렇게 표현해도 괜찮지만 여러 시점을 비교하며 보여줄때 어떤 그래프가 효율적일까요?</b></li>    <details><summary>답변 보기/접기</summary><div class="en""><li>20C 말 인지 심리학을 비롯한 인지 과학은 많은 사실을 알아냈습니다.</li>  <li>기하학적 요소와 주관적 아름다움이 인지에 미치는 영향을 알게 되었으므로 이 지식을 활용하는 것이 합리적입니다.</li>  <li>예를 들어, <b>시간에 따른 비율 변화</b>는 stream graph나 ridge plot을 쓰시면 좋습니다</li><p><li>클라우스 윌케의 <a href="http://www.yes24.com/Product/Goods/87631760"><b>데이터 시각화 교과서</b></a>를 추천드리며,</li>  <li>더 깊은 이해를 위해서는 <a href="http://www.yes24.com/Product/Goods/19013968"><b>데이터 시각화, 인지과학을 만나다</b></a>를 권합니다.</li>  <li>두 번째 책은 아쉽지만 절판되었습니다. 도서관 등을 찾아보시면 좋겠습니다.</li>  <li>Python의 가장 대표적인 시각화 라이브러리는 Matplotlib인데, 이를 다루는 시중의 기술서는 아쉬운 점이 많습니다.</li><li>책 몇 권을 봤는데 <a href="https://matplotlib.org/stable/gallery/index.html"><b>공식 홈페이지 예제 (링크)</b></a>, 그 중에서도 초급 수준만을 번역해 놓은 수준이더군요.</li>  <li>차라리 그 돈은 다른 데 쓰고 공식 홈페이지를 보는 게 낫다는 생각이 들었습니다.</li>    </div><img src="93_nia_datavis_qa_03.png"><img src="93_nia_datavis_qa_04.png"><img src="93_nia_datavis_qa_05.png"><img src="93_nia_datavis_qa_12.png"><img src="93_nia_datavis_qa_10.png"></details><p> <li><b>3-11. 데이터 시각화를 잘 하기 위한 통찰력을 얻는 소스가 있으신가요?</b></li>    <li><b>3-12. 초보자가 데이터분석 공부하기 좋은 방법을 알려주세요.</b></li><li><b>3-13. 데이터 분석을 위한 기초 학습은 어떤 것부터 하면 좋을까요? </b></li><li><b>3-14. 다른 사람이 시각화 한 것을 많이 찾아보는 것도 도움이 될까요?</b></li><li><b>3-15. 쉽게 이해할수있는 시각화를 만들려면 ui/ux가 매우 중요한데, 시각화하는 사람은 이미 데이터에 대한 이해가 있기때문에 시각화자료를 볼 사람들에겐 여전히 어려운 시각화 자료를 만들 수 있다고 생각합니다. 시각화하실때 이러한 갭을 최소화하기위해서 어떻게 하시나요</b></li>    <details><summary>답변 보기/접기</summary><div class="en""><li>글을 잘 쓰려면 <b>많이 읽고(多讀), 많이 쓰고(多作), 많이 생각하라(多商量)</b>는 말이 있습니다.</li>  <li>시각화도, 그 무엇도 비슷하다고 생각합니다.</li><li>좋은 그림을 많이 보고, 많이 그려보고, 많이 생각하는 것이 처음이자 끝이 아닐까요?</li>    <p><li>다만 데이터 시각화를 잘 하겠다고 <b>데이터 시각화만 많이 보지는 않았으면</b> 좋겠습니다.</li>  <li>데이터 시각화는 회화, 영화 등 시각적 예술활동을 데이터에 적용한 것이니 시야를 넓히면 더 좋습니다.</li>  <li>고전미술, 웹툰, 영화 포스터, 광고 등 많은 작품에서 영감을 받으시기를 바랍니다.</li>  <li>코드가 손가락에 스며들도록 연습해야 하는 것은 말할 것도 없고,</li>  <li>키보드와 모니터를 치우고 백지와 펜을 들어 코드의 제약 없이 스케치하는 연습도 좋습니다.</li>  <li>생각은 혼자 하기보다는 동료나 대중의 반응을 보면서 feedback loop을 형성하시길 바랍니다.</li>  <li>주신 질문처럼 <b>분석가가 데이터에 너무 익숙해서 문제가 되기도 합니다</b>. 낯선 시각의 피드백이 필요합니다.</li>  </div><img src="93_nia_datavis_qa_06.png"></details><p> <li><b>3-16. 학생들에게 데이터시각화가 중요하다는 것을 알려줄만한 쉬운 사례가 있다면 소개부탁드립니다~</b></li>    <details><summary>답변 보기/접기</summary><div class="en""><li>나이팅게일의 rose chart와 hans rosling의 animated bubble chart가 대표적일 것입니다.</li>  <li>나이팅게일을 <b>백의의 천사</b>로만 알고 있다면 <a href="https://www.sedaily.com/NewsVIew/1OFW72CBYO"><b>망치로 창고 열쇠를 부순 백의의 전사 (링크)</b></a>라는 사실도 알려주면 어떨까요? <li><a href="https://en.wikipedia.org/wiki/Anscombe%27s_quartet"><b>Anscombe's quartet (링크)</b></a>이나 Autodesk의 <a href="https://www.autodesk.com/research/publications/same-stats-different-graphs"><b>datasaurus (링크)</b></a>도 자주 인용되지요 :)</li>  </div><img src="93_nia_datavis_qa_07.jpg"><img src="93_nia_datavis_qa_08.gif"><img src="93_nia_datavis_qa_09.gif"></details><p> <li><b>3-17. 학교에서 데이터 사례 수업을 하려고 하는데 쓸만한 데이터를 어디서 찾을 수 있을까요?(공공데이터 포털 말구요 ㅠㅠ!)</b></li>    <details><summary>답변 보기/접기</summary><div class="en""><li>제가 교육 현장을 질문자만큼 잘 몰라서 <b>서울고등학교 송석리 선생님</b>의 말씀을 전달해 드립니다.</li>  <li>선생님께서 한성과학고에 재직중이던 2019년 PyCon Korea에서 <a href="https://www.youtube.com/watch?v=9FCNiijm3Jc"><b>교육의 미래를 바꾸는 오늘의 파이써니스쿨 (링크)</b></a>이라는 발표를 하셨습니다.</li>  <li>학생들이 (과거의 저보다 훨씬) 열정적으로 참여한 모습을 보고 신기해서 <b>"과학고라고 해도 관심이 없는 학생도 있었을텐데 어떻게 저런 참여를 이끌었는지"</b>를 질문드렸습니다.</li>  <li>선생님의 대답은 <b>"학생들 본인들의 데이터로 수업을 했다. 자기 스스로에게는 누구나 관심이 있다."</b>였습니다.</li>  <li>생각해보니 저도 고등학교때 한 친구가 공학용 계산기로 자리 추첨 프로그램을 만들어서 매주 자리를 뽑은 기억이 있습니다.</li>  <li>본인의 일주일 짝과 자리가 결정되는 그 순간 저를 포함한 모두가 초인적인 집중력을 발휘했습니다. ^^;</li>  </div><img src="93_nia_datavis_qa_13.png"></details><p> <li><b>3-18. 쉽게따라하기 좋은 데이터 시각화 방법에 대해서 궁금합니다.</b></li><li><b>3-19. 파이썬 기반으로 여러 모델을 만들고 개발했지만.. 시각화는 거의 제대로 해본적이 없습니다. 사실 제게는 모델 만드는 것보다 파이썬으로 예쁘게 제대로 시각화하는게 더 어렵고 귀찮더라구요... 소요되는 시간이 더 많이 소요되고.. 피땀은 배신하지 않겠지만, 혹시 쉽게 파이썬 기반으로 시각화를 예쁘게 하는 쉬운 방법이 있는지.. 만약 없다면 혹시 쉽게 파이썬 기반 시각화 코딩을 익히는 방법이 있는지 궁금합니다.</b></li>    <details><summary>답변 보기/접기</summary><div class="en""><li>먼저 <b>쉽게</b>, <b>귀찮더라</b>라는 단어와 <b>좋은</b>, <b>예쁘게</b>라는 단어의 조합에 이의를 제기하고 싶습니다.</li>  <li><b>"베끼기 좋은 코드 알려주세요"</b>로 해석할 수도 있겠지만 설마 이건 아니라고 생각합니다. 검색하면 나오거든요.</li>  <li>분야를 막론하고 뭔가 잘 했다는 느낌을 받으셨다면 그건 창조자의 뼈를 깎는 노력이 배어 나왔기 때문입니다.</li>  <li>노력 없이 좋은 결과를 내는 천재들도 있습니다만 타고 나야 하니 본 질문이나 답변의 대상이 될 수 없겠죠.</li>  <li><b>쉽게 익히는 방법이 있을지도 모르겠지만 아쉽게도 저는 알지 못합니다.</b> 그냥 매일 조금씩이나마 꾸준히 하는 법 밖에는요.</li><p> <li><b>"그래서 넌 뭘 얼마나 열심히 했는데?"</b>라고 물어보신다면, <b>"내게 코딩 실력이 부족하구나."</b>를 느낀 2019년 여름 이후 일일 커밋을 하고 있습니다. 오늘(12/4)까지 757일째입니다.</li><li><b>1000일이 넘는 분들도 있습니다.</b> 스스로 아직 많이 부족하다고 느끼고 있고, 더 열심히 하려고 노력하고 있습니다.</li>  <li>따라하기 좋은 예제는 라이브러리 공식 홈페이지, Kaggle Notebook, 여러 블로그에서 찾을 수 있습니다.</li>  <li>목표를 세우셨다면 <b>그냥 묵묵히 정진하는 것</b>이 답입니다. 진심을 담아 응원하겠습니다. :)</li>  </div><img src="93_nia_datavis_qa_11.png"><img src="93_nia_datavis_qa_13.jpeg"></details><p> <h3 id="4-시각화-도구"><a href="#4-시각화-도구" class="headerlink" title="4. 시각화 도구"></a>4. 시각화 도구</h3><li><b>4-1. 다양한 데이터 작성 툴이 있습니다. 엑셀, R, 파이썬 등. 디자인 전공자들에게 추천하는 툴이 있으신가요?</b></li><li><b>4-2. 초보 및 전문가를 위한 데이터 시각화를 설계/개발하기 위한 요구사항은 어떻게 될까요? </b></li><li><b>4-3. 데이터 시각화에서 가장 많이 이용하는 툴은 어떤 것인가요?</b></li><li><b>4-4. 시각화를 어떤식으로 보여주실지는 모르겠지만, 시각화에 태블로 역량이 중요하다고 생각하시나요.</b></li><li><b>4-5. 평소에 시각화자료 올려주시는거 즐겨보고 있습니다. 요즘은 어떤 패키지가 유행인가요?</b></li><li><b>4-6. 사례에 사용하시는 기술들도 함께 나눠주세요!</b></li><li><b>4-7. 인터렉티브한 시각화를 위해서 가장 선호하는 방법은 무엇인가요?</b></li>    <details><summary>답변 보기/접기</summary><div class="en""><li>가장 좋은 도구는 본인이 속한 환경에 따라 달라진다고 생각합니다. </li>  <li>실시간으로 데이터를 받아 보여주는 대시보드를 만든다면 tableau, power BI 등이 유용하실 것이고</li>  <li>통계 문제를 많이 푼다면 R이, 머신러닝이나 다른 앱과 연동한다면 Python이 가장 좋을 겁니다.</li>  <li>코딩을 잘 모르는 분들을 상대해야 한다면 엑셀만한 게 없을지도 모릅니다.</li><p>  <li>저는 <b>python만 사용</b>합니다. 웹으로 deploy할 일이 없고 복잡한 수식을 풀 일이 종종 있기 때문입니다.</li>  <li>python 중에서도 <b>matplotlib을 포함한 관련 생태계</b>(seaborn, geopandas, sklearn-plot, yellowbrick)만 사용합니다.</li>  <li>제가 쓰는 라이브러리들이 다 matplotlib을 활용하고 있기 때문이고, interactive한 결과물을 만들 필요가 없기 때문입니다.</li>  <li>조만간 web deploy를 할 것 같습니다. 같은 이유로 plot.ly를 배울까 생각중입니다.</li><li>본인의 필요에 따라 배우고 활용하시는게 가장 좋지 않을까요? :)</li><p><li>유행 따라 주무기를 바꾸는 것을 선호하지 않습니다.</li><li>크리티컬한 문제가 없다면 <b>내 손에 스며든 도구가 최적의 도구</b>라고 생각합니다.</li><li>이 도구로 할 수 없는 일을 해야만 하면 기꺼이 최선을 다해 바꾸겠지만요.</li> </div></details><p> <h3 id="5-노하우"><a href="#5-노하우" class="headerlink" title="5. 노하우"></a>5. 노하우</h3><li><b>5-1. 시각화에서 가장 조심할점은 무엇인가요?</b></li>  <li><b>5-2. 데이터 시각화를 구현할 때 고려사항을 설명해주셨으면 좋겠습니다.</b></li>  <li><b>5-3. 데이터 시각화를 하는데 있어 가장 사람들이 실수하는 것이 무엇입니까.</b></li>  <li><b>5-4. 데이터를 시각화하면 데이터를 쉽게 이해하는데 많은 도움이 된다고 이해하고 있습니다만, 간혹 잘못된(?) 데이터 시각화는 자칫 데이터에 대한 잘못된 이해 또는 오해를 불러오기도 한다고 생각합니다, 이러한 오해의 요소가 있다면 데이터 시각화 과정에서 주의해야 할, 또는 피해야할 부분은 무엇일까요? 데이터 시각화의 휴먼에러(?)를 줄일 수 있는 방법에 대해서 알고 싶습니다 </b></li>    <details><summary>답변 보기/접기</summary><div class="en"><li>데이터 시각화는 분석가의 의지를 담아 데이터를 그림으로 표현하는 작업이라 생각합니다.</li>  <li><b>생각이 없어도 문제</b>가 되고,</li>  <li><b>생각이 너무 많아도 문제</b>가 되고,</li>  <li><b>생각이 잘못되면 당연히 문제</b>가 될 것입니다.</li><p><li>아무 생각이 없이 그림을 그리면 <b>메시지 전달력</b>이 떨어지기도 하고, <b>허위 상관</b>이 중요한 듯 그려집니다.</li>  <li>메시지를 전달하겠다고 힘을 주는 건 좋은데 <b>주관이나 주장이 fact를 가리면 곤란</b>합니다.</li>  <li>이런 일들은 gray zone에서 벌어지는 일이 많아서 <b>"이 선 넘어가면 나쁜 놈"</b>식의 말씀을 드리기는 참 어렵습니다.</li><p><li>일단 <b>사실에 근거해서</b>, <b>한 마디로 정리하라면 뭐라고 할까? 그게 그림에 보이나?</b>를 염두에 두고, <b>작업에 매몰되지 않도록 시차를 두기도 하고 산책도 하고 중간 중간 다른 이들에게 보이기도 하면</b> 좀 낫지 않을까 싶습니다.</li>  <img src="93_nia_datavis_qa_15.png"><p><li>가장 흔한 실수는 <b>하던 대로만, 배운 대로만 하는 관성</b>이 아닐까 생각합니다.</li><li>선배의 말을 경청하는 것과 선배의 말만 듣는 것은 완전 다릅니다.</li><li>단적인 예로 <b>학회장 포스터가 천편일률적입니다.</b> 자기 주장이나 발견을 더 잘 드러내고자 하면 저렇게는 안 만들 것 같습니다.</li></div><img src="93_nia_datavis_qa_17.png"></details><p> <li><b>5-5. 여러가지 시각화 방법중 데이터와 연계해서 빠르게 효과적인 시각화 방법을 찾는 노하우가 있을까요?</b></li><li><b>5-6. 데이터 시각화를 하다보면 시각화자체에 시간이 많이 소요됩니다. 데이터를 이해하고 인사이트를얻는데 시간을 더 투자하고 시각화자체는 효율적으로하는 방법이있을까요 </b></li><li><b>5-7. 데이터 시각화는 데이터를 보고 딱 떠오르는 것에 대해 시각화를 하는 건가요? 아니면 이런저런 시행착오를 통해 점진적으로 만드는 건가요</b></li><li><b>5-8. 현업에서 특별히 보고를 위한 플롯이 아니라면 최소의 템플릿이나 컨벤션이 있는지?</b></li><li><b>5-9. 데이터를 이용해서 기존의 방식처럼 일반적인 차트를 구성해서 보여주고 있는 경우 pandas등을 통해서 좀더 데이터를 다양하게 다루기 위해서 시도해보고 있습니다. 머신러닝, 딥러닝을 통해서 좀더 데이터를 다루고 싶은데 기준과 데이터의 접근법등이 뚜렷한 기준이 없기에 고민이 됩니다.</b></li>    <details><summary>답변 보기/접기</summary><div class="en"><li>빠르게 찾는 방법은 저도 알고 싶습니다. 시간이 많이 소요되거든요 ^^;</li>  <li>일단 데이터를 받으면 목적에 따라 scatter plot, bar plot, line plot 등을 그려봅니다.</li>  <li>분포 같은 통계적 양상이 중요한 경우에는 kde plot도 그려보고요.</li>  <li>인자가 좀 많은데 서로 연관성을 봐야 한다 싶으면 3D plot도 그립니다.</li>  <li>한 마디로, <b>할 수 있는 건 다 해 보느라 시간이 많이 갑니다.</b></li><p><li><b>시각화에 드는 시간을 줄이려고 노력을 합니다.</b></li>  <li>파워포인트 템플릿을 바꾸지 않습니다 - 하얀 백지만 씁니다. 전체 색조가 바뀌거나 크기가 바뀌면 다 바뀌거든요.</li>  <li>색을 고르는 데 시간을 들이지 않습니다 - 색을 이리 저리 바꾸다 보면 시간이 증발합니다.</li>  <li>코드를 짜기 전에 산책을 하거나 백지에 손으로 그립니다 - 최대한 생각을 미리 많이 하면 몸이 편해지더군요.</li>  <li><b>엄청난 시행착오를 전제하는 작업</b>이라 생각합니다.</li>  <li><b>경험</b>이 쌓이고 코딩 같은 <b>스킬</b>이 늘면 엉뚱한 짓에 소모되는 시간은 적을 것 같네요.</li></div></details><p> <li><b>5-10. 추천하는 보고서 양식(markdown, web 등)</b></li>    <details><summary>답변 보기/접기</summary><div class="en"><li><b>직장에서 정해주는 대로</b> 하는 주의입니다.</li>  <li>미생에도 장그래가 폴더 정리하는 에피소드가 나오듯, 조직에서는 전체의 흐름에 맞추는 게 더 낫습니다.</li><li>제 힘으로 어쩔 수 없는 일도 많아서 군말없이 문서는 hwp, 발표는 ppt를 사용하고 있습니다.</li>    </div></details><p> <li><b>5-11. 인공지능 모델을 구축하기에 앞서 EDA, 혹은 데이터 시각화를 통해 확인해야 할 부분들이 어떤 것이 있을지 궁금합니다</b></li><li><b>5-12. 데이터시각화를 활용하기 위해서 선형수학이라던가 누적분포함수 등 수학적 기본지식이 꼭 필요한가요? </b></li><li><b>5-13. 데이터 시각화라고 하면 시각화를 위한 데이터 전처리가 포함되나요?</b></li>    <details><summary>답변 보기/접기</summary><div class="en"><li><b>"EDA의 절반 이상은 시각화"</b>라는 말을 많이 듣고 저도 많이 합니다.</li>  <li>데이터 시각화를 통해 기본적으로 데이터의 분포 양상과 인자간 상관성을 확인합니다.</li>  <li>그러나 파생변수를 만들 때마다 이 파생변수에 대한 일이 생겨나고, PCA같은 차원 축소나 클러스터링이 더해지기도 합니다.</li>  <li>일이 많기도 하지만 <b>내가 뭘 하는지</b> 정확히 파악하지 않으면 엉뚱한 판단을 하기 너무 좋습니다.</li>  <li>이를 예방할 수 있는 유일한 백신은 <b>탄탄한 수학적 지식</b>이라고 생각합니다.</li>  <li>통계 전문가가 될 필요까지는 없겠지만 <b>내가 뭘 하는지 알 만큼은 알아야 합니다.</b></li><li><a href="https://www.sjsu.edu/faculty/guangliang.chen/Math250.html">San Jose State University에는 이런 강좌도 있습니다.</a></li></div><img src="93_nia_datavis_qa_16.png"></details><p> <h3 id="6-기타"><a href="#6-기타" class="headerlink" title="6. 기타"></a>6. 기타</h3><ul><li>어딘가에 속하기 어려운 질문들에 대해 최대한 단답형으로 답을 달았습니다.</li><li>답을 드리기 어려운 질문들(ex. 인공태양에 관심이 있습니다)은 생략했음을 양해해 주시기 바랍니다.</li></ul><li><b>6-1. 취준생 포토폴리오에 꼭 넣었으면 하는 시각화 방법은 무엇이 있을까요?</b></li>    <details><summary>답변 보기/접기</summary><div class="en"><li>뻔한 답이지만, <b>회사가 원하는 기술</b>을 넣으셔야 하지 않을까요?</li>  <li>데이터 분석의 정확성이 중요한 회사라면 현란한 tableau보다 정확한 정보를 잡아내는 능력이 필요하겠지만,</li><li>대중을 상대로 한 대시보드 제작사라면 주의를 끌 수 있는 디자인 능력이 중요할 겁니다.</li><li>뭐가 되었듯 <b>경쟁자들을 압도할만한 레벨</b>을 담으실 수 있기를 바랍니다.</li></div></details><p> <li><b>6-2. 온라인에서 내려받은 실시간 데이터를 처리하여 다시 온라인 게시하고 싶습니다. 온라인 데이터 송수신 경험이 없는데 따라하기 좋은 길라잡이 좀 추천 부탁드립니다.</b></li>    <details><summary>답변 보기/접기</summary><div class="en"><li>Open API를 써서 데이터를 다운받아 본 적은 있지만 결과물을 웹으로는 게시해 본 적이 없습니다.</li>  <li>구글링해보니 글이 많이 나오네요. <a href="https://velog.io/@1yangsh/python-Open-API-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0">이런 글들 (링크)</a>을 참고하시면 좋을 듯 합니다.</li></div></details><p> <li><b>6-3. 데이터 분석 직무로 취업을 준비하는 학생입니다. 데이터 분석 공부를 할수록 도메인의 지식의 중요성을 느끼고 있는데 여러가지 도메인 지식을 쌓기 위한 노력이 궁금합니다.</b></li>    <details><summary>답변 보기/접기</summary><div class="en"><li>한 분야의 지식(도메인 지식)을 익히는 데는 적잖은 노력과 비용이 소요됩니다.</li>  <li>괜히 대학에서 4년간 가르치는 걸로 모자라 대학원까지 가기도 하는 게 아니거든요.</li>  <li>데이터 관점에서 도메인을 접근해서 진짜로 깊이 알기는 굉장히 어렵다고 생각합니다.</li>  <li><b>핵심 개념</b>중심으로 파악하면 일단 큰 실수는 면할 수 있다고 생각합니다.</li>  <li>스스로의 노력으로 개념과 흐름을 얼추 파악한 뒤에 인맥을 최대한으로 활용해 <b>도메인 전문가</b>를 찾고 잦은 대화를 통해 갭을 줄여 나가는 것이 가장 좋을 것이라 생각합니다.</li>  </div></details><p> <li><b>6-4. 시각화로 돈 버는 방법은 어떤 것들이 있는지</b></li>    <details><summary>답변 보기/접기</summary><div class="en"><li><a href="https://www.indeed.com/career-advice/finding-a-job/data-visualization-jobs-with-salary"><b>10 visualization career paths</b></a>에 따르면 대략 10가지 정도의 길이 있습니다.</li>  <li>미국 기준이긴 하지만 연소득도 33,583 USD부터 124,518 USD까지 있네요.</li><li><a href="https://www.glassdoor.com/Salaries/data-visualizer-salary-SRCH_KO0,15.htm"><b>glassdoor</b></a>에 따르면 84,775 USD가 평균이라고 합니다.</li><li>데이터 시각화 직군이 특별히 있는 경우는 모르겠지만 그렇지 않으면 속한 회사의 급여 체계에 따르는 것이 보통이 아닐까 합니다.</li><li>하지만 최근 등장한 NFT 시장을 이용하면 <b>data art</b>로 소득을 올릴 수도 있습니다. <a href="https://towardsdatascience.com/creating-generative-art-nfts-from-genomic-data-16a48ae4df99">(관련 기사 링크)</a></li><li>아래 그림은 R로 그려진 data art입니다 <a href="https://generative.substack.com/p/generative-art-and-r">(원문)</a></li></div><img src="https://cdn.substack.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff4605b82-0c61-48f2-85f1-8345fd5312dc_900x894.png"></details><p> <h3 id="7-마치며"><a href="#7-마치며" class="headerlink" title="7. 마치며"></a>7. 마치며</h3><ul><li>총 50개가 넘는 질문에 제 나름의 최선을 다해 답을 드렸습니다.</li><li>발표시간의 제약으로 드리지 못한 답이 조금이나마 전달되었기를 바랍니다.</li></ul><ul><li>처음에 말씀드렸듯 저도 이 답이 100점이라고는 생각하지 않습니다.</li><li>하지만 이 시점의 제가 드릴 수 있는 최선이라고 생각합니다.</li><li>여러분 스스로 더 좋은 답을 찾으시길 바랍니다.</li></ul><p><img src="datavis.png" alt="NIA 공지"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/NIA/">NIA</category>
      
      
    </item>
    
    <item>
      <title>Sci Vis) 1. Rotated histogram</title>
      <link>https://jehyunlee.github.io/2021/12/02/Python-DS-92-rougier01/</link>
      <guid>https://jehyunlee.github.io/2021/12/02/Python-DS-92-rougier01/</guid>
      <pubDate>Thu, 02 Dec 2021 00:50:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Scientific Visualization: Python + Matplotlib&lt;/strong&gt; 책에는 최고 수준의 시각화 기술이 담겼습니다.&lt;/li&gt;
&lt;li&gt;높은 수준에 비해 설명이 다소 짧아 초심자에게 어려워 보였습</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><strong>Scientific Visualization: Python + Matplotlib</strong> 책에는 최고 수준의 시각화 기술이 담겼습니다.</li><li>높은 수준에 비해 설명이 다소 짧아 초심자에게 어려워 보였습니다.</li><li>저자인 Nicolas P. Rougier 박사님의 허가 하에 일부를 해설합니다.</li><li>이 시리즈는 해외 독자를 위해 영어를 회색 상자 안에 병기합니다.</li></ul><style>    .en {        background-color: #EEEEEE;        padding: 0px;        margin-top: 0px;        margin-bottom: 0px;        margin-left: 0px;        margin-right: 0px;    }</style><div class="en" bgcolor="#AAAAAA"><ul><li> <b>Scientific Visualization: Python + Matplotlib</b> contains cutting-edge visualization skills and examples of Matplotlib and Python.  </li><li> Despite its high quality content, relatively short explanations in the book may prevent the readers from fully grasping all of its contents.  </li><li> With the permission of the author, Dr. Nicolas P. Rougier, I'll try to help the beginners understand the more complex concepts within the book by providing explanations and commentary where needed.  </li><li> This series will be posted in <b>English</b> as well as Korean, for international readers.  </ul></div><p><blockquote><p><b>영어 감수:</b> <a href="mailto:jsleeindex@gmail.com">EY한영회계법인 이지수 시니어</a></p></blockquote><blockquote><p><a href="https://github.com/rougier/scientific-visualization-book">Scientific Visualization: Python + Matplotlib</a><br><a href="https://github.com/rougier">github: Nicolas P. Rougier</a></p></blockquote><p><img src="92_rougier01_13.png"><br></p><h1 id="1-Rotated-Histogram"><a href="#1-Rotated-Histogram" class="headerlink" title="1. Rotated Histogram"></a>1. Rotated Histogram</h1><blockquote><p><a href="https://github.com/rougier/scientific-visualization-book/blob/master/code/coordinates/transforms-hist.py">transforms-hist.py</a></p></blockquote><p><img src="92_rougier01_12.png"><br></p><ul><li>이번에 살펴볼 그림은 scatter plot에 histogram이 겹친 모양입니다.</li><li>데이터의 PC1 축 방향으로 돌려 놓인 histogram은 PC2 방향의 데이터 분포를 나타내고 있습니다.</li></ul><div class="en"><ul><li> We are going to investigate a scatter plot with a histogram.</li><li> The histogram is rotated and placed along PC1 axis, representing data distribution along the PC2's direction.</li></ul></div><h1 id="2-Matplotlib-coding"><a href="#2-Matplotlib-coding" class="headerlink" title="2. Matplotlib coding"></a>2. Matplotlib coding</h1><ul><li>저자는 Matplotlib 자체 기능만을 사용해서 그렸습니다.</li><li>저자의 코드를 따라가며 어떻게 그렸는지 확인해 보겠습니다.</li></ul><div class="en"><ul><li> The author created the figure with Matplotlib only.</li><li> We'll see the author's code is working by following every step.</li></ul></div><h2 id="2-1-import-libraries"><a href="#2-1-import-libraries" class="headerlink" title="2.1. import libraries"></a>2.1. import libraries</h2><ul><li>코드는 라이브러리를 불러오는 것부터 시작합니다.</li><li><code>Polygon</code>, <code>Affine2D</code>, <code>floating_axes</code>처럼 전에 보기 힘들었던 기능을 불러옵니다.</li><li>numpy random seed를 설정하여 재현성을 확보합니다.</li></ul><div class="en"><ul><li> We start by importing the libraries.</li><li> Unlike "normal" visualizations, the modules named <code>Polygon</code>, <code>Affine2D</code>, <code>floating_axes</code> are imported.</li><li> Reproducibality is secured by setting numpy random seed.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Polygon</span><br><span class="line"><span class="keyword">from</span> matplotlib.transforms <span class="keyword">import</span> Affine2D</span><br><span class="line"><span class="keyword">import</span> mpl_toolkits.axisartist.floating_axes <span class="keyword">as</span> floating_axes</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reroducibility seed</span></span><br><span class="line">np.random.seed(<span class="number">123</span>)</span><br></pre></td></tr></table></figure><h2 id="2-2-Affine-transformation"><a href="#2-2-Affine-transformation" class="headerlink" title="2.2. Affine transformation"></a>2.2. Affine transformation</h2><blockquote><p><a href="https://mathworld.wolfram.com/AffineTransformation.html">Affine Transformation</a></p></blockquote><ul><li>Affine 변환은 공선성과 거리 비율을 유지하는 모든 종류의 형태 변환을 말합니다.</li><li>Matplotlib은 2차원 Affine 변환을 구현하는 <code>Affine2D</code> 함수를 지원합니다.</li><li>본격적으로 코드를 들여다보기 전에 <code>Affine2D</code> 용법을 확인합니다.</li></ul><div class="en"><ul><li> An affine transformation is any transformation that preserves collinearity (i.e., all points lying on a line initially still lie on a line after transformation) and ratios of distances (e.g., the midpoint of a line segment remains the midpoint after transformation).</li><li> Matplotlib provides <code>Affine2D</code> function in which 2-dimensional Affine transformation is implemented.</li><li> Before diving into the original code, we need to learn how to use <code>Affine2D</code>.</li></ul></div><ul><li>7개의 점으로 이루어진 예제 데이터 <b>S0</b>을 만듭니다. 각 점은 x, y 좌표가 있으므로 형상은 (7, 2)가 됩니다.</li><li>각 점마다 다른 색을 입히기 위해 0부터 1까지 7개의 값 데이터 <b>Sc</b>를 만듭니다. <code>numpy.linspace()</code>를 사용합니다.</li><li><code>Affine2D().rotate_deg(30).transform(S0)</code> 명령으로 <b>S0</b>를 30도 회전해 <b>S1</b>을 얻습니다. 방향은 반시계 방향입니다.</li></ul><div class="en"><ul><li> <b>S0</b>, sample data consisted of 7 points, is prepared on cartesian coordinate system. Each point has x and y coordinate, therefore shape of S0 is (7, 2).</li><li> <b>Sc</b>, a dataset with 7 values are prepared by using <code>numpy.linspace()</code> to paint each point with a differnt color.</li><li> <b>S1</b> is obtained by rotating <b>S0</b> by 30 degree in a counterclockwise direction by using <code>Affine2D().rotate_deg(30).transform(S0)</code>.</li></ul></div><ul><li><b>S0</b>과 <b>S1</b>를 그려 데이터가 의도대로 변환되었음을 확인합니다.</li></ul><div class="en"><ul><li> Successful rotational transform is confirmed by visualization of <b>S0</b> and <b>S1</b>.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># numpy array</span></span><br><span class="line">S0 = np.array([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">3</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line">Sc = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">len</span>(S0))</span><br><span class="line">S1 = Affine2D().rotate_deg(<span class="number">30</span>).transform(S0)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Visualize</span></span><br><span class="line">fig_s, axs_s = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">6</span>, <span class="number">3</span>), sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax_s, S, t <span class="keyword">in</span> <span class="built_in">zip</span>(axs_s, [S0, S1], [<span class="number">0</span>, <span class="number">30</span>]):</span><br><span class="line">    ax_s.scatter(S[:, <span class="number">0</span>], S[:, <span class="number">1</span>], c=Sc, s=<span class="number">100</span>, ec=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">       </span><br><span class="line">    ax_s.set_aspect(<span class="number">1</span>)</span><br><span class="line">    ax_s.set_ylim(-<span class="number">0.5</span>, <span class="number">4.5</span>)</span><br><span class="line">    ax_s.set_title(<span class="string">f&quot;rotation = <span class="subst">&#123;t&#125;</span>$^o$&quot;</span>, fontsize=<span class="string">&quot;large&quot;</span>)</span><br><span class="line">    </span><br><span class="line">fig_s.tight_layout()</span><br></pre></td></tr></table></figure><p><img src="92_rougier01_02.png"><br></p><ul><li>다른 방식으로도 변환할 수 있습니다. Matplotlib Rectangle 객체 <b>R0</b>을 대상으로 합니다.</li><li><b>Rt</b>라는 이름의 변환을 선언하고 <code>R0.set_transform(Rt)</code>를 적용하면 <b>R0</b>의 좌표가 바뀝니다.</li></ul><div class="en"><ul><li> We can get the same result by using a different method. We will rotate <b>R0</b>, a Matplotlib Rectangle object.</li><li> Declerating <b>Rt</b> as the designation and applying <code>R0.set_transform(Rt)</code> to <b>R0</b> changes the coordinates of itself.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Rectangle</span><br><span class="line"></span><br><span class="line">R0 = Rectangle((<span class="number">0</span>, <span class="number">0</span>), <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax_s <span class="keyword">in</span> axs_s:</span><br><span class="line">    R0 = Rectangle((<span class="number">0</span>, <span class="number">0</span>), <span class="number">3</span>, <span class="number">3</span>, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;c&quot;</span>, zorder=-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> ax_s == axs_s[<span class="number">1</span>]:</span><br><span class="line">        Rt = Affine2D().rotate_deg(<span class="number">30</span>) + axs_s[<span class="number">1</span>].transData</span><br><span class="line">        R0.set_transform(Rt)</span><br><span class="line">    ax_s.add_patch(R0)</span><br><span class="line">    </span><br><span class="line">fig_s.tight_layout()</span><br><span class="line">display(fig_s)</span><br></pre></td></tr></table></figure><p><img src="92_rougier01_03.png"><br></p><ul><li>(150, 2) 데이터 <b>Z0</b>를 생성하고 같은 방식으로 원본 데이터를 35도 회전해 <b>Z1</b>를 만듭니다.</li><li><b>Z1</b>의 x, y 평균([ 0.13746892, -0.02793329])을 구해 <b>Zm</b>에 저장합니다.</li></ul><div class="en"><ul><li> Create (150, 2) points data <b>Z0</b> then rotate 35 degree in the same manner to generate <b>Z1</b>.</li><li> Calculate mean of <b>Z1</b> ([ 0.13746892, -0.02793329]) and store it as <b>Zm</b>.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generate some data</span></span><br><span class="line">Z0 = np.random.normal(<span class="number">0</span>, (<span class="number">1.25</span>, <span class="number">0.75</span>), (<span class="number">150</span>, <span class="number">2</span>))  <span class="comment"># Z0: 2D random points array</span></span><br><span class="line">Z1 = Affine2D().rotate_deg(<span class="number">35</span>).transform(Z0)      <span class="comment"># Z1: rotated Z0</span></span><br><span class="line">Zm = Z1.mean(axis=<span class="number">0</span>)                              <span class="comment"># mean of Z1. Zm = np.array([ 0.13746892, -0.02793329])</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Visualize</span></span><br><span class="line">fig_r, axs_r = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">6</span>, <span class="number">3</span>), sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> Z, ax, t <span class="keyword">in</span> <span class="built_in">zip</span>([Z0, Z1], axs_r, [<span class="number">0</span>, <span class="number">35</span>]):</span><br><span class="line">    ax.scatter(Z[:,<span class="number">0</span>], Z[:,<span class="number">1</span>], c=np.linspace(<span class="number">0</span>, <span class="number">1</span>, Z.shape[<span class="number">0</span>]))</span><br><span class="line">    ax.axhline(<span class="number">0</span>, c=<span class="string">&quot;k&quot;</span>, zorder=-<span class="number">1</span>)</span><br><span class="line">    ax.axvline(<span class="number">0</span>, c=<span class="string">&quot;k&quot;</span>, zorder=-<span class="number">1</span>)</span><br><span class="line">    ax.set_title(<span class="string">f&quot;rotation = <span class="subst">&#123;t&#125;</span>$^o$&quot;</span>, fontsize=<span class="string">&quot;large&quot;</span>)</span><br><span class="line"></span><br><span class="line">Zall = np.concatenate([Z0, Z1])    </span><br><span class="line">xmin, xmax = Zall[:,<span class="number">0</span>].<span class="built_in">min</span>(), Zall[:,<span class="number">0</span>].<span class="built_in">max</span>()</span><br><span class="line">ymin, ymax = Zall[:,<span class="number">1</span>].<span class="built_in">min</span>(), Zall[:,<span class="number">1</span>].<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line">axs_s[<span class="number">0</span>].set_xlim(xmin, xmax)</span><br><span class="line"></span><br><span class="line">fig_r.tight_layout()</span><br></pre></td></tr></table></figure><p><img src="92_rougier01_14.png"><br></p><h2 id="2-3-Principal-Component-Analysis-PCA"><a href="#2-3-Principal-Component-Analysis-PCA" class="headerlink" title="2.3. Principal Component Analysis (PCA)"></a>2.3. Principal Component Analysis (PCA)</h2><ul><li><code>numpy.linalg.eig</code>를 사용해 PCA를 수행합니다.</li><li>eigenvalue <b>V</b>와 eigenvector <b>W</b>로부터 PC1과 PC2를 구하고 각각 <b>T</b>(PC1)와 <b>O</b>(PC1과 직각. PC2)으로 복사합니다. </li></ul><div class="en"><ul><li> Perform PCA using <code>numpy.linalg.eig()</code>.</li><li> Get PC1 and PC2 from the eigenvalue <b>V</b> and eigenvector <b>W</b>, and copy them as <b>T</b>(tangent to PC1) and <b>O</b>(orthogonal to PC1, equivalent to PC2).</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Principal components analysis</span></span><br><span class="line"><span class="comment"># Note that for some seeds, the PC1 and PC2 needs to be inverted</span></span><br><span class="line"><span class="comment"># It could be fixed by looking at the orientation but I&#x27;m lazy</span></span><br><span class="line">W, V = np.linalg.eig(np.cov(Z1.T))                 <span class="comment"># W: eigenvalues, V: eigenvectors</span></span><br><span class="line">PC1, PC2 = V[np.argsort(<span class="built_in">abs</span>(W))]                   <span class="comment"># PC1, PC2: 1st and 2nd Principal components</span></span><br><span class="line"><span class="keyword">if</span> PC2[<span class="number">1</span>] &lt; <span class="number">0</span>:                                     <span class="comment"># to make PC2 &quot;upwards&quot;</span></span><br><span class="line">    PC2 = -PC2</span><br><span class="line">    </span><br><span class="line">rotation = <span class="number">180</span> * np.arctan2(*PC1) / np.pi</span><br><span class="line">T = np.array([PC1[<span class="number">0</span>], PC1[<span class="number">1</span>]])                     <span class="comment"># tangent vector of PC1 (a deep copy of PC1)</span></span><br><span class="line">O = np.array([PC2[<span class="number">0</span>], PC2[<span class="number">1</span>]])                     <span class="comment"># orthogonal vector of PC1 (a deep copy of PC2)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># visualize</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">ax.scatter(Z1[:,<span class="number">0</span>], Z1[:,<span class="number">1</span>], c=<span class="string">&quot;lightgray&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pc, c <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="string">&quot;PC1&quot;</span>, <span class="string">&quot;PC2&quot;</span>], [<span class="string">&quot;b&quot;</span>, <span class="string">&quot;r&quot;</span>]):</span><br><span class="line">    ax.arrow(<span class="number">0</span>, <span class="number">0</span>, *<span class="built_in">eval</span>(pc), width=<span class="number">0.1</span>, length_includes_head=<span class="literal">True</span>, ec=<span class="string">&quot;none&quot;</span>, fc=c)</span><br><span class="line">    ax.text(*<span class="built_in">eval</span>(pc), pc, ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;bottom&quot;</span>, fontsize=<span class="string">&quot;large&quot;</span>, color=c)</span><br><span class="line"></span><br><span class="line">ax.set_aspect(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="92_rougier01_15.png"><br></p><ul><li><b>rotation</b>, <b>T</b>, <b>O</b>를 확인합니다.</li></ul><div class="en"><ul><li> Let's take a look at <b>rotation</b>, <b>T</b>, and <b>O</b>.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;rotation = <span class="subst">&#123;rotation&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;tangent vector = <span class="subst">&#123;T&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;orthogonal vector = <span class="subst">&#123;O&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과 <div class="en">output</div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rotation = 37.89555000213857</span><br><span class="line">tangent vector = [0.61422391 0.78913179]</span><br><span class="line">orthogonal vector = [-0.78913179  0.61422391]</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-4-scatter-plot-and-PC1-axis"><a href="#2-4-scatter-plot-and-PC1-axis" class="headerlink" title="2.4. scatter plot and PC1 axis"></a>2.4. scatter plot and PC1 axis</h2><ul><li>이제 본격적으로 시각화를 수행합니다.</li><li>scatter plot을 그리고 x, y 축의 범위와 값을 지정합니다.</li><li>PC1 축을 따라 점선을 긋습니다.</li></ul><div class="en"><ul><li> Finally data visualization is about to begin.</li><li> Draw a scatter plot; subsidiary x, y ticks and ticklabels are controlled.</li><li> PC1 axis is marked as a dashed line.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Draw</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">ax1 = fig.add_axes([<span class="number">0.05</span>, <span class="number">0.05</span>, <span class="number">0.9</span>, <span class="number">0.9</span>], aspect=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Main scatter plot</span></span><br><span class="line">ax1.scatter(Z1[:, <span class="number">0</span>], Z1[:, <span class="number">1</span>], s=<span class="number">50</span>, fc=<span class="string">&quot;C0&quot;</span>, ec=<span class="string">&quot;white&quot;</span>, lw=<span class="number">0.75</span>)</span><br><span class="line">ax1.set_xlim([-<span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line">ax1.set_xticks([-<span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line">ax1.set_xticklabels([])</span><br><span class="line">ax1.set_ylim([-<span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line">ax1.set_yticks([-<span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line">ax1.set_yticklabels([])</span><br><span class="line">ax1.spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">ax1.spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Draw main PCA axis</span></span><br><span class="line">P0 = np.vstack([Zm - T * <span class="number">10</span>, Zm + T * <span class="number">10</span>])         <span class="comment"># P0 : endpoints of a long line along PC1</span></span><br><span class="line">ax1.plot(P0[:, <span class="number">0</span>], P0[:, <span class="number">1</span>], color=<span class="string">&quot;black&quot;</span>, linestyle=<span class="string">&quot;--&quot;</span>, linewidth=<span class="number">0.75</span>, zorder=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><img src="92_rougier01_05.png"><br></p><h2 id="2-5-Bounding-box-along-PCA-axes"><a href="#2-5-Bounding-box-along-PCA-axes" class="headerlink" title="2.5. Bounding box along PCA axes"></a>2.5. Bounding box along PCA axes</h2><ul><li>데이터 전체를 감싸는 bounding box를 그릴 차례입니다.</li><li>데이터 <b>Z1</b>을 x축을 따라 역회전시킨 후 y 절대값의 최대치로부터 box 높이의 절반 <b>d</b>를 구합니다.</li><li><b>O</b>, <b>T</b>, <b>d</b>로부터 bounding box의 네 꼭지점을 구해 <b>P2</b>에 저장합니다.</li><li>마지막으로 <b>P2</b>로부터 Polygon 객체를 생성해 <code>ax1.add_patch()</code>로 그림에 붙입니다.</li></ul><div class="en"><ul><li> It's time to draw bounding box around the points.</li><li> Rotate the <b>Z1</b> along its X-axis, then find <b>d</b> which is half of the box's abolute y value.</li><li> Get 4 points of the bounding box from <b>O</b>, <b>T</b> and <b>d</b>, store as <b>P2</b>.</li><li> Finally, create Polygon object from <b>P2</b> and add it by using <code>ax1.add_patch()</code>. </li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Compute the width of the distribution along orthogonal direction to the PCA</span></span><br><span class="line"><span class="comment"># main axis. This is made by rotating points and taking max on the Y axis.</span></span><br><span class="line">transform = Affine2D().rotate_deg(-rotation)</span><br><span class="line">P1 = transform.transform(Z1 - Z1.mean(axis=<span class="number">0</span>))     <span class="comment"># P1 : rotated Z1, along x-axis</span></span><br><span class="line">d = np.<span class="built_in">abs</span>(P1[:, <span class="number">1</span>]).<span class="built_in">max</span>()                         <span class="comment"># d  : max. distance between P0 and Z1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Draw a rectangle surrounding the distribution &amp; oriented along PCA main axis</span></span><br><span class="line">P2 = np.vstack(                                    <span class="comment"># P2 : rectangle surrounding Z1</span></span><br><span class="line">    [</span><br><span class="line">        Zm - <span class="number">10</span> * T - d * O,</span><br><span class="line">        Zm + (<span class="number">6</span> - d) * T - d * O,</span><br><span class="line">        Zm + (<span class="number">6</span> - d) * T + d * O,</span><br><span class="line">        Zm - <span class="number">10</span> * T + d * O,</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line">ax1.add_patch(</span><br><span class="line">    Polygon(</span><br><span class="line">        P2,</span><br><span class="line">        closed=<span class="literal">True</span>,</span><br><span class="line">        fill=<span class="literal">True</span>,</span><br><span class="line">        edgecolor=<span class="string">&quot;None&quot;</span>,</span><br><span class="line">        facecolor=<span class="string">&quot;C0&quot;</span>,</span><br><span class="line">        alpha=<span class="number">0.1</span>,</span><br><span class="line">        zorder=-<span class="number">50</span>,</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="92_rougier01_06.png"><br></p><ul><li>bounding box에 윤곽선을 추가하고 축 위에 평균 <b>Zm</b>을 표시하는 삼각형 마커를 추가합니다.</li><li><b>Zm</b>, <b>d</b>, <b>T</b>, <b>O</b>로부터 윤곽선 좌표 <b>P3</b>과 <b>P4</b>를 구해 <code>ax1.plot()</code>으로 조금 진한 윤곽선을 입힙니다.</li></ul><div class="en"><ul><li> Boundary of the bounding box should be more clear, and the triangle markers denoting means <b>Zm</b> should be visible on each axis.</li><li> Get the coordinates of the outline, <b>P3</b> and <b>P4</b>, from <b>Zm</b>, <b>d</b>, <b>T</b> and <b>O</b>, then apply a slightly darker outline by using the command <code>ax1.plot()</code>.</li> </ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># P3, P4 : edges of P2 parallel to PC1</span></span><br><span class="line">P3 = np.vstack([Zm - <span class="number">10</span> * T, Zm + (<span class="number">6</span> - d) * T]) - d * O  </span><br><span class="line">plt.plot(P3[:, <span class="number">0</span>], P3[:, <span class="number">1</span>], color=<span class="string">&quot;C0&quot;</span>, linestyle=<span class="string">&quot;-&quot;</span>, linewidth=<span class="number">0.75</span>, alpha=<span class="number">0.25</span>)</span><br><span class="line">P4 = np.vstack([Zm - <span class="number">10</span> * T, Zm + (<span class="number">6</span> - d) * T]) + d * O</span><br><span class="line">plt.plot(P4[:, <span class="number">0</span>], P4[:, <span class="number">1</span>], color=<span class="string">&quot;C0&quot;</span>, linestyle=<span class="string">&quot;-&quot;</span>, linewidth=<span class="number">0.75</span>, alpha=<span class="number">0.25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Some markers on the axis to show the mean (we could compute exactly the delta</span></span><br><span class="line"><span class="comment"># for placing the marker but it is not the point of this example)</span></span><br><span class="line">ax1.scatter(Zm[<span class="number">0</span>], -<span class="number">2.85</span>, s=<span class="number">50</span>, color=<span class="string">&quot;black&quot;</span>, marker=<span class="string">&quot;v&quot;</span>, clip_on=<span class="literal">False</span>)</span><br><span class="line">ax1.scatter(-<span class="number">2.85</span>, Zm[<span class="number">1</span>], s=<span class="number">50</span>, color=<span class="string">&quot;black&quot;</span>, marker=<span class="string">&quot;&lt;&quot;</span>, clip_on=<span class="literal">False</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="92_rougier01_07.png"><br></p><h2 id="2-6-Add-Axes-for-rotated-histogram"><a href="#2-6-Add-Axes-for-rotated-histogram" class="headerlink" title="2.6. Add Axes for rotated histogram"></a>2.6. Add Axes for rotated histogram</h2><ul><li>이번 시각화의 하일라이트, 회전된 histogram을 붙일 차례입니다.</li><li>회전된 histogram을 붙이기 위해서는 정확한 자리에 정확한 각도와 크기로 새 Axes를 형성하고</li><li>이 Axes 위에 histogram을 회전시켜 붙여야 합니다.</li></ul><div class="en"><ul><li> The next step is the grand finale of this visualization, the rotated histogram.</li><li> In order to add rotated histogram, new Axes should be formed at the exact site with the exact angle and size.</li><li> And then histogram is added with the rotation.</li></ul></div><ul><li>정사각형 모양의 공간을 PC1 방향의 연장선에 형성할 것입니다.</li><li>높이와 너비는 <b>P2</b>로 만들어진 Polygon의 높이와 동일합니다.</li><li>histogram이 놓일 공간의 중심 좌표 <b>C</b>를 구합니다.</li></ul><div class="en"><ul><li> We are now going to form a square shaped space in the direction, and as an extension, of <b>PC1</b>.</li><li> The height and width of the space is same as the height of Polygon based on <b>P2</b>.</li><li> The center coordinate <b>C</b> of the histogram space is calculated.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Compute the center of the histogram</span></span><br><span class="line">C = Zm + <span class="number">6</span> * T</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># visualization</span></span><br><span class="line">ax1.scatter(*C, s=<span class="number">100</span>, c=<span class="string">&quot;orange&quot;</span>, marker=<span class="string">&quot;X&quot;</span>, zorder=<span class="number">1</span>)</span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure><p><img src="92_rougier01_08.png"><br></p><ul><li>histogram이 놓일 공간의 높이 <b>h0</b>와 너비 <b>w0</b>를 구합니다.</li></ul><div class="en"><ul><li> Calculate the height <b>h0</b> and width <b>w0</b> of the histogram space.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. Compute the coordinate and the size in normalized figure coordinates</span></span><br><span class="line">x, y = fig.transFigure.inverted().transform(ax1.transData.transform(C))</span><br><span class="line">xo, yo = fig.transFigure.inverted().transform(ax1.transData.transform(C + <span class="number">2</span> * d * O))</span><br><span class="line">h0 = w0 = np.sqrt((xo - x) ** <span class="number">2</span> + (yo - y) ** <span class="number">2</span>)    <span class="comment"># preparation of the histogram Axes</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#visualize</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.lines <span class="keyword">as</span> lines</span><br><span class="line"></span><br><span class="line">text_xy = fig.text(x, y, <span class="string">&quot;(x, y)&quot;</span>, c=<span class="string">&quot;r&quot;</span>, zorder=<span class="number">1</span>,</span><br><span class="line">                   ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;large&quot;</span>)</span><br><span class="line">text_xyo = fig.text(xo, yo, <span class="string">&quot;(xo, yo)&quot;</span>, c=<span class="string">&quot;r&quot;</span>, zorder=<span class="number">1</span>,</span><br><span class="line">                    ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;large&quot;</span>)</span><br><span class="line">line_hw = fig.add_artist(lines.Line2D([x, xo], [y, yo], c=<span class="string">&quot;orange&quot;</span>, ls=<span class="string">&quot;:&quot;</span>))</span><br><span class="line">text_hw = fig.text((x+xo)/<span class="number">2</span>, (y+yo)/<span class="number">2</span>, <span class="string">&quot;h = w&quot;</span>, c=<span class="string">&quot;r&quot;</span>, </span><br><span class="line">                   ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;large&quot;</span>)</span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure><p><img src="92_rougier01_09.png"><br></p><blockquote><p><a href="https://matplotlib.org/stable/gallery/axisartist/demo_floating_axes.html">matplotlib: mpl_toolkits.axisartist.floating_axes</a></p></blockquote><p><img src="92_rougier01_16.png"><br></p><ul><li>이 치수를 바탕으로 histogram이 놓일 Axes <b>ax2</b>를 생성합니다.</li><li>불규칙한 Axes를 만들 때 <code>floating_axes</code>를 사용합니다.</li></ul><div class="en"><ul><li> Based on this dimensions Axes for histogram, <b>ax2</b> is generated.</li><li> <code>floating_axes</code> is used for irregular Axes.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3. Create the secondary axis</span></span><br><span class="line"><span class="comment">#    Warning: it must be squared, ie. xmax-xmin = ymax-ymin</span></span><br><span class="line"><span class="comment">#    It is possible to have non squared axis, but it would complicate things.</span></span><br><span class="line">xmin, xmax = -<span class="number">16</span>, <span class="number">16</span></span><br><span class="line">ymin, ymax = <span class="number">0</span>, xmax - xmin</span><br><span class="line">transform = Affine2D().rotate_deg(-rotation)</span><br><span class="line">helper = floating_axes.GridHelperCurveLinear(transform, (xmin, xmax, ymin, ymax))</span><br><span class="line">ax2 = floating_axes.FloatingSubplot(fig, <span class="number">111</span>, grid_helper=helper, zorder=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. We know the size of the axis we want but it is rotated. When we specify</span></span><br><span class="line"><span class="comment">#    the size and position, it related to the non-rotate axis and we thus need</span></span><br><span class="line"><span class="comment">#    to compute the bounding box. To do that, we rotate the four coordinates</span></span><br><span class="line"><span class="comment">#    from which we deduce the bounding box coordinates.</span></span><br><span class="line">transform = Affine2D().rotate_deg(-rotation)</span><br><span class="line">R = transform.transform(                            <span class="comment"># outline of the histogram Axes</span></span><br><span class="line">    [</span><br><span class="line">        (x - w0 / <span class="number">2</span>, y - h0 / <span class="number">2</span>),</span><br><span class="line">        (x + w0 / <span class="number">2</span>, y - h0 / <span class="number">2</span>),</span><br><span class="line">        (x - w0 / <span class="number">2</span>, y + h0 / <span class="number">2</span>),</span><br><span class="line">        (x + w0 / <span class="number">2</span>, y + h0 / <span class="number">2</span>),</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line">w1 = R[:, <span class="number">0</span>].<span class="built_in">max</span>() - R[:, <span class="number">0</span>].<span class="built_in">min</span>()                  <span class="comment"># width of the histogram Axes</span></span><br><span class="line">h1 = R[:, <span class="number">1</span>].<span class="built_in">max</span>() - R[:, <span class="number">1</span>].<span class="built_in">min</span>()                  <span class="comment"># height of the histogram Axes</span></span><br><span class="line">ax2.set_position((x - w1 / <span class="number">2</span>, y - h1 / <span class="number">2</span>, w1, h1))</span><br><span class="line">fig.add_subplot(ax2)                                <span class="comment"># Adding histogram Axes</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># visualization</span></span><br><span class="line"><span class="keyword">for</span> text <span class="keyword">in</span> fig.texts:</span><br><span class="line">    text.set_zorder(<span class="number">1</span>)</span><br><span class="line">ax2.set_zorder(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure><p><img src="92_rougier01_10.png"><br></p><h2 id="2-7-Add-Rotated-histogram-and-axis-settings"><a href="#2-7-Add-Rotated-histogram-and-axis-settings" class="headerlink" title="2.7. Add Rotated histogram and axis settings"></a>2.7. Add Rotated histogram and axis settings</h2><ul><li>이제 공간이 마련되었으니 histogram을 붙일 차례입니다.</li><li>회전된 공간에 데이터를 넣으려면 <code>ax2.get_aux_axes(transform)</code>을 사용해 별도의 Axes를 만들어야 합니다.</li><li>PC2 방향의 histogram을 얻기 위해 <code>numpy.histogram(-Z @ PC1)</code>을 사용했습니다. <b>PC1에 수직 방향의 빈도를 구하라</b>는 뜻입니다.</li></ul><div class="en"><ul><li> Since the new Axes is prepared, it is time to add the histogram.</li><li> To visualize data on a rotated space, another Axes should be generated using <code>ax2.get_aux_axes(transform)</code>.</li><li> <code>numpy.histogram(-Z1 @ PC1)</code> is used to obtain histogram along the PC2 axis. The code means <b>return data frequences orthogonal to PC1 axis</b>.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5. Some decoration the secondary axis</span></span><br><span class="line">ax2.axis[<span class="string">&quot;left&quot;</span>].major_ticklabels.set_visible(<span class="literal">False</span>)</span><br><span class="line">ax2.axis[<span class="string">&quot;bottom&quot;</span>].major_ticklabels.set_visible(<span class="literal">False</span>)</span><br><span class="line">ax2.axis[<span class="string">&quot;bottom&quot;</span>].major_ticks.set_tick_out(<span class="literal">True</span>)</span><br><span class="line">ax2.axis[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">ax2.axis[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">ax2.axis[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">ax2.set_xticks([<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">ax2.patch.set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. Display the histogram, taking care of the extents of the X axis</span></span><br><span class="line">counts, bins = np.histogram(-Z1 @ PC1, bins=<span class="number">12</span>)     <span class="comment"># histogram of -Z1 orthogonal to PC1 direction with 12 bins</span></span><br><span class="line">X0 = (bins - bins[<span class="number">0</span>]) / (bins[-<span class="number">1</span>] - bins[<span class="number">0</span>])        <span class="comment"># X0 : normalized bins range [0, 1]</span></span><br><span class="line">X1 = xmin + (xmax - xmin) * X0                      <span class="comment"># X1 : stretched bins range [xmin, xmax] = [-16, 16]</span></span><br><span class="line">Y = np.array(counts)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This auxiliary axis is necessary to draw stuff (no real idea why)</span></span><br><span class="line">ax2_aux = ax2.get_aux_axes(transform)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plotting histogram </span></span><br><span class="line">ax2_aux.hist(X1[:-<span class="number">1</span>], X1, weights=Y, facecolor=<span class="string">&quot;C0&quot;</span>, edgecolor=<span class="string">&quot;white&quot;</span>, linewidth=<span class="number">0.25</span>)</span><br><span class="line"></span><br><span class="line">text_xy.remove()</span><br><span class="line">text_xyo.remove()</span><br><span class="line">text_hw.remove()</span><br><span class="line">line_hw.remove()</span><br><span class="line"></span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure><p><img src="92_rougier01_11.png"><br></p><ul><li>마지막으로 히스토그램 숫자를 기입합니다.</li></ul><div class="en"><ul><li> At last, put numbers on top of the bars of histogram.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 7. Adding some labels</span></span><br><span class="line">dx, dy = (X1[<span class="number">1</span>] - X1[<span class="number">0</span>]) / <span class="number">2</span>, <span class="number">0.75</span></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(X1, Y):</span><br><span class="line">    ax2_aux.text(</span><br><span class="line">        x + dx,</span><br><span class="line">        y + dy,</span><br><span class="line">        <span class="string">&quot;%d&quot;</span> % y,</span><br><span class="line">        ha=<span class="string">&quot;center&quot;</span>,</span><br><span class="line">        va=<span class="string">&quot;center&quot;</span>,</span><br><span class="line">        size=<span class="number">8</span>,</span><br><span class="line">        rotation=-rotation,</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure><p><img src="92_rougier01_12.png"><br></p><h1 id="3-Conclusion"><a href="#3-Conclusion" class="headerlink" title="3. Conclusion"></a>3. Conclusion</h1><ul><li>코드를 여러 부분으로 나누어 그림이 만들어지는 과정을 코드와 함께 살펴봤습니다.</li><li>리뷰 과정에서 원본을 일부 수정한 Pull Request가 적용되었습니다. 이 글은 수정본을 기반으로 작성되었습니다.</li><li>Matplotlib은 표현력이 매우 강한 라이브러리입니다. </li><li>여러분의 상상을 실현하는 데, Nicolas의 훌륭한 코드를 이해하는 데 도움이 되시길 바랍니다.</li></ul><div class="en"><ul><li> In this article we divide the source code into many parts, and looked through how the final figure was created.</li><li> A couple of changes were suggested as a form of Pull Request to correct small errors, and accepted. This article is written based on the revised version of mine.</li><li> Matplotlib is a library with a strong power of expression.</li><li> I hope this article to be an assistant to realize your imagination, as well as help you understand Nicolas's excellent code.</li></ul></div>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/Nicolas-P-Rougier/">Nicolas P. Rougier</category>
      
      
    </item>
    
    <item>
      <title>NIA Data Story - Movie) 0. intro</title>
      <link>https://jehyunlee.github.io/2021/11/29/Python-DS-91-movie01/</link>
      <guid>https://jehyunlee.github.io/2021/11/29/Python-DS-91-movie01/</guid>
      <pubDate>Mon, 29 Nov 2021 11:50:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;한국지능정보사회진흥원(NIA) 요청으로 데이터 스토리를 작성했습니다.&lt;/li&gt;
&lt;li&gt;1971-2020, 50년간 국내 개봉작을 데이터의 형태로 경험했습니다.&lt;/li&gt;
&lt;li&gt;시각화 코드를 조금 자세히 풀어서 전달드리고자 합니다.&lt;/l</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>한국지능정보사회진흥원(NIA) 요청으로 데이터 스토리를 작성했습니다.</li><li>1971-2020, 50년간 국내 개봉작을 데이터의 형태로 경험했습니다.</li><li>시각화 코드를 조금 자세히 풀어서 전달드리고자 합니다.</li></ul><h1 id="1-“빅”데이터-검수-문제"><a href="#1-“빅”데이터-검수-문제" class="headerlink" title="1. “빅”데이터 검수 문제"></a>1. “빅”데이터 검수 문제</h1><blockquote><p><a href="http://www.bigdata-map.kr/">통합 데이터 지도</a></p></blockquote><ul><li>최근 전에 없이 국가적인 단위에서 데이터 수집 사업이 수행되었습니다.</li><li>앞으로 다가올 데이터 기반 사회를 위한 기초공사입니다.</li></ul><ul><li>그러나 <b>수집된 데이터의 유효성을 검증하기는 참으로 어렵습니다.</b></li><li>데이터가 한 두 개도 아니고 일일이 열어보기 어려울 뿐더러, </li><li><b>데이터가 있다</b>와 <b>쓸만한 데이터가 있다</b>는 것은 완전히 다른 차원의 문제입니다.<br><img src="91_movie01_5.png"><br></li></ul><ul><li>NIA의 데이터 검증 의지를 가지신 분들 덕택에 모니터링단으로 활동할 수 있었습니다.</li><li>적지 않은 문제를 발견해 공식 보고와 함께 여러 제언을 드렸습니다.</li><li>그 중 가장 강하게 말씀드린 것은 <b>데이터는 활용될 때 검증된다</b>는 것,</li><li>그리고 <b>사람의 힘으로는 불가능하니 자동 검수 시스템이 필요하다</b>는 것이었습니다.<br><br><img src="91_movie01_4.png"><br></li></ul><ul><li>작년 AI Festival에서 이 말씀을 발표드리는 한편 신문에 기고문도 실었습니다.<ul><li>해당 발표와 기고문은 <a href="https://jehyunlee.github.io/2020/09/03/Python-DS-33-aifestival_bigdatareality/">여기서 보실 수 있습니다.</a></li></ul></li></ul><p><img src="91_movie01_6.png" alt="2020 AI Festival 발표 영상"><br></p><h1 id="2-NIA-데이터-스토리"><a href="#2-NIA-데이터-스토리" class="headerlink" title="2. NIA 데이터 스토리"></a>2. NIA 데이터 스토리</h1><blockquote><p><a href="http://www.bigdata-map.kr/datastory">데이터 스토리</a></p></blockquote><ul><li>다행히 NIA에 비슷한 생각을 하는 분들이 있으셨습니다.</li><li><b>적재된 데이터를 소비자가 구매하기 전에 스토리로 가공하여 게시</b>하셨습니다.</li><li>많은 분들이 글을 써 주셨고, 제게도 기회가 주어졌습니다.<br><br><img src="91_movie01_3.png"><br></li></ul><ul><li>데이터 스토리 작성을 위해 여러 데이터를 살펴보았고, 문제점을 찾을 때마다 보고를 했습니다.</li><li>그리고 영화 데이터에 정착하여 <b>영화 데이터를 분석한 스토리</b>를 기고했습니다.</li><li><b>1971년 이후 50년간의 개봉 영화 23,409편</b>을 대상으로 삼았습니다.</li><li><b>(1) 장르 <a href="https://bit.ly/3xhc8BV">[Link]</a></b>와 <b>(2) 박스오피스 <a href="https://bit.ly/3cBpZK3">[Link]</a></b> 두 편으로 나누어 작성했습니다.<br><br><img src="91_movie01_7.png"><br></li></ul><ul><li>제 글에 점수를 주라면 100점 만점에 60~70점 정도 되는 것 같습니다.</li><li>너무 힘이 들어간 부분도 있고, 지쳐 힘이 빠진 부분도 있습니다.</li><li>이렇게 긴 분석 글을 처음 쓰다 보니 결과물을 볼 때 많이 아쉬운 것이 사실입니다.</li><li>한편 부족하나마 제 성장에도 보탬이 된 것이 사실입니다.</li></ul><h1 id="3-과정"><a href="#3-과정" class="headerlink" title="3. 과정"></a>3. 과정</h1><ul><li>데이터 스토리는 <b><a href="https://github.com/niadatamap/DataMap_DataStory/raw/master/2021/23/">소스 코드까지 제출하여 공개</a>했습니다.</b></li><li>그러나 <b>저 그림을 그리기 위해 생각한 과정들,</b></li><li>그리고 <b>저 그림의 코드는 왜 저렇게 작성되었는지</b>는 충분히 설명되지 않았습니다.</li></ul><ul><li>앞으로 여러 개의 글을 통해 이 점을 메꾸려고 합니다.</li><li>여러분께서 보시고 좋은 점은 교사로, 부족한 점은 반면교사로 활용하시면 좋겠습니다.</li><li>이 글을 쓰는 과정이 제 성장의 거름이 되었듯 여러분의 성장에도 보탬이 되기를 바랍니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/Google-Colab/">Google Colab</category>
      
      <category domain="https://jehyunlee.github.io/tags/open-API/">open API</category>
      
      <category domain="https://jehyunlee.github.io/tags/NIA-data-story/">NIA data story</category>
      
      
    </item>
    
    <item>
      <title>2D distribution</title>
      <link>https://jehyunlee.github.io/2021/11/22/Python-DS-90-density2d/</link>
      <guid>https://jehyunlee.github.io/2021/11/22/Python-DS-90-density2d/</guid>
      <pubDate>Mon, 22 Nov 2021 11:50:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;2차원 공간의 데이터 분포를 표현합니다.&lt;/li&gt;
&lt;li&gt;많이 사용하는 기능이면서도 막상 쓰려면 디테일에 발목을 잡힙니다.&lt;/li&gt;
&lt;li&gt;Matplotlib, seaborn에 이어 mpl-scatter-density도 알아봅니다.&lt;/</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>2차원 공간의 데이터 분포를 표현합니다.</li><li>많이 사용하는 기능이면서도 막상 쓰려면 디테일에 발목을 잡힙니다.</li><li>Matplotlib, seaborn에 이어 mpl-scatter-density도 알아봅니다.</li></ul><h1 id="1-2D-data-distribution"><a href="#1-2D-data-distribution" class="headerlink" title="1. 2D data distribution"></a>1. 2D data distribution</h1><ul><li>데이터가 2차원으로 분포하는 경우는 매우 흔합니다.</li><li>N차원으로 분포하는 데이터의 두 차원만 떼어 보여주는 경우도 많고</li><li>머신러닝 모델의 예측 성능을 평가하는 parity plot도 그렇습니다.</li></ul><ul><li><p>먼저 필수 라이브러리를 불러오고</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure></li><li><p>2차원에 분포한 데이터를 만듭니다.</p></li><li><p>$y = x^2$를 사용해서 막대기같은 데이터보다는 조금 보기 좋은 모양을 만듭니다.</p></li><li><p>데이터는 1만개입니다. 0이 많은 숫자를 쓸 때 천 단위로 _를 넣어주면 읽기 좋습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">10_000</span>) + np.random.normal(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10_000</span>)</span><br><span class="line">y = np.power(x, <span class="number">2</span>)/<span class="number">14</span> + np.random.normal(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10_000</span>)</span><br></pre></td></tr></table></figure></li></ul><h1 id="2-정석-scatter-plot"><a href="#2-정석-scatter-plot" class="headerlink" title="2. 정석, scatter plot"></a>2. 정석, scatter plot</h1><ul><li><p>x, y 공간에 분포한 데이터 시각화의 정석은 scatter plot입니다.</p></li><li><p>경험으로부터 좁은 공간에 밀집한 점은 서로를 가린다는 것을 알고 있습니다.</p></li><li><p><code>alpha=0.1</code>로 투명도 90%를 설정해서 겹친 점이 보이게 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">8</span>, <span class="number">4</span>), </span><br><span class="line">                        gridspec_kw=&#123;<span class="string">&quot;wspace&quot;</span>:<span class="number">0.1</span>, <span class="string">&quot;hspace&quot;</span>:<span class="number">0.1</span>&#125;,</span><br><span class="line">                        sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>, constrained_layout=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># scatter plot</span></span><br><span class="line">axs[<span class="number">0</span>].scatter(x, y, s=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># scatter plot with transparancy</span></span><br><span class="line">axs[<span class="number">1</span>].scatter(x, y, s=<span class="number">3</span>, alpha=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># titles</span></span><br><span class="line">titles = [<span class="string">&quot;Matplotlib scatter (alpha=1)&quot;</span>, <span class="string">&quot;Matplotlib scatter (alpha=0.1)&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, titles):</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;x-large&quot;</span>, pad=<span class="number">16</span>)</span><br><span class="line">    ax.set_aspect(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="90_density2d_01.png"><br></p></li><li><p>반투명이 적용되지 않은 왼쪽은 데이터의 위치는 보이지만 밀도가 보이지 않습니다.</p></li><li><p>반투명을 90% 적용한 오른쪽은 데이터의 밀도는 보이지만 경계가 잘 보이지 않습니다.</p></li><li><p>고급 방법이 필요합니다.</p></li></ul><h1 id="3-2D-histogram-hexbin-KDE-plot"><a href="#3-2D-histogram-hexbin-KDE-plot" class="headerlink" title="3. 2D histogram, hexbin, KDE plot"></a>3. 2D histogram, hexbin, KDE plot</h1><ul><li>1D에서 많이 쓰는 histogram과 KDE plot은 2D에도 적용 가능합니다.</li><li>2D 공간을 육각으로 나누는 hexbin도 사용할 만 합니다.</li></ul><ul><li><p>조금 색다른 colormap을 사용합시다.</p></li><li><p><a href="https://jehyunlee.github.io/2020/12/28/Python-DS-51-cmocean/">전에 작성한 글에서 <b>cmocean</b>이라는 colormap set을 소개했습니다.</a></p></li><li><p> 얼음을 정말 그럴듯하게 표현하는 <b>ice</b> colormap이 있습니다.<br><img src="https://jehyunlee.github.io/2020/12/28/Python-DS-51-cmocean/giphy.gif"><br></p></li><li><p>ice colormap을 cmap이라는 변수에 넣어서 사용하기로 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cmocean.cm <span class="keyword">as</span> cmo</span><br><span class="line">cmap = cmo.ice</span><br><span class="line">cmap</span><br></pre></td></tr></table></figure><p><img src="90_density2d_06.png"><br></p></li></ul><ul><li><p>Matplotlib의 <b>hist2d</b>, <b>hexbin</b>,</p></li><li><p>seaborn의 <b>kdeplot</b>에 ice colormap을 입혀 사용합니다.</p></li><li><p><code>sns.kdeplot()</code>은 <code>fill=True</code>를 추가하면 등고선이 아니라 면을 칠합니다.</p></li><li><p><code>levels</code>에 충분히 큰 값을 넣어서 매끄러운 그라데이션을 구현합니다.</p></li><li><p>바탕이 텅 비어버리므로 <code>set_facecolor(&#39;k&#39;)</code>를 넣어서 배경을 검게 한번 더 칠합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(ncols=<span class="number">2</span>, nrows=<span class="number">2</span>, figsize=(<span class="number">8</span>, <span class="number">8</span>), </span><br><span class="line">                         gridspec_kw=&#123;<span class="string">&quot;wspace&quot;</span>:<span class="number">0.1</span>, <span class="string">&quot;hspace&quot;</span>:<span class="number">0.1</span>&#125;,</span><br><span class="line">                         sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>, constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2D histogram</span></span><br><span class="line">axes[<span class="number">0</span>, <span class="number">0</span>].hist2d(x, y, cmap=cmap, bins=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># hexbin</span></span><br><span class="line">axes[<span class="number">0</span>, <span class="number">1</span>].hexbin(x, y, cmap=cmap, gridsize=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2D KDE plot (contour)</span></span><br><span class="line">sns.kdeplot(x, y, cmap=cmap, ax=axes[<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2D KDE plot (fill)</span></span><br><span class="line">sns.kdeplot(x, y, cmap=cmap, fill=<span class="literal">True</span>, thread=<span class="number">0</span>, levels=<span class="number">20</span>, ax=axes[<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">axes[<span class="number">1</span>, <span class="number">1</span>].set_facecolor(<span class="string">&quot;k&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># titles</span></span><br><span class="line">titles = [<span class="string">&quot;Matplotlib hist2d&quot;</span>, <span class="string">&quot;Matplotlib hexbin&quot;</span>, <span class="string">&quot;seaborn kdeplot&quot;</span>, <span class="string">&quot;seaborn kdeplot(fill=True)&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axes.ravel(), titles):</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;x-large&quot;</span>, pad=<span class="number">16</span>)</span><br><span class="line">    ax.set_aspect(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="90_density2d_02.png"><br></p></li><li><p>코딩을 한 보람이 비로소 느껴집니다.</p></li></ul><h1 id="4-colorbar-달기"><a href="#4-colorbar-달기" class="headerlink" title="4. colorbar 달기"></a>4. colorbar 달기</h1><ul><li>데이터의 밀도를 표현하는 그림에서 색이 나타내는 데이터의 수나 밀도는 중요하지 않을 지도 모릅니다.</li><li>그러나 교양 삼아 colorbar를 붙이는 방법을 짚고 넘어갑시다.</li><li>필요할 때 붙이려면 은근히 안 붙습니다.</li></ul><ul><li><b><code>Matplotlib hist2d</code></b>은 return하는 여러 값 중 맨 마지막이 그림입니다.</li><li>맨 마지막만 <code>im0</code>라는 이름으로 받아서 이를 <code>plt.colorbar()</code>에 넣습니다.</li><li><b><code>Matplotlib hexbin</code></b>은 곧장 그림을 return합니다.</li><li>그대로 <code>im1</code>로 받아서 넣습니다.</li><li>Matplotlib에서 만든 colorbar는 <code>set_label</code>로 이름을 추가할 수 있습니다.</li></ul><ul><li><b><code>seaborn KDE plot</code></b>은 자체에 colorbar 출력을 결정하는 매개변수가 있습니다.</li><li><code>cbar=True</code>로 놓고 <code>cbar_kws</code>에 속성을 결정하는 키워드를 딕셔너리 형식으로 추가합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(ncols=<span class="number">2</span>, nrows=<span class="number">2</span>, figsize=(<span class="number">8</span>, <span class="number">7</span>), </span><br><span class="line">                         gridspec_kw=&#123;<span class="string">&quot;wspace&quot;</span>:<span class="number">0.1</span>, <span class="string">&quot;hspace&quot;</span>:<span class="number">0.1</span>&#125;,</span><br><span class="line">                         sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>, constrained_layout=<span class="literal">True</span>)</span><br><span class="line">axs = axes.ravel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2D histogram</span></span><br><span class="line">_, _, _, im0 = axs[<span class="number">0</span>].hist2d(x, y, cmap=cmap, bins=<span class="number">30</span>)</span><br><span class="line">cbar0 = plt.colorbar(im0, ax=axs[<span class="number">0</span>])</span><br><span class="line">cbar0.set_label(<span class="string">&quot;data counts&quot;</span>, fontsize=<span class="string">&quot;large&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># hexbin</span></span><br><span class="line">im1 = axs[<span class="number">1</span>].hexbin(x, y, cmap=cmap, gridsize=<span class="number">30</span>)</span><br><span class="line">cbar1 = plt.colorbar(im1, ax=axs[<span class="number">1</span>])</span><br><span class="line">cbar1.set_label(<span class="string">&quot;data counts&quot;</span>, fontsize=<span class="string">&quot;large&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2D KDE plot (contour)</span></span><br><span class="line">sns.kdeplot(x, y, cmap=cmap, ax=axs[<span class="number">2</span>], </span><br><span class="line">            cbar=<span class="literal">True</span>, cbar_kws=&#123;<span class="string">&quot;label&quot;</span>:<span class="string">&quot;data density&quot;</span>, <span class="string">&quot;format&quot;</span>:<span class="string">&quot;%.3f&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2D KDE plot (fill)</span></span><br><span class="line">sns.kdeplot(x, y, cmap=cmap, fill=<span class="literal">True</span>, thresh=<span class="number">0</span>, levels=<span class="number">20</span>, ax=axs[<span class="number">3</span>], </span><br><span class="line">            cbar=<span class="literal">True</span>, cbar_kws=&#123;<span class="string">&quot;label&quot;</span>:<span class="string">&quot;data density&quot;</span>, <span class="string">&quot;format&quot;</span>:<span class="string">&quot;%.3f&quot;</span>&#125;)</span><br><span class="line">axs[<span class="number">3</span>].set_facecolor(<span class="string">&quot;k&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># titles</span></span><br><span class="line">titles = [<span class="string">&quot;Matplotlib hist2d&quot;</span>, <span class="string">&quot;Matplotlib hexbin&quot;</span>, <span class="string">&quot;seaborn kdeplot&quot;</span>, <span class="string">&quot;seaborn kdeplot(fill=True)&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axes.ravel(), titles):</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;x-large&quot;</span>, pad=<span class="number">16</span>)</span><br><span class="line">    ax.set_aspect(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><img src="90_density2d_03.png"><br></li></ul><h1 id="5-mpl-scatter-density"><a href="#5-mpl-scatter-density" class="headerlink" title="5. mpl-scatter-density"></a>5. mpl-scatter-density</h1><blockquote><p><a href="https://pypi.org/project/mpl-scatter-density/">mpl-scatter-density</a></p></blockquote><ul><li><p><a href="https://pypi.org/project/mpl-scatter-density/">mpl-scatter-density</a>라는 라이브러리가 있습니다.</p></li><li><p><b>scatter plot을 그리면 점의 밀도를 계산해서 색을 입혀주는 라이브러리</b>입니다.</p></li><li><p>위에서 살펴본 Matplotlib, seaborn 자체 기능과 얼마나 비슷하고 다른지 살펴봅니다.</p></li><li><p>먼저, 노트북 셀 안에서 설치합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!pip install mpl-scatter-density</span><br></pre></td></tr></table></figure></li><li><p>공식 홈페이지에 나온 설명을 따라 그립니다.</p></li><li><p>공식 홈페이지에는 Figure와 Axes를 따로 그리면서 <code>ax = fig.add_subplot(1, 1, 1, projection=&#39;scatter_density&#39;)</code>를 사용했습니다.</p></li><li><p><code>plt.subplots()</code>를 사용할 때는 <code>subplot_kw=&#123;&quot;projection&quot;:&quot;scatter_density&quot;&#125;</code>를 추가하면 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mpl_scatter_density</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">9</span>, <span class="number">3</span>), subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;scatter_density&quot;</span>&#125;,</span><br><span class="line">                        gridspec_kw=&#123;<span class="string">&quot;wspace&quot;</span>:<span class="number">0.1</span>&#125;, constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># scatter plot with transparancy</span></span><br><span class="line">axs[<span class="number">0</span>].scatter(x, y, s=<span class="number">3</span>, alpha=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># scatter density</span></span><br><span class="line">axs[<span class="number">1</span>].scatter_density(x, y, cmap=cmap, dpi=<span class="number">36</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># scatter density with colormap</span></span><br><span class="line">im2 = axs[<span class="number">2</span>].scatter_density(x, y, cmap=cmap, dpi=<span class="number">36</span>)</span><br><span class="line">plt.colorbar(im2, ax=axs[<span class="number">2</span>], shrink=<span class="number">0.86</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># titles</span></span><br><span class="line">titles = [<span class="string">&quot;Matplotlib scatter (alpha=0.1)&quot;</span>, <span class="string">&quot;scatter_density&quot;</span>, <span class="string">&quot;scatter_density with colorbar&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, titles):</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;x-large&quot;</span>, pad=<span class="number">16</span>)</span><br><span class="line">    ax.set_aspect(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="90_density2d_04.png"><br></p></li><li><p>scatter plot과 비슷한 명령이면서도 점의 밀도에 따라 밝기가 달라졌습니다.</p></li><li><p>위 코드를 보면 해상도를 의미하는 <b><code>dpi</code></b>라는 매개변수가 사용되었습니다.</p></li><li><p><b>Axes를 가로세로 구간으로 나누어 각 구간 안에 들어오는 점의 수를 세는 것</b>입니다.</p></li><li><p><b>음? Matplotlib hist2d랑 같은 것 아닌가 모르겠습니다?</b></p></li></ul><h1 id="6-Matplotlib-hist2d-vs-mpl-scatter-density"><a href="#6-Matplotlib-hist2d-vs-mpl-scatter-density" class="headerlink" title="6. Matplotlib hist2d vs mpl-scatter-density"></a>6. Matplotlib hist2d vs mpl-scatter-density</h1><ul><li><p><b>Matplotlib hist2d와 1:1로 비교</b>합니다.</p></li><li><p>Matplotlib hist2d는 <code>bins</code> 매개변수로 해상도를 조절합니다.</p></li><li><p>두 명령을 번갈아 사용하며 다양한 <code>bins</code>와 <code>dpi</code> 매개변수를 적용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(nrows=<span class="number">2</span>, ncols=<span class="number">4</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>), subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;scatter_density&quot;</span>&#125;,</span><br><span class="line">                         sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>,</span><br><span class="line">                         gridspec_kw=&#123;<span class="string">&quot;wspace&quot;</span>:<span class="number">0.1</span>, <span class="string">&quot;hspace&quot;</span>:<span class="number">0.15</span>&#125;, constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># hist2d</span></span><br><span class="line">axs_h2 = axes[<span class="number">0</span>, :]</span><br><span class="line">bins = [<span class="number">20</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">160</span>]</span><br><span class="line"><span class="keyword">for</span> ax, b <span class="keyword">in</span> <span class="built_in">zip</span>(axs_h2, bins):</span><br><span class="line">    ax.hist2d(x, y, bins=b, cmap=cmap)</span><br><span class="line">    ax.set_title(<span class="string">f&quot;\n\nbins=<span class="subst">&#123;b&#125;</span>&quot;</span>, fontsize=<span class="string">&quot;x-large&quot;</span>)</span><br><span class="line">fig.text(<span class="number">0.5</span>, <span class="number">0.95</span>, <span class="string">&quot;Matplotlib hist2d&quot;</span>, ha=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;xx-large&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># scatter_density</span></span><br><span class="line">axs_sd = axes[<span class="number">1</span>, :]</span><br><span class="line">dpis = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">36</span>, <span class="number">60</span>]</span><br><span class="line"><span class="keyword">for</span> ax, d <span class="keyword">in</span> <span class="built_in">zip</span>(axs_sd, dpis):</span><br><span class="line">    ax.scatter_density(x, y, dpi=d, cmap=cmap)</span><br><span class="line">    ax.set_title(<span class="string">f&quot;\ndpi=<span class="subst">&#123;d&#125;</span>&quot;</span>, fontsize=<span class="string">&quot;x-large&quot;</span>)</span><br><span class="line">fig.text(<span class="number">0.5</span>, <span class="number">0.45</span>, <span class="string">&quot;scatter-density&quot;</span>, ha=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;xx-large&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="90_density2d_05.png"><br></p></li><li><p><b>두 명령의 결과가 거의 동일합니다</b></p></li><li><p>원리가 같기 때문에 당연한 결과입니다. 실행 시간도 체감할 수 없을만큼 차이가 나지 않습니다.</p></li><li><p>둘이 만드는 객체를 비교합니다. 먼저 Matplotlib hist2d입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Matplotlib hist2d</span></span><br><span class="line">axes[<span class="number">0</span>, <span class="number">0</span>].get_children()[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;matplotlib.collections.QuadMesh at 0x7f1d06764510&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>이번에는 scatter-density 입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># scatter-density</span></span><br><span class="line">axes[<span class="number">1</span>, <span class="number">0</span>].get_children()[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mpl_scatter_density.scatter_density_artist.ScatterDensityArtist at 0x7f1d066f97d0&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li>별도의 라이브러리를 사용하고 projection을 따로 지정하는 만큼 별도의 객체를 생성하고 있습니다.</li></ul><h1 id="7-결론"><a href="#7-결론" class="headerlink" title="7. 결론"></a>7. 결론</h1><ul><li>scatter-density는 원리와 출력물의 외관이 Matplotlib hist2d와 같은 결과물을 내놓습니다.</li><li>라이브러리가 크게 부담스럽지 않아 추가로 설치하는 것은 괜찮습니다.</li><li>그러나 함수의 매개변수가 적어 표현력이 제한되어 있고 결과물이 Matplotlib 표준이 아니라는 점이 아쉽습니다.</li><li>특별한 이유가 있지 않다면 <b>Matplotlib hist2d를 사용하는 것을 권장드립니다.</b></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/scatter-density/">scatter-density</category>
      
      
    </item>
    
  </channel>
</rss>
