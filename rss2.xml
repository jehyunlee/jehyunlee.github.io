<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Pega Devlog</title>
    <link>https://jehyunlee.github.io/</link>
    
    <atom:link href="https://jehyunlee.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Pega&#39;s Development log for myself and others</description>
    <pubDate>Mon, 26 Jun 2023 08:43:13 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Bing Image Creator (1) 시작</title>
      <link>https://jehyunlee.github.io/2023/06/25/General-23-BingImageCreator1/</link>
      <guid>https://jehyunlee.github.io/2023/06/25/General-23-BingImageCreator1/</guid>
      <pubDate>Sat, 24 Jun 2023 15:40:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;b&gt;Contributor:&lt;/b&gt; 조남경님&lt;br&gt;&lt;a href=&quot;https://www.bing.com/create&quot;&gt;Bing Image Creator&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Microsof</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><b>Contributor:</b> 조남경님<br><a href="https://www.bing.com/create">Bing Image Creator</a></p></blockquote><ul><li>Microsoft가 OpenAI와 손을 잡고 진격을 계속하고 있습니다.</li><li>ChatGPT 관련된 협력에 이어 지난 5월 21일, <a href="https://blogs.microsoft.com/blog/2023/03/21/create-images-with-your-words-bing-image-creator-comes-to-the-new-bing/">BingChat에서 그림을 그릴 수 있음</a>을 공지했습니다.</li></ul><ul><li>이미 <a href="https://www.bing.com/create">Bing Image Creator</a>라는 이름으로 OpenAI의 DALL-E를 서비스하기 시작했으며</li><li><a href="https://divine.ai/blog/dall-e-2-vs-bing-image-creator-do-we-have-a-winner/">모든 면에서 DALL-E보다 성능이 우수하다</a>는 평을 받고 있습니다.</li><li>Midjourney, Stable Diffusion 등 다른 좋은 모델들이 있습니다.</li><li>그렇지만 Bing Image Creator는 간편합니다. <b>Discord 없이 웹에서 접근 가능</b>하고, <b>Bingchat</b>에서 쓸 수 있다는 장점이 있습니다.</li><li>특징을 하나씩 알아가는 중이지만 본 글을 통해 제가 알게 된 노하우를 조금씩 나누고자 합니다.</li></ul><h1 id="1-Bing-Image-Creator-접속"><a href="#1-Bing-Image-Creator-접속" class="headerlink" title="1. Bing Image Creator 접속"></a>1. Bing Image Creator 접속</h1><ul><li><p><a href="https://www.bing.com/create">https://www.bing.com/create</a>에 접속하면 다음과 같은 화면이 보입니다.<br><br><img src="23_bic1_01.png"><br></p></li><li><p>혹시 위와 같은 화면이 보이지 않는다면, <b>오른쪽 위</b>에서 <b>로그인</b>버튼을 찾아 들어갑니다.</p></li><li><p><b>Microsoft 계정</b>이 필요합니다.</p></li><li><p>윈도우 사용자라면 윈도우를 설치할 때 사용한 그 계정을 사용하시면 됩니다.</p></li></ul><ul><li><p>전반적인 구성은 단순합니다.</p></li><li><p><b>상단 입력창</b>에 프롬프트를 입력해 그림을 생성합니다.</p></li><li><p>자주색 <b>만들기</b> 버튼을 누르면 그림이 생성되는데, 바로 왼쪽 <b>번개 코인</b> 숫자가 보일 것입니다.</p></li><li><p><b>부스트</b>라고 합니다.</p></li><li><p>그림을 한 번 그릴 때마다 숫자가 차감이 되지만 0이 된다고 못 그리지 않습니다. 늦게 그려질 뿐입니다.<br><br><img src="23_bic1_17.png"><br></p></li><li><p>부스트는 <b>오후 4시경 리셋</b>됩니다.</p></li><li><p>Microsoft bing 검색, Edge browser 사용 등 Microsoft 제품을 열심히 쓰면 최대 코인 수가 늘어납니다.</p></li><li><p>저는 매일 코인이 100개로 리셋됩니다.</p></li><li><p><b>Microsoft Edge browser</b>를 기본으로 사용하고 있기 때문입니다.</p></li></ul><h1 id="2-그림-그리기"><a href="#2-그림-그리기" class="headerlink" title="2. 그림 그리기"></a>2. 그림 그리기</h1><ul><li>첫 번째 그림으로 <b>고양이</b>를 그립니다.</li><li>입력창에 <b>cat</b>이라고 입력하고 <b>만들기</b>를 누릅니다.<br></li></ul><p><img src="23_bic1_02.png" alt="&quot;cat&quot;"><br></p><ul><li>잠시 기다림이 지난 후 고양이 얼굴이 생겼습니다.</li><li>반가운 마음에 곧장 다운로드를 하고 싶겠지만 조금만 참아봅시다.</li><li>내 머리 속에는 <b>하얀 고양이가 웃는 옆모습</b>이 자리잡고 있기 때문입니다.</li><li>이 그림을 머리 속에서 화면으로 옮기려고 합니다.</li></ul><h1 id="3-그림-고치기"><a href="#3-그림-고치기" class="headerlink" title="3. 그림 고치기"></a>3. 그림 고치기</h1><h2 id="3-1-고양이-표정-색-고치기"><a href="#3-1-고양이-표정-색-고치기" class="headerlink" title="3.1. 고양이 표정, 색 고치기"></a>3.1. 고양이 표정, 색 고치기</h2><ul><li>cat 앞에 smiling과 white를 차례로 추가해 표정과 색을 지정합니다.<br></li></ul><p><img src="23_bic1_03.png" alt="&quot;smiling cat&quot;"><br></p><p><img src="23_bic1_04.png" alt="&quot;smiling white cat&quot;"><br></p><ul><li>이 밖에 원하는 그림이 있다면 속성을 지정하는 말을 얼마든지 붙일 수 있습니다.</li><li><b>귀찮게 외워야 하는 특별한 명령어가 없습니다.</b></li><li><b>머리 속으로 그림을 최대한 구체적으로 그린 후, 이를 말로 옮기면 됩니다.</b></li></ul><h2 id="3-2-우리말로-명령하기"><a href="#3-2-우리말로-명령하기" class="headerlink" title="3.2. 우리말로 명령하기"></a>3.2. 우리말로 명령하기</h2><ul><li>꼭 영어를 사용해야 하는 것은 아닙니다.</li><li><b>미소짓는 하얀 고양이</b>를 입력해도 같은 효과가 있습니다.<br></li></ul><p><img src="23_bic1_07.png" alt="&quot;미소짓는 하얀 고양이&quot;"><br></p><ul><li>그러나 저는 영어 입력을 선호하는 편입니다.</li><li>이런 모델이 학습한 언어 중 영어의 비율이 압도적이기 때문에 적확한 표현이 가능하기 때문입니다.</li><li>물론 영어단어가 잘 떠오르지 않거나 한글 입력이 더 적확할 때는 한글을 씁니다만,</li><li>경험적으로 영어 입력이 의도를 더 잘 반영하는 것 같습니다.</li></ul><ul><li>“미소짓는 white cat” 처럼 <b>여러 언어를 섞어도 됩니다.</b><br></li></ul><p><img src="23_bic1_08.png" alt="&quot;미소짓는 white cat&quot;"><br></p><h2 id="3-3-속성-개별-지정"><a href="#3-3-속성-개별-지정" class="headerlink" title="3.3. 속성 개별 지정"></a>3.3. 속성 개별 지정</h2><ul><li>고양이의 속성으로 “smiling”과 “white”를 지정했습니다.</li><li>묘사하고자 하는 속성이 길어지면 문장이 꼬이기 시작합니다.</li><li>이럴 때, 속성을 따로 떼어 지정할 수 있으면 의도 반영이 유리해집니다.</li><li><b>중괄호</b>를 사용할 수 있으며, 소재, 스타일, 색, 크기 등 여러 속성을 지정할 수 있습니다.<br></li></ul><p><img src="23_bic1_05.png" alt="&quot;cat {smile}{white}&quot;"><br></p><h2 id="3-4-구도-지정"><a href="#3-4-구도-지정" class="headerlink" title="3.4. 구도 지정"></a>3.4. 구도 지정</h2><ul><li>우리 그림에서는 고양이가 정면을 보여주고 있습니다.</li><li>그러나 사실 그래야만 하는 이유는 없습니다. <b>smile</b>이라는 단어에 의해 확률적으로 앞모습이 나왔을 뿐입니다.</li><li>고양이를 바라보는 카메라의 방향을 지정하면 구도가 바뀝니다.<br></li></ul><p><img src="23_bic1_16.png" alt="여러 가지 구도"><br></p><ul><li><b>side view</b>라는 입력에 <b>left view</b>가 나온 것은 우연입니다.</li><li>방향을 지정하고자 하면 <b>right view</b>처럼 명확히 지정할 수 있습니다.</li><li>뒷모습을 뜻하는 <b>rear view</b>에서는 고양이가 고개를 돌리고 있습니다. <b>smiling</b>때문입니다.</li></ul><ul><li><b>같은 구도가 여러 이름으로 표현되기도 합니다.</b></li><li><b>top view</b>는 <b>overhead shot</b>과 동일하고, <b>bottom view</b>는 <b>low angle</b>과 동일합니다.</li><li><b>dutch angle</b>은 <b>front view</b>와 유사하나 삐딱합니다.</li></ul><ul><li>좌우는 딱히 중요하지 않으므로 side view로 지정하겠습니다.</li></ul><h2 id="3-5-표현-범위-지정"><a href="#3-5-표현-범위-지정" class="headerlink" title="3.5. 표현 범위 지정"></a>3.5. 표현 범위 지정</h2><ul><li>고양이 머리만 잔뜩 그려지고 있지만, 저는 고양이 전체 모습을 그리고 싶습니다.</li><li>그림 대상을 명확히 해서 다리와 꼬리까지 모두 나오게 해봅니다.</li><li>먼저, full body라는 프롬프트를 시도합니다.<br></li></ul><p><img src="23_bic1_10.png" alt="&quot;smiling white cat, side view, full body&quot;"><br></p><ul><li>명령이 불충분한 것 같습니다. 마음에 드는 그림이 나오지 않았습니다.</li><li>발과 꼬리를 포함하라는 뜻으로 including feet and tail을 추가합니다.<br></li></ul><p><img src="23_bic1_12.png" alt="&quot;smiling white cat, side view, full body including feet and tail&quot;"><br></p><ul><li>갑자기 만화체가 등장해서 조금 당황스럽긴 하지만 이상한 일은 아닙니다.</li><li>그림체를 지정한 적은 없으니까요. 애초에 사진 같은 이미지도 랜덤으로 나왔을 뿐입니다.</li><li><b>왼쪽 아래 이미지</b>가 맘에 듭니다. 저장하기로 합시다. 선택합니다.</li></ul><h1 id="4-그림-저장"><a href="#4-그림-저장" class="headerlink" title="4. 그림 저장"></a>4. 그림 저장</h1><ul><li>화면 한가득 내가 선택한 그림이 펼쳐집니다.<br></li></ul><p><img src="23_bic1_13.png" alt="&quot;smiling white cat, side view, full body&quot;"><br></p><ul><li><b>다운로드</b>를 누르면 파일이 저장됩니다. <b>1024 x 1024</b>의 .jpg입니다.</li></ul><p><img src="23_bic1_17.jpg"><br></p><ul><li><b>저장</b>을 누르면 내 bing 계정에 저장됩니다. <br></li></ul><p><img src="23_bic1_14.png" alt="&quot;smiling white cat, side view, full body&quot;"><br></p><ul><li>링크를 따라가면 내가 저장했던 그림들을 나중에 다시 꺼내볼 수 있습니다. <br></li></ul><p><img src="23_bic1_15.png"><br></p><ul><li>오늘은 여기까지입니다.</li><li>각자 머리 속에 떠오른 그림을 그려보면 어떨까요?</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/openai/">openai</category>
      
      <category domain="https://jehyunlee.github.io/tags/microsoft/">microsoft</category>
      
      <category domain="https://jehyunlee.github.io/tags/dalle/">dalle</category>
      
      <category domain="https://jehyunlee.github.io/tags/bingimagecreator/">bingimagecreator</category>
      
      
    </item>
    
    <item>
      <title>SciPy Smoothing</title>
      <link>https://jehyunlee.github.io/2023/06/20/Python-DS-131-kierlecture202302/</link>
      <guid>https://jehyunlee.github.io/2023/06/20/Python-DS-131-kierlecture202302/</guid>
      <pubDate>Tue, 20 Jun 2023 13:20:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://scipy.org/&quot;&gt;SciPy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;한국에너지기술연구원 AI 학습조직&lt;/b&gt;에서는 2023년 한 해동안 &lt;b&gt;데이터 처리&lt;/b&gt;를 공부</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><a href="https://scipy.org/">SciPy</a></p></blockquote><ul><li><b>한국에너지기술연구원 AI 학습조직</b>에서는 2023년 한 해동안 <b>데이터 처리</b>를 공부합니다.<ul><li>두 번째 시간으로 <a href="https://scipy.org/">SciPy</a>를 활용한 smoothing을 소개합니다.</li><li>smoothing은 신호의 잡음을 억제해 신호를 더 잘 드러내는 기술입니다.</li><li>인접한 데이터끼리 평균을 내는 <b>adjacent averaging</b>, 중간값을 취하는 <b>median</b> 외에도</li><li>데이터를 따라가며 polynomial fitting을 하는 <b>Savitsky-Golay</b>,</li><li>데이터의 주기성을 파악하여 이를 바탕으로 신호를 재구성하는 <b>inverse FFT</b>까지 여러 기법이 있습니다.</li></ul></li></ul><ul><li><b>이미지 부분 확대</b>를 사용했습니다.<ul><li>데이터의 일부를 확대하기 위해 Matplotlib의 <code>Axes.indicate_inset_zoom()</code>을 활용했습니다.</li><li>자세한 내용은 소스코드를 참고하시기 바랍니다.<br><img src="131-kierlecture202302_01.png"></li></ul></li></ul><ul><li>발표 영상 : <a href="https://youtu.be/swIlsPoprQM">Youtube Link</a><br></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/swIlsPoprQM" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <ul><li>실습 코드 : (<a href="https://bit.ly/3NaBpX0">https://bit.ly/3NaBpX0</a>)</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/numpy/">numpy</category>
      
      <category domain="https://jehyunlee.github.io/tags/scipy/">scipy</category>
      
      
    </item>
    
    <item>
      <title>SciPy 소개 + curve fitting</title>
      <link>https://jehyunlee.github.io/2023/05/19/Python-DS-130-kierlecture202301/</link>
      <guid>https://jehyunlee.github.io/2023/05/19/Python-DS-130-kierlecture202301/</guid>
      <pubDate>Fri, 19 May 2023 08:13:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://scipy.org/&quot;&gt;SciPy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;한국에너지기술연구원 AI 학습조직&lt;/b&gt;에서는 2023년 한 해동안 &lt;b&gt;데이터 처리&lt;/b&gt;를 공부</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><a href="https://scipy.org/">SciPy</a></p></blockquote><ul><li><b>한국에너지기술연구원 AI 학습조직</b>에서는 2023년 한 해동안 <b>데이터 처리</b>를 공부합니다.<ul><li>첫 시간으로 <a href="https://scipy.org/">SciPy</a>를 소개합니다.</li><li><b>SciPy</b>는 미분방정식을 풀고, 적분을 해주고, 최적해를 찾아주는 막강한 기능을 가지고 있습니다.</li><li>그러나 Numpy에 비해 덜 필수적이고 - Numpy는 데이터를 다룰 때 필수니까요</li><li>SciPy가 막강한 힘을 발휘하는 공학 분야에 계신 분들은 의외로 코딩과 친하지 않아서 그런지,</li><li>수년 전부터 억울하게 저평가를 받고 있다는 느낌이 있어 여러분께 소개드리고자 합니다.</li><li><a href="230517_%EC%9D%B4%EC%A0%9C%ED%98%84_KIER_EnergyAI_1%EC%B0%A8%EB%AA%A8%EC%9E%84.pdf">강의 자료는 여기에서 다운받으실 수 있습니다</a></li></ul></li></ul><ul><li>발표 영상 : <a href="https://youtu.be/r7GABULBFvA">Youtube Link</a><br></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/r7GABULBFvA" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <ul><li>실습 코드 : (<a href="https://bit.ly/AIEnergy_230517_2">https://bit.ly/AIEnergy_230517_2</a>)</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/numpy/">numpy</category>
      
      <category domain="https://jehyunlee.github.io/tags/scipy/">scipy</category>
      
      
    </item>
    
    <item>
      <title>챗GPT 러닝데이 &amp; MS 애저톤 - Open API를 활용한 연구원의 업무 효율화</title>
      <link>https://jehyunlee.github.io/2023/04/28/Python-DS-129-azurethon/</link>
      <guid>https://jehyunlee.github.io/2023/04/28/Python-DS-129-azurethon/</guid>
      <pubDate>Thu, 27 Apr 2023 21:54:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://aifactory.space/&quot;&gt;AI Factory&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://aifactory.space/learning/2361/discussion/234&quot;&gt;AI Facto</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><a href="https://aifactory.space/">AI Factory</a><br><a href="https://aifactory.space/learning/2361/discussion/234">AI Factory: [챗GPT 러닝데이 &amp; MS 애저톤] Open API를 활용한 연구원의 업무 효율화 -이제현</a><br><a href="230425_MVP_OpenAPI.pdf">강의자료 다운로드</a><br><a href="https://bit.ly/3HaUIgy">예제코드: Google Colab</a><br><a href="https://blog.langchain.dev/">Langchain 공식 블로그</a><br><a href="https://python.langchain.com/en/latest/index.html">Langchain 공식문서</a></p></blockquote><ul><li><a href="https://aifactory.space/">AI Factory</a> 김태영 대표님(MS RD, MS MVP AI)의 초청으로 <b>챗GPT 러닝데이 &amp; MS 애저톤</b>에서 발표를 드렸습니다.</li><li>제가 늘상 수행하는 연구원의 업무 효율화 일부를 <a href="https://blog.langchain.dev/">Langchain</a>을 사용해 대체했습니다.</li></ul><ul><li><p>대량의 논문을 가져와서 약간의 데이터 처리를 거쳐 두 가지로 정리합니다.</p></li><li><p>첫번째로 <b>년도별 출판 건수</b>를 그림으로 정리하고,</p></li><li><p>두번째로는 <b>요약보고서</b>를 만드는 시나리오입니다.<br><br><img src="129_azurethon_01.png"><br><br><img src="129_azurethon_02.png"><br></p></li><li><p>발표 영상 : <a href="https://youtu.be/ENun2zuvZuE">Youtube Link</a><br></p><p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/ENun2zuvZuE" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <ul><li><a href="https://aifactory.space/">AI Factory</a>에서는 이 외에도 많은 양질의 강의를 제공합니다.</li><li>원하는 내용의 영상을 보시고 필요한 기술을 습득하시기 바랍니다.<br><br><img src="129_azurethon_03.png"></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/openai/">openai</category>
      
      <category domain="https://jehyunlee.github.io/tags/chatgpt/">chatgpt</category>
      
      <category domain="https://jehyunlee.github.io/tags/microsoft/">microsoft</category>
      
      <category domain="https://jehyunlee.github.io/tags/llm/">llm</category>
      
      <category domain="https://jehyunlee.github.io/tags/langchain/">langchain</category>
      
      <category domain="https://jehyunlee.github.io/tags/azurethon/">azurethon</category>
      
      <category domain="https://jehyunlee.github.io/tags/AI-Factory/">AI Factory</category>
      
      
    </item>
    
    <item>
      <title>연구 및 행정 활용 AI 도구들</title>
      <link>https://jehyunlee.github.io/2023/04/15/General-22-AItools/</link>
      <guid>https://jehyunlee.github.io/2023/04/15/General-22-AItools/</guid>
      <pubDate>Sat, 15 Apr 2023 07:08:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://chat.openai.com/chat&quot;&gt;ChatGPT&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;ChatGPT 이후 업무 효율화로 관심이 이어지고 있습니다.&lt;/li&gt;
&lt;li&gt;Cha</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><a href="https://chat.openai.com/chat">ChatGPT</a></p></blockquote><ul><li>ChatGPT 이후 업무 효율화로 관심이 이어지고 있습니다.</li><li>ChatGPT는 블로그나 이메일을 쉽게 쓰는 것도 장점이지만 업무도 덜어줄 수 있습니다.</li><li>그리고 <b>ChatGPT 외에도 좋은 도구들이 많이 있습니다.</b></li><li>이 도구 중 제가 사용하는 것들을 모아서 소개드리고자 합니다.</li></ul><ul><li>4/10 원내 ChatGPT 발표에서 원장님이 지시하여 작성한 문서이므로 연구원 로고가 날인되어 있습니다.</li><li><b><a href="AI_tools_KIER.pdf">PDF 파일은 여기에서 내려받을 수 있습니다</a></b></li></ul><h2 id="1-전체-요약"><a href="#1-전체-요약" class="headerlink" title="1. 전체 요약"></a>1. 전체 요약</h2><p><img src="AI_tools_KIER_01.png" alt="전체 요약 (1)"></p><p><img src="AI_tools_KIER_02.png" alt="전체 요약 (2)"></p><h2 id="2-활용-예시"><a href="#2-활용-예시" class="headerlink" title="2. 활용 예시"></a>2. 활용 예시</h2><ul><li><p><a href="https://chat.openai.com/"><b>ChatGPT :</b> 문서 초안 작성, 번역, 요약, 어조 변경 </a><br><img src="AI_tools_KIER_03.png"><br></p></li><li><p><a href="http://pf.kakao.com/_BhxkWxj"><b>아숙업(AskUp) :</b> 카톡에서 실행하는 눈 달린 ChatGPT </a><br><img src="AI_tools_KIER_04.png"><br></p></li><li><p><a href="https://perplexity.ai/"><b>perplexity :</b> 참고문헌 검색 </a><br><img src="AI_tools_KIER_05.png"><br></p></li><li><p><a href="https://elicit.org/"><b>elicit :</b> 참고문헌 검색 </a><br><img src="AI_tools_KIER_06.png"><br></p></li><li><p><a href="https://www.chatpdf.com/"><b>ChatPDF :</b> 입력한 PDF에 대한 질의 응답 </a><br><img src="AI_tools_KIER_07.png"><br></p></li><li><p><a href="https://tldrthis.com/"><b>TLDRThis :</b> 요약 및 키워드 추출 </a><br><img src="AI_tools_KIER_08.png"><br></p></li><li><p><a href="https://www.deepl.com/"><b>DeepL :</b> 다국어 번역 </a><br><img src="AI_tools_KIER_09.png"><br></p></li><li><p><a href="https://www.connectedpapers.com/"><b>connected papers :</b> 인용 네트워크 활용 레퍼런스 탐색 </a><br><img src="AI_tools_KIER_10.png"><br></p></li><li><p><a href="https://www.paper-digest.com/"><b>paper digest :</b> 논문 요약해서 보기 </a><br><img src="AI_tools_KIER_11.png"><br></p></li><li><p><a href="https://typeset.io/"><b>scispace :</b> Research Copilot 표방. 용어 설명 및 관련 문헌 검색 </a><br><img src="AI_tools_KIER_12.png"><br></p></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/openai/">openai</category>
      
      <category domain="https://jehyunlee.github.io/tags/chatgpt/">chatgpt</category>
      
      <category domain="https://jehyunlee.github.io/tags/RPA/">RPA</category>
      
      
    </item>
    
    <item>
      <title>디스플레이 CEO 인사이트 - AI를 하고 싶은 C-LEVEL의 흔한 실수들</title>
      <link>https://jehyunlee.github.io/2023/03/27/General-21-kdiaceo/</link>
      <guid>https://jehyunlee.github.io/2023/03/27/General-21-kdiaceo/</guid>
      <pubDate>Mon, 27 Mar 2023 01:59:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.kdia.org/&quot;&gt;한국디스플레이 산업협회&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;작년 한국디스플레이 산업협회에서 발표 기회를 주셔서 &lt;a href=&quot;https:/</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><a href="https://www.kdia.org/">한국디스플레이 산업협회</a></p></blockquote><ul><li><p>작년 한국디스플레이 산업협회에서 발표 기회를 주셔서 <a href="https://jehyunlee.github.io/2022/03/28/Python-DS-97-ceo_mistakes/">온라인으로 발표</a>를 드린 바 있습니다.</p></li><li><p>같은 내용을 발행물에 원고로 기고하게 되었고, 요약본의 형태로 이번에 실렸습니다.<br></p></li><li><p><b>기사 링크:</b> <a href="https://web.kdia.org/ceo/20230324/index_1.html">AI를 하고 싶은 C-LEVEL의 흔한 실수들 (디스플레이 CEO 인사이트 vol.99)</a><br><br><img src="21_kdiaceo_02.png"><br></p></li><li><p>CEO는 한 회사의 선장입니다.</p></li><li><p>선장이 길을 잘못 인도하면 모두가 위험에 처합니다.</p></li><li><p>AI라는 새로운 돛을 달기 전에 우리 배의 어디에 어떻게 달지 판단할 수 있어야 합니다.</p></li><li><p>아래는 기사 전문입니다.<br></p><img src="https://web.kdia.org/ceo/20230324/images/a1.png"><img src="https://web.kdia.org/ceo/20230324/images/a2.png"><img src="https://web.kdia.org/ceo/20230324/images/a3.png"><img src="https://web.kdia.org/ceo/20230324/images/a4.png"><img src="https://web.kdia.org/ceo/20230324/images/a5.png"></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/c-level/">c-level</category>
      
      <category domain="https://jehyunlee.github.io/tags/display/">display</category>
      
      
    </item>
    
    <item>
      <title>서울특별시 교육청 - ChatGPT와 인공지능시대</title>
      <link>https://jehyunlee.github.io/2023/03/26/General-20-seouledu/</link>
      <guid>https://jehyunlee.github.io/2023/03/26/General-20-seouledu/</guid>
      <pubDate>Sat, 25 Mar 2023 22:49:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sen.go.kr/&quot;&gt;서울특별시 교육청&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.youtube.com/@GoodSenNews&quot;&gt;YouTube: 서울특별시 교육청 TV&lt;/a&gt;&lt;b</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><a href="https://www.sen.go.kr/">서울특별시 교육청</a><br><a href="https://www.youtube.com/@GoodSenNews">YouTube: 서울특별시 교육청 TV</a><br><a href="https://news.mt.co.kr/mtview.php?no=2023031609193638586">머니투데이: 챗GPT 활용방안 찾는 ‘서울시교육청’..직원 특강 -우수 사례 공유</a><br><a href="https://v.daum.net/v/20230316143150820">EBS뉴스: 서울교육청 “챗GPT 적극 활용한다” 사례집·연수 제공</a></p></blockquote><ul><li>서울특별시 교육청에서 초청해주셔서 발표를 드렸습니다.</li><li>오프라인 200분을 포함해 460분 정도가 신청해주셨고 당일 500분 이상 접속하셨다고 들었습니다.</li><li>현장에서 반갑게 맞아주시고 경청해주셔서 감사드리고, 온라인으로 들어주신 분들께도 감사드립니다.</li></ul><ul><li><b>영상 링크:</b> (<a href="https://www.youtube.com/live/-5S8yHHsaHQ?feature=share">Youtube Link</a>)<br><ul><li>유튜브에서만 재생되도록 설정되어 있습니다. 링크를 클릭해서 시청해주시기 바랍니다.<br><img src="20_seouledu_01.png"><p><p></li></ul></li></ul><ul><li>며칠 전 <b><a href="https://jehyunlee.github.io/2023/03/24/Python-General-19-sciencepeople/">과학하고 앉아있네</a></b>에서도 그랬지만 이런 이야기를 하면 수렴하는 주제가 있습니다.</li><li><b>“앞으로 우리 아이들을 어떻게 가르쳐야 할 것인가”</b>가 그 것입니다.</li><li>작년 말 대전광역시 교육청에서 불러주셨던 덕에 인공지능시대에 대한 생각을 미리 정리할 수 있었습니다.</li><li>교육 전문가들 앞에서 교육 방식을 제가 언급하는 것은 어불성설이지만 <b>다가올 미래</b>에 대한 제 생각은 말씀드릴 수 있을 것 같아 전체의 3분의 1 정도를 할애했습니다.<p></li></ul><ul><li>영상 중 해당 부분 : (<a href="https://youtu.be/-5S8yHHsaHQ?t=3722">YoutTube Link</a>)<br></li></ul><ul><li><b>발표자료를 공유합니다. (<a href="230324_%EC%9D%B4%EC%A0%9C%ED%98%84_ChatGPT.pdf">다운로드</a>)</b></li><li>새로운 시대를 맞는 분들께 조금이나마 도움이 되시기를 바랍니다.</li><li><b>이 자료와 발표에서 언급한 ChatGPT는 2023년 3월 23일 현황입니다.</b> </li><li>매우 빠른 속도로 변화와 진화가 벌어지고 있기 때문에 이후에는 새로운 내용을 반영해야 함을 유의해주시기 바랍니다.</li></ul><h1 id="ChatGPT-활용-교육-분야-업무-효율화-가이드"><a href="#ChatGPT-활용-교육-분야-업무-효율화-가이드" class="headerlink" title="ChatGPT 활용 교육 분야 업무 효율화 가이드"></a>ChatGPT 활용 교육 분야 업무 효율화 가이드</h1><ul><li><b>한국교원대 김귀훈</b> 교수님께서 <b>교육 분야 업무 효율화 가이드</b>를 작성해 주셨습니다.</li><li><a href="https://jehyunlee.github.io/2023/02/15/Python-General-16-chatgpt/">제가 만들었던 범용 업무 효율화 가이드</a>를 기반으로,</li><li><b>교사</b>, <b>행정</b>, <b>학생</b> 관점에서 ChatGPT를 사용할 때 믿어도 되는 점과 주의할 점을 정리해 주셨습니다.</li><li><a href="ChatGPT_AiFrenz_edu_guide.pdf">pdf 파일로도 다운받으실 수 있습니다.</a><br><br><img src="ChatGPT_AiFrenz_edu_guide.png"><br></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/openai/">openai</category>
      
      <category domain="https://jehyunlee.github.io/tags/chatgpt/">chatgpt</category>
      
      <category domain="https://jehyunlee.github.io/tags/seoul/">seoul</category>
      
      <category domain="https://jehyunlee.github.io/tags/education/">education</category>
      
      
    </item>
    
    <item>
      <title>과학하고 앉아있네 - 최팀장의 과학탐구</title>
      <link>https://jehyunlee.github.io/2023/03/24/General-19-sciencepeople/</link>
      <guid>https://jehyunlee.github.io/2023/03/24/General-19-sciencepeople/</guid>
      <pubDate>Fri, 24 Mar 2023 14:08:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sciencepeople.co.kr/&quot;&gt;과학과사람들&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;과학과 사람들에서 운영하는 유튜브, &lt;b&gt;과학하고 앉아있네&lt;/b&gt;에 출연</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><a href="https://www.sciencepeople.co.kr/">과학과사람들</a></p></blockquote><ul><li><p>과학과 사람들에서 운영하는 유튜브, <b>과학하고 앉아있네</b>에 출연했습니다.</p></li><li><p><b>최진영 팀장</b>, <b>곽재식 작가</b>, 게임평론가 <b>이경혁 작가</b>님과 함께 했습니다.</p></li><li><p>선망하는 채널이라 섭외 요청에 너무 기뻤는데 시간이 맞지 않아 함께 할 수 없었습니다.</p></li><li><p>다행히 운영진께서 배려해주셔서 온라인으로 함께 참여할 수 있었습니다.</p></li><li><p>영상 : (<a href="https://youtu.be/VMJ492EzKv4">Youtube Link</a>)<br></p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/VMJ492EzKv4" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><ul><li>스튜디오에서 함께 했다면, </li><li>이 분들과 사전에 친분이 좀 있어서 끼어들 수 있었다면 더 재밌었을 것 같은 아쉬움도 남습니다.</li><li>마이크가 넘어오기를 기다리며 가만히 있는 모습을 보고 사진인 줄 알았다는 댓글도 있네요 ^^;</li><li>2시간 반 녹화분이 2시간으로 편집되어서 정리되었습니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/openai/">openai</category>
      
      <category domain="https://jehyunlee.github.io/tags/chatgpt/">chatgpt</category>
      
      <category domain="https://jehyunlee.github.io/tags/science-and-people/">science and people</category>
      
      
    </item>
    
    <item>
      <title>대전MBC 시시각각- 대덕 과학자가 본 챗GPT 열풍</title>
      <link>https://jehyunlee.github.io/2023/03/19/General-18-ssgg/</link>
      <guid>https://jehyunlee.github.io/2023/03/19/General-18-ssgg/</guid>
      <pubDate>Sun, 19 Mar 2023 08:08:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://chat.openai.com/chat&quot;&gt;ChatGPT&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;대전 MBC&lt;/b&gt; 초청으로 ChatGPT 관련 방송에 참여했습니다.&lt;/li&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><a href="https://chat.openai.com/chat">ChatGPT</a></p></blockquote><ul><li><b>대전 MBC</b> 초청으로 ChatGPT 관련 방송에 참여했습니다.</li><li>시사토론 프로그램인 <b>시시각각</b>에 참여해 다른 전문가 분들과 함께 말씀을 나눴습니다.</li></ul><ul><li><p>2016년, 우리는 준비되지 않은 채 알파고라는 이름에 얽매였던 경험이 있습니다.</p></li><li><p>오늘의 우리는 <b>ChatGPT라는 이름에 얽매이지 않기를 바랍니다.</b></p></li><li><p>지금의 관심이 새로운 파도를 탈 수 있는 기초체력으로 이어지기를 희망합니다.</p></li><li><p>영상 : (<a href="https://youtu.be/snd_LISfByA">Youtube Link</a>)<br></p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/snd_LISfByA" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/openai/">openai</category>
      
      <category domain="https://jehyunlee.github.io/tags/chatgpt/">chatgpt</category>
      
      <category domain="https://jehyunlee.github.io/tags/mbc/">mbc</category>
      
      
    </item>
    
    <item>
      <title>Company Personification</title>
      <link>https://jehyunlee.github.io/2023/03/09/Python-General-17-company/</link>
      <guid>https://jehyunlee.github.io/2023/03/09/Python-General-17-company/</guid>
      <pubDate>Thu, 09 Mar 2023 14:02:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://chat.openai.com/chat&quot;&gt;ChatGPT&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://platform.openai.com/docs/introduction&quot;&gt;OpenAI API doc</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><a href="https://chat.openai.com/chat">ChatGPT</a><br><a href="https://platform.openai.com/docs/introduction">OpenAI API documentation</a></p></blockquote><ul><li>ChatGPT API가 공개되었습니다.</li><li>사전 신청자를 받고 있긴 했지만 기습적으로 느껴질만큼 갑자기 공개했습니다.</li><li>API를 공개했기 때문에 다른 여러 기능과 연계기를 발휘하기 좋습니다.</li><li>기존의 GPT API를 사용해 회사의 이미지를 의인화합니다.</li></ul><h1 id="1-인물로-본-회사-이미지"><a href="#1-인물로-본-회사-이미지" class="headerlink" title="1. 인물로 본 회사 이미지"></a>1. 인물로 본 회사 이미지</h1><blockquote><p><a href="https://www.yna.co.kr/view/GYH20141105001500044">연합뉴스: 인물로 본 6개 그룹 이미지</a></p></blockquote><p><img src="yna.jpg"></p><ul><li>가끔 언론에 이런 보도가 납니다.</li><li>특정 집단을 대상으로 특정 회사에 대한 이미지를 조사한 후 인물로 표현합니다.</li><li>직관적이기도 하지만 재미가 있어서 좋아하는 기사입니다.</li><li><b>ChatGPT</b>한테 이걸 시키면 잘 할 것 같다는 생각이 들었습니다.</li><li>그림으로 표현하는 능력이 없으니 그림은 <b>DALL.E</b>에게 그리도록 합니다.</li></ul><h1 id="2-ChatGPT를-통해-회사를-의인화해서-묘사하기"><a href="#2-ChatGPT를-통해-회사를-의인화해서-묘사하기" class="headerlink" title="2. ChatGPT를 통해 회사를 의인화해서 묘사하기"></a>2. ChatGPT를 통해 회사를 의인화해서 묘사하기</h1><ul><li><p>ChatGPT에게 회사 이름을 주고, 의인화해서 설명을 해보라면 잘 합니다.</p></li><li><p><b>삼성전자</b>가 사람으로 치면 어떤 사람인지 물어봤습니다.</p></li><li><p>한국인이고, 중성이고, 확신감에 차있고 전문성이 있다고 합니다.<br><br><img src="17_company_01.png"><br></p></li><li><p>ChatGPT 사이트에 가서 물어볼 수도 있지만 API를 이용해보겠습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"><span class="keyword">from</span> MyAPIKEY <span class="keyword">import</span> OpenAI  <span class="comment"># openai API key를 미리 발급받아 저장했습니다.</span></span><br><span class="line">openai.api_key = OpenAI  <span class="comment"># API Key 입력</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ChatGPT API 활용 : 회사를 의인화해서 정보 말하기.</span></span><br><span class="line">company = <span class="string">&quot;Samsung Electronics&quot;</span></span><br><span class="line">completion = openai.ChatCompletion.create(</span><br><span class="line">  model=<span class="string">&quot;gpt-3.5-turbo&quot;</span>,</span><br><span class="line">  messages=[</span><br><span class="line">    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, </span><br><span class="line">     <span class="string">&quot;content&quot;</span>: <span class="string">f&quot;Answer me about the company, whose name is <span class="subst">&#123;company&#125;</span>, without using any other words. \</span></span><br><span class="line"><span class="string">                  What is its nationality? \</span></span><br><span class="line"><span class="string">                  Imagine the company as a person. \</span></span><br><span class="line"><span class="string">                  Is it male or female? What is its impression? How does it dress?&quot;</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ChatGPT 응답 출력</span></span><br><span class="line">answer = completion.choices[<span class="number">0</span>].message</span><br><span class="line">answer</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;OpenAIObject at 0x1fd3ca48a40&gt; JSON: &#123;</span><br><span class="line">  <span class="string">&quot;content&quot;</span>: <span class="string">&quot;\n\nNationality: South Korean\n\nImagined person: Gender-neutral \n\nImpression: Technologically advanced and innovative \n\nDressing style: Modern and trendy with a focus on functionality.&quot;</span>,</span><br><span class="line">  <span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>웹과 완전 동일하지는 않지만 비슷한 형식의 답변이 나왔습니다.</p></li><li><p>다음과 같이 답변에서 원하는 문장만 깔끔하게 뽑아낼 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prompt = <span class="built_in">dict</span>(answer)[<span class="string">&quot;content&quot;</span>].lstrip(<span class="string">&quot;\n&quot;</span>).replace(<span class="string">&quot;\n\n&quot;</span>, <span class="string">&quot;, &quot;</span>)</span><br><span class="line">prompt</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;Nationality: South Korean, Imagined person: Gender-neutral , Impression: Technologically advanced and innovative , Dressing style: Modern and trendy with a focus on functionality.&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="3-DALL-E를-통해-그림으로-표현하기"><a href="#3-DALL-E를-통해-그림으로-표현하기" class="headerlink" title="3. DALL.E를 통해 그림으로 표현하기"></a>3. DALL.E를 통해 그림으로 표현하기</h1><ul><li><p>회사에 대한 이미지를 얻었으니 그림으로 그립니다.</p></li><li><p>마찬가지로 OpenAI API를 사용합니다.</p></li><li><p>ChatGPT가 만든 <code>prompt</code>를 입력으로 넣고, 그 앞에 <b>길에 서있는 사람의 몸통 사진</b>이라는 뜻의 문구를 추가합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">response = openai.Image.create(</span><br><span class="line">  prompt= <span class="string">&quot;a photography of torso of a person, standing on the street: &quot;</span> + prompt,</span><br><span class="line">  n=<span class="number">4</span>,</span><br><span class="line">  size=<span class="string">&quot;512x512&quot;</span></span><br><span class="line">)</span><br><span class="line">images = response[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">images_url = [i[<span class="string">&quot;url&quot;</span>] <span class="keyword">for</span> i <span class="keyword">in</span> images]</span><br><span class="line">images_url</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;https://oaidalleapiprodscus.blob.core.windows.net/private/org-AhUkzJK2WZGMFoMyGMghYXRV/user-GJilwEnUIKmd9QOgEkYhUF46/img-wmfnBPTbuqfFVPWhBCgWAehQ.png?st=2023-03-09T13%3A45%3A16Z&amp;se=2023-03-09T15%3A45%3A16Z&amp;sp=r&amp;sv=2021-08-06&amp;sr=b&amp;rscd=inline&amp;rsct=image/png&amp;skoid=6aaadede-4fb3-4698-a8f6-684d7786b067&amp;sktid=a48cca56-e6da-484e-a814-9c849652bcb3&amp;skt=2023-03-08T23%3A46%3A41Z&amp;ske=2023-03-09T23%3A46%3A41Z&amp;sks=b&amp;skv=2021-08-06&amp;sig=A9gkIRkfbORN06hfMsCAfIB6ZxDCyYg3PBGVhY9pjX4%3D&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;https://oaidalleapiprodscus.blob.core.windows.net/private/org-AhUkzJK2WZGMFoMyGMghYXRV/user-GJilwEnUIKmd9QOgEkYhUF46/img-ILfQqDLOe9qezlAS4HNDYIb0.png?st=2023-03-09T13%3A45%3A16Z&amp;se=2023-03-09T15%3A45%3A16Z&amp;sp=r&amp;sv=2021-08-06&amp;sr=b&amp;rscd=inline&amp;rsct=image/png&amp;skoid=6aaadede-4fb3-4698-a8f6-684d7786b067&amp;sktid=a48cca56-e6da-484e-a814-9c849652bcb3&amp;skt=2023-03-08T23%3A46%3A41Z&amp;ske=2023-03-09T23%3A46%3A41Z&amp;sks=b&amp;skv=2021-08-06&amp;sig=RSDcoiw3vqtHQTgXqEeQKBf2EOY9Zbx%2BCNrgcJetcFU%3D&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;https://oaidalleapiprodscus.blob.core.windows.net/private/org-AhUkzJK2WZGMFoMyGMghYXRV/user-GJilwEnUIKmd9QOgEkYhUF46/img-wxblEkkn0ZZjmp3vxwA3Kso2.png?st=2023-03-09T13%3A45%3A16Z&amp;se=2023-03-09T15%3A45%3A16Z&amp;sp=r&amp;sv=2021-08-06&amp;sr=b&amp;rscd=inline&amp;rsct=image/png&amp;skoid=6aaadede-4fb3-4698-a8f6-684d7786b067&amp;sktid=a48cca56-e6da-484e-a814-9c849652bcb3&amp;skt=2023-03-08T23%3A46%3A41Z&amp;ske=2023-03-09T23%3A46%3A41Z&amp;sks=b&amp;skv=2021-08-06&amp;sig=2pDH7f8ONdppBdPcEsQJcZ/qNt/jpmUrpZ9LVuLDzQw%3D&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;https://oaidalleapiprodscus.blob.core.windows.net/private/org-AhUkzJK2WZGMFoMyGMghYXRV/user-GJilwEnUIKmd9QOgEkYhUF46/img-lfyMHLR93DZ8a0iOM9H268Jr.png?st=2023-03-09T13%3A45%3A16Z&amp;se=2023-03-09T15%3A45%3A16Z&amp;sp=r&amp;sv=2021-08-06&amp;sr=b&amp;rscd=inline&amp;rsct=image/png&amp;skoid=6aaadede-4fb3-4698-a8f6-684d7786b067&amp;sktid=a48cca56-e6da-484e-a814-9c849652bcb3&amp;skt=2023-03-08T23%3A46%3A41Z&amp;ske=2023-03-09T23%3A46%3A41Z&amp;sks=b&amp;skv=2021-08-06&amp;sig=UJIty7F3F7wDiFhOLpMewwXjzw4K9M3zocJlGuHiwso%3D&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li><p>아주 긴 URL이 나왔습니다. 긁어다 인터넷 주소창에 붙이면 그림이 보입니다.</p></li><li><p>이 그림을 받아다 모아서 파일로 저장합니다.</p></li><li><p><code>urllib</code>과 <code>numpy</code>, <code>PIL</code>을 사용해 주소를 가져와 <code>Matplotlib</code>으로 표현합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> PIL</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>]=<span class="string">&#x27;NanumGothic&#x27;</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">imgs = [np.array(PIL.Image.<span class="built_in">open</span>(urllib.request.urlopen(url))) <span class="keyword">for</span> url <span class="keyword">in</span> images_url]</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(ncols=<span class="number">2</span>, nrows=<span class="number">2</span>, figsize=(<span class="number">6</span>, <span class="number">6</span>), gridspec_kw=&#123;<span class="string">&quot;hspace&quot;</span>:<span class="number">0</span>, <span class="string">&quot;wspace&quot;</span>:<span class="number">0</span>&#125;)</span><br><span class="line">axs = axes.ravel()</span><br><span class="line"><span class="keyword">for</span> ax, img <span class="keyword">in</span> <span class="built_in">zip</span>(axs, imgs):</span><br><span class="line">    ax.imshow(img)</span><br><span class="line">    ax.axis(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">fig.suptitle(<span class="string">f&quot;<span class="subst">&#123;company&#125;</span>&quot;</span>, fontsize=<span class="string">&quot;x-large&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">fig.savefig(<span class="string">f&quot;imgs_<span class="subst">&#123;company&#125;</span>.png&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="imgs_Samsung_Electronics.png"><br></p></li></ul><h1 id="4-회사-이름을-입력받아-그림으로-출력"><a href="#4-회사-이름을-입력받아-그림으로-출력" class="headerlink" title="4. 회사 이름을 입력받아 그림으로 출력"></a>4. 회사 이름을 입력받아 그림으로 출력</h1><ul><li><p>ChatGPT는 회사 이름에서 회사의 인상을 도출했고</p></li><li><p>DALL.E는 회사의 인상을 그림으로 표현했습니다.</p></li><li><p>이제 둘을 합칩니다.</p></li><li><p>먼저 ChatGPT 활용 부분을 함수로 만들어 잘 동작하는지 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tell_me_about</span>(<span class="params">company</span>):</span></span><br><span class="line">    completion = openai.ChatCompletion.create(</span><br><span class="line">      model=<span class="string">&quot;gpt-3.5-turbo&quot;</span>,</span><br><span class="line">      messages=[</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, </span><br><span class="line">         <span class="string">&quot;content&quot;</span>: <span class="string">f&quot;Answer me about the company, whose name is <span class="subst">&#123;company&#125;</span>, without using any other words. \</span></span><br><span class="line"><span class="string">                      What is its nationality? \</span></span><br><span class="line"><span class="string">                      Imagine the company as a person. \</span></span><br><span class="line"><span class="string">                      Is it male or female? What is its impression? How does it dress?&quot;</span>&#125;</span><br><span class="line">      ]</span><br><span class="line">    )</span><br><span class="line">    answer = completion.choices[<span class="number">0</span>].message</span><br><span class="line">    prompt = <span class="built_in">dict</span>(answer)[<span class="string">&quot;content&quot;</span>].lstrip(<span class="string">&quot;\n&quot;</span>).replace(<span class="string">&quot;\n\n&quot;</span>, <span class="string">&quot;, &quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> prompt</span><br><span class="line"></span><br><span class="line">prompt = tell_me_about(<span class="string">&quot;LG Chemistry&quot;</span>)</span><br><span class="line">prompt</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;This company is from South Korea. As a person, LG Chemistry would be considered gender-neutral. Its impression would be innovative and tech-savvy. In terms of dressing, it would likely wear modern, professional attire.&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>잘 됩니다.</p></li><li><p>이번엔 DALL.E를 사용해 설명을 그림으로 변환합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_about</span>(<span class="params">prompt, company</span>):</span></span><br><span class="line">    response = openai.Image.create(</span><br><span class="line">    prompt= <span class="string">&quot;a photography of torso of a person, standing on the street: &quot;</span> + prompt,</span><br><span class="line">    n=<span class="number">4</span>,</span><br><span class="line">    size=<span class="string">&quot;512x512&quot;</span></span><br><span class="line">    )</span><br><span class="line">    images = response[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">    images_url = [i[<span class="string">&quot;url&quot;</span>] <span class="keyword">for</span> i <span class="keyword">in</span> images]</span><br><span class="line"></span><br><span class="line">    imgs = [np.array(PIL.Image.<span class="built_in">open</span>(urllib.request.urlopen(url))) <span class="keyword">for</span> url <span class="keyword">in</span> images_url]</span><br><span class="line"></span><br><span class="line">    fig, axes = plt.subplots(ncols=<span class="number">2</span>, nrows=<span class="number">2</span>, figsize=(<span class="number">6</span>, <span class="number">6</span>), gridspec_kw=&#123;<span class="string">&quot;hspace&quot;</span>:<span class="number">0</span>, <span class="string">&quot;wspace&quot;</span>:<span class="number">0</span>&#125;)</span><br><span class="line">    axs = axes.ravel()</span><br><span class="line">    <span class="keyword">for</span> ax, img <span class="keyword">in</span> <span class="built_in">zip</span>(axs, imgs):</span><br><span class="line">        ax.imshow(img)</span><br><span class="line">        ax.axis(<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    fig.suptitle(<span class="string">f&quot;<span class="subst">&#123;company&#125;</span>&quot;</span>, fontsize=<span class="string">&quot;x-large&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">    fig.savefig(<span class="string">f&quot;imgs_<span class="subst">&#123;company.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;_&#x27;</span>)&#125;</span>.png&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> fig</span><br><span class="line"></span><br><span class="line">fig = draw_about(<span class="string">&quot;LG Chemistry&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="imgs_LG_Chemistry.png"><br></p></li></ul><ul><li>그리고 두 함수를 합칩니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tell_and_draw</span>(<span class="params">company</span>):</span></span><br><span class="line">    prompt = tell_me_about(company)</span><br><span class="line">    fig = draw_about(company)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;# Name: <span class="subst">&#123;company&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;# <span class="subst">&#123;prompt&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> prompt, fig</span><br><span class="line"></span><br><span class="line">prompt, fig = tell_and_draw(<span class="string">&quot;TSMC&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># Name: TSMC</span></span><br><span class="line"><span class="comment"># Taiwanese. , The company is an entity and therefore does not have a gender or dress style.</span></span><br></pre></td></tr></table></figure><img src="imgs_TSMC.png"><br></li></ul><h1 id="5-DeepL로-묘사-부분-번역"><a href="#5-DeepL로-묘사-부분-번역" class="headerlink" title="5. DeepL로 묘사 부분 번역"></a>5. DeepL로 묘사 부분 번역</h1><ul><li>나름 재밌게 돌아가는데 설명을 읽기 귀찮습니다. </li><li>외국어는 모국어보다 불편하거든요.</li><li>번역기를 붙입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> MyAPIKEY <span class="keyword">import</span> RapidAPI</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># DeepL 사용 번역</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deepl</span>(<span class="params">text, RapidAPI=RapidAPI, src=<span class="string">&quot;auto&quot;</span>, dest=<span class="string">&quot;ko&quot;</span></span>):</span></span><br><span class="line">    url = <span class="string">&quot;https://deepl-translator.p.rapidapi.com/translate&quot;</span></span><br><span class="line">    </span><br><span class="line">    payload = &#123;</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: text,</span><br><span class="line">        <span class="string">&quot;source&quot;</span>: src,</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: dest</span><br><span class="line">    &#125;</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;X-RapidAPI-Key&quot;</span>: RapidAPI,</span><br><span class="line">        <span class="string">&quot;X-RapidAPI-Host&quot;</span>: <span class="string">&quot;deepl-translator.p.rapidapi.com&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.request(<span class="string">&quot;POST&quot;</span>, url, json=payload, headers=headers)</span><br><span class="line">    translated = response.json()[<span class="string">&quot;text&quot;</span>]</span><br><span class="line">    <span class="keyword">return</span> translated</span><br><span class="line"></span><br><span class="line"><span class="comment"># DeelL 포함 함수 재정의</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tell_and_draw</span>(<span class="params">company</span>):</span></span><br><span class="line">    prompt = tell_me_about(company)</span><br><span class="line">    fig = draw_about(company)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;# Name: <span class="subst">&#123;company&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;# <span class="subst">&#123;deepl(prompt)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> prompt, fig</span><br><span class="line"></span><br><span class="line">prompt, fig = tell_and_draw(<span class="string">&quot;IBM&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>실행 결과 : 영문을 모르겠지만 IBM 묘사가 유달리 짧습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Name: IBM</span></span><br><span class="line"><span class="comment"># IBM은 컴퓨터 하드웨어, 미들웨어 및 소프트웨어를 설계하고 판매하는 다국적 기업입니다.</span></span><br></pre></td></tr></table></figure><img src="imgs_IBM.png"><br></li></ul><ul><li>하나를 더 해봅니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt, fig = tell_and_draw(<span class="string">&quot;Toyota&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># Name: Toyota</span></span><br><span class="line"><span class="comment"># 국적: 일본어, 의인화: 도요타는 품질과 신뢰성을 중시하는 근면하고 혁신적인 개인입니다. , 성별: 중립 , 인상: 도요타는 자동차 산업의 리더로 간주되며 첨단 기술과 친환경으로 존경 받고 있습니다. , 복장: 기업 이미지에 걸맞게 깔끔하고 전문적인 외모에 스마트한 정장 차림을 주로 합니다.</span></span><br></pre></td></tr></table></figure><img src="imgs_Toyota.png"><br></li></ul><h1 id="6-결론"><a href="#6-결론" class="headerlink" title="6. 결론"></a>6. 결론</h1><ul><li>길지 않은 코드이지만 ChatGPT + DALL.E + DeepL을 묶었습니다.</li><li><b>단순해보이지만 세 개의 API를 묶은 컴비네이션</b>입니다.</li><li>API를 활용하면 여러 기능을 레고 조립하듯 마음껏 엮을 수 있습니다.</li><li>마음껏 사용하시기 바랍니다.</li></ul><h1 id="6-마음껏-사용하기"><a href="#6-마음껏-사용하기" class="headerlink" title="6. 마음껏 사용하기"></a>6. 마음껏 사용하기</h1><h3 id="Apple"><a href="#Apple" class="headerlink" title="Apple"></a><b>Apple</b><br></h3><p><img src="Apple.png"><br></p><h3 id="Tesla"><a href="#Tesla" class="headerlink" title="Tesla"></a><b>Tesla</b><br></h3><p><img src="Tesla.png"><br></p><h3 id="Facebook"><a href="#Facebook" class="headerlink" title="Facebook"></a><b>Facebook</b><br></h3><p><img src="Facebook.png"><br></p><h3 id="McDonalds"><a href="#McDonalds" class="headerlink" title="McDonalds"></a><b>McDonalds</b><br></h3><p><img src="McDonalds.png"><br></p><h3 id="YouTube"><a href="#YouTube" class="headerlink" title="YouTube"></a><b>YouTube</b><br></h3><p><img src="YouTube.png"><br></p><h3 id="OpenAI"><a href="#OpenAI" class="headerlink" title="OpenAI"></a><b>OpenAI</b><br></h3><p><img src="OpenAI.png"><br></p><ul><li><b># Name: Amazon</b><ul><li><b># 국적: 미국, 의인화:</b> 성별: 중립. 인상: 혁신적이고, 기술에 정통함. 복장: 모던하고 캐주얼하면서도 전문적인 복장</li></ul></li><li><b># Name: Microsoft</b><ul><li><b># 국적: 미국, 의인화:</b> 마이크로소프트는 고도로 분석적이고 혁신적인 기술에 정통한 개인으로 묘사됩니다., 성별: N/A(마이크로소프트는 회사이기 때문에 성별이 없음), 인상: 소프트웨어, 하드웨어 및 클라우드 서비스 분야의 리더로서 기술 업계에서 높은 존경과 인정을 받고 있습니다., 복장: N/A(Microsoft는 회사이기 때문에 복장은 없지만 제품과 로고는 세련되고 현대적인 스타일을 나타냅니다).</li></ul></li><li><b># Name: Google</b><ul><li>(설명이 전혀 없음)<br><br><img src="imgs_Amazon_Microsoft_Google.png"><br></li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/openai/">openai</category>
      
      <category domain="https://jehyunlee.github.io/tags/chatgpt/">chatgpt</category>
      
      <category domain="https://jehyunlee.github.io/tags/DALL-E/">DALL.E</category>
      
      <category domain="https://jehyunlee.github.io/tags/DeepL/">DeepL</category>
      
      
    </item>
    
    <item>
      <title>번역 모델 비교 - 성능, 시간, 요금</title>
      <link>https://jehyunlee.github.io/2023/02/20/Python-DS-128-transqual/</link>
      <guid>https://jehyunlee.github.io/2023/02/20/Python-DS-128-transqual/</guid>
      <pubDate>Sun, 19 Feb 2023 22:09:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;딥러닝의 빠른 발전으로 기계번역이 매우 쉬워졌습니다.&lt;/li&gt;
&lt;li&gt;다양한 모델을 선택할 수 있고, 구독 모델도 여럿 나와있습니다.&lt;/li&gt;
&lt;li&gt;현명한 소비자가 되기 위해 모델들의 번역 성능을 비교합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>딥러닝의 빠른 발전으로 기계번역이 매우 쉬워졌습니다.</li><li>다양한 모델을 선택할 수 있고, 구독 모델도 여럿 나와있습니다.</li><li>현명한 소비자가 되기 위해 모델들의 번역 성능을 비교합니다.</li></ul><h1 id="1-번역-성능-평가"><a href="#1-번역-성능-평가" class="headerlink" title="1. 번역 성능 평가"></a>1. 번역 성능 평가</h1><blockquote><p><a href="https://dl.acm.org/doi/10.3115/1073083.1073135">BLEU: a method for automatic evaluation of machine translation</a><br><a href="https://wikidocs.net/31695">유원준, 안상준, “딥 러닝을 이용한 자연어 처리 입문”</a></p></blockquote><ul><li>최근 논문 내용을 요약, 추출하고 번역하여 제공하는 프로그램을 개발중입니다.</li><li>일반적으로 학술적으로 사용하는 성능 평가는 <b>BLEU significance</b>를 사용합니다.</li><li><a href="https://wikidocs.net/31695">기계 번역 결과와 사람이 직접 번역한 결과가 얼마나 유사한지 비교하여 성능을 측정하는 방법입니다.</a></li><li><a href="https://wikidocs.net/31695">n-gram에 기반하여 언어에 구애받지 않고 사용할 수 있으며 계산 속도가 빠릅니다.</a></li></ul><p><img src="128_transqual_01.png" alt="Skimmer: 논문 요약, 추출 번역 프로그램 (개발중)"></p><ul><li>그러나 제 프로그램에 사용할 프로그램은 <b>꼭 최고의 성능이 아니어도 됩니다.</b></li><li>문장이 다소 어색해도 내용을 파악할 수 있는 각 분야의 준전문가 이상이 예상 사용자입니다.</li><li><b>문장 끊김과 같은 치명적인 어색함</b>과 함께 <b>번역 속도</b>, <b>비용</b>이 중요 포인트입니다.</li></ul><h1 id="2-번역-모델"><a href="#2-번역-모델" class="headerlink" title="2. 번역 모델"></a>2. 번역 모델</h1><blockquote><p><a href="https://huggingface.co/docs/transformers">Huggingface Transformer</a><br><a href="https://rapidapi.com/">Rapidapi</a><br><a href="https://platform.openai.com/docs/guides/completion/translation">OpenAI</a><br><a href="https://developers.naver.com/docs/papago/">Naver Papago</a></p></blockquote><ul><li>몇 년 전만 해도 구글 번역기가 거의 유일한 대안이었지만 판도가 바뀌었습니다.</li><li>Transformer 딥러닝 모델의 대두로 언어 처리 성능이 크게 향상되었을 뿐더러,</li><li><a href="https://huggingface.co/docs/transformers">Huggingface</a>와 <a href="https://rapidapi.com/">Rapidapi</a>같은 곳들 덕택에 모델 사용이 쉬워졌습니다.</li><li><a href="https://platform.openai.com/docs/guides/completion/translation">OpenAI</a>에서 내놓은 GPT와 ChatGPT도 우수한 성능을 보입니다.</li><li>국내에서는 네이버의 <a href="https://developers.naver.com/docs/papago/">파파고</a>가 대표적입니다.</li></ul><blockquote><p><a href="https://jehyunlee.github.io/2022/07/02/Python-DS-106-aaicon/">실용인공지능학회: Open API를 이용한 고속 논문 분석</a></p></blockquote><ul><li>논문 초록(abstract)을 요약한 것과 함께 독창성(originality)을 추출한 문장을 대상으로 테스트를 진행합니다.</li><li><a href="https://jehyunlee.github.io/2022/07/02/Python-DS-106-aaicon/">지난 학회</a>에서 발표한 내용을 바탕으로 일차 서비스를 만들었습니다.</li><li>여기서 도출된 데이터를 이용해 번역 모델을 테스트합니다.</li><li><b>abstract summary</b>는 초록이 요약된 것, <b>originality</b>는 초록 중에서 독창성을 드러내는 문장을 추출한 것입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df_ex = pd.read_excel(<span class="string">&quot;samples.xlsx&quot;</span>)</span><br><span class="line">df_ex</span><br></pre></td></tr></table></figure><img src="128_transqual_02.png"></li></ul><ul><li>예컨대 첫 번째 데이터는 다음 논문입니다.</li></ul><p><img src="128_transqual_03.png"><br></p><ul><li><p>이 논문의 초록을 요약하면 다음과 같습니다.</p></li><li><p><b>초록 요약본</b>은 <b>64단어, 413자</b>로 구성되어 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abs0 =</span><br><span class="line"><span class="string">&quot;PV panels produce unnecessary heat energy during power generation which increases the temperature and affects the efficiency of PV cells. This article investigates the performance of PV modules using aluminum heat sinks and forced air cooling techniques. The average electrical efficiency of the studied PV panels is 17% and is very close to the PV module efficiency of 19.38% under standard test conditions (STC)&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>그리고 첫 문장 같은 전반적인 동향을 뜻하는 말을 제외하고 <b>독창성</b>만 추출하면 다음과 같습니다.</p></li><li><p><b>독창성 추출본</b>은 <b>31단어, 184자</b>로 구성되어 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org0 =</span><br><span class="line"><span class="string">&quot;The results of the study show that solar energy generation can be optimized by considering the design, use of materials and proper cooling methods even when using the same solar panel.&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>읽을 수 있는 영문이고 원문에 비해 길이도 크게 줄었습니다.</p></li><li><p>하지만 더 쉽게 읽고 싶습니다. 여러 번역 엔진을 비교합니다.</p></li></ul><h2 id="2-1-Google-Translate"><a href="#2-1-Google-Translate" class="headerlink" title="2.1. Google Translate"></a>2.1. Google Translate</h2><blockquote><p><a href="https://pypi.org/project/googletrans/">pypi:googletrans</a></p></blockquote><ul><li><p>googletrans를 사용하는 방법이 있고 Google Cloud를 API로 이용하는 방법이 있습니다.</p></li><li><p>googletrans도 <b>Google Translate Ajax API</b>를 사용한다니 완전한 설치형은 아닙니다.</p></li><li><p>여기서는 googletrans만 사용합니다. 글이 그다지 길지 않기 때문입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!pip install googletrans   # Error 발생</span></span><br><span class="line">!pip install googletrans==<span class="number">3.1</span><span class="number">.0</span>a0</span><br></pre></td></tr></table></figure></li><li><p><code>!pip install googletrans</code>를 실행하면 현재 기준 <code>3.0.0</code> 버전이 설치됩니다.</p></li><li><p>하지만 번역 수행시 오류가 발생하므로 문제가 없는 <code>3.1.0a0</code> 버전을 설치하시기 바랍니다.</p></li><li><p>사용법은 간단합니다. <code>Translator()</code>로 번역기 인스턴스를 만든 후 <code>.translate(문구, 목표언어)</code>를 입력하면 됩니다.</p></li><li><p>번역에 걸리는 소요시간을 계산하기 위해 앞뒤로 시간 계산 코드를 붙였습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> googletrans <span class="keyword">import</span> Translator</span><br><span class="line"></span><br><span class="line">google = Translator()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 초록 요약</span></span><br><span class="line">time_start = time()</span><br><span class="line">abs_translator0 = google.translate(abs0, dest=<span class="string">&quot;ko&quot;</span>)  <span class="comment"># 초록 번역</span></span><br><span class="line">time_end = time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# 초록요약= <span class="subst">&#123;abs_translator0.text&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;- 소요시간: <span class="subst">&#123;time_end-time_start:<span class="number">.2</span>f&#125;</span>s\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 독창성 추출</span></span><br><span class="line">time_start = time()</span><br><span class="line">org_translator0 = google.translate(org0, dest=<span class="string">&quot;ko&quot;</span>)  <span class="comment"># 독창성 번역</span></span><br><span class="line">time_end = time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# 독창성추출= <span class="subst">&#123;org_translator0.text&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;- 소요시간: <span class="subst">&#123;time_end-time_start:<span class="number">.2</span>f&#125;</span>s&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 초록요약= PV 패널은 발전 중에 불필요한 열 에너지를 생성하여 온도를 높이고 PV 전지의 효율에 영향을 미칩니다. 이 기사에서는 알루미늄 방열판과 강제 공기 냉각 기술을 사용하는 PV 모듈의 성능을 조사합니다. 연구된 PV 패널의 평균 전기 효율은 17%이며 표준 테스트 조건(STC)에서 PV 모듈 효율 19.38%에 매우 가깝습니다.</span></span><br><span class="line">- 소요시간: 0.39s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 독창성추출= 연구 결과는 동일한 태양광 패널을 사용하더라도 설계, 재료 사용 및 적절한 냉각 방법을 고려하여 태양광 발전을 최적화할 수 있음을 보여줍니다.</span></span><br><span class="line">- 소요시간: 0.29s</span><br></pre></td></tr></table></figure></li></ul></li><li><p><b>안정적인 성능</b>과 <b>매우 빠른 속도</b>를 보여줍니다.</p></li></ul><h2 id="2-2-Papago"><a href="#2-2-Papago" class="headerlink" title="2.2. Papago"></a>2.2. Papago</h2><blockquote><p><a href="https://developers.naver.com/docs/papago/">파파고 API</a><br><a href="https://console.ncloud.com/papago-translation/apis">네이버 클라우드 콘솔:파파고 번역</a><br><a href="https://www.fin-ncloud.com/product/aiService/papagoTranslation">네이버 파파고 API 활용 예시</a></p></blockquote><ul><li><p>일 5백만글자와 월 3천만글자 한도가 있습니다.</p></li><li><p><a href="https://console.ncloud.com/papago-translation/apis">네이버 클라우드 콘솔</a>에 가입하고 <b>client id</b>와 <b>secret</b>을 발급받아야 합니다.</p></li><li><p>이들을 각기 <code>Naver_client_id</code>, <code>Naver_client_secret</code>에 넣으면 다음과 같은 함수를 만들 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">papago</span>(<span class="params">text, src=<span class="string">&quot;en&quot;</span>, dest=<span class="string">&quot;ko&quot;</span></span>):</span>  </span><br><span class="line">    data = &#123;<span class="string">&#x27;text&#x27;</span> : text,</span><br><span class="line">            <span class="string">&#x27;source&#x27;</span> : src,</span><br><span class="line">            <span class="string">&#x27;target&#x27;</span>: dest&#125;</span><br><span class="line"></span><br><span class="line">    url = <span class="string">&quot;https://naveropenapi.apigw.ntruss.com/nmt/v1/translation&quot;</span></span><br><span class="line"></span><br><span class="line">    header = &#123;<span class="string">&quot;X-NCP-APIGW-API-KEY-ID&quot;</span>:Naver_client_id,</span><br><span class="line">              <span class="string">&quot;X-NCP-APIGW-API-KEY&quot;</span>:Naver_client_secret&#125;</span><br><span class="line"></span><br><span class="line">    response = requests.post(url, headers=header, data=data)</span><br><span class="line">    rescode = response.status_code</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(rescode==<span class="number">200</span>):</span><br><span class="line">        send_data = response.json()</span><br><span class="line">        trans_data = (send_data[<span class="string">&#x27;message&#x27;</span>][<span class="string">&#x27;result&#x27;</span>][<span class="string">&#x27;translatedText&#x27;</span>])</span><br><span class="line">        <span class="keyword">return</span> trans_data</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error Code:&quot;</span> , rescode)</span><br></pre></td></tr></table></figure></li><li><p>위 함수를 사용해 번역을 수행합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 초록 요약</span></span><br><span class="line">time_start = time()</span><br><span class="line">abs_translator1 = papago(abs0, dest=<span class="string">&quot;ko&quot;</span>)</span><br><span class="line">time_end = time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# 초록요약= <span class="subst">&#123;abs_translator1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;- 소요시간: <span class="subst">&#123;time_end-time_start:<span class="number">.2</span>f&#125;</span>s\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 독창성 추출</span></span><br><span class="line">time_start = time()</span><br><span class="line">org_translator1 = papago(org0, dest=<span class="string">&quot;ko&quot;</span>)</span><br><span class="line">time_end = time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# 독창성추출= <span class="subst">&#123;org_translator1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;- 소요시간: <span class="subst">&#123;time_end-time_start:<span class="number">.2</span>f&#125;</span>s&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 초록요약= PV 패널은 발전 시 불필요한 열에너지를 발생시켜 온도를 상승시키고 PV 셀의 효율에 영향을 미친다. 본 논문에서는 알루미늄 히트 싱크와 강제 공기 냉각 기술을 사용한 PV 모듈의 성능을 조사한다. 연구된 PV 패널의 평균 전기 효율은 17%이며 표준 시험 조건(STC)에서 PV 모듈 효율 19.38%에 매우 가깝다</span></span><br><span class="line">- 소요시간: 0.15s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 독창성추출= 연구 결과는 동일한 태양광 패널을 사용하는 경우에도 설계와 재료 사용, 적절한 냉각 방식 등을 고려하면 태양광 발전을 최적화할 수 있음을 보여준다.</span></span><br><span class="line">- 소요시간: 0.35s</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Google Translate가 존대말을 하는 반면 Naver는 반말을 합니다. </p></li><li><p>속도도 Google Translate 비슷하지만 유료 과금이 다소 마음에 걸립니다.</p></li><li><p><b>5백만 글자/일</b>까지는 무료이지만 이후 <b>2만원/1백만 글자</b>로 월별 과금됩니다.</p></li><li><p>서비스가 인기라도 끌면 곤란해질 수 있습니다.</p></li></ul><h2 id="2-3-Huggingface"><a href="#2-3-Huggingface" class="headerlink" title="2.3. Huggingface"></a>2.3. Huggingface</h2><blockquote><p><a href="https://huggingface.co/docs/transformers/tasks/translation">Huggingface: Transformers-translation</a><br><a href="https://www.theclickreader.com/language-translation-using-hugging-face-and-python/">TheClickReader: Language Translation using Huggingface and Python in 3 lines of code</a><br><a href="https://ai.facebook.com/blog/introducing-many-to-many-multilingual-machine-translation/">Meta AI: The first AI model that translates 100 languages without relying on English data</a><br><a href="https://scontent.ficn2-2.fna.fbcdn.net/v/t39.8562-6/122141102_1284164108584699_8596121596808227915_n.pdf?_nc_cat=108&ccb=1-7&_nc_sid=ae5e01&_nc_ohc=hBPnkJzF-6AAX8qvUzN&_nc_ht=scontent.ficn2-2.fna&oh=00_AfAXVKNnFRZgRp37P9wjJFQAWslRGNXPFvCiOphK83fXXQ&oe=63F726B4">Beyond English-Centric Multilingual Machine Translation</a></p></blockquote><ul><li>Huggingface를 사용하면 transformer등 최신 모델을 활용하기 좋습니다.</li><li>별도 요금을 지불할 필요가 없기 때문에 과금에서도 자유롭습니다.</li><li><code>pip</code>로 간단하게 설치하고 시작합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install transformers sentencepiece -q</span><br></pre></td></tr></table></figure></li></ul><p><img src="128_transqual_04.png"><br></p><ul><li>여러 모델이 있지만 여기서는 최초의 다중언어 기계학습 모델인 M2M-100을 사용하겠습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> pipeline</span><br><span class="line"></span><br><span class="line">pipe = pipeline(task=<span class="string">&#x27;text2text-generation&#x27;</span>, model=<span class="string">&#x27;facebook/m2m100_418M&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 초록 요약</span></span><br><span class="line">time_start = time()</span><br><span class="line">abs_translator2 = pipe(abs0, forced_bos_token_id=pipe.tokenizer.get_lang_id(lang=<span class="string">&#x27;ko&#x27;</span>))</span><br><span class="line">time_end = time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# 초록요약= <span class="subst">&#123;abs_translator2[<span class="number">0</span>][<span class="string">&#x27;generated_text&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;- 소요시간: <span class="subst">&#123;time_end-time_start:<span class="number">.2</span>f&#125;</span>s\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 독창성 추출</span></span><br><span class="line">time_start = time()</span><br><span class="line">org_translator2 = pipe(org0, forced_bos_token_id=pipe.tokenizer.get_lang_id(lang=<span class="string">&#x27;ko&#x27;</span>))</span><br><span class="line">time_end = time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# 독창성추출= <span class="subst">&#123;org_translator2[<span class="number">0</span>][<span class="string">&#x27;generated_text&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;- 소요시간: <span class="subst">&#123;time_end-time_start:<span class="number">.2</span>f&#125;</span>s&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 초록요약= PV 패널은 전원 생산 중에 불필요한 열 에너지를 생산하여 온도를 증가시키고 PV 세포의 효율성에 영향을 미칩니다.이 기사는 알루미늄 열 싱크 및 강제 공기 냉각 기술을 사용하여 PV 모듈의 성능을 조사합니다. 연구 된 PV 패널의 평균 전기 효율성은 17 %이며 표준 테스트 조건 (STC)에서 19.38 %의 PV 모듈 효율성에 매우 가깝습니다.</span></span><br><span class="line">- 소요시간: 23.89s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 독창성추출= 연구 결과에 따르면 태양 에너지 생산은 디자인, 재료 사용 및 적절한 냉각 방법을 고려하여 동일한 태양 전지판을 사용할 때에도 최적화 될 수 있습니다.</span></span><br><span class="line">- 소요시간: 8.82s</span><br></pre></td></tr></table></figure></li></ul></li><li>앞의 두 모델과 달리 시간이 적지 않게 걸렸습니다.</li><li>GPU(NVIDIA GeForce RTX 2070)이 설치된 데스크탑에서도 실행해 보았습니다.</li><li>하지만 <b>abs0: 15.59s</b>, <b>org0: 5.88s</b>로 서비스에는 적합하지 않은 시간이 소요됐습니다.</li></ul><h2 id="2-4-OpenAI-GPT3"><a href="#2-4-OpenAI-GPT3" class="headerlink" title="2.4. OpenAI GPT3"></a>2.4. OpenAI GPT3</h2><blockquote><p><a href="https://platform.openai.com/docs/guides/completion/translation">OpenAI: Translation</a><br><a href="https://chat.openai.com/">ChatGPT</a><br><a href="https://community.openai.com/t/randomly-occurring-openai-api-timeouts/28573/12">OpenAI: Randomly Occuring OpenAI API Timeouts</a></p></blockquote><ul><li>최근 ChatGPT로 인해 언어 모델이 주목을 받고 있습니다.</li><li>많은 유튜버들이 ChatGPT를 엑셀 등에 적용한 영상을 올리고 있지만 실상은 OpenAI의 <b>GPT API</b>를 사용하는 것입니다.</li><li>OpenAI는 번역에 사용할 수 있는 GPT3계열의 여러 가지 모델을 지원합니다.</li></ul><ul><li>공식 설명을 <a href="https://www.deepl.com/">DeepL</a>로 번역한 결과는 다음과 같습니다.<ul><li><b>text-davinci-003</b> : GPT-3 시리즈 중 가장 성능이 뛰어난 모델입니다. 다른 GPT-3 모델보다 더 높은 품질, 더 긴 출력, 더 나은 명령 수행 능력으로 어떤 작업도 수행할 수 있습니다. 요청당 최대 4,000개의 토큰을 처리할 수 있습니다.</li><li><b>text-davinci-002</b> : GPT-3 시리즈의 2세대 모델입니다. GPT-3 모델의 엘리어가 할 수 있는 모든 작업을 수행할 수 있지만 컨텍스트가 적은 경우가 많습니다. 요청당 최대 4,000개의 토큰을 처리할 수 있습니다.</li><li><b>text-davinci-001</b> : GPT-3 시리즈 중 가장 성능이 뛰어난 모델의 이전 버전입니다. 다른 GPT-3 모델이 할 수 있는 모든 작업을 수행할 수 있지만 컨텍스트가 적은 경우가 많습니다.</li><li><b>text-curie-001</b> : 기능이 매우 뛰어나지만 텍스트 다빈치-003보다 빠르고 비용이 저렴합니다.</li></ul></li></ul><ul><li>GPT를 사용하려면 openai에서 API key를 받아야 합니다.</li><li>davinci 모델은 <b>0.12 USD/1k token</b>, curie 모델은 <b>0.012 USD/1k token</b>가 과금됩니다.</li><li>함수를 만드는 김에 시간 측정을 decorator로 합니다.</li><li>먼저 동일 모델을 여러번 반복하면서 일관성을 테스트합니다. 모델은 text-davinci-003 모델을 사용했습니다.</li><li><b>앞서 사용한 다른 모델들과 달리 수행시마다 다른 결과가 나옵니다.</b><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timed</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        time_start = time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        time_end = time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;- 소요시간: <span class="subst">&#123;time_end-time_start:<span class="number">.2</span>f&#125;</span>s&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timed</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translateGPT</span>(<span class="params">text, model=<span class="string">&quot;text-davinci-003&quot;</span>, max_tokens=<span class="number">1000</span>, top_p=<span class="number">1.0</span></span>):</span></span><br><span class="line">    response = openai.Completion.create(</span><br><span class="line">      model=model,</span><br><span class="line">      prompt=<span class="string">f&quot;Translate this in Korean:<span class="subst">&#123;text&#125;</span>&quot;</span>,</span><br><span class="line">      temperature=<span class="number">0.3</span>,</span><br><span class="line">      max_tokens=max_tokens,</span><br><span class="line">      top_p=top_p,</span><br><span class="line">      frequency_penalty=<span class="number">0.0</span>,</span><br><span class="line">      presence_penalty=<span class="number">0.0</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> response.to_dict()[<span class="string">&#x27;choices&#x27;</span>][<span class="number">0</span>][<span class="string">&quot;text&quot;</span>].lstrip(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 5회 번역</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;# <span class="subst">&#123;i&#125;</span>회: <span class="subst">&#123;translateGPT(abs0)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1회: - 소요시간: 23.38s</span></span><br><span class="line"><span class="string">&#x27;PV 패널은 전력 생산 시 불필요한 열 에너지를 발생시키며 온도를 증가시키고 PV 셀의 효율에 영향을 미칩니다. 이 기사는 알루미늄 히트 싱크와 강제 공기 쿨링 기술을 사용하여 PV 모듈의 성능을 조사합니다. 연구된 PV 패널의 평균 전기 효율은 17 %로 표준 시험 조건 (STC) 하에서의 PV 모듈 효율인 19.38 %에 매우 가깝습니다.&#x27;</span></span><br><span class="line"><span class="comment"># 2회: - 소요시간: 20.41s</span></span><br><span class="line"><span class="string">&#x27;PV 패널은 전력 생산 시 불필요한 열 에너지를 발생시켜 PV 셀의 수율에 영향을 미치는 온도를 증가시킵니다. 이 논문은 알루미늄 히트 싱크와 강제 공기 쿨링 기술을 사용한 PV 모듈의 성능을 조사합니다. 연구된 PV 패널의 평균 전기 효율은 17 %로 표준 시험 조건(STC)에서의 PV 모듈 효율인 19.38 %에 매우 가깝습니다.&#x27;</span></span><br><span class="line"><span class="comment"># 3회: - 소요시간: 23.22s</span></span><br><span class="line"><span class="string">&#x27;PV 패널은 전력 생산 중 불필요한 열 에너지를 생산하여 온도를 증가시키고 PV 셀의 효율에 영향을 미칩니다. 이 기사는 알루미늄 히트 싱크 및 강제 공기 쿨링 기술을 사용하여 PV 모듈의 성능을 조사합니다. 연구 된 PV 패널의 평균 전기 효율은 17 %이며 표준 시험 조건 (STC) 하에서의 PV 모듈 효율인 19.38 %에 가깝습니다.&#x27;</span></span><br><span class="line"><span class="comment"># 4회: - 소요시간: 22.51s</span></span><br><span class="line"><span class="string">&#x27;PV 패널은 전력 생산 중 불필요한 열 에너지를 생산하여 온도를 증가시키고 PV 셀의 효율에 영향을 미칩니다. 이 논문은 알루미늄 히트 싱크와 강제 공기 쿨링 기술을 사용하는 PV 모듈의 성능을 조사합니다. 연구 된 PV 패널의 평균 전기 효율은 17 %이며 표준 시험 조건 (STC) 의 PV 모듈 효율인 19.38 %에 가깝습니다.&#x27;</span></span><br><span class="line"><span class="comment"># 5회: - 소요시간: 22.86s</span></span><br><span class="line"><span class="string">&#x27;PV 패널은 전력 생산 중에 불필요한 열 에너지를 발생시켜 온도를 증가시키고 PV 셀의 효율에 영향을 미칩니다. 이 기사는 알루미늄 히트 싱크와 강제 공기 쿨링 기술을 사용한 PV 모듈의 성능을 조사합니다. 연구된 PV 패널의 평균 전기 효율은 17 %이며 표준 시험 조건 (STC) 에서의 PV 모듈 효율인 19.38 %에 매우 가깝습니다.&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li><li>모델별 소요 시간을 확인하기 위해 같은 문구를 모델만 바꾸어 적용했습니다. </li><li>초록 요약본에서 과거 모델일수록 시간이 짧게 걸리는 동향이 확인되지만 독창성은 그렇지 않습니다.<br><br><img src="128_transqual_06.png"><br></li></ul><ul><li><p>이상해서 확인을 해보니 <b>좀 심각한 문제가 있습니다.</b></p></li><li><p><b>originality 번역이 간혹 엉뚱한 결과를 내놓습니다.</b><br></p></li><li><p><b>text-davinci-001</b>은 번역을 하다가 말았고 <b>text-curie-001</b>은 영문을 같이 내뱉습니다.<br><br><img src="128_transqual_05.png"><br></p></li><li><p><b><a href="https://community.openai.com/t/randomly-occurring-openai-api-timeouts/28573/12">간혹 API 접속 오류도 발생합니다</a></b></p></li><li><p>최근 ChatGPT의 인기 때문인지 모르겠지만 접속이 불안정합니다.</p></li><li><p>이런 일을 겪는 것이 저 혼자만은 아닌 것 같습니다.</p></li></ul><h2 id="2-5-Deep-Translate-RapidAPI"><a href="#2-5-Deep-Translate-RapidAPI" class="headerlink" title="2.5. Deep Translate (RapidAPI)"></a>2.5. Deep Translate (RapidAPI)</h2><blockquote><p><a href="https://rapidapi.com/gatzuma/api/deep-translate1">RapidAPI: Deep Translate</a></p></blockquote><p><img src="128_transqual_07.png" alt="RapidAPI에서 제공하는 번역 API"><br></p><ul><li><a href="https://rapidapi.com/">Rapidapi</a>는 장점이 많습니다.</li><li>딥러닝 모델과 여러 데이터 등을 API로 제공할 뿐 아니라</li><li>다양한 언어로 예제 코드를 지원하기 때문에 고급 기능을 복붙 수준으로 구현할 수 있습니다.</li><li>그 중 Google Translate와 동일 품질에 100배 저렴하다고 광고하는 Deep Translate를 사용해봅니다.</li><li><b>무료로 월 10만글자</b>를 번역할 수 있고, <b>월 9달러를 지불하면 천만 글자</b>를 번역할 수 있습니다.</li></ul><ul><li><p>API를 받고, 예제를 따라 Deep Translate를 실행하는 함수를 만듭니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deeptranslate</span>(<span class="params">text, RapidAPI=RapidAPI, sl=<span class="string">&quot;en&quot;</span>, tl=<span class="string">&quot;ko&quot;</span></span>):</span></span><br><span class="line">    url = <span class="string">&quot;https://deep-translate1.p.rapidapi.com/language/translate/v2&quot;</span></span><br><span class="line">    </span><br><span class="line">    payload = &#123;</span><br><span class="line">        <span class="string">&quot;q&quot;</span>: text,</span><br><span class="line">        <span class="string">&quot;source&quot;</span>: sl,</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: tl</span><br><span class="line">    &#125;</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">        <span class="string">&quot;X-RapidAPI-Key&quot;</span>: RapidAPI,</span><br><span class="line">        <span class="string">&quot;X-RapidAPI-Host&quot;</span>: <span class="string">&quot;deep-translate1.p.rapidapi.com&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    response = requests.request(<span class="string">&quot;POST&quot;</span>, url, json=payload, headers=headers)</span><br><span class="line">    translated = response.json()[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;translations&quot;</span>][<span class="string">&quot;translatedText&quot;</span>]</span><br><span class="line">    <span class="keyword">return</span> translated</span><br></pre></td></tr></table></figure></li><li><p>위와 마찬가지로 소요 시간을 확인하며 실행합니다.</p></li><li><p>먼저 초록 요약본 번역입니다. 5회 반복합니다.</p></li><li><p>5회 모두 동일하며, 광고대로 구글 번역 결과와 완전 동일합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;# <span class="subst">&#123;i&#125;</span>회: <span class="subst">&#123;deeptranslate(abs0)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 소요시간: 1.84s</span><br><span class="line"><span class="comment"># 1회: PV 패널은 발전 중에 불필요한 열 에너지를 생성하여 온도를 높이고 PV 전지의 효율에 영향을 미칩니다. 이 기사에서는 알루미늄 방열판과 강제 공기 냉각 기술을 사용하는 PV 모듈의 성능을 조사합니다. 연구된 PV 패널의 평균 전기 효율은 17%이며 표준 테스트 조건(STC)에서 PV 모듈 효율 19.38%에 매우 가깝습니다.</span></span><br><span class="line">- 소요시간: 2.00s</span><br><span class="line"><span class="comment"># 2회: PV 패널은 발전 중에 불필요한 열 에너지를 생성하여 온도를 높이고 PV 전지의 효율에 영향을 미칩니다. 이 기사에서는 알루미늄 방열판과 강제 공기 냉각 기술을 사용하는 PV 모듈의 성능을 조사합니다. 연구된 PV 패널의 평균 전기 효율은 17%이며 표준 테스트 조건(STC)에서 PV 모듈 효율 19.38%에 매우 가깝습니다.</span></span><br><span class="line">- 소요시간: 3.20s</span><br><span class="line"><span class="comment"># 3회: PV 패널은 발전 중에 불필요한 열 에너지를 생성하여 온도를 높이고 PV 전지의 효율에 영향을 미칩니다. 이 기사에서는 알루미늄 방열판과 강제 공기 냉각 기술을 사용하는 PV 모듈의 성능을 조사합니다. 연구된 PV 패널의 평균 전기 효율은 17%이며 표준 테스트 조건(STC)에서 PV 모듈 효율 19.38%에 매우 가깝습니다.</span></span><br><span class="line">- 소요시간: 1.83s</span><br><span class="line"><span class="comment"># 4회: PV 패널은 발전 중에 불필요한 열 에너지를 생성하여 온도를 높이고 PV 전지의 효율에 영향을 미칩니다. 이 기사에서는 알루미늄 방열판과 강제 공기 냉각 기술을 사용하는 PV 모듈의 성능을 조사합니다. 연구된 PV 패널의 평균 전기 효율은 17%이며 표준 테스트 조건(STC)에서 PV 모듈 효율 19.38%에 매우 가깝습니다.</span></span><br><span class="line">- 소요시간: 2.35s</span><br><span class="line"><span class="comment"># 5회: PV 패널은 발전 중에 불필요한 열 에너지를 생성하여 온도를 높이고 PV 전지의 효율에 영향을 미칩니다. 이 기사에서는 알루미늄 방열판과 강제 공기 냉각 기술을 사용하는 PV 모듈의 성능을 조사합니다. 연구된 PV 패널의 평균 전기 효율은 17%이며 표준 테스트 조건(STC)에서 PV 모듈 효율 19.38%에 매우 가깝습니다.</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>독창성 부분 번역입니다. 5회 반복합니다.</p></li><li><p>초록 요약본과 마찬가지로 2초 가량 소요되며, 결과물도 마찬가지입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;# <span class="subst">&#123;i&#125;</span>회: <span class="subst">&#123;deeptranslate(abs0)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 소요시간: 3.10s</span><br><span class="line"><span class="comment"># 1회: 연구 결과는 동일한 태양광 패널을 사용하더라도 설계, 재료 사용 및 적절한 냉각 방법을 고려하여 태양광 발전을 최적화할 수 있음을 보여줍니다.</span></span><br><span class="line">- 소요시간: 2.05s</span><br><span class="line"><span class="comment"># 2회: 연구 결과는 동일한 태양광 패널을 사용하더라도 설계, 재료 사용 및 적절한 냉각 방법을 고려하여 태양광 발전을 최적화할 수 있음을 보여줍니다.</span></span><br><span class="line">- 소요시간: 2.07s</span><br><span class="line"><span class="comment"># 3회: 연구 결과는 동일한 태양광 패널을 사용하더라도 설계, 재료 사용 및 적절한 냉각 방법을 고려하여 태양광 발전을 최적화할 수 있음을 보여줍니다.</span></span><br><span class="line">- 소요시간: 1.99s</span><br><span class="line"><span class="comment"># 4회: 연구 결과는 동일한 태양광 패널을 사용하더라도 설계, 재료 사용 및 적절한 냉각 방법을 고려하여 태양광 발전을 최적화할 수 있음을 보여줍니다.</span></span><br><span class="line">- 소요시간: 1.76s</span><br><span class="line"><span class="comment"># 5회: 연구 결과는 동일한 태양광 패널을 사용하더라도 설계, 재료 사용 및 적절한 냉각 방법을 고려하여 태양광 발전을 최적화할 수 있음을 보여줍니다.</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>무료로 사용할 수 있는 Google Translate와 동일한 성능이라면,</p></li><li><p><b>시간도 10배쯤 더 걸리는데 굳이 돈을 내고 사용할 필요가 없습니다.</b></p></li></ul><h2 id="2-6-DeepL-Translator-RapidAPI"><a href="#2-6-DeepL-Translator-RapidAPI" class="headerlink" title="2.6. DeepL Translator (RapidAPI)"></a>2.6. DeepL Translator (RapidAPI)</h2><blockquote><p><a href="https://www.deepl.com/">DeepL Translator</a><br><a href="https://rapidapi.com/splintPRO/api/deepl-translator">RapidAPI: DeepL Translator</a></p></blockquote><p><img src="128_transqual_08.png" alt="RapidAPI DeepL"><br></p><ul><li><p><b><a href="https://www.deepl.com/">DeepL</a></b>은 최근 공개되어 <b>구글 번역기를 능가하는 성능</b>으로 유명한 번역기입니다.</p></li><li><p>DeepL API를 사용하려면 신용카드 등록이 필요한데, 현재 대한민국의 신용카드는 지원하지 않습니다.</p></li><li><p>그러나 뜻밖으로 <b>RapidAPI</b>에서 DeepL API를 찾을 수 있었습니다.</p></li><li><p><b>DeepL 개발사에서 업로드한 것인지는 알 수 없으나</b>(검색을 해도 나오지 않습니다) </p></li><li><p>테스트 결과 <b>검색 품질은 DeepL.com</b>에서 수행한 것과 동일합니다.</p></li><li><p>누군가 본인의 DeepL 계정을 사용해 사설 API를 개발하고 올린 것이 아닌가 추측합니다.</p></li><li><p>함수를 만들고 사용합니다. <b>RapidAPI는 동일 Key를 모든 API에 사용할 수 있습니다.</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timed</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deepl</span>(<span class="params">text, RapidAPI=RapidAPI, sl=<span class="string">&quot;en&quot;</span>, tl=<span class="string">&quot;ko&quot;</span></span>):</span></span><br><span class="line">    url = <span class="string">&quot;https://deepl-translator.p.rapidapi.com/translate&quot;</span></span><br><span class="line">    </span><br><span class="line">    payload = &#123;</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: text,</span><br><span class="line">        <span class="string">&quot;source&quot;</span>: sl,</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: tl</span><br><span class="line">    &#125;</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;X-RapidAPI-Key&quot;</span>: RapidAPI,</span><br><span class="line">        <span class="string">&quot;X-RapidAPI-Host&quot;</span>: <span class="string">&quot;deepl-translator.p.rapidapi.com&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    response = requests.request(<span class="string">&quot;POST&quot;</span>, url, json=payload, headers=headers)</span><br><span class="line">    <span class="keyword">return</span> response.json()[<span class="string">&quot;text&quot;</span>]</span><br></pre></td></tr></table></figure></li><li><p>초록과 독창성 부분을 번역시킵니다. 5회 반복해도 동일한 결과가 반복되며 시간은 2초 미만입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(deepl(abs0))</span><br><span class="line"><span class="built_in">print</span>(deepl(org0))</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 소요시간: 0.94s</span><br><span class="line"><span class="string">&#x27;태양광 패널은 발전 중에 불필요한 열 에너지를 생성하여 온도를 높이고 태양광 셀의 효율에 영향을 미칩니다. 이 글에서는 알루미늄 방열판과 강제 공기 냉각 기술을 사용한 태양광 모듈의 성능을 조사합니다. 연구 대상 태양광 패널의 평균 전기 효율은 17%이며 표준 테스트 조건(STC)에서의 태양광 모듈 효율인 19.38%에 매우 근접합니다.&#x27;</span></span><br><span class="line">- 소요시간: 0.85s</span><br><span class="line">연구 결과에 따르면 동일한 태양 전지판을 사용하더라도 설계, 재료 사용, 적절한 냉각 방법을 고려하면 태양 에너지 생산을 최적화할 수 있습니다.</span><br></pre></td></tr></table></figure></li></ul></li><li><p>DeepL은 <b>대체 문장을 제공한다</b>는 특징이 있습니다.</p></li><li><p>짧은 문장을 입력하면 <code>response.json()</code>에서 <code>&quot;text&quot;</code>를 우선 번역 결과로 제공하지만,</p></li><li><p><code>&quot;alternative_texts&quot;</code>에는 다른 버전의 번역본을 제공합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># input text</span></span><br><span class="line">text = <span class="string">&quot;what a wonderful world.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DeepL 실행: payload와 headers는 deepl() 내부와 동일. payload내 text만 변경.</span></span><br><span class="line">response = requests.request(<span class="string">&quot;POST&quot;</span>, url, json=payload, headers=headers)</span><br><span class="line">r_json = response.json()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# text : <span class="subst">&#123;r_json[<span class="string">&#x27;text&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# alternative_texts : <span class="subst">&#123;r_json[<span class="string">&#x27;alternative_texts&#x27;</span>]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># text : 정말 멋진 세상입니다.</span></span><br><span class="line"><span class="comment"># alternative_texts : [&#x27;이 얼마나 멋진 세상인가요.&#x27;, &#x27;이 얼마나 멋진 세상입니까.&#x27;, &#x27;이 얼마나 멋진 세상입니까.&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="3-번역-성능-비교"><a href="#3-번역-성능-비교" class="headerlink" title="3. 번역 성능 비교"></a>3. 번역 성능 비교</h1><ul><li>이제까지 동일 문장을 6가지 모델을 사용해 번역해 보았습니다.</li><li>GPT 모델을 반응시간이 가장 짧은 <code>text-curie-001</code>으로 고정하고 얻은 결과를 포함하여 <a href="transqual.xlsx">결과 파일</a>에 정리했습니다.</li><li><b>경어와 반어</b>, <b>매끄러운 문장 구사</b>, <b>가격</b>, <b>속도, 안정성</b> 관점에서 정리합니다.</li></ul><h2 id="3-1-경어와-반어-존대말과-반말"><a href="#3-1-경어와-반어-존대말과-반말" class="headerlink" title="3.1. 경어와 반어 (존대말과 반말)"></a>3.1. 경어와 반어 (존대말과 반말)</h2><ul><li>존대말이든 반말이든 <b>일관성</b>이 중요합니다.<ul><li><b>GOOD :</b> Google Translate(경어), huggingface(경어), GPT3(반어), DeepL(경어)</li><li><b>BAD :</b> Papago, Deep Translate</li></ul></li></ul><ul><li>Deep Translate는 본 테스트 파일에서는 모두 경어로 일관되었으나 다른 테스트에서 섞어 쓰는 것이 다수 발견되었습니다.</li></ul><h2 id="3-2-매끄러운-문장-구사"><a href="#3-2-매끄러운-문장-구사" class="headerlink" title="3.2. 매끄러운 문장 구사"></a>3.2. 매끄러운 문장 구사</h2><ul><li>문장의 자연스러움과 띄어쓰기를 확인합니다.<ul><li><b>BEST :</b> DeepL</li><li><b>GOOD :</b> Google Translate, Papago, Deep Translate</li><li><b>BAD :</b> Huggingface, GPT3</li></ul></li></ul><ul><li>Huggingface는 문장끼리 붙여쓰는 경우가 발견되었습니다.</li><li>GPT는 어색한 번역투 문장이 자주 보입니다 (ex. “에너지 공급을 가진다”)</li><li>DeepL의 유려함이 빛납니다. Abstract를 “초록”이라 번역하는 것은 DeepL뿐입니다.</li></ul><h2 id="3-3-가격"><a href="#3-3-가격" class="headerlink" title="3.3. 가격"></a>3.3. 가격</h2><ul><li>당연히 무료가 좋습니다. 적당한 선에서 가격을 지불할 용의도 있습니다. </li><li>운영 차원에서 종량제는 예측이 어려울 수 있습니다.<ul><li><b>BEST :</b> Google Translate, Huggingface</li><li><b>GOOD :</b> Deep Translate(hard limit), DeepL(hard limit), Papago(soft limit)</li><li><b>FAIR :</b> GPT3(종량제)</li></ul></li></ul><h2 id="3-4-속도-안정성"><a href="#3-4-속도-안정성" class="headerlink" title="3.4. 속도, 안정성"></a>3.4. 속도, 안정성</h2><ul><li>서비스 사용자 입장에서는 속도와 안정성이 매우 중요합니다. <ul><li><b>BEST :</b> Google Translate, Papago</li><li><b>GOOD :</b> Deep Translate(hard limit), DeepL(hard limit)</li><li><b>BAD :</b> Huggingface(속도)</li><li><b>WORST :</b> GPT3(속도, 안정성)</li></ul></li></ul><ul><li>Huggingface와 GPT3는 번역 결과를 받기까지 10초 이상 걸렸습니다. </li><li>GPT3는 사용자가 몰려서인지 모르겠으나 접속 안정성 이슈가 있었고 번역이 깨지는 경우가 확인됩니다.</li><li>향후 안정성을 업데이트하리라 믿습니다.</li></ul><h1 id="4-결론"><a href="#4-결론" class="headerlink" title="4. 결론"></a>4. 결론</h1><ul><li>RapidAPI의 <b>DeepL API</b>가 정상적인 것인지 의심이 되기는 하지만 성능과 안정성면에서는 가장 우수합니다.</li><li>hard limit라는 단점이 있는 만큼 이용자가 한도를 넘으면 <b>Google Translate</b>로 넘기는 방식을 구현할 수 있습니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/translation/">translation</category>
      
      <category domain="https://jehyunlee.github.io/tags/latural-language-processing/">latural language processing</category>
      
      
    </item>
    
    <item>
      <title>ChatGPT 업무효율화 가이드</title>
      <link>https://jehyunlee.github.io/2023/02/15/General-16-chatgpt/</link>
      <guid>https://jehyunlee.github.io/2023/02/15/General-16-chatgpt/</guid>
      <pubDate>Tue, 14 Feb 2023 16:08:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://chat.openai.com/chat&quot;&gt;ChatGPT&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;최근 대통령이 정부부처 업무보고에서 ChatGPT를 언급한 이후 관심이 뜨겁습니다.</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><a href="https://chat.openai.com/chat">ChatGPT</a></p></blockquote><ul><li>최근 대통령이 정부부처 업무보고에서 ChatGPT를 언급한 이후 관심이 뜨겁습니다.</li><li>여러 부처 및 기관 분들을 만나뵙고 받은 공통적인 질문들을 정리했습니다.</li><li><b>사무 업무효율화에 ChatGPT를 적용하기 위한</b> 가이드입니다.</li><li>AI가 낯선 분들께 ChatGPT가 다가선 만큼 엉뚱한 기대도 느껴진 것이 사실입니다.</li></ul><ul><li><b>ChatGPT가 향후 업데이트가 될 것이고, 다른 모델들이 경쟁하며 개발중입니다.</b></li><li><b>현재 시점에서의 가이드라는 점을 말씀드리며, 향후 ChatGPT 업그레이드 상황에 따라 변경될 수 있습니다.</b></li><li><a href="ChatGPT_AiFrenz_guide.pdf">pdf 파일은 여기에서 다운받으실 수 있습니다.</a></li><li>AI프렌즈 분들과 함께 여러 분들을 만났던 자리인 만큼 AI프렌즈 명의로 작성했습니다.</li></ul><p><img src="ChatGPT_AiFrenz_guide_01.png" alt="11줄 요약"></p><p><img src="ChatGPT_AiFrenz_guide_02.png" alt="예시 1"></p><p><img src="ChatGPT_AiFrenz_guide_03.png" alt="예시 2"></p><p><img src="ChatGPT_AiFrenz_guide_04.png" alt="예시 3"></p><p><img src="ChatGPT_AiFrenz_guide_05.png" alt="예시 3"></p><p><img src="ChatGPT_AiFrenz_guide_06.png" alt="예시 4"></p><p><img src="ChatGPT_AiFrenz_guide_07.png" alt="예시 4"></p><p><img src="ChatGPT_AiFrenz_guide_08.png" alt="예시 4"></p><p><img src="ChatGPT_AiFrenz_guide_09.png" alt="예시 6"></p><p><img src="ChatGPT_AiFrenz_guide_10.png" alt="예시 8"></p><p><img src="ChatGPT_AiFrenz_guide_11.png" alt="예시 9"></p><p><img src="ChatGPT_AiFrenz_guide_12.png" alt="예시 9"></p><p><img src="ChatGPT_AiFrenz_guide_13.png" alt="예시 10"></p><p><img src="ChatGPT_AiFrenz_guide_14.png" alt="예시 11"></p><p><img src="ChatGPT_AiFrenz_guide_15.png" alt="예시 11"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/openai/">openai</category>
      
      <category domain="https://jehyunlee.github.io/tags/chatgpt/">chatgpt</category>
      
      
    </item>
    
    <item>
      <title>KDE + threshold</title>
      <link>https://jehyunlee.github.io/2023/02/12/Python-DS-127_kdeth/</link>
      <guid>https://jehyunlee.github.io/2023/02/12/Python-DS-127_kdeth/</guid>
      <pubDate>Sun, 12 Feb 2023 08:20:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;밀도 함수는 데이터 분포를 볼 때 가장 많이 그리는 그림 중 하나입니다.&lt;/li&gt;
&lt;li&gt;특정 값을 기준으로 Pass와 Fail을 정한다고 할 때, 전체의 비율도 중요합니다.&lt;/li&gt;
&lt;li&gt;seaborn kdeplot을 살짝 다듬어서</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>밀도 함수는 데이터 분포를 볼 때 가장 많이 그리는 그림 중 하나입니다.</li><li>특정 값을 기준으로 Pass와 Fail을 정한다고 할 때, 전체의 비율도 중요합니다.</li><li>seaborn kdeplot을 살짝 다듬어서 쪼개고 비율을 계산합니다.</li></ul><h1 id="1-오늘의-목표"><a href="#1-오늘의-목표" class="headerlink" title="1. 오늘의 목표"></a>1. 오늘의 목표</h1><ul><li>오늘 우리는 데이터를 선별하는 데 쓰는, 이런 그림을 그릴 겁니다.</li><li>특정 값을 기준으로 왼쪽은 Fail, 오른쪽은 Pass입니다.</li><li>공장에서 발생하는 양품과 불량품으로 생각을 해도 좋고, 학생들 시험 결과의 분포로 봐도 좋습니다.</li><li>중요한 것은 <b>특정 지점을 기준으로 KDE plot을 자르고</b>, <b>좌우를 다른 색으로 칠하는 것</b>입니다.<br><br><img src="127_kdeth_8.png"><br></li></ul><h1 id="2-데이터-→-밀도-함수"><a href="#2-데이터-→-밀도-함수" class="headerlink" title="2. 데이터 → 밀도 함수"></a>2. 데이터 → 밀도 함수</h1><ul><li><p><code>numpy</code>를 사용해서 정규분포에 가까운 데이터를 만듭니다.</p></li><li><p><code>np.random.normal()</code>을 사용하면 뚝딱 만들어집니다.</p></li><li><p><code>loc</code>, <code>scale</code>을 사용해서 평균과 표준편차를 지정하고, <code>size</code>에는 10만을 넣습니다.</p></li><li><p>이렇게 얻은 결과를 <code>seaborn.kdeplot()</code>으로 밀도함수로 표현합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 예제 데이터 생성</span></span><br><span class="line">set0 = np.random.normal(loc=<span class="number">3</span>, scale=<span class="number">1</span>, size=<span class="number">100_000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 데이터 분포 밀도함수 시각화</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">sns.kdeplot(set0, fill=<span class="literal">True</span>, ax=ax)</span><br></pre></td></tr></table></figure><p><img src="127_kdeth_0.png"><br></p></li><li><p>매끈한 밀도함수가 얻어졌습니다.</p></li><li><p>이토록 데이터 분포가 매끈해보이는 것은 <code>seaborn.kdeplot()</code>에 숨겨진 <code>gridsize=200</code>이라는 매개변수 덕분입니다.</p></li><li><p>데이터가 쪼개지는 지점을 눈에 잘 띄게 하겠습니다. <code>gridsize=20</code>을 입력해서 같은 데이터를 거칠게 표현합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">sns.kdeplot(set0, fill=<span class="literal">True</span>, gridsize=<span class="number">20</span>, ax=ax)</span><br></pre></td></tr></table></figure><p><img src="127_kdeth_1.png"><br></p></li></ul><h1 id="3-밀도-함수-절단"><a href="#3-밀도-함수-절단" class="headerlink" title="3. 밀도 함수 절단"></a>3. 밀도 함수 절단</h1><blockquote><p><a href="https://matplotlib.org/stable/api/path_api.html">matplotlib.org matplotlib.path</a></p></blockquote><ul><li>똑같은 데이터인데 전혀 매끈하지 않습니다.</li><li>한 눈에 봐도 꼭지점과 선분으로 이루어진 다각형이라는 것을 알 수 있습니다.</li><li><b>$x = 2$</b></li><li>꼭지점 중 <b>$x &gt; 2$만 남겨서 이것들로 다각형을 새로 만들면 되지 않을까요?</b></li></ul><ul><li><p>KDE plot을 구성하는 다각형은 <code>ax.collections</code>로 추출할 수 있습니다.</p></li><li><p>이 중에서도 윤곽선은 <code>.get_path()[0]</code>명령으로 뽑아낼 수 있고,</p></li><li><p>꼭지점은 여기에 <code>.vertices</code>, 꼭지점의 특성은 <code>.codes</code> 속성을 보면 됩니다.</p></li><li><p>한번 추출해 봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vertices</span></span><br><span class="line">path = ax.collections[<span class="number">0</span>].get_paths()[<span class="number">0</span>]</span><br><span class="line">vertices = path.vertices</span><br><span class="line">codes = path.codes</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# vertices = <span class="subst">&#123;vertices&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;#    codes = <span class="subst">&#123;codes&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vertices = [[-1.68144422e+00  4.44446302e-07]</span></span><br><span class="line">[-1.68144422e+00  0.00000000e+00]</span><br><span class="line">[-1.20843724e+00  0.00000000e+00]</span><br><span class="line">[-7.35430261e-01  0.00000000e+00]</span><br><span class="line">[-2.62423283e-01  0.00000000e+00]</span><br><span class="line"> </span><br><span class="line">              (중략)</span><br><span class="line">        </span><br><span class="line">[-1.68144422e+00  4.44446302e-07]</span><br><span class="line">[-1.68144422e+00  4.44446302e-07]]</span><br><span class="line"><span class="comment">#    codes = [ 1  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2</span></span><br><span class="line"> 2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2 79]</span><br></pre></td></tr></table></figure></li></ul></li><li><p><b>vertices</b>에는 수많은 점의 $(x, y)$ 좌표가 나열되어 있습니다. </p></li><li><p>이 데이터를 기준으로 threshold를 적용하면 될 것 같습니다.</p></li><li><p>해당 데이터의 index를 추출합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x &gt; 2 인 꼭지점 추출</span></span><br><span class="line">idx_th = np.where(vertices[:, <span class="number">0</span>] &gt; <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">idx_th</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([ 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,</span><br><span class="line">     26, 27, 28, 29, 30, 31, 32, 33])</span><br></pre></td></tr></table></figure></li></ul></li><li><p><b>codes</b>가 <a href="https://matplotlib.org/stable/api/path_api.html">중요한 정보</a>를 담고 있습니다.</p></li><li><p><b>1은 시작점</b>, <b>2는 연결점</b>, <b>79는 polygon close</b>입니다.</p></li><li><p><b>$ x &gt; 2 $</b>인 점들의 index를 추출하다 보면 code가 규칙에서 어긋날 수 있습니다.</p></li><li><p>그렇기 때문에, 첫 점과 마지막 점의 code에 강제로 1과 79를 할당합니다.</p></li><li><p>이렇게 추출된 vertices와 codes를 다시 윤곽선을 의미하는 path에 할당하고 그림을 그리면 변화가 관찰됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vertices_th = vertices[idx_th]</span><br><span class="line">codes_th = codes[idx_th]</span><br><span class="line"></span><br><span class="line">path.vertices = vertices_th</span><br><span class="line">path.codes = codes_th</span><br><span class="line">path.codes[<span class="number">0</span>] = <span class="number">1</span>    <span class="comment"># 시작점 (MOVETE)</span></span><br><span class="line">path.codes[-<span class="number">1</span>] = <span class="number">79</span>  <span class="comment"># 닫는 점 (CLOSEPOLY)</span></span><br><span class="line"></span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure></li></ul><h1 id="4-부가-요소-활용"><a href="#4-부가-요소-활용" class="headerlink" title="4. 부가 요소 활용"></a>4. 부가 요소 활용</h1><ul><li><p>전체 코드를 한 번 정리합니다.</p></li><li><p><code>gridsize</code>를 기본값으로 복구시켜 매끈한 곡선을 얻고,</p></li><li><p>밀도 함수를 절단한 뒤 다시 전체 밀도 함수를 선으로만 그려 부분과 전체를 동시에 표시합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. threshold 적용 KDE plot</span></span><br><span class="line">sns.kdeplot(set0, fill=<span class="literal">True</span>, ax=ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># vertices</span></span><br><span class="line">path = ax.collections[<span class="number">0</span>].get_paths()[<span class="number">0</span>]</span><br><span class="line">vertices = path.vertices</span><br><span class="line">codes = path.codes</span><br><span class="line"></span><br><span class="line"><span class="comment"># threshold</span></span><br><span class="line">idx_th = np.where(vertices[:, <span class="number">0</span>] &gt; <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">vertices_th = vertices[idx_th]</span><br><span class="line">codes_th = codes[idx_th]</span><br><span class="line">path.vertices = vertices_th</span><br><span class="line">path.codes = codes_th</span><br><span class="line">path.codes[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">path.codes[-<span class="number">1</span>] = <span class="number">79</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. threshold 미적용 KDE plot</span></span><br><span class="line">sns.kdeplot(set0, fill=<span class="literal">False</span>, color=<span class="string">&quot;k&quot;</span>, ax=ax)</span><br></pre></td></tr></table></figure><p><img src="127_kdeth_3.png"></p></li><li><p>이제 저 영역이 Pass라는 것을 문자를 사용해 명시합니다.</p></li><li><p>색도 기본색보다 조금은 의지를 반영해 특정 색을 지정합니다. 파랑으로 갑시다.</p></li><li><p>기준점이 되는 <b>$x = 2$</b>에 기준 막대도 우뚝 세워줍니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. threshold 적용 KDE plot</span></span><br><span class="line">sns.kdeplot(set0, color=<span class="string">&quot;b&quot;</span>, gridsize=<span class="number">500</span>, fill=<span class="literal">True</span>, ax=ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># vertices</span></span><br><span class="line">path = ax.collections[<span class="number">0</span>].get_paths()[<span class="number">0</span>]</span><br><span class="line">vertices = path.vertices</span><br><span class="line">codes = path.codes</span><br><span class="line"></span><br><span class="line"><span class="comment"># threshold</span></span><br><span class="line">idx_th = np.where(vertices[:, <span class="number">0</span>] &gt; <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">vertices_th = vertices[idx_th]</span><br><span class="line">codes_th = codes[idx_th]</span><br><span class="line">path.vertices = vertices_th</span><br><span class="line">path.codes = codes_th</span><br><span class="line">path.codes[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">path.codes[-<span class="number">1</span>] = <span class="number">79</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. threshold 미적용 KDE plot</span></span><br><span class="line">sns.kdeplot(set0, fill=<span class="literal">False</span>, color=<span class="string">&quot;k&quot;</span>, ax=ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. additional information</span></span><br><span class="line">ax.collections[<span class="number">0</span>].set_lw(<span class="number">0</span>)     <span class="comment"># threshold 적용 KDE plot의 윤곽선 제거</span></span><br><span class="line">ax.axvline(<span class="number">2</span>, c=<span class="string">&quot;k&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>) <span class="comment"># threshold line</span></span><br><span class="line">ax.text(<span class="number">3.2</span>, <span class="number">0.15</span>, <span class="string">&quot;PASS&quot;</span>, color=<span class="string">&quot;b&quot;</span>, ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="127_kdeth_4.png"></p></li></ul><ul><li>같은 요령으로, 왼쪽에 FAIL이라고 명시할 수 있습니다.</li><li>동일한 작업을 threshold 방향만 바꾸어 반복하면 됩니다.<details>  <summary><b>코드 보기/접기</b></summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PASS and FAIL</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. threshold 적용 KDE plot</span></span><br><span class="line">sns.kdeplot(set0, color=<span class="string">&quot;b&quot;</span>, gridsize=<span class="number">500</span>, fill=<span class="literal">True</span>, ax=ax)  <span class="comment"># Pass</span></span><br><span class="line">sns.kdeplot(set0, color=<span class="string">&quot;r&quot;</span>, gridsize=<span class="number">500</span>, fill=<span class="literal">True</span>, ax=ax)  <span class="comment"># Fail</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## PASS</span></span><br><span class="line"><span class="comment"># vertices</span></span><br><span class="line">path_p = ax.collections[<span class="number">0</span>].get_paths()[<span class="number">0</span>]</span><br><span class="line">vertices_p = path_p.vertices</span><br><span class="line">codes_p = path_p.codes</span><br><span class="line"></span><br><span class="line"><span class="comment"># threshold</span></span><br><span class="line">idx_th_p = np.where(vertices_p[:, <span class="number">0</span>] &gt; <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">vertices_th_p = vertices_p[idx_th_p]</span><br><span class="line">codes_th_p = codes_p[idx_th_p]</span><br><span class="line">path_p.vertices = vertices_th_p</span><br><span class="line">path_p.codes = codes_th_p</span><br><span class="line">path_p.codes[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">path_p.codes[-<span class="number">1</span>] = codes[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## FAIL</span></span><br><span class="line"><span class="comment"># vertices</span></span><br><span class="line">path_f = ax.collections[<span class="number">1</span>].get_paths()[<span class="number">0</span>]</span><br><span class="line">vertices_f = path_f.vertices</span><br><span class="line">codes_f = path_f.codes</span><br><span class="line"></span><br><span class="line"><span class="comment"># threshold</span></span><br><span class="line">idx_th_f = np.where(vertices_p[:, <span class="number">0</span>] &lt;= <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">vertices_th_f = vertices_p[idx_th_f]</span><br><span class="line">codes_th_f = codes_p[idx_th_f]</span><br><span class="line">path_f.vertices = vertices_th_f</span><br><span class="line">path_f.codes = codes_th_f</span><br><span class="line">path_f.codes[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">path_f.codes[-<span class="number">1</span>] = <span class="number">79</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. threshold 미적용 KDE plot</span></span><br><span class="line">sns.kdeplot(set0, fill=<span class="literal">False</span>, color=<span class="string">&quot;k&quot;</span>, ax=ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. additional information</span></span><br><span class="line">ax.collections[<span class="number">0</span>].set_lw(<span class="number">0</span>)     <span class="comment"># PASS KDE plot의 윤곽선 제거</span></span><br><span class="line">ax.collections[<span class="number">1</span>].set_lw(<span class="number">0</span>)     <span class="comment"># FAIL KDE plot의 윤곽선 제거</span></span><br><span class="line">ax.axvline(<span class="number">2</span>, c=<span class="string">&quot;k&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>) <span class="comment"># threshold line</span></span><br><span class="line">ax.text(<span class="number">3.2</span>, <span class="number">0.15</span>, <span class="string">&quot;PASS&quot;</span>, color=<span class="string">&quot;b&quot;</span>, ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>)</span><br><span class="line">ax.text(<span class="number">0.5</span>, <span class="number">0.15</span>, <span class="string">&quot;FAIL&quot;</span>, color=<span class="string">&quot;r&quot;</span>, ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><p><img src="127_kdeth_5.png"></p><h1 id="5-넓이-계산"><a href="#5-넓이-계산" class="headerlink" title="5. 넓이 계산"></a>5. 넓이 계산</h1><blockquote><p><a href="https://shapely.readthedocs.io/en/stable/manual.html#polygons">shapely.geometry.Polygon</a></p></blockquote><ul><li>이런 시각화는 그림 뿐 아니라 숫자도 중요합니다.</li><li>기준선을 넘은 데이터가 전체의 몇 %인지, 넘지 못한 것은 얼마인지 알아야 합니다.</li><li>밀도 함수의 전체 넓이는 1이라는 사실은 널리 알려져 있지만 이렇게 자르면 계산이 어렵습니다.</li></ul><ul><li><p><b><code>shapely</code> 라이브러리가 이런 도형 계산에 편리합니다.</b></p></li><li><p><code>shapely.geometry.Polygon()</code>에 vertices를 넣은 뒤 <code>.area</code>속성을 출력하면 넓이가 나옵니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> Polygon</span><br><span class="line"></span><br><span class="line">poly_p = Polygon(vertices_th_p)</span><br><span class="line">poly_f = Polygon(vertices_th_f)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# PASS: <span class="subst">&#123;poly_p.area*<span class="number">100</span>:<span class="number">.2</span>f&#125;</span> %&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# FAIL: <span class="subst">&#123;poly_f.area*<span class="number">100</span>:<span class="number">.2</span>f&#125;</span> %&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# PASS + FAIL: <span class="subst">&#123;(poly_p.area + poly_f.area)*<span class="number">100</span>:<span class="number">.2</span>f&#125;</span> %&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PASS: 83.87 %</span></span><br><span class="line"><span class="comment"># FAIL: 15.70 %</span></span><br><span class="line"><span class="comment"># PASS + FAIL: 99.57 %</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>더해서 100%가 되어야 하는데, 0.5%가량 부족하지만 전체적으로 얼추 맞습니다.</p></li><li><p>대략 84%는 Pass, 16%는 Fail로 볼 수 있을 듯 합니다.</p></li><li><p>실제 앞에서 만든 우리 데이터셋으로 확인하면 84.25% vs 15.75%라고 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# PASS (Ground Truth): <span class="subst">&#123;<span class="built_in">len</span>(set0[set0 &gt; <span class="number">2</span>])/<span class="number">1e5</span> * <span class="number">100</span>:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# FAIL (Ground Truth): <span class="subst">&#123;<span class="built_in">len</span>(set0[set0 &lt;= <span class="number">2</span>])/<span class="number">1e5</span> * <span class="number">100</span>:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PASS (Ground Truth): 84.25</span></span><br><span class="line"><span class="comment"># FAIL (Ground Truth): 15.75</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="6-함수-제작"><a href="#6-함수-제작" class="headerlink" title="6. 함수 제작"></a>6. 함수 제작</h1><ul><li><p>자, 이제 함수를 만들어 사용합시다.</p></li><li><p>data와 threshold를 필수로 입력하게 하고, pass와 fail의 색, 그리고 gridsize를 보조 입력으로 받습니다.</p></li><li><p>제가 만드는 다른 함수들처럼 활용성을 위해 Axes를 입력받을 수 있는, Axes를 출력하는 함수로 만듭니다.</p></li><li><p>이러면 다른 큰 그림의 일부로 활용하기 좋습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_passfail</span>(<span class="params">data, threshold, color_pass=<span class="string">&quot;b&quot;</span>, color_fail=<span class="string">&quot;r&quot;</span>, gridsize=<span class="number">500</span>, ax=<span class="literal">None</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ax:    <span class="comment"># 입력 Axes가 없을 때, 생성</span></span><br><span class="line">        fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. threshold 적용 KDE plot</span></span><br><span class="line">    sns.kdeplot(x=data, color=color_pass, gridsize=gridsize, fill=<span class="literal">True</span>, ax=ax)  <span class="comment"># Pass</span></span><br><span class="line">    sns.kdeplot(x=data, color=color_fail, gridsize=gridsize, fill=<span class="literal">True</span>, ax=ax)  <span class="comment"># Fail</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. pass, fail thrsholding &amp; coloring</span></span><br><span class="line">    labels = []</span><br><span class="line">    <span class="keyword">for</span> i, (part, color_pf, label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(ax.collections, [color_pass, color_fail], [<span class="string">&quot;PASS&quot;</span>, <span class="string">&quot;FAIL&quot;</span>])):</span><br><span class="line">        part.set_lw(<span class="number">0</span>)</span><br><span class="line">        path = part.get_paths()[<span class="number">0</span>]</span><br><span class="line">        vertices = path.vertices</span><br><span class="line">        codes = path.codes</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>: <span class="comment"># pass</span></span><br><span class="line">            idx_th = np.where(vertices[:, <span class="number">0</span>] &gt; threshold)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            idx_th = np.where(vertices[:, <span class="number">0</span>] &lt;= threshold)[<span class="number">0</span>]</span><br><span class="line">            </span><br><span class="line">        vertices_th = vertices[idx_th]</span><br><span class="line">        codes_th = codes_p[idx_th]</span><br><span class="line">        path.vertices = vertices_th</span><br><span class="line">        path.codes = codes_th</span><br><span class="line">        path.codes[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        path.codes[-<span class="number">1</span>] = <span class="number">79</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># calculate area</span></span><br><span class="line">        poly = Polygon(vertices_th)</span><br><span class="line">        labels.append(<span class="string">f&quot;<span class="subst">&#123;label&#125;</span>: <span class="subst">&#123;poly.area*<span class="number">100</span>:<span class="number">.1</span>f&#125;</span> %&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. threshold 미적용 KDE plot</span></span><br><span class="line">    sns.kdeplot(data, fill=<span class="literal">False</span>, color=<span class="string">&quot;k&quot;</span>, ax=ax)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. additional information</span></span><br><span class="line">    ax.axvline(threshold, c=<span class="string">&quot;k&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>) <span class="comment"># threshold line</span></span><br><span class="line">    ax.legend(handles=ax.collections, labels=labels, loc=<span class="string">&quot;upper right&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 5. auxiliaries</span></span><br><span class="line">    ax.spines[[<span class="string">&quot;left&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;right&quot;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.set_yticks([])</span><br><span class="line">    ax.set_ylabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ax</span><br><span class="line"></span><br><span class="line"><span class="comment"># 함수 실행</span></span><br><span class="line">ax = plot_passfail(set0, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><img src="127_kdeth_6.png"><br></p></li><li><p>Pass와 Fail 비율은 범례로 출력하게 만들었습니다.</p></li><li><p>실제 활용시 다른 그래프와 중첩될 수 있고, 그래프 모양이 데이터에 따라 달라지기 때문에</p></li><li><p>아까처럼 그래프 위에 글자를 놓으려면 고칠 일이 더 많아질 수 있기 때문입니다.</p></li><li><p>이제 한 줄로 threshold가 반영된 밀도 함수를 그릴 수 있게 되었습니다.</p></li></ul><h1 id="7-함수-수정"><a href="#7-함수-수정" class="headerlink" title="7. 함수 수정"></a>7. 함수 수정</h1><ul><li>이렇게 만들어진 그래프는 객체 제어를 통해 색을 비롯한 여러 요소를 마음껏 제어할 수 있습니다.</li><li>Pass를 green, Fail을 orange로 바꾸고 legend까지 반영합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">labels = []</span><br><span class="line"><span class="keyword">for</span> part, fc, label <span class="keyword">in</span> <span class="built_in">zip</span>(ax.collections, [<span class="string">&quot;green&quot;</span>, <span class="string">&quot;orange&quot;</span>], [<span class="string">&quot;PASS&quot;</span>, <span class="string">&quot;FAIL&quot;</span>]):</span><br><span class="line">    part.set_fc(fc)</span><br><span class="line">    part.set_alpha(<span class="number">0.5</span>)</span><br><span class="line">    vertices = part.get_paths()[<span class="number">0</span>].vertices</span><br><span class="line">    labels.append(<span class="string">f&quot;<span class="subst">&#123;label&#125;</span>: <span class="subst">&#123;Polygon(vertices).area*<span class="number">100</span>:<span class="number">.1</span>f&#125;</span> %&quot;</span>)</span><br><span class="line">    </span><br><span class="line">ax.legend(ax.collections, labels, loc=<span class="string">&quot;upper right&quot;</span>)</span><br><span class="line">ax.set_xlim(-<span class="number">1</span>, <span class="number">8</span>)</span><br><span class="line">display(ax.figure)</span><br></pre></td></tr></table></figure><img src="127_kdeth_7.png"><br></li></ul><h1 id="8-활용-펭귄-데이터셋"><a href="#8-활용-펭귄-데이터셋" class="headerlink" title="8. 활용 - 펭귄 데이터셋"></a>8. 활용 - 펭귄 데이터셋</h1><ul><li>펭귄 데이터셋의 세 수치형 데이터, bill_length, bill_depth, flipper_length에 이 함수를 적용합니다.</li><li><code>plt.subplots(ncols=3)</code>으로 틀을 잡아 놓고 Axes마다 데이터를 threshold와 함께 넣었습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 데이터셋 읽어오기</span></span><br><span class="line">df_peng = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 전체 Figure 설정</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Axes마다 함수 적용</span></span><br><span class="line">plot_passfail(df_peng[<span class="string">&quot;bill_length_mm&quot;</span>], <span class="number">40</span>, ax=axs[<span class="number">0</span>], color_pass=<span class="string">&quot;b&quot;</span>, color_fail=<span class="string">&quot;r&quot;</span>)</span><br><span class="line">plot_passfail(df_peng[<span class="string">&quot;bill_depth_mm&quot;</span>], <span class="number">15</span>, ax=axs[<span class="number">1</span>], color_pass=<span class="string">&quot;g&quot;</span>, color_fail=<span class="string">&quot;orange&quot;</span>)</span><br><span class="line">plot_passfail(df_peng[<span class="string">&quot;flipper_length_mm&quot;</span>], <span class="number">180</span>, ax=axs[<span class="number">2</span>], color_pass=<span class="string">&quot;c&quot;</span>, color_fail=<span class="string">&quot;m&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Axes마다 y 범위 설정</span></span><br><span class="line">axs[<span class="number">0</span>].set_ylim(<span class="number">0</span>, <span class="number">0.1</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_ylim(<span class="number">0</span>, <span class="number">0.4</span>)</span><br><span class="line">axs[<span class="number">2</span>].set_ylim(<span class="number">0</span>, <span class="number">0.06</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 전체 title 설정</span></span><br><span class="line">fig.suptitle(<span class="string">&quot;penguins dataset feature distribution with threshold\n&quot;</span>, color=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig.savefig(<span class="string">&quot;127_kdeth_8.png&quot;</span>)</span><br></pre></td></tr></table></figure><img src="127_kdeth_8.png"><br></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      
    </item>
    
    <item>
      <title>신천식의 이슈토론 - 과학자 그들은 누구인가? 과학자가 행복한 도시는?</title>
      <link>https://jehyunlee.github.io/2023/02/02/General-15-scs_issue/</link>
      <guid>https://jehyunlee.github.io/2023/02/02/General-15-scs_issue/</guid>
      <pubDate>Wed, 01 Feb 2023 20:11:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;중도TV &lt;b&gt;신천식의 이슈토론&lt;/b&gt;에 패널로 출연했습니다.&lt;ul&gt;
&lt;li&gt;&lt;b&gt;과학자 그들은 누구인가? 과학자가 행복한 도시는?&lt;/b&gt;이라는 주제로 대화를 나눴고,&lt;/li&gt;
&lt;li&gt;채연석 박사님 (前항공우주연구원장, 現국토교통부 항</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>중도TV <b>신천식의 이슈토론</b>에 패널로 출연했습니다.<ul><li><b>과학자 그들은 누구인가? 과학자가 행복한 도시는?</b>이라는 주제로 대화를 나눴고,</li><li>채연석 박사님 (前항공우주연구원장, 現국토교통부 항공,철도사고조사위원회 위원장),<br>유용균 박사 (한국원자력연구원 인공지능응용연구실 실장, AI프렌즈 즈장)<br>두 분과 함께 말씀을 나눴습니다.</li></ul></li></ul><ul><li>영상 : (<a href="https://youtu.be/gDC7agLJFeY">Youtube Link</a>)<br></li><li>기사 : <a href="http://www.joongdo.co.kr/web/view.php?key=20230201010000231">중도일보, “[신천식의 이슈토론]과학자 그들은 누구인가, 과학자들이 행복한 대전”</a></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/gDC7agLJFeY" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><img src="15_scs_issue_01.png" alt="신천식의 이슈토론이 1일 오전 10 중도일보 스튜디오에서 &#39;과학자 그들운 누구인가, 과학자들이 행복한 대전&#39;을 주제로 진행됐다. (왼쪽부터)최연석 전 항공우주연구원장, 신천식 박사, 유용균 원자력 연구원 박사, 이제헌 한국에너지기술 연구원 박사"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/youtube/">youtube</category>
      
      
    </item>
    
    <item>
      <title>연구소의 문헌분석 기술 활용</title>
      <link>https://jehyunlee.github.io/2023/01/09/Python-DS-126-labnlp/</link>
      <guid>https://jehyunlee.github.io/2023/01/09/Python-DS-126-labnlp/</guid>
      <pubDate>Mon, 09 Jan 2023 02:21:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;2022년 12월 13일 &lt;b&gt;모두의 연구소&lt;/b&gt; 초청으로  &lt;b&gt;MODUPOP&lt;/b&gt; 강연을 했습니다.&lt;ul&gt;
&lt;li&gt;몸담고 있는 연구원에서 적용하고 있는 문헌분석 기술을 공유드렸습니다.&lt;/li&gt;
&lt;li&gt;짧은 시간에 압축해서 전달드</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>2022년 12월 13일 <b>모두의 연구소</b> 초청으로  <b>MODUPOP</b> 강연을 했습니다.<ul><li>몸담고 있는 연구원에서 적용하고 있는 문헌분석 기술을 공유드렸습니다.</li><li>짧은 시간에 압축해서 전달드린터라 세부 기술보다는 적용처 중심으로 봐주시면 감사하겠습니다.</li><li>저녁 7시부터 시작된 강의였고, 비와 눈으로 날씨가 많이 나쁜 날이었습니다.</li><li>귀중한 시간을 내서 온라인, 오프라인으로 참석해주신 분들께 다시 한번 감사드립니다.</li><li>초반 2분 가량 소리가 조금 울립니다. 양해 부탁드립니다.</li></ul></li></ul><ul><li>발표 영상 : (<a href="https://youtu.be/fuyOoDBZc1k">Youtube Link</a>)<br></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/fuyOoDBZc1k" frameborder="0" loading="lazy" allowfullscreen></iframe></div> ]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/KIER/">KIER</category>
      
      <category domain="https://jehyunlee.github.io/tags/API/">API</category>
      
      <category domain="https://jehyunlee.github.io/tags/NLP/">NLP</category>
      
      
    </item>
    
    <item>
      <title>Impact of RPA</title>
      <link>https://jehyunlee.github.io/2023/01/01/Python-DS-125-rpa/</link>
      <guid>https://jehyunlee.github.io/2023/01/01/Python-DS-125-rpa/</guid>
      <pubDate>Sun, 01 Jan 2023 07:02:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;RPA(Robotic Process Automation: 업무 자동화) 과제를 하려고 합니다.&lt;/li&gt;
&lt;li&gt;RPA를 적용하면 효용이 얼마나 좋은지를 설득하기 위한 그림을 그립니다.&lt;/li&gt;
&lt;li&gt;RPA 도입 전과 후를 비교하는 그</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>RPA(Robotic Process Automation: 업무 자동화) 과제를 하려고 합니다.</li><li>RPA를 적용하면 효용이 얼마나 좋은지를 설득하기 위한 그림을 그립니다.</li><li>RPA 도입 전과 후를 비교하는 그림을 그려서 보여줍시다.</li></ul><h1 id="1-행정-업무"><a href="#1-행정-업무" class="headerlink" title="1. 행정 업무"></a>1. 행정 업무</h1><p><img src="125_rpa_01.png"></p><ul><li><p>어떤 가상의 데이터 관련 행정 업무가 있다고 합시다.</p></li><li><p>현재는 <b>총 2천만원의 용역비</b>를 포함해 <b>12주</b>가 걸립니다. <b>수작업</b>이기 때문입니다.</p></li><li><p>여기에 RPA를 적용하면, <b>용역비가 없어지고</b> 이어지는 작업도 훨씬 짧게 걸립니다.</p></li><li><p>서류 작업과 취합 작업도 단순 반복 작업에서 <b>검증으로 업무 성격이 바뀝니다.</b><br></p></li><li><p><b>보고서</b>나 <b>기획서</b>등에서 이 훌륭한 업무를 어필하고 싶습니다.</p></li><li><p>일단 <a href="RPA_comparison.xlsx">엑셀로 정리</a>해보니 이렇습니다. 전달은 되는데 아쉽습니다.<br><br><img src="125_rpa_02.png"><br></p></li></ul><h1 id="2-시각화"><a href="#2-시각화" class="headerlink" title="2. 시각화"></a>2. 시각화</h1><h2 id="2-1-용역-비용-amp-인력"><a href="#2-1-용역-비용-amp-인력" class="headerlink" title="2.1. 용역 비용 &amp; 인력"></a>2.1. 용역 비용 &amp; 인력</h2><ul><li>RPA 효과는 크게 두 가지입니다. 하나는 <b>용역 비용</b>, 하나는 <b>인력</b></li><li>인력도 man-week (MW)으로 정리했기 때문에 담당자의 연봉을 적용하면 비용 산정이 됩니다.</li><li>하지만 여기선 용역은 용역, 인력은 인력으로 나누어 그리기로 합니다.</li><li>항목 수에 따라 용역 비용과 인력이 그려질 공간을 1:3의 비율로 분할합니다.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), gridspec_kw=&#123;<span class="string">&quot;width_ratios&quot;</span>:[<span class="number">1</span>, <span class="number">3</span>]&#125;)</span><br></pre></td></tr></table></figure><img src="125_rpa_03.png"><br></li></ul><h2 id="2-2-용역-비용"><a href="#2-2-용역-비용" class="headerlink" title="2.2. 용역 비용"></a>2.2. 용역 비용</h2><ul><li>왼쪽 공간에 RPA 적용 전 2천만원이 들어간 용역 비용과 적용 후 0원이 된 것을 비교하여 그립니다.</li><li>이럴 때는 grouped bar plot이 제격입니다.</li><li>용역 비용 뿐 아니라 다른 모든 항목을 비교할 것이기 때문에 <b>RPA 전</b>과 <b>RPA 후</b> 비교에 일관성이 필요합니다.</li><li>적용 전과 후를 <b>“brown”</b>과 <b>“royalblue”</b>로 표기합니다.</li></ul><ul><li>또한, <b>grouped bar plot</b>은 <b>pandas가 더 편합니다.</b></li><li>pandas DataFrame에서 그림을 그릴 부분만 <code>.loc[]</code>를 사용해 데이터를 한정하고,</li><li><code>.plot.bar()</code>를 사용해 groupled bar plot을 그립니다.</li><li><code>cs = [&quot;brown&quot;, &quot;royalblue&quot;]</code>과 <code>color=cs</code>를 입력하면 적용 전과 후 색이 차례로 입혀집니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data 읽기</span></span><br><span class="line">rpa = pd.read_excel(<span class="string">&quot;RPA_comparison.xlsx&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), gridspec_kw=&#123;<span class="string">&quot;width_ratios&quot;</span>:[<span class="number">1</span>, <span class="number">3</span>]&#125;, constrained_layout=<span class="literal">True</span>)</span><br><span class="line">cs = [<span class="string">&quot;brown&quot;</span>, <span class="string">&quot;royalblue&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 용역 비용</span></span><br><span class="line">rpa.loc[[<span class="number">0</span>]].plot.bar(ax=axs[<span class="number">0</span>], lw=<span class="number">1</span>, ec=<span class="string">&quot;w&quot;</span>, legend=<span class="literal">False</span>, color=cs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 인력</span></span><br><span class="line">rpa.loc[<span class="number">1</span>:].plot.bar(ax=axs[<span class="number">1</span>], lw=<span class="number">1</span>, ec=<span class="string">&quot;w&quot;</span>, legend=<span class="literal">False</span>, color=cs)</span><br></pre></td></tr></table></figure><img src="125_rpa_04.png"><br></li></ul><h2 id="2-3-Annotation"><a href="#2-3-Annotation" class="headerlink" title="2.3. Annotation"></a>2.3. Annotation</h2><ul><li><p>가장 중요한 틀이 갖춰졌습니다.</p></li><li><p>이제 ticks, ticklabels 등을 다듬으면 쓸만한 그래프가 될겁니다.</p></li><li><p>하지만 그 전에, <b>데이터를 직설적으로 알려주는 장치를 하려고 합니다.</b></p></li><li><p>위 코드 아래에 코드를 덧붙여 bar 위에 데이터를 출력합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 용역 비용</span></span><br><span class="line">xs, ws, hs = [], [], []</span><br><span class="line"><span class="keyword">for</span> p, c <span class="keyword">in</span> <span class="built_in">zip</span>(axs[<span class="number">0</span>].patches, cs):</span><br><span class="line">    x, w, h = p.get_x(), p.get_width(), p.get_height()</span><br><span class="line">    xs.append(x)</span><br><span class="line">    ws.append(w)</span><br><span class="line">    hs.append(h)</span><br><span class="line">    cost = <span class="built_in">format</span>(<span class="built_in">int</span>(h), <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> h &gt; <span class="number">0</span>:</span><br><span class="line">        cost = <span class="string">f&quot;<span class="subst">&#123;cost&#125;</span> 천원&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cost = <span class="string">f&quot;<span class="subst">&#123;cost&#125;</span> 원&quot;</span></span><br><span class="line">    axs[<span class="number">0</span>].text(x+w/<span class="number">2</span>, h+<span class="number">1000</span>, cost, ha=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;small&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>, color=c, zorder=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><img src="125_rpa_05.png"><br></p></li><li><p>왼쪽 Axes를 구성하는 두 막대의 위치, 너비, 높이를 뽑아내 글자를 입혔습니다.</p></li><li><p>일반적으로 금액을 <b>천원</b>단위로 표현하기 때문에 일부러 엑셀 파일부터 천원으로 끊었습니다.</p></li></ul><h2 id="2-4-Spines-and-Ticks"><a href="#2-4-Spines-and-Ticks" class="headerlink" title="2.4. Spines and Ticks"></a>2.4. Spines and Ticks</h2><ul><li>이제 y축이 없어도 데이터가 잘 전달됩니다.</li><li>y축과 함께 네모난 테두리(spines)를 없애버립시다.</li><li>x축 눈금은 <code>tick_params()</code>를 사용해 폭을 0으로(<code>width=0</code>) 만듭니다.</li><li>그런데 xticklabel은 여기 말고도 오른쪽 Axes에도 세 개나 더 적용해야 됩니다.</li><li><code>font_label</code>이라는 이름의 dictionary type 매개변수를 만들어 적용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Spines and Ticks</span></span><br><span class="line">axs[<span class="number">0</span>].spines[[<span class="string">&quot;left&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;right&quot;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_yticks([])</span><br><span class="line">font_label = &#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;</span><br><span class="line">axs[<span class="number">0</span>].tick_params(axis=<span class="string">&quot;x&quot;</span>, width=<span class="number">0</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_xticklabels([<span class="string">&quot;용역 비용&quot;</span>], **font_label, rotation=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><img src="125_rpa_06.png"><br></li></ul><h2 id="2-5-Arrow"><a href="#2-5-Arrow" class="headerlink" title="2.5. Arrow"></a>2.5. Arrow</h2><blockquote><p><a href="https://matplotlib.org/stable/gallery/userdemo/connectionstyle_demo.html">matplotlib: Connection styles for annotations</a><br><a href="https://matplotlib.org/stable/gallery/text_labels_and_annotations/fancyarrow_demo.html">matplotlib: Annotation arrow style reference</a></p></blockquote><ul><li>RPA 적용 전후는 나왔는데 그림에서 알아보기 어렵습니다.</li><li><b>RPA를 적용했더니 확 비용이 확 떨어진다</b>는 느낌의 화살표가 있으면 좋을 것 같습니다.</li><li>Matplotlib에서 멋진 화살표를 만들기에는 <code>Axes.annotate()</code>가 가장 좋습니다.</li><li><b>“arrowstyle”:”fancy”</b>와 <b>“connectionstyle”</b>을 이용해 다이나믹한 화살표를 그립니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Arrow</span></span><br><span class="line">axs[<span class="number">0</span>].annotate(<span class="string">&quot;&quot;</span>, xy=(xs[<span class="number">1</span>]+w/<span class="number">2</span>, hs[<span class="number">1</span>]+w/<span class="number">2</span>), xytext=(xs[<span class="number">0</span>]+w/<span class="number">2</span>, hs[<span class="number">0</span>]+w/<span class="number">2</span>),</span><br><span class="line">            arrowprops=&#123;<span class="string">&quot;arrowstyle&quot;</span>:<span class="string">&quot;fancy&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;fc&quot;</span>:<span class="string">&quot;cornflowerblue&quot;</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>,</span><br><span class="line">                        <span class="string">&quot;connectionstyle&quot;</span>:<span class="string">&quot;arc3,rad=-0.3&quot;</span>, <span class="string">&quot;mutation_scale&quot;</span>:<span class="number">100</span>&#125;)</span><br></pre></td></tr></table></figure><img src="125_rpa_07.png"><br></li></ul><h2 id="2-6-인력에도-동일하게"><a href="#2-6-인력에도-동일하게" class="headerlink" title="2.6. 인력에도 동일하게"></a>2.6. 인력에도 동일하게</h2><ul><li>용역 비용에 적용한 사항들을 인력에도 동일하게 적용합니다.</li><li>아까 왼쪽 Axes의 xticklabel에 넣었던 <b>용역 비용</b>은 title이 더 잘 어울리는 것 같습니다.</li><li>내용을 올리고, xticklabel은 새롭게 <b>분석 용역</b>이라고 넣습니다.</li><li>오른쪽에도 여기에 대응되도록 <b>용역 검증</b>, <b>서류 작업</b>, <b>취합 작업</b>을 넣습니다.<br><br><img src="125_rpa_08.png"><br></li></ul><h2 id="2-7-비용과-기간-사이-칸막이"><a href="#2-7-비용과-기간-사이-칸막이" class="headerlink" title="2.7. 비용과 기간 사이 칸막이"></a>2.7. 비용과 기간 사이 칸막이</h2><ul><li>마지막 작업입니다.</li><li>왼쪽과 오른쪽 구간을 나누는 막대를 하나 넣습니다.</li><li><code>matplotlib.lines.Line2D</code>객체를 사용해 선을 그립니다. </li><li>양 끝점의 좌표를 입력해야 하는데 Figure 전체의 상대 좌표를 사용해 <code>[0.255, 0.255], [0.15, 0.85]</code>를 입력합니다.</li><li>양 끝을 둥글게 만들고자 <code>solid_capstyle = &quot;round&quot;</code>를 입력했습니다.</li><li>두 Axes 사이 공간에 그려야 하는 그림이기 때문에 <code>fig.add_artist()</code>로 추가합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.lines <span class="keyword">import</span> Line2D</span><br><span class="line"></span><br><span class="line">line = Line2D([<span class="number">0.255</span>, <span class="number">0.255</span>], [<span class="number">0.15</span>, <span class="number">0.85</span>], linewidth=<span class="number">5</span>, solid_capstyle=<span class="string">&quot;round&quot;</span>, color=<span class="string">&quot;0.6&quot;</span>)</span><br><span class="line">fig.add_artist(line)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">1</span>].legend()</span><br></pre></td></tr></table></figure><img src="125_rpa_09.png"><br></li></ul><h1 id="3-활용"><a href="#3-활용" class="headerlink" title="3. 활용"></a>3. 활용</h1><blockquote><p><a href="https://m.etnews.com/20221228000275">관련기사: 전자신문- NST, 출연연 연구행정혁신 성과확산 공모전 시상식 개최</a></p></blockquote><ul><li>이렇게 정리된 그림은 <b>적절한 표</b>, <b>근거 자료</b>와 함께 <b>보고서</b>와 <b>ppt</b>에 삽입하면 좋습니다.</li><li><b>그냥 파워포인트에서 그리면 더 쉽지 않냐</b>고 하실 수 있습니다.</li><li>경험상 이런 일은 현업 부서에서 수치가 수차례 변경되는 것이 일반적이고, 실제로 열번쯤 바뀐 것 같습니다.</li><li>일일이 새로 그렸다면 너무 힘들었을테지만 코드로 그린 덕택에 그때마다 데이터만 바꿔 끼웠습니다.</li></ul><ul><li><p>위 그림은 실제로 최근 있었던 한 공모전에서 서류 작성과 발표 자료에 사용했습니다.</p></li><li><p>데이터는 제가 접한 실제 사례와 다르게 바꾸었습니다만, 전반적인 틀은 살렸습니다.<br><br><img src="125_rpa_10.png" alt="혹시나 싶은 마음에 내용은 흐리게 가렸습니다."><br></p></li><li><p>전체 코드는 아래와 여기에서 확인할 수 있습니다: <a href="https://colab.research.google.com/drive/1RLo4aTtP_sM9EoxWyfkvR5hetGNmvVZH?usp=share_link">Colab 링크</a></p></li><li><p>여러분께도 좋은 결과가 있기를 바랍니다.</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> matplotlib.lines <span class="keyword">import</span> Line2D</span><br><span class="line"></span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line">plt.rcParams[<span class="string">&quot;font.family&quot;</span>] = <span class="string">&quot;NanumGothic&quot;</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># data 읽기</span></span><br><span class="line">rpa = pd.read_excel(<span class="string">&quot;RPA_comparison.xlsx&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), gridspec_kw=&#123;<span class="string">&quot;width_ratios&quot;</span>:[<span class="number">1</span>, <span class="number">3</span>]&#125;, constrained_layout=<span class="literal">True</span>)</span><br><span class="line">cs = [<span class="string">&quot;brown&quot;</span>, <span class="string">&quot;royalblue&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 용역 비용</span></span><br><span class="line">rpa.loc[[<span class="number">0</span>]].plot.bar(ax=axs[<span class="number">0</span>], lw=<span class="number">1</span>, ec=<span class="string">&quot;w&quot;</span>, legend=<span class="literal">False</span>, color=cs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 인력</span></span><br><span class="line">rpa.loc[<span class="number">1</span>:].plot.bar(ax=axs[<span class="number">1</span>], lw=<span class="number">1</span>, ec=<span class="string">&quot;w&quot;</span>, legend=<span class="literal">False</span>, color=cs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 용역 비용</span></span><br><span class="line">xs, ws, hs = [], [], []</span><br><span class="line"><span class="keyword">for</span> p, c <span class="keyword">in</span> <span class="built_in">zip</span>(axs[<span class="number">0</span>].patches, cs):</span><br><span class="line">    x, w, h = p.get_x(), p.get_width(), p.get_height()</span><br><span class="line">    xs.append(x)</span><br><span class="line">    ws.append(w)</span><br><span class="line">    hs.append(h)</span><br><span class="line">    cost = <span class="built_in">format</span>(<span class="built_in">int</span>(h), <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> h &gt; <span class="number">0</span>:</span><br><span class="line">        cost = <span class="string">f&quot;<span class="subst">&#123;cost&#125;</span> 천원&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cost = <span class="string">f&quot;<span class="subst">&#123;cost&#125;</span> 원&quot;</span></span><br><span class="line">    axs[<span class="number">0</span>].text(x+w/<span class="number">2</span>, h+<span class="number">1000</span>, cost, ha=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;small&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>, color=c, zorder=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Spines and Ticks</span></span><br><span class="line">font_label = &#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [<span class="string">&quot;용역 비용\n&quot;</span>, <span class="string">&quot;업무 기간\n&quot;</span>]):</span><br><span class="line">    ax.spines[[<span class="string">&quot;left&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;right&quot;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.set_yticks([])</span><br><span class="line">    ax.tick_params(axis=<span class="string">&quot;x&quot;</span>, width=<span class="number">0</span>)</span><br><span class="line">    ax.set_title(title, **font_label)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">0</span>].set_xticklabels([<span class="string">&quot;분석 용역&quot;</span>], rotation=<span class="number">0</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_xticklabels([<span class="string">&quot;용역 검증&quot;</span>, <span class="string">&quot;서류 작업&quot;</span>, <span class="string">&quot;취합 작업&quot;</span>], </span><br><span class="line">                       rotation=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Arrow</span></span><br><span class="line">axs[<span class="number">0</span>].annotate(<span class="string">&quot;&quot;</span>, xy=(xs[<span class="number">1</span>]+w/<span class="number">2</span>, hs[<span class="number">1</span>]+w/<span class="number">2</span>), xytext=(xs[<span class="number">0</span>]+w/<span class="number">2</span>, hs[<span class="number">0</span>]+w/<span class="number">2</span>),</span><br><span class="line">            arrowprops=&#123;<span class="string">&quot;arrowstyle&quot;</span>:<span class="string">&quot;fancy&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;fc&quot;</span>:<span class="string">&quot;cornflowerblue&quot;</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>,</span><br><span class="line">                        <span class="string">&quot;connectionstyle&quot;</span>:<span class="string">&quot;arc3,rad=-0.3&quot;</span>, <span class="string">&quot;mutation_scale&quot;</span>:<span class="number">100</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 인력 감축</span></span><br><span class="line">xs, ws, hs = [], [], []</span><br><span class="line"><span class="keyword">for</span> i, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(axs[<span class="number">1</span>].patches):</span><br><span class="line">    x, w, h = p.get_x(), p.get_width(), p.get_height()</span><br><span class="line">    xs.append(x)</span><br><span class="line">    ws.append(w)</span><br><span class="line">    hs.append(h)</span><br><span class="line">    person = <span class="built_in">format</span>(<span class="built_in">int</span>(h), <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> h &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> h%<span class="number">1</span>:</span><br><span class="line">            h = <span class="built_in">int</span>(h)</span><br><span class="line">        day = <span class="string">f&quot;<span class="subst">&#123;h&#125;</span> 주&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">3</span>:</span><br><span class="line">        c = cs[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        c = cs[<span class="number">1</span>]</span><br><span class="line">    p.set_fc(c)</span><br><span class="line">    axs[<span class="number">1</span>].text(x+w/<span class="number">2</span>, h+<span class="number">0.3</span>, day, ha=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;small&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>, color=c, zorder=<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    axs[<span class="number">1</span>].annotate(<span class="string">&quot;&quot;</span>, xy=(xs[i+<span class="number">3</span>]+w/<span class="number">2</span>, hs[i+<span class="number">3</span>]+w/<span class="number">2</span>), xytext=(xs[i]+w/<span class="number">2</span>, hs[i]+w/<span class="number">2</span>),</span><br><span class="line">            arrowprops=&#123;<span class="string">&quot;arrowstyle&quot;</span>:<span class="string">&quot;fancy&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;skyblue&quot;</span>, <span class="string">&quot;fc&quot;</span>:<span class="string">&quot;skyblue&quot;</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.8</span>,</span><br><span class="line">                        <span class="string">&quot;connectionstyle&quot;</span>:<span class="string">&quot;arc3,rad=-0.3&quot;</span>, <span class="string">&quot;mutation_scale&quot;</span>:<span class="number">40</span>&#125;)</span><br><span class="line"></span><br><span class="line">line = Line2D([<span class="number">0.255</span>, <span class="number">0.255</span>], [<span class="number">0.15</span>, <span class="number">0.85</span>], linewidth=<span class="number">5</span>, solid_capstyle=<span class="string">&quot;round&quot;</span>, color=<span class="string">&quot;0.6&quot;</span>)</span><br><span class="line">fig.add_artist(line)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">1</span>].legend()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      
    </item>
    
    <item>
      <title>산타 방문 증빙 feat. DALL.E</title>
      <link>https://jehyunlee.github.io/2022/12/26/General-14_santa/</link>
      <guid>https://jehyunlee.github.io/2022/12/26/General-14_santa/</guid>
      <pubDate>Mon, 26 Dec 2022 07:30:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;2022년 한 해는 그림 생성 모델로 뜨거웠습니다.&lt;/li&gt;
&lt;li&gt;DALL.E를 사용해서 산타가 다녀갔다는 증빙을 만듭니다.&lt;/li&gt;
&lt;li&gt;사진 한 장이 필요합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-산타가-다녀가셨다&quot;&gt;&lt;a h</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>2022년 한 해는 그림 생성 모델로 뜨거웠습니다.</li><li>DALL.E를 사용해서 산타가 다녀갔다는 증빙을 만듭니다.</li><li>사진 한 장이 필요합니다.</li></ul><h1 id="1-산타가-다녀가셨다"><a href="#1-산타가-다녀가셨다" class="headerlink" title="1. 산타가 다녀가셨다!"></a>1. 산타가 다녀가셨다!</h1><ul><li>크리스마스에 다녀가시는 산타는 아이들에게 큰 기쁨입니다.</li><li>선물 자체도 기쁘고, 한 해 잘 살았다는 칭찬을 받는 듯한 느낌도 나지요.</li><li>반면 부모에게는 어떻게 올해를 넘길지가 고민입니다.</li></ul><blockquote><p><b>산타가 다녀가셨나봐! 선물도 있고 아빠 핸드폰에 사진도 찍혔어!</b></p></blockquote><p><img src="14_santa_02.png"></p><ul><li>다행히 아이들은 눈을 동그랗게 뜨고 믿어주었습니다.</li><li><b>산타를 제외한 배경이 우리 집이었기 때문에 의심도 안 했을 것입니다.</b></li></ul><h1 id="2-준비"><a href="#2-준비" class="headerlink" title="2. 준비"></a>2. 준비</h1><blockquote><p><a href="https://labs.openai.com/">DALL.E</a></p></blockquote><ul><li><p>먼저, 그림을 그려주는 AI, <b><a href="https://labs.openai.com/">DALL.E</a> 계정</b>이 필요합니다.</p></li><li><p>아직 계정이 없으시다면 위 링크로 들어가 회원 가입을 합니다.</p></li><li><p>로그인을 마치면 아래와 같은 화면이 나타납니다.<br><br><img src="14_santa_04.png"><br></p></li><li><p>그리고 <b>집 사진 한 장</b>이 필요합니다.</p></li><li><p>크리스마스를 맞아 꾸민 트리 밑에 아이들에게 줄 선물을 놓고 사진을 찍습니다.</p></li><li><p>산타가 등장할 곳은 다소 어두워야 부모에게 유리합니다.<br><br><img src="14_santa_01.jpg"><br></p></li></ul><h1 id="3-DALL-E-활약"><a href="#3-DALL-E-활약" class="headerlink" title="3. DALL.E 활약"></a>3. DALL.E 활약</h1><ul><li><b>Upload an image</b>를 클릭해서 집 사진을 올립니다.</li><li>그러면 정사각형으로 자르라고 하는데, 적절히 위치를 지정하고 <b>Crop</b>을 누릅니다.<br><br><img src="14_santa_05.png"><br></li></ul><ul><li><p>확인이 되었으면 <b>Edit image</b>를 눌러 수정을 들어갑니다.</p></li><li><p>기본으로 설정된 <b>지우개</b> 아이콘으로 산타가 놓일 자리를 지웁니다.<br><br><img src="14_santa_06.png"><br></p></li><li><p>이제 산타를 그릴 차례입니다.</p></li><li><p>구글 검색창을 닮은 하얀 막대 안에 산타가 어떤 모습으로 들어올지를 씁니다.</p></li><li><p>저는 이렇게 적었습니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Realistic photography of Santa Clause from backside, bending his knee towards the tree, standing to distribute Christmas presents.</span><br></pre></td></tr></table></figure></li><li><p>마지막으로 <b>Generate</b> 버튼을 누르면 4장의 이미지가 한번에 생성됩니다.<br><br><img src="14_santa_03.png"><br></p></li><li><p>마음에 드는 이미지가 없다면 <b>Generate</b>를 다시 눌러 다른 그림을 만들어봅니다.</p></li><li><p>마음에 드는 이미지가 나오면 그림을 다운받아 휴대폰에 저장합니다.<br><br><img src="14_santa_02.png"><br></p></li><li><p>언젠가 산타의 정체가 부모라는 것을 알게 되겠지만, 그 날이 오기 전까지는 동심을 간직하기를 바랍니다.</p></li><li><p>훗날 아이들이 이 포스팅을 읽게 된다면, 2022년의 산타와 선물을 떠올려주면 좋겠습니다. :)</p></li></ul><blockquote><p><b>아빠, 산타가 우리가 키우는 나무 만져줬나봐! 하루 사이에 더 자랐어!</b></p></blockquote>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/dall-e/">dall.e</category>
      
      <category domain="https://jehyunlee.github.io/tags/inpaining/">inpaining</category>
      
      
    </item>
    
    <item>
      <title>Deep Learning by Open API</title>
      <link>https://jehyunlee.github.io/2022/11/29/Python-DS-124-kierlecture8/</link>
      <guid>https://jehyunlee.github.io/2022/11/29/Python-DS-124-kierlecture8/</guid>
      <pubDate>Mon, 28 Nov 2022 17:02:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;한국에너지기술연구원 AI 학습조직&lt;/b&gt;에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.&lt;ul&gt;
&lt;li&gt;이번에는 직접 하는 코딩을 벗어나 공개된 딥러닝 모델을 사용하는 방법을 알아봅니다.&lt;/li&gt;
&lt;li&gt;영상과 자연어 처</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b>한국에너지기술연구원 AI 학습조직</b>에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.<ul><li>이번에는 직접 하는 코딩을 벗어나 공개된 딥러닝 모델을 사용하는 방법을 알아봅니다.</li><li>영상과 자연어 처리를 중심으로 OpenAI에서 제공하는 여러 모델이 있습니다.</li><li>강의실 예약 시간 문제로 마무리가 매끄럽지 못했습니다.</li><li>요약본이 번역되다 만 문제는 <code>max_tokens=300</code>을 추가하면 해결됩니다.</li><li><a href="221128_9%EC%B0%A8%EB%AA%A8%EC%9E%84.pdf">강의 자료는 여기에서 다운받으실 수 있습니다</a></li></ul></li></ul><ul><li><p>발표 영상 : (<a href="https://youtu.be/dsnrl0tLkdU">Youtube Link</a>)<br></p></li><li><p>실습 코드 : (<a href="https://bit.ly/3gEMeUS">https://bit.ly/3gEMeUS</a>)<br></p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/dsnrl0tLkdU" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><img src="cats.png" alt="DALL.E Open API로 그린 그림"><br></p><p><ul><li>1년간 총 8개의 강좌로 정리되었습니다.</li></ul><p><img src="schedule.png" alt="학습조직 일정"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/machine-learning/">machine learning</category>
      
      <category domain="https://jehyunlee.github.io/tags/KIER/">KIER</category>
      
      <category domain="https://jehyunlee.github.io/tags/API/">API</category>
      
      <category domain="https://jehyunlee.github.io/tags/Open-AI/">Open AI</category>
      
      <category domain="https://jehyunlee.github.io/tags/DALL-E/">DALL.E</category>
      
      <category domain="https://jehyunlee.github.io/tags/summary/">summary</category>
      
      
    </item>
    
    <item>
      <title>Gaussian Process Practice (3) Beware Boundaries</title>
      <link>https://jehyunlee.github.io/2022/11/19/Python-DS-123-gpr3/</link>
      <guid>https://jehyunlee.github.io/2022/11/19/Python-DS-123-gpr3/</guid>
      <pubDate>Sat, 19 Nov 2022 08:35:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;Gaussian Process 연습입니다.&lt;/li&gt;
&lt;li&gt;scikit-learn을 비롯한 예제를 재구성하여 연습합니다.&lt;/li&gt;
&lt;li&gt;주의사항을 알려드립니다. Gaussian Process는 경계조건에 매우 취약합니다.&lt;/li&gt;
&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>Gaussian Process 연습입니다.</li><li>scikit-learn을 비롯한 예제를 재구성하여 연습합니다.</li><li>주의사항을 알려드립니다. Gaussian Process는 경계조건에 매우 취약합니다.</li></ul><h1 id="1-Gaussian-Process의-한계"><a href="#1-Gaussian-Process의-한계" class="headerlink" title="1. Gaussian Process의 한계"></a>1. Gaussian Process의 한계</h1><blockquote><p><a href="https://scikit-learn.org/stable/auto_examples/gaussian_process/plot_gpr_noisy_targets.html#sphx-glr-auto-examples-gaussian-process-plot-gpr-noisy-targets-py">scikit-learn: Gaussian Process Regression: basic introductory example</a></p></blockquote><ul><li><p>Gaussian Process는 적은 데이터로도 꽤 믿을만한 결과를 출력합니다.</p></li><li><p>심지어 신뢰 구간까지 알 수 있어서 매우 정직해 보입니다.</p></li><li><p>하지만 치명적인 단점이 있습니다.</p></li><li><p><a href="https://jehyunlee.github.io/2022/11/16/Python-DS-121-gpr1/">지난 글</a>과 같은 예제를 사용합니다.<br><img src="123_gpr3_3.png"><br></p></li><li><p>모든 것이 정상으로 보입니다.</p></li><li><p>합리적인 범위의 평균값(<code>GP prediction (mean)</code>)과 신뢰 구간(<code>95% CI</code>)을 보이고 있습니다.</p></li><li><p>하지만 오른쪽 끄트머리를 보면, 조금 미심쩍습니다.</p></li><li><p><b>참값이 신뢰 구간의 바닥에 겨우 걸려있습니다.</b><br><br><img src="123_gpr3_8.png" alt="개그콘서트, &quot;불편한 진실&quot; "><br></p></li><li><p>극단적인 경우를 살펴봅니다.</p></li><li><p><b>X 값의 범위</b>로 참값의 좌우에 50씩을 보태 <b>-50 ~ 60을 입력</b>합니다.</p></li><li><p>평균이 0, 95% 신뢰구간이 무려 10에 가까운 커다란 밴드가 생겼습니다.</p></li><li><p>다항회귀를 해도 이렇지는 않을 것 같습니다.<br><br><img src="123_gpr3_7.png"><br></p></li><li><p><b>Gaussian Process의 원리</b>에 답이 있습니다.</p></li><li><p>Gaussian 분포를 prior로 놓기 때문에 평균이 0입니다.</p></li><li><p>학습 데이터(evidence)가 반영된 구간 안쪽은 그나마 괜찮지만 바깥쪽이 문제입니다.</p></li><li><p><b>안쪽에서 학습을 시켜봐야 바깥쪽의 중심값이 0이라고 가정되어 있기 때문에 저런 일이 벌어집니다.</b></p></li></ul><h1 id="2-비교"><a href="#2-비교" class="headerlink" title="2. 비교"></a>2. 비교</h1><ul><li><p>조금 더 확실하게 확인합니다.</p></li><li><p>위의 예제에 <b>offset = $\pm 5$</b>를 해서 <b>새로운 참값</b>을 만듭니다.</p></li><li><p>그리고, 여기서 같은 X 좌표의 데이터들을 학습용으로 추출합니다.<br><br><img src="123_gpr3_4.png"><br></p></li><li><p>여기에 똑같은 RBF 커널을 적용한 Gaussian Process를 적용하면 아래와 같은 결과가 나옵니다.</p></li><li><p>좌우 그림에서 <b>파란 선</b>으로 표시한 평균값의 양 끝이 향하는 방향이 반대입니다.<br></p></li><li><p><b>offset=+5</b>인 왼쪽 그림은 양 끝이 아래를 향하고 있고,</p></li><li><p><b>offset=-5</b>인 오른쪽 그림은 양 끝이 기를 쓰고 고개를 들려고 하고 있습니다.</p></li><li><p>모두 <b>0을 향하고 있습니다.</b><br><br><img src="123_gpr3_5.png"><br></p></li><li><p>양 끝만 영향을 받는 것이 아닙니다.</p></li><li><p>X = 6~8 사이 구간도 offset에 따라 달라집니다.</p></li><li><p>0에서 먼 왼쪽 그림은 신뢰 구간이 비교적 얇은 반면 오른쪽은 두텁고 mean 값도 참값과 더 벌어져 있습니다.</p></li></ul><h1 id="3-Solution"><a href="#3-Solution" class="headerlink" title="3. Solution"></a>3. Solution</h1><ul><li><p>해결 방법은 생각보다 간단합니다.</p></li><li><p>외삽(extrapolation)이 문제라면 외삽을 하지 않으면 됩니다.</p></li><li><p>학습 데이터에 데이터 범위의 양 끝을 추가하면 모든 범위가 내삽이 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sample including ends</span></span><br><span class="line">training_indices += [<span class="number">0</span>, <span class="number">999</span>]</span><br><span class="line">Xp_train1, Xm_train1 = Xp[training_indices], Xm[training_indices]</span><br><span class="line">yp_train1, ym_train1 = yp[training_indices], ym[training_indices]</span><br></pre></td></tr></table></figure></li><li><p>그리고 같은 학습을 시키면 offset에 관계 없이 동일한 결과를 얻을 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">6</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>, sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, X, y, X_train, y_train, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [Xp, Xm], [yp, ym], </span><br><span class="line">                                             [Xp_train1, Xm_train1], [yp_train1, ym_train1], </span><br><span class="line">                                             [<span class="string">&quot;offset = +5&quot;</span>, <span class="string">&quot;offset = -5&quot;</span>]):</span><br><span class="line">    <span class="comment"># Gaussian Process</span></span><br><span class="line">    gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, random_state=<span class="number">0</span>)</span><br><span class="line">    gpr.fit(X_train, y_train)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># prediction</span></span><br><span class="line">    y_pred_mean, y_pred_std = gpr.predict(X, return_std=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    ax.plot(X, y, c=<span class="string">&quot;0.5&quot;</span>, label=<span class="string">&quot;true&quot;</span>)</span><br><span class="line">    ax.scatter(X_train, y_train, label=<span class="string">&quot;sample&quot;</span>)</span><br><span class="line">    ax.plot(X.ravel(), y_pred_mean, c=<span class="string">&quot;b&quot;</span>, label=<span class="string">&quot;GP prediction (mean)&quot;</span>)</span><br><span class="line">    ax.fill_between(X.ravel(), y_pred_mean-<span class="number">1.96</span>*y_pred_std, y_pred_mean+<span class="number">1.96</span>*y_pred_std, alpha=<span class="number">0.5</span>, fc=<span class="string">&quot;cornflowerblue&quot;</span>, label=<span class="string">&quot;95% CI&quot;</span>)</span><br><span class="line">    ax.axhline(<span class="number">0</span>, c=<span class="string">&quot;g&quot;</span>, lw=<span class="number">1</span>)</span><br><span class="line">    ax.set_title(title, pad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">axs[<span class="number">0</span>].legend(loc=<span class="string">&quot;lower right&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="123_gpr3_6.png"><br></p></li></ul><h1 id="4-결론"><a href="#4-결론" class="headerlink" title="4. 결론"></a>4. 결론</h1><ul><li>머신 러닝 기법들이 모두 그렇지만 외삽은 주의해야 합니다.</li><li>Gaussian Process는 prior의 존재로 인해 외삽에 더 취약할 수 있으니 각별히 주의해야 합니다.</li><li>본 글에 사용된 코드는 <b><a href="gpr3.ipynb">여기에서 다운받으실 수 있습니다.</a></b></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/gaussian-process/">gaussian process</category>
      
      <category domain="https://jehyunlee.github.io/tags/bayesian/">bayesian</category>
      
      <category domain="https://jehyunlee.github.io/tags/scikit-learn/">scikit-learn</category>
      
      
    </item>
    
    <item>
      <title>Gaussian Process Practice (2) Kernels</title>
      <link>https://jehyunlee.github.io/2022/11/17/Python-DS-122-gpr2/</link>
      <guid>https://jehyunlee.github.io/2022/11/17/Python-DS-122-gpr2/</guid>
      <pubDate>Thu, 17 Nov 2022 10:22:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;Gaussian Process 연습입니다.&lt;/li&gt;
&lt;li&gt;scikit-learn을 비롯한 예제를 재구성하여 연습합니다.&lt;/li&gt;
&lt;li&gt;여러 커널의 특징을 알아보고 사용처를 알아봅니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-Data-</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>Gaussian Process 연습입니다.</li><li>scikit-learn을 비롯한 예제를 재구성하여 연습합니다.</li><li>여러 커널의 특징을 알아보고 사용처를 알아봅니다.</li></ul><h1 id="1-Data-Preparation"><a href="#1-Data-Preparation" class="headerlink" title="1. Data Preparation"></a>1. Data Preparation</h1><blockquote><p><a href="https://scikit-learn.org/stable/auto_examples/gaussian_process/plot_gpr_noisy_targets.html#sphx-glr-auto-examples-gaussian-process-plot-gpr-noisy-targets-py">scikit-learn: Gaussian Process Regression: basic introductory example</a></p></blockquote><h2 id="1-1-example-data"><a href="#1-1-example-data" class="headerlink" title="1.1. example data"></a>1.1. example data</h2><ul><li><a href="https://jehyunlee.github.io/2022/11/16/Python-DS-121-gpr1/">지난 글</a>과 같은 예제를 사용합니다.</li><li>오늘은 어제보다는 색을 많이 사용할 겁니다. 참값과 Gaussian Process 결과를 무채색으로 표현합니다.</li><li>관측값은 참값이라고 합시다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.gaussian_process <span class="keyword">import</span> GaussianProcessRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> RBF</span><br><span class="line"></span><br><span class="line"><span class="comment"># Random Number Generation</span></span><br><span class="line">rng = np.random.RandomState(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Gaussian Process Regression</span></span><br><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, random_state=<span class="number">0</span>)</span><br><span class="line">gpr.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prediction</span></span><br><span class="line">y_pred_mean, y_pred_std = gpr.predict(X, return_std=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br><span class="line">ax.plot(X, y, c=<span class="string">&quot;k&quot;</span>, label=<span class="string">&quot;true&quot;</span>)</span><br><span class="line">ax.scatter(X_train, y_train, fc=<span class="string">&quot;k&quot;</span>, label=<span class="string">&quot;sample without noise&quot;</span>)</span><br><span class="line"></span><br><span class="line">ax.plot(X.ravel(), y_pred_mean, c=<span class="string">&quot;0.5&quot;</span>, label=<span class="string">&quot;GP prediction (mean)&quot;</span>)</span><br><span class="line">ax.fill_between(X.ravel(), y_pred_mean-<span class="number">1.96</span>*y_pred_std, y_pred_mean+<span class="number">1.96</span>*y_pred_std, alpha=<span class="number">0.5</span>, fc=<span class="string">&quot;lightgray&quot;</span>, label=<span class="string">&quot;95% CI&quot;</span>)</span><br><span class="line">ax.legend(loc=<span class="string">&quot;upper left&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_3.png"><br></li></ul><h2 id="1-2-sample-추출"><a href="#1-2-sample-추출" class="headerlink" title="1.2. sample 추출"></a>1.2. sample 추출</h2><blockquote><p><a href="https://scikit-learn.org/stable/auto_examples/gaussian_process/plot_gpr_prior_posterior.html#sphx-glr-auto-examples-gaussian-process-plot-gpr-prior-posterior-py">scikit-learn: Illustration of prior and posterior Gaussian process for different kernels</a></p></blockquote><p><img src="ds.gif" alt="14,000,605개의 미래를 보는 닥터 스트레인지, 대혼돈의 멀티버스 中"></p><ul><li><p>신뢰구간에는 다양한 가능성이 내포되어 있습니다.</p></li><li><p>이들 중 일부를 골라 추출할 수 있습니다.</p></li><li><p>5개를 골라 Gaussian Process Regression 위에 얹어봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sampling</span></span><br><span class="line">n_samples=<span class="number">5</span></span><br><span class="line">y_samples = gpr.sample_y(X, n_samples)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prediction</span></span><br><span class="line">y_pred_mean, y_pred_std = gpr.predict(X, return_std=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br><span class="line">ax.plot(X, y, c=<span class="string">&quot;k&quot;</span>, label=<span class="string">&quot;true&quot;</span>)</span><br><span class="line">ax.scatter(X_train, y_train, fc=<span class="string">&quot;k&quot;</span>, label=<span class="string">&quot;sample without noise&quot;</span>)</span><br><span class="line"></span><br><span class="line">ax.plot(X.ravel(), y_pred_mean, c=<span class="string">&quot;0.5&quot;</span>, label=<span class="string">&quot;GP prediction (mean)&quot;</span>)</span><br><span class="line">ax.fill_between(X.ravel(), y_pred_mean-<span class="number">1.96</span>*y_pred_std, y_pred_mean+<span class="number">1.96</span>*y_pred_std, alpha=<span class="number">0.5</span>, fc=<span class="string">&quot;lightgray&quot;</span>, label=<span class="string">&quot;95% CI&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> y_sample <span class="keyword">in</span> y_samples.T:</span><br><span class="line">    ax.plot(X.ravel(), y_sample, lw=<span class="number">1</span>, ls=<span class="string">&quot;:&quot;</span>, label=<span class="string">&quot;GP prediction (mean)&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="122_gpr2_4.png"><br></p></li><li><p>대부분 신뢰구간 안에 들어와 있지만 일부는 신뢰구간 밖으로도 나가 있습니다.</p></li><li><p>정상입니다.</p></li></ul><h2 id="1-3-posterior-vs-prior"><a href="#1-3-posterior-vs-prior" class="headerlink" title="1.3. posterior vs prior"></a>1.3. posterior vs prior</h2><ul><li><p>지금 그린 그림은 evidence가 반영된 결과, 즉 <b>posterior(사후확률)</b>입니다.</p></li><li><p>학습을 시키지 않은 채 예측을 하고 sample curve를 뽑을 수도 있습니다.</p></li><li><p>evidence가 반영되기 전의 <b>prior(사전확률)</b>입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prior</span></span><br><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sampling</span></span><br><span class="line">y_samples = gpr.sample_y(X, n_samples)</span><br></pre></td></tr></table></figure><p><img src="122_gpr2_5.png"><br></p></li><li><p>관측값이 반영되어 있지 않기 때문에 데이터와는 무관한 모습입니다.</p></li><li><p>그러나 곡선의 모양에는 우리가 선택한 RBF 커널이 드러나 있습니다.</p></li><li><p>학습에 커널이 반영되는만큼 <b>데이터의 모습을 반영</b>해 <b>커널을 선정</b>해야 합니다.</p></li><li><p>scikit-learn이 지원하는 커널들의 prior와 posterior를 살펴보겠습니다.</p></li></ul><h1 id="2-Kernels"><a href="#2-Kernels" class="headerlink" title="2. Kernels"></a>2. Kernels</h1><blockquote><p><a href="https://pasus.tistory.com/209">Deep Campus: 가우시안 프로세스의 개념</a><br><a href="https://towardsdatascience.com/understanding-gaussian-process-the-socratic-way-ba02369d804">towardsdatascience: Understanding Gaussian Process, the Socratic Way</a><br><a href="https://thegradient.pub/gaussian-process-not-quite-for-dummies/">The Gradient, Gaussian process not quite for dummies</a></p></blockquote><h2 id="2-1-커널의-정체"><a href="#2-1-커널의-정체" class="headerlink" title="2.1. 커널의 정체"></a>2.1. 커널의 정체</h2><ul><li><p>Gaussian Process의 커널은 covariance function입니다. </p></li><li><p>서로 다른 두 점 $x_i$와 $x_j$와의 상호 연관성을 나타냅니다.</p></li><li><p>이 함수를 커널 함수라고 하며, <b>Radial basis function</b>은 다음과 같이 정의됩니다.<br>$$k(x_i, x_j) = \exp\left(- \frac{d(x_i, x_j)^2}{2l^2} \right)$$</p></li><li><p>$x_i$와 $x_j$의 거리가 같아도 $l$이 크면 $k$가 큽니다: 먼 거리의 데이터까지 연관성을 가진다는 뜻입니다.</p></li><li><p>$x_i = x_j$ 일때 공분산은 최대값으로 1을 가집니다.</p></li><li><p>그렇다면 $x_i$과 $x_j$ 사이의 한 점은 두 점 모두와의 공분산을 최대한 높이는 방향으로 결정될텐데</p></li><li><p>Gaussian Process는 결정변수가 아니라 확률변수이므로 <b>확률</b>이 높을 뿐 조금씩 변합니다.</p></li><li><p>이로 인해 아무런 관찰값이 입력되지 않아도(prior) <b>RBF</b>의 sample 함수는 <b>랜덤하게 매끈한 곡선</b>을 이룹니다.</p></li></ul><ul><li>같은 이유로 참값으로 관측값이 지정되면(posterior) <b>관측값과 관측값 사이를 최대한 매끈하게 잇는 곡선의 존재 범위</b>가 도출됩니다.</li><li>그렇다면, <b>커널 함수가 바뀌면 예측값이 바뀔 것</b>이라는 것을 상상할 수 있으며</li><li><b>데이터의 성격에 맞는 커널 함수가 있음</b>을 예상할 수도 있습니다.</li><li>최적값을 얻는 방법으로 <b>MLE(Maximum Likelihood Estimation)</b>이 사용됩니다.</li><li><code>log_marginal_likelihood()</code> 메소드를 사용해 결과값을 추출할 수 있습니다.</li></ul><ul><li>커널 종류를 바꾸며 prior와 posterior를 관찰합니다.</li><li><b>커널을 입력받는 시각화 함수</b>를 아래와 같이 준비합니다.</li><li>코드가 길어 접어두었습니다.<details>  <summary><b>코드 보기/접기</b></summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">plt.rcParams[<span class="string">&#x27;mathtext.fontset&#x27;</span>] = <span class="string">&quot;cm&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_pp</span>(<span class="params">kernel, kernel_name=<span class="string">&quot;&quot;</span>, X_train=X_train, y_train=y_train, X_true=X, y_true=y, n_samples=<span class="number">5</span></span>):</span></span><br><span class="line">    gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, random_state=<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># prior</span></span><br><span class="line">    y_prior_mean, y_prior_std = gpr.predict(X_true, return_std=<span class="literal">True</span>)</span><br><span class="line">    y_prior_samples = gpr.sample_y(X_true, n_samples)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># posterior</span></span><br><span class="line">    gpr.fit(X_train, y_train)</span><br><span class="line">    y_posterior_mean, y_posterior_std = gpr.predict(X_true, return_std=<span class="literal">True</span>)</span><br><span class="line">    y_posterior_samples = gpr.sample_y(X_true, n_samples)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># kernel after fitting</span></span><br><span class="line">    kernel_ = gpr.kernel_</span><br><span class="line">    theta = gpr.kernel_.theta</span><br><span class="line">    ll = gpr.log_marginal_likelihood(theta)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># visualize</span></span><br><span class="line">    fig, axs = plt.subplots(nrows=<span class="number">2</span>, figsize=(<span class="number">6</span>, <span class="number">4</span>), sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>, constrained_layout=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> ax, y_mean, y_std, y_samples, title, k <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [y_prior_mean, y_posterior_mean], </span><br><span class="line">                                                           [y_prior_std, y_posterior_std], [y_prior_samples, y_posterior_samples],</span><br><span class="line">                                                           [<span class="string">&quot;prior&quot;</span>, <span class="string">&quot;posterior&quot;</span>], [kernel, kernel_]):</span><br><span class="line">        <span class="comment"># true</span></span><br><span class="line">        ax.plot(X_true, y_true, c=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">        ax.scatter(X_train, y_train, fc=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># pred</span></span><br><span class="line">        ax.plot(X_true.ravel(), y_mean, c=<span class="string">&quot;0.5&quot;</span>)</span><br><span class="line">        ax.fill_between(X_true.ravel(), y_mean-<span class="number">1.96</span>*y_std, y_mean+<span class="number">1.96</span>*y_std, alpha=<span class="number">0.5</span>, fc=<span class="string">&quot;lightgray&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># samples</span></span><br><span class="line">        <span class="keyword">for</span> y_sample <span class="keyword">in</span> y_samples.T:</span><br><span class="line">            ax.plot(X_true.ravel(), y_sample, lw=<span class="number">1</span>, ls=<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># title</span></span><br><span class="line">        ax.text(<span class="number">0.18</span>, <span class="number">0.97</span>, title, fontsize=<span class="string">&quot;large&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>, color=<span class="string">&quot;b&quot;</span>, ha=<span class="string">&quot;right&quot;</span>, va=<span class="string">&quot;top&quot;</span>, transform=ax.transAxes)</span><br><span class="line">        str_k = <span class="built_in">str</span>(k).replace(<span class="string">&#x27; ** &#x27;</span>,<span class="string">&#x27;^&#x27;</span>).replace(<span class="string">&#x27;**&#x27;</span>,<span class="string">&#x27;^&#x27;</span>).replace(<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;\cdot&#x27;</span>).replace(<span class="string">&#x27;length_scale&#x27;</span>,<span class="string">&#x27;l&#x27;</span>).replace(<span class="string">&#x27;alpha&#x27;</span>,<span class="string">&#x27;\\alpha&#x27;</span>).replace(<span class="string">&#x27;periodicity&#x27;</span>, <span class="string">&#x27;p&#x27;</span>).replace(<span class="string">&#x27;sigma&#x27;</span>,<span class="string">&#x27;\\sigma&#x27;</span>).replace(<span class="string">&#x27;nu&#x27;</span>,<span class="string">&#x27;\\nu&#x27;</span>)</span><br><span class="line">        ax.text(<span class="number">0.2</span>, <span class="number">0.97</span>, <span class="string">&quot;kernel: &quot;</span> + <span class="string">f&quot;$<span class="subst">&#123;str_k&#125;</span>$&quot;</span>, ha=<span class="string">&quot;left&quot;</span>, va=<span class="string">&quot;top&quot;</span>, color=<span class="string">&quot;darkblue&quot;</span>, transform=ax.transAxes)</span><br><span class="line">        </span><br><span class="line">    axs[<span class="number">1</span>].text(<span class="number">0.105</span>, <span class="number">0.84</span>, <span class="string">&quot;Log-likelihood: &quot;</span> + <span class="string">f&quot;$&#123;&#123;<span class="subst">&#123;ll:<span class="number">.3</span>f&#125;</span>&#125;&#125;$&quot;</span>, ha=<span class="string">&quot;left&quot;</span>, va=<span class="string">&quot;top&quot;</span>, color=<span class="string">&quot;darkblue&quot;</span>, transform=axs[<span class="number">1</span>].transAxes)</span><br><span class="line">    str_theta = <span class="string">&quot;, &quot;</span>.join([<span class="string">f&quot;<span class="subst">&#123;t:<span class="number">.3</span>f&#125;</span>&quot;</span> <span class="keyword">for</span> t <span class="keyword">in</span> theta])</span><br><span class="line">    axs[<span class="number">1</span>].text(<span class="number">0.265</span>, <span class="number">0.71</span>, <span class="string">f&quot;$\\theta: (&#123;&#123;<span class="subst">&#123;str_theta&#125;</span>&#125;&#125;)$&quot;</span>, ha=<span class="string">&quot;left&quot;</span>, va=<span class="string">&quot;top&quot;</span>, color=<span class="string">&quot;darkblue&quot;</span>, transform=axs[<span class="number">1</span>].transAxes)</span><br><span class="line">    fig.suptitle(kernel_name, fontsize=<span class="string">&quot;x-large&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fig</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2-Radial-Basis-Function"><a href="#2-2-Radial-Basis-Function" class="headerlink" title="2.2. Radial Basis Function"></a>2.2. Radial Basis Function</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.RBF.html">scikit-learn: RBF Kernel</a></p></blockquote><ul><li>Gaussian Process의 가장 기본이 되는 커널입니다.</li><li>매끈한 곡선이 우리가 알고 있는 가장 기본적인 모양입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;Radial Basis Function&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_6.png"><br></li></ul><h2 id="2-2-White-Kernel"><a href="#2-2-White-Kernel" class="headerlink" title="2.2. White Kernel"></a>2.2. White Kernel</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.WhiteKernel.html">scikit-learn: White Kernel</a></p></blockquote><p>$$k(x_i, x_j) = noise \_ level \text{ if } x_i == x_j \text{ else } 0$$</p><ul><li>단독으로 사용되기보다 다른 커널에 더해져 노이즈 레벨을 측정하는데 활용됩니다.</li><li>아래 예제에서는 RBF와의 합으로 사용되었으며, posterior에서 noise level = $1.13 \times 10^{-8}$에 불과합니다.</li><li>prior의 noise level이 데이터를 만나 0에 가깝게 수렴한 것입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> WhiteKernel</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>)) + WhiteKernel(noise_level=<span class="number">1</span>, noise_level_bounds=(<span class="number">1e-8</span>, <span class="number">1e1</span>))</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;Radial Basis Function + White Noise&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_11.png"><br></li></ul><h2 id="2-3-Radial-Quadratic-Kernel"><a href="#2-3-Radial-Quadratic-Kernel" class="headerlink" title="2.3. Radial Quadratic Kernel"></a>2.3. Radial Quadratic Kernel</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.RationalQuadratic.html">scikit-learn: Rational Quadratic Kernel</a></p></blockquote><p>$$k(x_i, x_j) = \left(1 + \frac{d(x_i, x_j)^2 }{ 2\alpha  l^2}\right)^{-\alpha}$$</p><ul><li>RBF Kernel과 다른 거리 스케일링의 혼합 척도(scale mixture)로 볼 수 있습니다.</li><li>prior에서는 RBF 커널에 비해 곧게 펴진 듯한 모습이지만 posterior는 RBF와 잘 구분되지 않습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> RationalQuadratic</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1.0</span> * RationalQuadratic(length_scale=<span class="number">1.0</span>, alpha=<span class="number">0.1</span>, alpha_bounds=(<span class="number">1e-5</span>, <span class="number">1e15</span>))</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;Radial Quadratic Function&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_7.png"><br></li></ul><h2 id="2-4-Constant-Kernel"><a href="#2-4-Constant-Kernel" class="headerlink" title="2.4. Constant Kernel"></a>2.4. Constant Kernel</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.ConstantKernel.html">scikit-learn: Constant Kernel</a></p></blockquote><p>$$k(x_1, x_2) = constant\_value ;\forall; x_1, x_2$$</p><ul><li>글자 그대로 상수 커널입니다.</li><li>White Kernel과 유사하게 다른 커널과 함께 사용됩니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> ConstantKernel</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1.0</span> * ConstantKernel(constant_value=<span class="number">1.0</span>, constant_value_bounds=(<span class="number">1e-5</span>, <span class="number">1e15</span>))</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;Constant Kernel&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_15.png"><br></li></ul><h2 id="2-5-Exp-Sine-Squared-Kernel-periodic-kernel"><a href="#2-5-Exp-Sine-Squared-Kernel-periodic-kernel" class="headerlink" title="2.5. Exp-Sine-Squared Kernel (periodic kernel)"></a>2.5. Exp-Sine-Squared Kernel (periodic kernel)</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.ExpSineSquared.html">scikit-learn: ExpSineSquared</a></p></blockquote><p>$$k(x_i, x_j) = \text{exp}\left(-\frac{ 2\sin^2(\pi d(x_i, x_j)/p) }{ l^ 2} \right)$$</p><ul><li>지수함수에 sine함수의 제곱이 포함된 형태입니다.</li><li>주기성을 갖는 데이터를 묘사하기 좋으며 length scale $l &gt; 0$과 함께 periodicity $p &gt; 0$를 매개변수로 가집니다.</li><li>$p$는 Euclidean distance입니다.</li><li>prior와 posterior 모두 자세히 보면 주기성을 띄고 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> ExpSineSquared</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1.0</span> * ExpSineSquared(</span><br><span class="line">    length_scale=<span class="number">1.0</span>,</span><br><span class="line">    periodicity=<span class="number">3.0</span>,</span><br><span class="line">    length_scale_bounds=(<span class="number">0.1</span>, <span class="number">10.0</span>),</span><br><span class="line">    periodicity_bounds=(<span class="number">1.0</span>, <span class="number">10.0</span>),</span><br><span class="line">)</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;ExpSineSquared&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_8.png"><br></li></ul><h2 id="2-6-Dot-Product"><a href="#2-6-Dot-Product" class="headerlink" title="2.6. Dot Product"></a>2.6. Dot Product</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.DotProduct.html?highlight=dotproduct#sklearn.gaussian_process.kernels.DotProduct">scikit-learn: Dot Product</a></p></blockquote><p>$$k(x_i, x_j) = \sigma_0 ^ 2 + x_i \cdot x_j$$</p><ul><li><p>앞에서 본 커널들은 형태는 달라도 두 점 사이의 거리 $d(x_i, x_j)$를 주요 인자로 가집니다.</p></li><li><p>이런 커널을 <b>stationary kernel</b>이라고 합니다.</p></li><li><p>반면 $x_i$, $x_j$ 값 자체에 의해 좌우되는 커널을 <b>non-stationary kernel</b>이라고 합니다.</p></li><li><p>dot product로 정의되기 때문에 원점으로부터의 회전에는 무관하지만 transition에는 민감하게 반응합니다.</p></li><li><p>$\sigma_0 = 0$이라면 homogeneous linear kernel, $\sigma_0 \neq 0$이라면 inhomogeneous가 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1st degree</span></span><br><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> DotProduct</span><br><span class="line"></span><br><span class="line">kernel = DotProduct(sigma_0=<span class="number">1.0</span>, sigma_0_bounds=(<span class="number">0.1</span>, <span class="number">100.0</span>))</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;DotProduct&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="122_gpr2_9.png"><br></p></li><li><p>제곱식을 통해 다항식을 만들 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3rd degree</span></span><br><span class="line">kernel = DotProduct(sigma_0=<span class="number">1.0</span>, sigma_0_bounds=(<span class="number">0.1</span>, <span class="number">100.0</span>))**<span class="number">3</span></span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;DotProduct&quot;</span>)</span><br><span class="line">fig.axes[<span class="number">1</span>].set_ylim(-<span class="number">25</span>, <span class="number">25</span>)</span><br></pre></td></tr></table></figure><p><img src="122_gpr2_16.png"><br></p></li></ul><h2 id="2-7-Matern-Kernel"><a href="#2-7-Matern-Kernel" class="headerlink" title="2.7. Matérn Kernel"></a>2.7. Matérn Kernel</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.Matern.html#sklearn.gaussian_process.kernels.Matern">scikit-learn: Matern</a></p></blockquote><p>$$k(x_i, x_j) =  \frac{1}{\Gamma(\nu)2^{\nu-1}}\Bigg(\frac{\sqrt{2\nu}}{l} d(x_i , x_j )\Bigg)^\nu K_\nu\Bigg(\frac{\sqrt{2\nu}}{l} d(x_i , x_j )\Bigg)$$</p><ul><li>RBF의 일반화된 버전입니다.</li><li>$\nu$로 결과 함수의 smoothness를 조절하는데 $\nu$가 $\infty$에 접근할수록 RBF에 가까워집니다.</li><li>위 식의 $K_{\nu}(\cdot)$는 modified Bessel function, $\Gamma(\cdot)$는 gamma function입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> Matern</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1.0</span> * Matern(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-1</span>, <span class="number">10.0</span>), nu=<span class="number">1.5</span>)</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;Matérn&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_10.png"><br></li></ul><h2 id="3-결론"><a href="#3-결론" class="headerlink" title="3. 결론"></a>3. 결론</h2><ul><li>Gaussian Process는 임의의 적은 데이터로 멋진 결과물을 만들어내지만 Kernel function에 크게 좌우됩니다.</li><li>문제의 성격과 데이터의 특성에 맞는 적절한 Kernel 선택이 매우 중요합니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/gaussian-process/">gaussian process</category>
      
      <category domain="https://jehyunlee.github.io/tags/bayesian/">bayesian</category>
      
      <category domain="https://jehyunlee.github.io/tags/scikit-learn/">scikit-learn</category>
      
      
    </item>
    
  </channel>
</rss>
