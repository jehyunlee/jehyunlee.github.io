<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Pega Devlog</title>
    <link>https://jehyunlee.github.io/</link>
    
    <atom:link href="https://jehyunlee.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Pega&#39;s Development log for myself and others</description>
    <pubDate>Thu, 16 Feb 2023 08:45:54 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>ChatGPT 업무효율화 가이드</title>
      <link>https://jehyunlee.github.io/2023/02/15/Python-General-16-chatgpt/</link>
      <guid>https://jehyunlee.github.io/2023/02/15/Python-General-16-chatgpt/</guid>
      <pubDate>Tue, 14 Feb 2023 16:08:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://chat.openai.com/chat&quot;&gt;ChatGPT&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;최근 대통령이 정부부처 업무보고에서 ChatGPT를 언급한 이후 관심이 뜨겁습니다.</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><a href="https://chat.openai.com/chat">ChatGPT</a></p></blockquote><ul><li>최근 대통령이 정부부처 업무보고에서 ChatGPT를 언급한 이후 관심이 뜨겁습니다.</li><li>여러 부처 및 기관 분들을 만나뵙고 받은 공통적인 질문들을 정리했습니다.</li><li><b>사무 업무효율화에 ChatGPT를 적용하기 위한</b> 가이드입니다.</li><li>AI가 낯선 분들께 ChatGPT가 다가선 만큼 엉뚱한 기대도 느껴진 것이 사실입니다.</li></ul><ul><li><b>ChatGPT가 향후 업데이트가 될 것이고, 다른 모델들이 경쟁하며 개발중입니다.</b></li><li><b>현재 시점에서의 가이드라는 점을 말씀드리며, 향후 ChatGPT 업그레이드 상황에 따라 변경될 수 있습니다.</b></li><li><a href="ChatGPT_AiFrenz_guide.pdf">pdf 파일은 여기에서 다운받으실 수 있습니다.</a></li><li>AI프렌즈 분들과 함께 여러 분들을 만났던 자리인 만큼 AI프렌즈 명의로 작성했습니다.</li></ul><p><img src="ChatGPT_AiFrenz_guide_01.png" alt="11줄 요약"></p><p><img src="ChatGPT_AiFrenz_guide_02.png" alt="예시 1"></p><p><img src="ChatGPT_AiFrenz_guide_03.png" alt="예시 2"></p><p><img src="ChatGPT_AiFrenz_guide_04.png" alt="예시 3"></p><p><img src="ChatGPT_AiFrenz_guide_05.png" alt="예시 3"></p><p><img src="ChatGPT_AiFrenz_guide_06.png" alt="예시 4"></p><p><img src="ChatGPT_AiFrenz_guide_07.png" alt="예시 4"></p><p><img src="ChatGPT_AiFrenz_guide_08.png" alt="예시 4"></p><p><img src="ChatGPT_AiFrenz_guide_09.png" alt="예시 6"></p><p><img src="ChatGPT_AiFrenz_guide_10.png" alt="예시 8"></p><p><img src="ChatGPT_AiFrenz_guide_11.png" alt="예시 9"></p><p><img src="ChatGPT_AiFrenz_guide_12.png" alt="예시 9"></p><p><img src="ChatGPT_AiFrenz_guide_13.png" alt="예시 10"></p><p><img src="ChatGPT_AiFrenz_guide_14.png" alt="예시 11"></p><p><img src="ChatGPT_AiFrenz_guide_15.png" alt="예시 11"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/openai/">openai</category>
      
      <category domain="https://jehyunlee.github.io/tags/chatgpt/">chatgpt</category>
      
      
    </item>
    
    <item>
      <title>KDE + threshold</title>
      <link>https://jehyunlee.github.io/2023/02/12/Python-DS-127_kdeth/</link>
      <guid>https://jehyunlee.github.io/2023/02/12/Python-DS-127_kdeth/</guid>
      <pubDate>Sun, 12 Feb 2023 08:20:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;밀도 함수는 데이터 분포를 볼 때 가장 많이 그리는 그림 중 하나입니다.&lt;/li&gt;
&lt;li&gt;특정 값을 기준으로 Pass와 Fail을 정한다고 할 때, 전체의 비율도 중요합니다.&lt;/li&gt;
&lt;li&gt;seaborn kdeplot을 살짝 다듬어서</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>밀도 함수는 데이터 분포를 볼 때 가장 많이 그리는 그림 중 하나입니다.</li><li>특정 값을 기준으로 Pass와 Fail을 정한다고 할 때, 전체의 비율도 중요합니다.</li><li>seaborn kdeplot을 살짝 다듬어서 쪼개고 비율을 계산합니다.</li></ul><h1 id="1-오늘의-목표"><a href="#1-오늘의-목표" class="headerlink" title="1. 오늘의 목표"></a>1. 오늘의 목표</h1><ul><li>오늘 우리는 데이터를 선별하는 데 쓰는, 이런 그림을 그릴 겁니다.</li><li>특정 값을 기준으로 왼쪽은 Fail, 오른쪽은 Pass입니다.</li><li>공장에서 발생하는 양품과 불량품으로 생각을 해도 좋고, 학생들 시험 결과의 분포로 봐도 좋습니다.</li><li>중요한 것은 <b>특정 지점을 기준으로 KDE plot을 자르고</b>, <b>좌우를 다른 색으로 칠하는 것</b>입니다.<br><br><img src="127_kdeth_8.png"><br></li></ul><h1 id="2-데이터-→-밀도-함수"><a href="#2-데이터-→-밀도-함수" class="headerlink" title="2. 데이터 → 밀도 함수"></a>2. 데이터 → 밀도 함수</h1><ul><li><p><code>numpy</code>를 사용해서 정규분포에 가까운 데이터를 만듭니다.</p></li><li><p><code>np.random.normal()</code>을 사용하면 뚝딱 만들어집니다.</p></li><li><p><code>loc</code>, <code>scale</code>을 사용해서 평균과 표준편차를 지정하고, <code>size</code>에는 10만을 넣습니다.</p></li><li><p>이렇게 얻은 결과를 <code>seaborn.kdeplot()</code>으로 밀도함수로 표현합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 예제 데이터 생성</span></span><br><span class="line">set0 = np.random.normal(loc=<span class="number">3</span>, scale=<span class="number">1</span>, size=<span class="number">100_000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 데이터 분포 밀도함수 시각화</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">sns.kdeplot(set0, fill=<span class="literal">True</span>, ax=ax)</span><br></pre></td></tr></table></figure><p><img src="127_kdeth_0.png"><br></p></li><li><p>매끈한 밀도함수가 얻어졌습니다.</p></li><li><p>이토록 데이터 분포가 매끈해보이는 것은 <code>seaborn.kdeplot()</code>에 숨겨진 <code>gridsize=200</code>이라는 매개변수 덕분입니다.</p></li><li><p>데이터가 쪼개지는 지점을 눈에 잘 띄게 하겠습니다. <code>gridsize=20</code>을 입력해서 같은 데이터를 거칠게 표현합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">sns.kdeplot(set0, fill=<span class="literal">True</span>, gridsize=<span class="number">20</span>, ax=ax)</span><br></pre></td></tr></table></figure><p><img src="127_kdeth_1.png"><br></p></li></ul><h1 id="3-밀도-함수-절단"><a href="#3-밀도-함수-절단" class="headerlink" title="3. 밀도 함수 절단"></a>3. 밀도 함수 절단</h1><blockquote><p><a href="https://matplotlib.org/stable/api/path_api.html">matplotlib.org matplotlib.path</a></p></blockquote><ul><li>똑같은 데이터인데 전혀 매끈하지 않습니다.</li><li>한 눈에 봐도 꼭지점과 선분으로 이루어진 다각형이라는 것을 알 수 있습니다.</li><li><b>$x = 2$</b></li><li>꼭지점 중 <b>$x &gt; 2$만 남겨서 이것들로 다각형을 새로 만들면 되지 않을까요?</b></li></ul><ul><li><p>KDE plot을 구성하는 다각형은 <code>ax.collections</code>로 추출할 수 있습니다.</p></li><li><p>이 중에서도 윤곽선은 <code>.get_path()[0]</code>명령으로 뽑아낼 수 있고,</p></li><li><p>꼭지점은 여기에 <code>.vertices</code>, 꼭지점의 특성은 <code>.codes</code> 속성을 보면 됩니다.</p></li><li><p>한번 추출해 봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vertices</span></span><br><span class="line">path = ax.collections[<span class="number">0</span>].get_paths()[<span class="number">0</span>]</span><br><span class="line">vertices = path.vertices</span><br><span class="line">codes = path.codes</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# vertices = <span class="subst">&#123;vertices&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;#    codes = <span class="subst">&#123;codes&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vertices = [[-1.68144422e+00  4.44446302e-07]</span></span><br><span class="line">[-1.68144422e+00  0.00000000e+00]</span><br><span class="line">[-1.20843724e+00  0.00000000e+00]</span><br><span class="line">[-7.35430261e-01  0.00000000e+00]</span><br><span class="line">[-2.62423283e-01  0.00000000e+00]</span><br><span class="line"> </span><br><span class="line">              (중략)</span><br><span class="line">        </span><br><span class="line">[-1.68144422e+00  4.44446302e-07]</span><br><span class="line">[-1.68144422e+00  4.44446302e-07]]</span><br><span class="line"><span class="comment">#    codes = [ 1  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2</span></span><br><span class="line"> 2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2 79]</span><br></pre></td></tr></table></figure></li></ul></li><li><p><b>vertices</b>에는 수많은 점의 $(x, y)$ 좌표가 나열되어 있습니다. </p></li><li><p>이 데이터를 기준으로 threshold를 적용하면 될 것 같습니다.</p></li><li><p>해당 데이터의 index를 추출합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x &gt; 2 인 꼭지점 추출</span></span><br><span class="line">idx_th = np.where(vertices[:, <span class="number">0</span>] &gt; <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">idx_th</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([ 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,</span><br><span class="line">     26, 27, 28, 29, 30, 31, 32, 33])</span><br></pre></td></tr></table></figure></li></ul></li><li><p><b>codes</b>가 <a href="https://matplotlib.org/stable/api/path_api.html">중요한 정보</a>를 담고 있습니다.</p></li><li><p><b>1은 시작점</b>, <b>2는 연결점</b>, <b>79는 polygon close</b>입니다.</p></li><li><p><b>$ x &gt; 2 $</b>인 점들의 index를 추출하다 보면 code가 규칙에서 어긋날 수 있습니다.</p></li><li><p>그렇기 때문에, 첫 점과 마지막 점의 code에 강제로 1과 79를 할당합니다.</p></li><li><p>이렇게 추출된 vertices와 codes를 다시 윤곽선을 의미하는 path에 할당하고 그림을 그리면 변화가 관찰됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vertices_th = vertices[idx_th]</span><br><span class="line">codes_th = codes[idx_th]</span><br><span class="line"></span><br><span class="line">path.vertices = vertices_th</span><br><span class="line">path.codes = codes_th</span><br><span class="line">path.codes[<span class="number">0</span>] = <span class="number">1</span>    <span class="comment"># 시작점 (MOVETE)</span></span><br><span class="line">path.codes[-<span class="number">1</span>] = <span class="number">79</span>  <span class="comment"># 닫는 점 (CLOSEPOLY)</span></span><br><span class="line"></span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure></li></ul><h1 id="4-부가-요소-활용"><a href="#4-부가-요소-활용" class="headerlink" title="4. 부가 요소 활용"></a>4. 부가 요소 활용</h1><ul><li><p>전체 코드를 한 번 정리합니다.</p></li><li><p><code>gridsize</code>를 기본값으로 복구시켜 매끈한 곡선을 얻고,</p></li><li><p>밀도 함수를 절단한 뒤 다시 전체 밀도 함수를 선으로만 그려 부분과 전체를 동시에 표시합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. threshold 적용 KDE plot</span></span><br><span class="line">sns.kdeplot(set0, fill=<span class="literal">True</span>, ax=ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># vertices</span></span><br><span class="line">path = ax.collections[<span class="number">0</span>].get_paths()[<span class="number">0</span>]</span><br><span class="line">vertices = path.vertices</span><br><span class="line">codes = path.codes</span><br><span class="line"></span><br><span class="line"><span class="comment"># threshold</span></span><br><span class="line">idx_th = np.where(vertices[:, <span class="number">0</span>] &gt; <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">vertices_th = vertices[idx_th]</span><br><span class="line">codes_th = codes[idx_th]</span><br><span class="line">path.vertices = vertices_th</span><br><span class="line">path.codes = codes_th</span><br><span class="line">path.codes[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">path.codes[-<span class="number">1</span>] = <span class="number">79</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. threshold 미적용 KDE plot</span></span><br><span class="line">sns.kdeplot(set0, fill=<span class="literal">False</span>, color=<span class="string">&quot;k&quot;</span>, ax=ax)</span><br></pre></td></tr></table></figure><p><img src="127_kdeth_3.png"></p></li><li><p>이제 저 영역이 Pass라는 것을 문자를 사용해 명시합니다.</p></li><li><p>색도 기본색보다 조금은 의지를 반영해 특정 색을 지정합니다. 파랑으로 갑시다.</p></li><li><p>기준점이 되는 <b>$x = 2$</b>에 기준 막대도 우뚝 세워줍니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. threshold 적용 KDE plot</span></span><br><span class="line">sns.kdeplot(set0, color=<span class="string">&quot;b&quot;</span>, gridsize=<span class="number">500</span>, fill=<span class="literal">True</span>, ax=ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># vertices</span></span><br><span class="line">path = ax.collections[<span class="number">0</span>].get_paths()[<span class="number">0</span>]</span><br><span class="line">vertices = path.vertices</span><br><span class="line">codes = path.codes</span><br><span class="line"></span><br><span class="line"><span class="comment"># threshold</span></span><br><span class="line">idx_th = np.where(vertices[:, <span class="number">0</span>] &gt; <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">vertices_th = vertices[idx_th]</span><br><span class="line">codes_th = codes[idx_th]</span><br><span class="line">path.vertices = vertices_th</span><br><span class="line">path.codes = codes_th</span><br><span class="line">path.codes[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">path.codes[-<span class="number">1</span>] = <span class="number">79</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. threshold 미적용 KDE plot</span></span><br><span class="line">sns.kdeplot(set0, fill=<span class="literal">False</span>, color=<span class="string">&quot;k&quot;</span>, ax=ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. additional information</span></span><br><span class="line">ax.collections[<span class="number">0</span>].set_lw(<span class="number">0</span>)     <span class="comment"># threshold 적용 KDE plot의 윤곽선 제거</span></span><br><span class="line">ax.axvline(<span class="number">2</span>, c=<span class="string">&quot;k&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>) <span class="comment"># threshold line</span></span><br><span class="line">ax.text(<span class="number">3.2</span>, <span class="number">0.15</span>, <span class="string">&quot;PASS&quot;</span>, color=<span class="string">&quot;b&quot;</span>, ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="127_kdeth_4.png"></p></li></ul><ul><li>같은 요령으로, 왼쪽에 FAIL이라고 명시할 수 있습니다.</li><li>동일한 작업을 threshold 방향만 바꾸어 반복하면 됩니다.<details>  <summary><b>코드 보기/접기</b></summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PASS and FAIL</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. threshold 적용 KDE plot</span></span><br><span class="line">sns.kdeplot(set0, color=<span class="string">&quot;b&quot;</span>, gridsize=<span class="number">500</span>, fill=<span class="literal">True</span>, ax=ax)  <span class="comment"># Pass</span></span><br><span class="line">sns.kdeplot(set0, color=<span class="string">&quot;r&quot;</span>, gridsize=<span class="number">500</span>, fill=<span class="literal">True</span>, ax=ax)  <span class="comment"># Fail</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## PASS</span></span><br><span class="line"><span class="comment"># vertices</span></span><br><span class="line">path_p = ax.collections[<span class="number">0</span>].get_paths()[<span class="number">0</span>]</span><br><span class="line">vertices_p = path_p.vertices</span><br><span class="line">codes_p = path_p.codes</span><br><span class="line"></span><br><span class="line"><span class="comment"># threshold</span></span><br><span class="line">idx_th_p = np.where(vertices_p[:, <span class="number">0</span>] &gt; <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">vertices_th_p = vertices_p[idx_th_p]</span><br><span class="line">codes_th_p = codes_p[idx_th_p]</span><br><span class="line">path_p.vertices = vertices_th_p</span><br><span class="line">path_p.codes = codes_th_p</span><br><span class="line">path_p.codes[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">path_p.codes[-<span class="number">1</span>] = codes[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## FAIL</span></span><br><span class="line"><span class="comment"># vertices</span></span><br><span class="line">path_f = ax.collections[<span class="number">1</span>].get_paths()[<span class="number">0</span>]</span><br><span class="line">vertices_f = path_f.vertices</span><br><span class="line">codes_f = path_f.codes</span><br><span class="line"></span><br><span class="line"><span class="comment"># threshold</span></span><br><span class="line">idx_th_f = np.where(vertices_p[:, <span class="number">0</span>] &lt;= <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">vertices_th_f = vertices_p[idx_th_f]</span><br><span class="line">codes_th_f = codes_p[idx_th_f]</span><br><span class="line">path_f.vertices = vertices_th_f</span><br><span class="line">path_f.codes = codes_th_f</span><br><span class="line">path_f.codes[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">path_f.codes[-<span class="number">1</span>] = <span class="number">79</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. threshold 미적용 KDE plot</span></span><br><span class="line">sns.kdeplot(set0, fill=<span class="literal">False</span>, color=<span class="string">&quot;k&quot;</span>, ax=ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. additional information</span></span><br><span class="line">ax.collections[<span class="number">0</span>].set_lw(<span class="number">0</span>)     <span class="comment"># PASS KDE plot의 윤곽선 제거</span></span><br><span class="line">ax.collections[<span class="number">1</span>].set_lw(<span class="number">0</span>)     <span class="comment"># FAIL KDE plot의 윤곽선 제거</span></span><br><span class="line">ax.axvline(<span class="number">2</span>, c=<span class="string">&quot;k&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>) <span class="comment"># threshold line</span></span><br><span class="line">ax.text(<span class="number">3.2</span>, <span class="number">0.15</span>, <span class="string">&quot;PASS&quot;</span>, color=<span class="string">&quot;b&quot;</span>, ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>)</span><br><span class="line">ax.text(<span class="number">0.5</span>, <span class="number">0.15</span>, <span class="string">&quot;FAIL&quot;</span>, color=<span class="string">&quot;r&quot;</span>, ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><p><img src="127_kdeth_5.png"></p><h1 id="5-넓이-계산"><a href="#5-넓이-계산" class="headerlink" title="5. 넓이 계산"></a>5. 넓이 계산</h1><blockquote><p><a href="https://shapely.readthedocs.io/en/stable/manual.html#polygons">shapely.geometry.Polygon</a></p></blockquote><ul><li>이런 시각화는 그림 뿐 아니라 숫자도 중요합니다.</li><li>기준선을 넘은 데이터가 전체의 몇 %인지, 넘지 못한 것은 얼마인지 알아야 합니다.</li><li>밀도 함수의 전체 넓이는 1이라는 사실은 널리 알려져 있지만 이렇게 자르면 계산이 어렵습니다.</li></ul><ul><li><p><b><code>shapely</code> 라이브러리가 이런 도형 계산에 편리합니다.</b></p></li><li><p><code>shapely.geometry.Polygon()</code>에 vertices를 넣은 뒤 <code>.area</code>속성을 출력하면 넓이가 나옵니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> Polygon</span><br><span class="line"></span><br><span class="line">poly_p = Polygon(vertices_th_p)</span><br><span class="line">poly_f = Polygon(vertices_th_f)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# PASS: <span class="subst">&#123;poly_p.area*<span class="number">100</span>:<span class="number">.2</span>f&#125;</span> %&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# FAIL: <span class="subst">&#123;poly_f.area*<span class="number">100</span>:<span class="number">.2</span>f&#125;</span> %&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# PASS + FAIL: <span class="subst">&#123;(poly_p.area + poly_f.area)*<span class="number">100</span>:<span class="number">.2</span>f&#125;</span> %&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PASS: 83.87 %</span></span><br><span class="line"><span class="comment"># FAIL: 15.70 %</span></span><br><span class="line"><span class="comment"># PASS + FAIL: 99.57 %</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>더해서 100%가 되어야 하는데, 0.5%가량 부족하지만 전체적으로 얼추 맞습니다.</p></li><li><p>대략 84%는 Pass, 16%는 Fail로 볼 수 있을 듯 합니다.</p></li><li><p>실제 앞에서 만든 우리 데이터셋으로 확인하면 84.25% vs 15.75%라고 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# PASS (Ground Truth): <span class="subst">&#123;<span class="built_in">len</span>(set0[set0 &gt; <span class="number">2</span>])/<span class="number">1e5</span> * <span class="number">100</span>:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# FAIL (Ground Truth): <span class="subst">&#123;<span class="built_in">len</span>(set0[set0 &lt;= <span class="number">2</span>])/<span class="number">1e5</span> * <span class="number">100</span>:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PASS (Ground Truth): 84.25</span></span><br><span class="line"><span class="comment"># FAIL (Ground Truth): 15.75</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="6-함수-제작"><a href="#6-함수-제작" class="headerlink" title="6. 함수 제작"></a>6. 함수 제작</h1><ul><li><p>자, 이제 함수를 만들어 사용합시다.</p></li><li><p>data와 threshold를 필수로 입력하게 하고, pass와 fail의 색, 그리고 gridsize를 보조 입력으로 받습니다.</p></li><li><p>제가 만드는 다른 함수들처럼 활용성을 위해 Axes를 입력받을 수 있는, Axes를 출력하는 함수로 만듭니다.</p></li><li><p>이러면 다른 큰 그림의 일부로 활용하기 좋습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_passfail</span>(<span class="params">data, threshold, color_pass=<span class="string">&quot;b&quot;</span>, color_fail=<span class="string">&quot;r&quot;</span>, gridsize=<span class="number">500</span>, ax=<span class="literal">None</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ax:    <span class="comment"># 입력 Axes가 없을 때, 생성</span></span><br><span class="line">        fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. threshold 적용 KDE plot</span></span><br><span class="line">    sns.kdeplot(x=data, color=color_pass, gridsize=gridsize, fill=<span class="literal">True</span>, ax=ax)  <span class="comment"># Pass</span></span><br><span class="line">    sns.kdeplot(x=data, color=color_fail, gridsize=gridsize, fill=<span class="literal">True</span>, ax=ax)  <span class="comment"># Fail</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. pass, fail thrsholding &amp; coloring</span></span><br><span class="line">    labels = []</span><br><span class="line">    <span class="keyword">for</span> i, (part, color_pf, label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(ax.collections, [color_pass, color_fail], [<span class="string">&quot;PASS&quot;</span>, <span class="string">&quot;FAIL&quot;</span>])):</span><br><span class="line">        part.set_lw(<span class="number">0</span>)</span><br><span class="line">        path = part.get_paths()[<span class="number">0</span>]</span><br><span class="line">        vertices = path.vertices</span><br><span class="line">        codes = path.codes</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>: <span class="comment"># pass</span></span><br><span class="line">            idx_th = np.where(vertices[:, <span class="number">0</span>] &gt; threshold)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            idx_th = np.where(vertices[:, <span class="number">0</span>] &lt;= threshold)[<span class="number">0</span>]</span><br><span class="line">            </span><br><span class="line">        vertices_th = vertices[idx_th]</span><br><span class="line">        codes_th = codes_p[idx_th]</span><br><span class="line">        path.vertices = vertices_th</span><br><span class="line">        path.codes = codes_th</span><br><span class="line">        path.codes[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        path.codes[-<span class="number">1</span>] = <span class="number">79</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># calculate area</span></span><br><span class="line">        poly = Polygon(vertices_th)</span><br><span class="line">        labels.append(<span class="string">f&quot;<span class="subst">&#123;label&#125;</span>: <span class="subst">&#123;poly.area*<span class="number">100</span>:<span class="number">.1</span>f&#125;</span> %&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. threshold 미적용 KDE plot</span></span><br><span class="line">    sns.kdeplot(data, fill=<span class="literal">False</span>, color=<span class="string">&quot;k&quot;</span>, ax=ax)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. additional information</span></span><br><span class="line">    ax.axvline(threshold, c=<span class="string">&quot;k&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>) <span class="comment"># threshold line</span></span><br><span class="line">    ax.legend(handles=ax.collections, labels=labels, loc=<span class="string">&quot;upper right&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 5. auxiliaries</span></span><br><span class="line">    ax.spines[[<span class="string">&quot;left&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;right&quot;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.set_yticks([])</span><br><span class="line">    ax.set_ylabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ax</span><br><span class="line"></span><br><span class="line"><span class="comment"># 함수 실행</span></span><br><span class="line">ax = plot_passfail(set0, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><img src="127_kdeth_6.png"><br></p></li><li><p>Pass와 Fail 비율은 범례로 출력하게 만들었습니다.</p></li><li><p>실제 활용시 다른 그래프와 중첩될 수 있고, 그래프 모양이 데이터에 따라 달라지기 때문에</p></li><li><p>아까처럼 그래프 위에 글자를 놓으려면 고칠 일이 더 많아질 수 있기 때문입니다.</p></li><li><p>이제 한 줄로 threshold가 반영된 밀도 함수를 그릴 수 있게 되었습니다.</p></li></ul><h1 id="7-함수-수정"><a href="#7-함수-수정" class="headerlink" title="7. 함수 수정"></a>7. 함수 수정</h1><ul><li>이렇게 만들어진 그래프는 객체 제어를 통해 색을 비롯한 여러 요소를 마음껏 제어할 수 있습니다.</li><li>Pass를 green, Fail을 orange로 바꾸고 legend까지 반영합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">labels = []</span><br><span class="line"><span class="keyword">for</span> part, fc, label <span class="keyword">in</span> <span class="built_in">zip</span>(ax.collections, [<span class="string">&quot;green&quot;</span>, <span class="string">&quot;orange&quot;</span>], [<span class="string">&quot;PASS&quot;</span>, <span class="string">&quot;FAIL&quot;</span>]):</span><br><span class="line">    part.set_fc(fc)</span><br><span class="line">    part.set_alpha(<span class="number">0.5</span>)</span><br><span class="line">    vertices = part.get_paths()[<span class="number">0</span>].vertices</span><br><span class="line">    labels.append(<span class="string">f&quot;<span class="subst">&#123;label&#125;</span>: <span class="subst">&#123;Polygon(vertices).area*<span class="number">100</span>:<span class="number">.1</span>f&#125;</span> %&quot;</span>)</span><br><span class="line">    </span><br><span class="line">ax.legend(ax.collections, labels, loc=<span class="string">&quot;upper right&quot;</span>)</span><br><span class="line">ax.set_xlim(-<span class="number">1</span>, <span class="number">8</span>)</span><br><span class="line">display(ax.figure)</span><br></pre></td></tr></table></figure><img src="127_kdeth_7.png"><br></li></ul><h1 id="8-활용-펭귄-데이터셋"><a href="#8-활용-펭귄-데이터셋" class="headerlink" title="8. 활용 - 펭귄 데이터셋"></a>8. 활용 - 펭귄 데이터셋</h1><ul><li>펭귄 데이터셋의 세 수치형 데이터, bill_length, bill_depth, flipper_length에 이 함수를 적용합니다.</li><li><code>plt.subplots(ncols=3)</code>으로 틀을 잡아 놓고 Axes마다 데이터를 threshold와 함께 넣었습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 데이터셋 읽어오기</span></span><br><span class="line">df_peng = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 전체 Figure 설정</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Axes마다 함수 적용</span></span><br><span class="line">plot_passfail(df_peng[<span class="string">&quot;bill_length_mm&quot;</span>], <span class="number">40</span>, ax=axs[<span class="number">0</span>], color_pass=<span class="string">&quot;b&quot;</span>, color_fail=<span class="string">&quot;r&quot;</span>)</span><br><span class="line">plot_passfail(df_peng[<span class="string">&quot;bill_depth_mm&quot;</span>], <span class="number">15</span>, ax=axs[<span class="number">1</span>], color_pass=<span class="string">&quot;g&quot;</span>, color_fail=<span class="string">&quot;orange&quot;</span>)</span><br><span class="line">plot_passfail(df_peng[<span class="string">&quot;flipper_length_mm&quot;</span>], <span class="number">180</span>, ax=axs[<span class="number">2</span>], color_pass=<span class="string">&quot;c&quot;</span>, color_fail=<span class="string">&quot;m&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Axes마다 y 범위 설정</span></span><br><span class="line">axs[<span class="number">0</span>].set_ylim(<span class="number">0</span>, <span class="number">0.1</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_ylim(<span class="number">0</span>, <span class="number">0.4</span>)</span><br><span class="line">axs[<span class="number">2</span>].set_ylim(<span class="number">0</span>, <span class="number">0.06</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 전체 title 설정</span></span><br><span class="line">fig.suptitle(<span class="string">&quot;penguins dataset feature distribution with threshold\n&quot;</span>, color=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig.savefig(<span class="string">&quot;127_kdeth_8.png&quot;</span>)</span><br></pre></td></tr></table></figure><img src="127_kdeth_8.png"><br></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      
    </item>
    
    <item>
      <title>신천식의 이슈토론 - 과학자 그들은 누구인가? 과학자가 행복한 도시는?</title>
      <link>https://jehyunlee.github.io/2023/02/02/Python-General-15-scs_issue/</link>
      <guid>https://jehyunlee.github.io/2023/02/02/Python-General-15-scs_issue/</guid>
      <pubDate>Wed, 01 Feb 2023 20:11:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;중도TV &lt;b&gt;신천식의 이슈토론&lt;/b&gt;에 패널로 출연했습니다.&lt;ul&gt;
&lt;li&gt;&lt;b&gt;과학자 그들은 누구인가? 과학자가 행복한 도시는?&lt;/b&gt;이라는 주제로 대화를 나눴고,&lt;/li&gt;
&lt;li&gt;채연석 박사님 (前항공우주연구원장, 現국토교통부 항</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>중도TV <b>신천식의 이슈토론</b>에 패널로 출연했습니다.<ul><li><b>과학자 그들은 누구인가? 과학자가 행복한 도시는?</b>이라는 주제로 대화를 나눴고,</li><li>채연석 박사님 (前항공우주연구원장, 現국토교통부 항공,철도사고조사위원회 위원장),<br>유용균 박사 (한국원자력연구원 인공지능응용연구실 실장, AI프렌즈 즈장)<br>두 분과 함께 말씀을 나눴습니다.</li></ul></li></ul><ul><li>영상 : (<a href="https://youtu.be/gDC7agLJFeY">Youtube Link</a>)<br></li><li>기사 : <a href="http://www.joongdo.co.kr/web/view.php?key=20230201010000231">중도일보, “[신천식의 이슈토론]과학자 그들은 누구인가, 과학자들이 행복한 대전”</a></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/gDC7agLJFeY" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><img src="15_scs_issue_01.png" alt="신천식의 이슈토론이 1일 오전 10 중도일보 스튜디오에서 &#39;과학자 그들운 누구인가, 과학자들이 행복한 대전&#39;을 주제로 진행됐다. (왼쪽부터)최연석 전 항공우주연구원장, 신천식 박사, 유용균 원자력 연구원 박사, 이제헌 한국에너지기술 연구원 박사"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/youtube/">youtube</category>
      
      
    </item>
    
    <item>
      <title>연구소의 문헌분석 기술 활용</title>
      <link>https://jehyunlee.github.io/2023/01/09/Python-DS-126-labnlp/</link>
      <guid>https://jehyunlee.github.io/2023/01/09/Python-DS-126-labnlp/</guid>
      <pubDate>Mon, 09 Jan 2023 02:21:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;2022년 12월 13일 &lt;b&gt;모두의 연구소&lt;/b&gt; 초청으로  &lt;b&gt;MODUPOP&lt;/b&gt; 강연을 했습니다.&lt;ul&gt;
&lt;li&gt;몸담고 있는 연구원에서 적용하고 있는 문헌분석 기술을 공유드렸습니다.&lt;/li&gt;
&lt;li&gt;짧은 시간에 압축해서 전달드</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>2022년 12월 13일 <b>모두의 연구소</b> 초청으로  <b>MODUPOP</b> 강연을 했습니다.<ul><li>몸담고 있는 연구원에서 적용하고 있는 문헌분석 기술을 공유드렸습니다.</li><li>짧은 시간에 압축해서 전달드린터라 세부 기술보다는 적용처 중심으로 봐주시면 감사하겠습니다.</li><li>저녁 7시부터 시작된 강의였고, 비와 눈으로 날씨가 많이 나쁜 날이었습니다.</li><li>귀중한 시간을 내서 온라인, 오프라인으로 참석해주신 분들께 다시 한번 감사드립니다.</li><li>초반 2분 가량 소리가 조금 울립니다. 양해 부탁드립니다.</li></ul></li></ul><ul><li>발표 영상 : (<a href="https://youtu.be/fuyOoDBZc1k">Youtube Link</a>)<br></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/fuyOoDBZc1k" frameborder="0" loading="lazy" allowfullscreen></iframe></div> ]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/KIER/">KIER</category>
      
      <category domain="https://jehyunlee.github.io/tags/API/">API</category>
      
      <category domain="https://jehyunlee.github.io/tags/NLP/">NLP</category>
      
      
    </item>
    
    <item>
      <title>Impact of RPA</title>
      <link>https://jehyunlee.github.io/2023/01/01/Python-DS-125-rpa/</link>
      <guid>https://jehyunlee.github.io/2023/01/01/Python-DS-125-rpa/</guid>
      <pubDate>Sun, 01 Jan 2023 07:02:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;RPA(Robotic Process Automation: 업무 자동화) 과제를 하려고 합니다.&lt;/li&gt;
&lt;li&gt;RPA를 적용하면 효용이 얼마나 좋은지를 설득하기 위한 그림을 그립니다.&lt;/li&gt;
&lt;li&gt;RPA 도입 전과 후를 비교하는 그</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>RPA(Robotic Process Automation: 업무 자동화) 과제를 하려고 합니다.</li><li>RPA를 적용하면 효용이 얼마나 좋은지를 설득하기 위한 그림을 그립니다.</li><li>RPA 도입 전과 후를 비교하는 그림을 그려서 보여줍시다.</li></ul><h1 id="1-행정-업무"><a href="#1-행정-업무" class="headerlink" title="1. 행정 업무"></a>1. 행정 업무</h1><p><img src="125_rpa_01.png"></p><ul><li><p>어떤 가상의 데이터 관련 행정 업무가 있다고 합시다.</p></li><li><p>현재는 <b>총 2천만원의 용역비</b>를 포함해 <b>12주</b>가 걸립니다. <b>수작업</b>이기 때문입니다.</p></li><li><p>여기에 RPA를 적용하면, <b>용역비가 없어지고</b> 이어지는 작업도 훨씬 짧게 걸립니다.</p></li><li><p>서류 작업과 취합 작업도 단순 반복 작업에서 <b>검증으로 업무 성격이 바뀝니다.</b><br></p></li><li><p><b>보고서</b>나 <b>기획서</b>등에서 이 훌륭한 업무를 어필하고 싶습니다.</p></li><li><p>일단 <a href="RPA_comparison.xlsx">엑셀로 정리</a>해보니 이렇습니다. 전달은 되는데 아쉽습니다.<br><br><img src="125_rpa_02.png"><br></p></li></ul><h1 id="2-시각화"><a href="#2-시각화" class="headerlink" title="2. 시각화"></a>2. 시각화</h1><h2 id="2-1-용역-비용-amp-인력"><a href="#2-1-용역-비용-amp-인력" class="headerlink" title="2.1. 용역 비용 &amp; 인력"></a>2.1. 용역 비용 &amp; 인력</h2><ul><li>RPA 효과는 크게 두 가지입니다. 하나는 <b>용역 비용</b>, 하나는 <b>인력</b></li><li>인력도 man-week (MW)으로 정리했기 때문에 담당자의 연봉을 적용하면 비용 산정이 됩니다.</li><li>하지만 여기선 용역은 용역, 인력은 인력으로 나누어 그리기로 합니다.</li><li>항목 수에 따라 용역 비용과 인력이 그려질 공간을 1:3의 비율로 분할합니다.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), gridspec_kw=&#123;<span class="string">&quot;width_ratios&quot;</span>:[<span class="number">1</span>, <span class="number">3</span>]&#125;)</span><br></pre></td></tr></table></figure><img src="125_rpa_03.png"><br></li></ul><h2 id="2-2-용역-비용"><a href="#2-2-용역-비용" class="headerlink" title="2.2. 용역 비용"></a>2.2. 용역 비용</h2><ul><li>왼쪽 공간에 RPA 적용 전 2천만원이 들어간 용역 비용과 적용 후 0원이 된 것을 비교하여 그립니다.</li><li>이럴 때는 grouped bar plot이 제격입니다.</li><li>용역 비용 뿐 아니라 다른 모든 항목을 비교할 것이기 때문에 <b>RPA 전</b>과 <b>RPA 후</b> 비교에 일관성이 필요합니다.</li><li>적용 전과 후를 <b>“brown”</b>과 <b>“royalblue”</b>로 표기합니다.</li></ul><ul><li>또한, <b>grouped bar plot</b>은 <b>pandas가 더 편합니다.</b></li><li>pandas DataFrame에서 그림을 그릴 부분만 <code>.loc[]</code>를 사용해 데이터를 한정하고,</li><li><code>.plot.bar()</code>를 사용해 groupled bar plot을 그립니다.</li><li><code>cs = [&quot;brown&quot;, &quot;royalblue&quot;]</code>과 <code>color=cs</code>를 입력하면 적용 전과 후 색이 차례로 입혀집니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data 읽기</span></span><br><span class="line">rpa = pd.read_excel(<span class="string">&quot;RPA_comparison.xlsx&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), gridspec_kw=&#123;<span class="string">&quot;width_ratios&quot;</span>:[<span class="number">1</span>, <span class="number">3</span>]&#125;, constrained_layout=<span class="literal">True</span>)</span><br><span class="line">cs = [<span class="string">&quot;brown&quot;</span>, <span class="string">&quot;royalblue&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 용역 비용</span></span><br><span class="line">rpa.loc[[<span class="number">0</span>]].plot.bar(ax=axs[<span class="number">0</span>], lw=<span class="number">1</span>, ec=<span class="string">&quot;w&quot;</span>, legend=<span class="literal">False</span>, color=cs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 인력</span></span><br><span class="line">rpa.loc[<span class="number">1</span>:].plot.bar(ax=axs[<span class="number">1</span>], lw=<span class="number">1</span>, ec=<span class="string">&quot;w&quot;</span>, legend=<span class="literal">False</span>, color=cs)</span><br></pre></td></tr></table></figure><img src="125_rpa_04.png"><br></li></ul><h2 id="2-3-Annotation"><a href="#2-3-Annotation" class="headerlink" title="2.3. Annotation"></a>2.3. Annotation</h2><ul><li><p>가장 중요한 틀이 갖춰졌습니다.</p></li><li><p>이제 ticks, ticklabels 등을 다듬으면 쓸만한 그래프가 될겁니다.</p></li><li><p>하지만 그 전에, <b>데이터를 직설적으로 알려주는 장치를 하려고 합니다.</b></p></li><li><p>위 코드 아래에 코드를 덧붙여 bar 위에 데이터를 출력합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 용역 비용</span></span><br><span class="line">xs, ws, hs = [], [], []</span><br><span class="line"><span class="keyword">for</span> p, c <span class="keyword">in</span> <span class="built_in">zip</span>(axs[<span class="number">0</span>].patches, cs):</span><br><span class="line">    x, w, h = p.get_x(), p.get_width(), p.get_height()</span><br><span class="line">    xs.append(x)</span><br><span class="line">    ws.append(w)</span><br><span class="line">    hs.append(h)</span><br><span class="line">    cost = <span class="built_in">format</span>(<span class="built_in">int</span>(h), <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> h &gt; <span class="number">0</span>:</span><br><span class="line">        cost = <span class="string">f&quot;<span class="subst">&#123;cost&#125;</span> 천원&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cost = <span class="string">f&quot;<span class="subst">&#123;cost&#125;</span> 원&quot;</span></span><br><span class="line">    axs[<span class="number">0</span>].text(x+w/<span class="number">2</span>, h+<span class="number">1000</span>, cost, ha=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;small&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>, color=c, zorder=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><img src="125_rpa_05.png"><br></p></li><li><p>왼쪽 Axes를 구성하는 두 막대의 위치, 너비, 높이를 뽑아내 글자를 입혔습니다.</p></li><li><p>일반적으로 금액을 <b>천원</b>단위로 표현하기 때문에 일부러 엑셀 파일부터 천원으로 끊었습니다.</p></li></ul><h2 id="2-4-Spines-and-Ticks"><a href="#2-4-Spines-and-Ticks" class="headerlink" title="2.4. Spines and Ticks"></a>2.4. Spines and Ticks</h2><ul><li>이제 y축이 없어도 데이터가 잘 전달됩니다.</li><li>y축과 함께 네모난 테두리(spines)를 없애버립시다.</li><li>x축 눈금은 <code>tick_params()</code>를 사용해 폭을 0으로(<code>width=0</code>) 만듭니다.</li><li>그런데 xticklabel은 여기 말고도 오른쪽 Axes에도 세 개나 더 적용해야 됩니다.</li><li><code>font_label</code>이라는 이름의 dictionary type 매개변수를 만들어 적용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Spines and Ticks</span></span><br><span class="line">axs[<span class="number">0</span>].spines[[<span class="string">&quot;left&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;right&quot;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_yticks([])</span><br><span class="line">font_label = &#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;</span><br><span class="line">axs[<span class="number">0</span>].tick_params(axis=<span class="string">&quot;x&quot;</span>, width=<span class="number">0</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_xticklabels([<span class="string">&quot;용역 비용&quot;</span>], **font_label, rotation=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><img src="125_rpa_06.png"><br></li></ul><h2 id="2-5-Arrow"><a href="#2-5-Arrow" class="headerlink" title="2.5. Arrow"></a>2.5. Arrow</h2><blockquote><p><a href="https://matplotlib.org/stable/gallery/userdemo/connectionstyle_demo.html">matplotlib: Connection styles for annotations</a><br><a href="https://matplotlib.org/stable/gallery/text_labels_and_annotations/fancyarrow_demo.html">matplotlib: Annotation arrow style reference</a></p></blockquote><ul><li>RPA 적용 전후는 나왔는데 그림에서 알아보기 어렵습니다.</li><li><b>RPA를 적용했더니 확 비용이 확 떨어진다</b>는 느낌의 화살표가 있으면 좋을 것 같습니다.</li><li>Matplotlib에서 멋진 화살표를 만들기에는 <code>Axes.annotate()</code>가 가장 좋습니다.</li><li><b>“arrowstyle”:”fancy”</b>와 <b>“connectionstyle”</b>을 이용해 다이나믹한 화살표를 그립니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Arrow</span></span><br><span class="line">axs[<span class="number">0</span>].annotate(<span class="string">&quot;&quot;</span>, xy=(xs[<span class="number">1</span>]+w/<span class="number">2</span>, hs[<span class="number">1</span>]+w/<span class="number">2</span>), xytext=(xs[<span class="number">0</span>]+w/<span class="number">2</span>, hs[<span class="number">0</span>]+w/<span class="number">2</span>),</span><br><span class="line">            arrowprops=&#123;<span class="string">&quot;arrowstyle&quot;</span>:<span class="string">&quot;fancy&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;fc&quot;</span>:<span class="string">&quot;cornflowerblue&quot;</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>,</span><br><span class="line">                        <span class="string">&quot;connectionstyle&quot;</span>:<span class="string">&quot;arc3,rad=-0.3&quot;</span>, <span class="string">&quot;mutation_scale&quot;</span>:<span class="number">100</span>&#125;)</span><br></pre></td></tr></table></figure><img src="125_rpa_07.png"><br></li></ul><h2 id="2-6-인력에도-동일하게"><a href="#2-6-인력에도-동일하게" class="headerlink" title="2.6. 인력에도 동일하게"></a>2.6. 인력에도 동일하게</h2><ul><li>용역 비용에 적용한 사항들을 인력에도 동일하게 적용합니다.</li><li>아까 왼쪽 Axes의 xticklabel에 넣었던 <b>용역 비용</b>은 title이 더 잘 어울리는 것 같습니다.</li><li>내용을 올리고, xticklabel은 새롭게 <b>분석 용역</b>이라고 넣습니다.</li><li>오른쪽에도 여기에 대응되도록 <b>용역 검증</b>, <b>서류 작업</b>, <b>취합 작업</b>을 넣습니다.<br><br><img src="125_rpa_08.png"><br></li></ul><h2 id="2-7-비용과-기간-사이-칸막이"><a href="#2-7-비용과-기간-사이-칸막이" class="headerlink" title="2.7. 비용과 기간 사이 칸막이"></a>2.7. 비용과 기간 사이 칸막이</h2><ul><li>마지막 작업입니다.</li><li>왼쪽과 오른쪽 구간을 나누는 막대를 하나 넣습니다.</li><li><code>matplotlib.lines.Line2D</code>객체를 사용해 선을 그립니다. </li><li>양 끝점의 좌표를 입력해야 하는데 Figure 전체의 상대 좌표를 사용해 <code>[0.255, 0.255], [0.15, 0.85]</code>를 입력합니다.</li><li>양 끝을 둥글게 만들고자 <code>solid_capstyle = &quot;round&quot;</code>를 입력했습니다.</li><li>두 Axes 사이 공간에 그려야 하는 그림이기 때문에 <code>fig.add_artist()</code>로 추가합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.lines <span class="keyword">import</span> Line2D</span><br><span class="line"></span><br><span class="line">line = Line2D([<span class="number">0.255</span>, <span class="number">0.255</span>], [<span class="number">0.15</span>, <span class="number">0.85</span>], linewidth=<span class="number">5</span>, solid_capstyle=<span class="string">&quot;round&quot;</span>, color=<span class="string">&quot;0.6&quot;</span>)</span><br><span class="line">fig.add_artist(line)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">1</span>].legend()</span><br></pre></td></tr></table></figure><img src="125_rpa_09.png"><br></li></ul><h1 id="3-활용"><a href="#3-활용" class="headerlink" title="3. 활용"></a>3. 활용</h1><blockquote><p><a href="https://m.etnews.com/20221228000275">관련기사: 전자신문- NST, 출연연 연구행정혁신 성과확산 공모전 시상식 개최</a></p></blockquote><ul><li>이렇게 정리된 그림은 <b>적절한 표</b>, <b>근거 자료</b>와 함께 <b>보고서</b>와 <b>ppt</b>에 삽입하면 좋습니다.</li><li><b>그냥 파워포인트에서 그리면 더 쉽지 않냐</b>고 하실 수 있습니다.</li><li>경험상 이런 일은 현업 부서에서 수치가 수차례 변경되는 것이 일반적이고, 실제로 열번쯤 바뀐 것 같습니다.</li><li>일일이 새로 그렸다면 너무 힘들었을테지만 코드로 그린 덕택에 그때마다 데이터만 바꿔 끼웠습니다.</li></ul><ul><li><p>위 그림은 실제로 최근 있었던 한 공모전에서 서류 작성과 발표 자료에 사용했습니다.</p></li><li><p>데이터는 제가 접한 실제 사례와 다르게 바꾸었습니다만, 전반적인 틀은 살렸습니다.<br><br><img src="125_rpa_10.png" alt="혹시나 싶은 마음에 내용은 흐리게 가렸습니다."><br></p></li><li><p>전체 코드는 아래와 여기에서 확인할 수 있습니다: <a href="https://colab.research.google.com/drive/1RLo4aTtP_sM9EoxWyfkvR5hetGNmvVZH?usp=share_link">Colab 링크</a></p></li><li><p>여러분께도 좋은 결과가 있기를 바랍니다.</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> matplotlib.lines <span class="keyword">import</span> Line2D</span><br><span class="line"></span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line">plt.rcParams[<span class="string">&quot;font.family&quot;</span>] = <span class="string">&quot;NanumGothic&quot;</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># data 읽기</span></span><br><span class="line">rpa = pd.read_excel(<span class="string">&quot;RPA_comparison.xlsx&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), gridspec_kw=&#123;<span class="string">&quot;width_ratios&quot;</span>:[<span class="number">1</span>, <span class="number">3</span>]&#125;, constrained_layout=<span class="literal">True</span>)</span><br><span class="line">cs = [<span class="string">&quot;brown&quot;</span>, <span class="string">&quot;royalblue&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 용역 비용</span></span><br><span class="line">rpa.loc[[<span class="number">0</span>]].plot.bar(ax=axs[<span class="number">0</span>], lw=<span class="number">1</span>, ec=<span class="string">&quot;w&quot;</span>, legend=<span class="literal">False</span>, color=cs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 인력</span></span><br><span class="line">rpa.loc[<span class="number">1</span>:].plot.bar(ax=axs[<span class="number">1</span>], lw=<span class="number">1</span>, ec=<span class="string">&quot;w&quot;</span>, legend=<span class="literal">False</span>, color=cs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 용역 비용</span></span><br><span class="line">xs, ws, hs = [], [], []</span><br><span class="line"><span class="keyword">for</span> p, c <span class="keyword">in</span> <span class="built_in">zip</span>(axs[<span class="number">0</span>].patches, cs):</span><br><span class="line">    x, w, h = p.get_x(), p.get_width(), p.get_height()</span><br><span class="line">    xs.append(x)</span><br><span class="line">    ws.append(w)</span><br><span class="line">    hs.append(h)</span><br><span class="line">    cost = <span class="built_in">format</span>(<span class="built_in">int</span>(h), <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> h &gt; <span class="number">0</span>:</span><br><span class="line">        cost = <span class="string">f&quot;<span class="subst">&#123;cost&#125;</span> 천원&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cost = <span class="string">f&quot;<span class="subst">&#123;cost&#125;</span> 원&quot;</span></span><br><span class="line">    axs[<span class="number">0</span>].text(x+w/<span class="number">2</span>, h+<span class="number">1000</span>, cost, ha=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;small&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>, color=c, zorder=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Spines and Ticks</span></span><br><span class="line">font_label = &#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [<span class="string">&quot;용역 비용\n&quot;</span>, <span class="string">&quot;업무 기간\n&quot;</span>]):</span><br><span class="line">    ax.spines[[<span class="string">&quot;left&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;right&quot;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.set_yticks([])</span><br><span class="line">    ax.tick_params(axis=<span class="string">&quot;x&quot;</span>, width=<span class="number">0</span>)</span><br><span class="line">    ax.set_title(title, **font_label)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">0</span>].set_xticklabels([<span class="string">&quot;분석 용역&quot;</span>], rotation=<span class="number">0</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_xticklabels([<span class="string">&quot;용역 검증&quot;</span>, <span class="string">&quot;서류 작업&quot;</span>, <span class="string">&quot;취합 작업&quot;</span>], </span><br><span class="line">                       rotation=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Arrow</span></span><br><span class="line">axs[<span class="number">0</span>].annotate(<span class="string">&quot;&quot;</span>, xy=(xs[<span class="number">1</span>]+w/<span class="number">2</span>, hs[<span class="number">1</span>]+w/<span class="number">2</span>), xytext=(xs[<span class="number">0</span>]+w/<span class="number">2</span>, hs[<span class="number">0</span>]+w/<span class="number">2</span>),</span><br><span class="line">            arrowprops=&#123;<span class="string">&quot;arrowstyle&quot;</span>:<span class="string">&quot;fancy&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;fc&quot;</span>:<span class="string">&quot;cornflowerblue&quot;</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>,</span><br><span class="line">                        <span class="string">&quot;connectionstyle&quot;</span>:<span class="string">&quot;arc3,rad=-0.3&quot;</span>, <span class="string">&quot;mutation_scale&quot;</span>:<span class="number">100</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 인력 감축</span></span><br><span class="line">xs, ws, hs = [], [], []</span><br><span class="line"><span class="keyword">for</span> i, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(axs[<span class="number">1</span>].patches):</span><br><span class="line">    x, w, h = p.get_x(), p.get_width(), p.get_height()</span><br><span class="line">    xs.append(x)</span><br><span class="line">    ws.append(w)</span><br><span class="line">    hs.append(h)</span><br><span class="line">    person = <span class="built_in">format</span>(<span class="built_in">int</span>(h), <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> h &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> h%<span class="number">1</span>:</span><br><span class="line">            h = <span class="built_in">int</span>(h)</span><br><span class="line">        day = <span class="string">f&quot;<span class="subst">&#123;h&#125;</span> 주&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">3</span>:</span><br><span class="line">        c = cs[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        c = cs[<span class="number">1</span>]</span><br><span class="line">    p.set_fc(c)</span><br><span class="line">    axs[<span class="number">1</span>].text(x+w/<span class="number">2</span>, h+<span class="number">0.3</span>, day, ha=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;small&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>, color=c, zorder=<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    axs[<span class="number">1</span>].annotate(<span class="string">&quot;&quot;</span>, xy=(xs[i+<span class="number">3</span>]+w/<span class="number">2</span>, hs[i+<span class="number">3</span>]+w/<span class="number">2</span>), xytext=(xs[i]+w/<span class="number">2</span>, hs[i]+w/<span class="number">2</span>),</span><br><span class="line">            arrowprops=&#123;<span class="string">&quot;arrowstyle&quot;</span>:<span class="string">&quot;fancy&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;skyblue&quot;</span>, <span class="string">&quot;fc&quot;</span>:<span class="string">&quot;skyblue&quot;</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.8</span>,</span><br><span class="line">                        <span class="string">&quot;connectionstyle&quot;</span>:<span class="string">&quot;arc3,rad=-0.3&quot;</span>, <span class="string">&quot;mutation_scale&quot;</span>:<span class="number">40</span>&#125;)</span><br><span class="line"></span><br><span class="line">line = Line2D([<span class="number">0.255</span>, <span class="number">0.255</span>], [<span class="number">0.15</span>, <span class="number">0.85</span>], linewidth=<span class="number">5</span>, solid_capstyle=<span class="string">&quot;round&quot;</span>, color=<span class="string">&quot;0.6&quot;</span>)</span><br><span class="line">fig.add_artist(line)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">1</span>].legend()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      
    </item>
    
    <item>
      <title>산타 방문 증빙 feat. DALL.E</title>
      <link>https://jehyunlee.github.io/2022/12/26/Python-General-14_santa/</link>
      <guid>https://jehyunlee.github.io/2022/12/26/Python-General-14_santa/</guid>
      <pubDate>Mon, 26 Dec 2022 07:30:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;2022년 한 해는 그림 생성 모델로 뜨거웠습니다.&lt;/li&gt;
&lt;li&gt;DALL.E를 사용해서 산타가 다녀갔다는 증빙을 만듭니다.&lt;/li&gt;
&lt;li&gt;사진 한 장이 필요합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-산타가-다녀가셨다&quot;&gt;&lt;a h</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>2022년 한 해는 그림 생성 모델로 뜨거웠습니다.</li><li>DALL.E를 사용해서 산타가 다녀갔다는 증빙을 만듭니다.</li><li>사진 한 장이 필요합니다.</li></ul><h1 id="1-산타가-다녀가셨다"><a href="#1-산타가-다녀가셨다" class="headerlink" title="1. 산타가 다녀가셨다!"></a>1. 산타가 다녀가셨다!</h1><ul><li>크리스마스에 다녀가시는 산타는 아이들에게 큰 기쁨입니다.</li><li>선물 자체도 기쁘고, 한 해 잘 살았다는 칭찬을 받는 듯한 느낌도 나지요.</li><li>반면 부모에게는 어떻게 올해를 넘길지가 고민입니다.</li></ul><blockquote><p><b>산타가 다녀가셨나봐! 선물도 있고 아빠 핸드폰에 사진도 찍혔어!</b></p></blockquote><p><img src="14_santa_02.png"></p><ul><li>다행히 아이들은 눈을 동그랗게 뜨고 믿어주었습니다.</li><li><b>산타를 제외한 배경이 우리 집이었기 때문에 의심도 안 했을 것입니다.</b></li></ul><h1 id="2-준비"><a href="#2-준비" class="headerlink" title="2. 준비"></a>2. 준비</h1><blockquote><p><a href="https://labs.openai.com/">DALL.E</a></p></blockquote><ul><li><p>먼저, 그림을 그려주는 AI, <b><a href="https://labs.openai.com/">DALL.E</a> 계정</b>이 필요합니다.</p></li><li><p>아직 계정이 없으시다면 위 링크로 들어가 회원 가입을 합니다.</p></li><li><p>로그인을 마치면 아래와 같은 화면이 나타납니다.<br><br><img src="14_santa_04.png"><br></p></li><li><p>그리고 <b>집 사진 한 장</b>이 필요합니다.</p></li><li><p>크리스마스를 맞아 꾸민 트리 밑에 아이들에게 줄 선물을 놓고 사진을 찍습니다.</p></li><li><p>산타가 등장할 곳은 다소 어두워야 부모에게 유리합니다.<br><br><img src="14_santa_01.jpg"><br></p></li></ul><h1 id="3-DALL-E-활약"><a href="#3-DALL-E-활약" class="headerlink" title="3. DALL.E 활약"></a>3. DALL.E 활약</h1><ul><li><b>Upload an image</b>를 클릭해서 집 사진을 올립니다.</li><li>그러면 정사각형으로 자르라고 하는데, 적절히 위치를 지정하고 <b>Crop</b>을 누릅니다.<br><br><img src="14_santa_05.png"><br></li></ul><ul><li><p>확인이 되었으면 <b>Edit image</b>를 눌러 수정을 들어갑니다.</p></li><li><p>기본으로 설정된 <b>지우개</b> 아이콘으로 산타가 놓일 자리를 지웁니다.<br><br><img src="14_santa_06.png"><br></p></li><li><p>이제 산타를 그릴 차례입니다.</p></li><li><p>구글 검색창을 닮은 하얀 막대 안에 산타가 어떤 모습으로 들어올지를 씁니다.</p></li><li><p>저는 이렇게 적었습니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Realistic photography of Santa Clause from backside, bending his knee towards the tree, standing to distribute Christmas presents.</span><br></pre></td></tr></table></figure></li><li><p>마지막으로 <b>Generate</b> 버튼을 누르면 4장의 이미지가 한번에 생성됩니다.<br><br><img src="14_santa_03.png"><br></p></li><li><p>마음에 드는 이미지가 없다면 <b>Generate</b>를 다시 눌러 다른 그림을 만들어봅니다.</p></li><li><p>마음에 드는 이미지가 나오면 그림을 다운받아 휴대폰에 저장합니다.<br><br><img src="14_santa_02.png"><br></p></li><li><p>언젠가 산타의 정체가 부모라는 것을 알게 되겠지만, 그 날이 오기 전까지는 동심을 간직하기를 바랍니다.</p></li><li><p>훗날 아이들이 이 포스팅을 읽게 된다면, 2022년의 산타와 선물을 떠올려주면 좋겠습니다. :)</p></li></ul><blockquote><p><b>아빠, 산타가 우리가 키우는 나무 만져줬나봐! 하루 사이에 더 자랐어!</b></p></blockquote>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/dall-e/">dall.e</category>
      
      <category domain="https://jehyunlee.github.io/tags/inpaining/">inpaining</category>
      
      
    </item>
    
    <item>
      <title>Deep Learning by Open API</title>
      <link>https://jehyunlee.github.io/2022/11/29/Python-DS-124-kierlecture8/</link>
      <guid>https://jehyunlee.github.io/2022/11/29/Python-DS-124-kierlecture8/</guid>
      <pubDate>Mon, 28 Nov 2022 17:02:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;한국에너지기술연구원 AI 학습조직&lt;/b&gt;에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.&lt;ul&gt;
&lt;li&gt;이번에는 직접 하는 코딩을 벗어나 공개된 딥러닝 모델을 사용하는 방법을 알아봅니다.&lt;/li&gt;
&lt;li&gt;영상과 자연어 처</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b>한국에너지기술연구원 AI 학습조직</b>에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.<ul><li>이번에는 직접 하는 코딩을 벗어나 공개된 딥러닝 모델을 사용하는 방법을 알아봅니다.</li><li>영상과 자연어 처리를 중심으로 OpenAI에서 제공하는 여러 모델이 있습니다.</li><li>강의실 예약 시간 문제로 마무리가 매끄럽지 못했습니다.</li><li>요약본이 번역되다 만 문제는 <code>max_tokens=300</code>을 추가하면 해결됩니다.</li><li><a href="221128_9%EC%B0%A8%EB%AA%A8%EC%9E%84.pdf">강의 자료는 여기에서 다운받으실 수 있습니다</a></li></ul></li></ul><ul><li><p>발표 영상 : (<a href="https://youtu.be/dsnrl0tLkdU">Youtube Link</a>)<br></p></li><li><p>실습 코드 : (<a href="https://bit.ly/3gEMeUS">https://bit.ly/3gEMeUS</a>)<br></p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/dsnrl0tLkdU" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><img src="cats.png" alt="DALL.E Open API로 그린 그림"><br></p><p><ul><li>1년간 총 8개의 강좌로 정리되었습니다.</li></ul><p><img src="schedule.png" alt="학습조직 일정"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/machine-learning/">machine learning</category>
      
      <category domain="https://jehyunlee.github.io/tags/KIER/">KIER</category>
      
      <category domain="https://jehyunlee.github.io/tags/API/">API</category>
      
      <category domain="https://jehyunlee.github.io/tags/Open-AI/">Open AI</category>
      
      <category domain="https://jehyunlee.github.io/tags/DALL-E/">DALL.E</category>
      
      <category domain="https://jehyunlee.github.io/tags/summary/">summary</category>
      
      
    </item>
    
    <item>
      <title>Gaussian Process Practice (3) Beware Boundaries</title>
      <link>https://jehyunlee.github.io/2022/11/19/Python-DS-123-gpr3/</link>
      <guid>https://jehyunlee.github.io/2022/11/19/Python-DS-123-gpr3/</guid>
      <pubDate>Sat, 19 Nov 2022 08:35:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;Gaussian Process 연습입니다.&lt;/li&gt;
&lt;li&gt;scikit-learn을 비롯한 예제를 재구성하여 연습합니다.&lt;/li&gt;
&lt;li&gt;주의사항을 알려드립니다. Gaussian Process는 경계조건에 매우 취약합니다.&lt;/li&gt;
&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>Gaussian Process 연습입니다.</li><li>scikit-learn을 비롯한 예제를 재구성하여 연습합니다.</li><li>주의사항을 알려드립니다. Gaussian Process는 경계조건에 매우 취약합니다.</li></ul><h1 id="1-Gaussian-Process의-한계"><a href="#1-Gaussian-Process의-한계" class="headerlink" title="1. Gaussian Process의 한계"></a>1. Gaussian Process의 한계</h1><blockquote><p><a href="https://scikit-learn.org/stable/auto_examples/gaussian_process/plot_gpr_noisy_targets.html#sphx-glr-auto-examples-gaussian-process-plot-gpr-noisy-targets-py">scikit-learn: Gaussian Process Regression: basic introductory example</a></p></blockquote><ul><li><p>Gaussian Process는 적은 데이터로도 꽤 믿을만한 결과를 출력합니다.</p></li><li><p>심지어 신뢰 구간까지 알 수 있어서 매우 정직해 보입니다.</p></li><li><p>하지만 치명적인 단점이 있습니다.</p></li><li><p><a href="https://jehyunlee.github.io/2022/11/16/Python-DS-121-gpr1/">지난 글</a>과 같은 예제를 사용합니다.<br><img src="123_gpr3_3.png"><br></p></li><li><p>모든 것이 정상으로 보입니다.</p></li><li><p>합리적인 범위의 평균값(<code>GP prediction (mean)</code>)과 신뢰 구간(<code>95% CI</code>)을 보이고 있습니다.</p></li><li><p>하지만 오른쪽 끄트머리를 보면, 조금 미심쩍습니다.</p></li><li><p><b>참값이 신뢰 구간의 바닥에 겨우 걸려있습니다.</b><br><br><img src="123_gpr3_8.png" alt="개그콘서트, &quot;불편한 진실&quot; "><br></p></li><li><p>극단적인 경우를 살펴봅니다.</p></li><li><p><b>X 값의 범위</b>로 참값의 좌우에 50씩을 보태 <b>-50 ~ 60을 입력</b>합니다.</p></li><li><p>평균이 0, 95% 신뢰구간이 무려 10에 가까운 커다란 밴드가 생겼습니다.</p></li><li><p>다항회귀를 해도 이렇지는 않을 것 같습니다.<br><br><img src="123_gpr3_7.png"><br></p></li><li><p><b>Gaussian Process의 원리</b>에 답이 있습니다.</p></li><li><p>Gaussian 분포를 prior로 놓기 때문에 평균이 0입니다.</p></li><li><p>학습 데이터(evidence)가 반영된 구간 안쪽은 그나마 괜찮지만 바깥쪽이 문제입니다.</p></li><li><p><b>안쪽에서 학습을 시켜봐야 바깥쪽의 중심값이 0이라고 가정되어 있기 때문에 저런 일이 벌어집니다.</b></p></li></ul><h1 id="2-비교"><a href="#2-비교" class="headerlink" title="2. 비교"></a>2. 비교</h1><ul><li><p>조금 더 확실하게 확인합니다.</p></li><li><p>위의 예제에 <b>offset = $\pm 5$</b>를 해서 <b>새로운 참값</b>을 만듭니다.</p></li><li><p>그리고, 여기서 같은 X 좌표의 데이터들을 학습용으로 추출합니다.<br><br><img src="123_gpr3_4.png"><br></p></li><li><p>여기에 똑같은 RBF 커널을 적용한 Gaussian Process를 적용하면 아래와 같은 결과가 나옵니다.</p></li><li><p>좌우 그림에서 <b>파란 선</b>으로 표시한 평균값의 양 끝이 향하는 방향이 반대입니다.<br></p></li><li><p><b>offset=+5</b>인 왼쪽 그림은 양 끝이 아래를 향하고 있고,</p></li><li><p><b>offset=-5</b>인 오른쪽 그림은 양 끝이 기를 쓰고 고개를 들려고 하고 있습니다.</p></li><li><p>모두 <b>0을 향하고 있습니다.</b><br><br><img src="123_gpr3_5.png"><br></p></li><li><p>양 끝만 영향을 받는 것이 아닙니다.</p></li><li><p>X = 6~8 사이 구간도 offset에 따라 달라집니다.</p></li><li><p>0에서 먼 왼쪽 그림은 신뢰 구간이 비교적 얇은 반면 오른쪽은 두텁고 mean 값도 참값과 더 벌어져 있습니다.</p></li></ul><h1 id="3-Solution"><a href="#3-Solution" class="headerlink" title="3. Solution"></a>3. Solution</h1><ul><li><p>해결 방법은 생각보다 간단합니다.</p></li><li><p>외삽(extrapolation)이 문제라면 외삽을 하지 않으면 됩니다.</p></li><li><p>학습 데이터에 데이터 범위의 양 끝을 추가하면 모든 범위가 내삽이 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sample including ends</span></span><br><span class="line">training_indices += [<span class="number">0</span>, <span class="number">999</span>]</span><br><span class="line">Xp_train1, Xm_train1 = Xp[training_indices], Xm[training_indices]</span><br><span class="line">yp_train1, ym_train1 = yp[training_indices], ym[training_indices]</span><br></pre></td></tr></table></figure></li><li><p>그리고 같은 학습을 시키면 offset에 관계 없이 동일한 결과를 얻을 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">6</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>, sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, X, y, X_train, y_train, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [Xp, Xm], [yp, ym], </span><br><span class="line">                                             [Xp_train1, Xm_train1], [yp_train1, ym_train1], </span><br><span class="line">                                             [<span class="string">&quot;offset = +5&quot;</span>, <span class="string">&quot;offset = -5&quot;</span>]):</span><br><span class="line">    <span class="comment"># Gaussian Process</span></span><br><span class="line">    gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, random_state=<span class="number">0</span>)</span><br><span class="line">    gpr.fit(X_train, y_train)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># prediction</span></span><br><span class="line">    y_pred_mean, y_pred_std = gpr.predict(X, return_std=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    ax.plot(X, y, c=<span class="string">&quot;0.5&quot;</span>, label=<span class="string">&quot;true&quot;</span>)</span><br><span class="line">    ax.scatter(X_train, y_train, label=<span class="string">&quot;sample&quot;</span>)</span><br><span class="line">    ax.plot(X.ravel(), y_pred_mean, c=<span class="string">&quot;b&quot;</span>, label=<span class="string">&quot;GP prediction (mean)&quot;</span>)</span><br><span class="line">    ax.fill_between(X.ravel(), y_pred_mean-<span class="number">1.96</span>*y_pred_std, y_pred_mean+<span class="number">1.96</span>*y_pred_std, alpha=<span class="number">0.5</span>, fc=<span class="string">&quot;cornflowerblue&quot;</span>, label=<span class="string">&quot;95% CI&quot;</span>)</span><br><span class="line">    ax.axhline(<span class="number">0</span>, c=<span class="string">&quot;g&quot;</span>, lw=<span class="number">1</span>)</span><br><span class="line">    ax.set_title(title, pad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">axs[<span class="number">0</span>].legend(loc=<span class="string">&quot;lower right&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="123_gpr3_6.png"><br></p></li></ul><h1 id="4-결론"><a href="#4-결론" class="headerlink" title="4. 결론"></a>4. 결론</h1><ul><li>머신 러닝 기법들이 모두 그렇지만 외삽은 주의해야 합니다.</li><li>Gaussian Process는 prior의 존재로 인해 외삽에 더 취약할 수 있으니 각별히 주의해야 합니다.</li><li>본 글에 사용된 코드는 <b><a href="gpr3.ipynb">여기에서 다운받으실 수 있습니다.</a></b></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/gaussian-process/">gaussian process</category>
      
      <category domain="https://jehyunlee.github.io/tags/bayesian/">bayesian</category>
      
      <category domain="https://jehyunlee.github.io/tags/scikit-learn/">scikit-learn</category>
      
      
    </item>
    
    <item>
      <title>Gaussian Process Practice (2) Kernels</title>
      <link>https://jehyunlee.github.io/2022/11/17/Python-DS-122-gpr2/</link>
      <guid>https://jehyunlee.github.io/2022/11/17/Python-DS-122-gpr2/</guid>
      <pubDate>Thu, 17 Nov 2022 10:22:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;Gaussian Process 연습입니다.&lt;/li&gt;
&lt;li&gt;scikit-learn을 비롯한 예제를 재구성하여 연습합니다.&lt;/li&gt;
&lt;li&gt;여러 커널의 특징을 알아보고 사용처를 알아봅니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-Data-</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>Gaussian Process 연습입니다.</li><li>scikit-learn을 비롯한 예제를 재구성하여 연습합니다.</li><li>여러 커널의 특징을 알아보고 사용처를 알아봅니다.</li></ul><h1 id="1-Data-Preparation"><a href="#1-Data-Preparation" class="headerlink" title="1. Data Preparation"></a>1. Data Preparation</h1><blockquote><p><a href="https://scikit-learn.org/stable/auto_examples/gaussian_process/plot_gpr_noisy_targets.html#sphx-glr-auto-examples-gaussian-process-plot-gpr-noisy-targets-py">scikit-learn: Gaussian Process Regression: basic introductory example</a></p></blockquote><h2 id="1-1-example-data"><a href="#1-1-example-data" class="headerlink" title="1.1. example data"></a>1.1. example data</h2><ul><li><a href="https://jehyunlee.github.io/2022/11/16/Python-DS-121-gpr1/">지난 글</a>과 같은 예제를 사용합니다.</li><li>오늘은 어제보다는 색을 많이 사용할 겁니다. 참값과 Gaussian Process 결과를 무채색으로 표현합니다.</li><li>관측값은 참값이라고 합시다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.gaussian_process <span class="keyword">import</span> GaussianProcessRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> RBF</span><br><span class="line"></span><br><span class="line"><span class="comment"># Random Number Generation</span></span><br><span class="line">rng = np.random.RandomState(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Gaussian Process Regression</span></span><br><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, random_state=<span class="number">0</span>)</span><br><span class="line">gpr.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prediction</span></span><br><span class="line">y_pred_mean, y_pred_std = gpr.predict(X, return_std=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br><span class="line">ax.plot(X, y, c=<span class="string">&quot;k&quot;</span>, label=<span class="string">&quot;true&quot;</span>)</span><br><span class="line">ax.scatter(X_train, y_train, fc=<span class="string">&quot;k&quot;</span>, label=<span class="string">&quot;sample without noise&quot;</span>)</span><br><span class="line"></span><br><span class="line">ax.plot(X.ravel(), y_pred_mean, c=<span class="string">&quot;0.5&quot;</span>, label=<span class="string">&quot;GP prediction (mean)&quot;</span>)</span><br><span class="line">ax.fill_between(X.ravel(), y_pred_mean-<span class="number">1.96</span>*y_pred_std, y_pred_mean+<span class="number">1.96</span>*y_pred_std, alpha=<span class="number">0.5</span>, fc=<span class="string">&quot;lightgray&quot;</span>, label=<span class="string">&quot;95% CI&quot;</span>)</span><br><span class="line">ax.legend(loc=<span class="string">&quot;upper left&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_3.png"><br></li></ul><h2 id="1-2-sample-추출"><a href="#1-2-sample-추출" class="headerlink" title="1.2. sample 추출"></a>1.2. sample 추출</h2><blockquote><p><a href="https://scikit-learn.org/stable/auto_examples/gaussian_process/plot_gpr_prior_posterior.html#sphx-glr-auto-examples-gaussian-process-plot-gpr-prior-posterior-py">scikit-learn: Illustration of prior and posterior Gaussian process for different kernels</a></p></blockquote><p><img src="ds.gif" alt="14,000,605개의 미래를 보는 닥터 스트레인지, 대혼돈의 멀티버스 中"></p><ul><li><p>신뢰구간에는 다양한 가능성이 내포되어 있습니다.</p></li><li><p>이들 중 일부를 골라 추출할 수 있습니다.</p></li><li><p>5개를 골라 Gaussian Process Regression 위에 얹어봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sampling</span></span><br><span class="line">n_samples=<span class="number">5</span></span><br><span class="line">y_samples = gpr.sample_y(X, n_samples)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prediction</span></span><br><span class="line">y_pred_mean, y_pred_std = gpr.predict(X, return_std=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br><span class="line">ax.plot(X, y, c=<span class="string">&quot;k&quot;</span>, label=<span class="string">&quot;true&quot;</span>)</span><br><span class="line">ax.scatter(X_train, y_train, fc=<span class="string">&quot;k&quot;</span>, label=<span class="string">&quot;sample without noise&quot;</span>)</span><br><span class="line"></span><br><span class="line">ax.plot(X.ravel(), y_pred_mean, c=<span class="string">&quot;0.5&quot;</span>, label=<span class="string">&quot;GP prediction (mean)&quot;</span>)</span><br><span class="line">ax.fill_between(X.ravel(), y_pred_mean-<span class="number">1.96</span>*y_pred_std, y_pred_mean+<span class="number">1.96</span>*y_pred_std, alpha=<span class="number">0.5</span>, fc=<span class="string">&quot;lightgray&quot;</span>, label=<span class="string">&quot;95% CI&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> y_sample <span class="keyword">in</span> y_samples.T:</span><br><span class="line">    ax.plot(X.ravel(), y_sample, lw=<span class="number">1</span>, ls=<span class="string">&quot;:&quot;</span>, label=<span class="string">&quot;GP prediction (mean)&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="122_gpr2_4.png"><br></p></li><li><p>대부분 신뢰구간 안에 들어와 있지만 일부는 신뢰구간 밖으로도 나가 있습니다.</p></li><li><p>정상입니다.</p></li></ul><h2 id="1-3-posterior-vs-prior"><a href="#1-3-posterior-vs-prior" class="headerlink" title="1.3. posterior vs prior"></a>1.3. posterior vs prior</h2><ul><li><p>지금 그린 그림은 evidence가 반영된 결과, 즉 <b>posterior(사후확률)</b>입니다.</p></li><li><p>학습을 시키지 않은 채 예측을 하고 sample curve를 뽑을 수도 있습니다.</p></li><li><p>evidence가 반영되기 전의 <b>prior(사전확률)</b>입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prior</span></span><br><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sampling</span></span><br><span class="line">y_samples = gpr.sample_y(X, n_samples)</span><br></pre></td></tr></table></figure><p><img src="122_gpr2_5.png"><br></p></li><li><p>관측값이 반영되어 있지 않기 때문에 데이터와는 무관한 모습입니다.</p></li><li><p>그러나 곡선의 모양에는 우리가 선택한 RBF 커널이 드러나 있습니다.</p></li><li><p>학습에 커널이 반영되는만큼 <b>데이터의 모습을 반영</b>해 <b>커널을 선정</b>해야 합니다.</p></li><li><p>scikit-learn이 지원하는 커널들의 prior와 posterior를 살펴보겠습니다.</p></li></ul><h1 id="2-Kernels"><a href="#2-Kernels" class="headerlink" title="2. Kernels"></a>2. Kernels</h1><blockquote><p><a href="https://pasus.tistory.com/209">Deep Campus: 가우시안 프로세스의 개념</a><br><a href="https://towardsdatascience.com/understanding-gaussian-process-the-socratic-way-ba02369d804">towardsdatascience: Understanding Gaussian Process, the Socratic Way</a><br><a href="https://thegradient.pub/gaussian-process-not-quite-for-dummies/">The Gradient, Gaussian process not quite for dummies</a></p></blockquote><h2 id="2-1-커널의-정체"><a href="#2-1-커널의-정체" class="headerlink" title="2.1. 커널의 정체"></a>2.1. 커널의 정체</h2><ul><li><p>Gaussian Process의 커널은 covariance function입니다. </p></li><li><p>서로 다른 두 점 $x_i$와 $x_j$와의 상호 연관성을 나타냅니다.</p></li><li><p>이 함수를 커널 함수라고 하며, <b>Radial basis function</b>은 다음과 같이 정의됩니다.<br>$$k(x_i, x_j) = \exp\left(- \frac{d(x_i, x_j)^2}{2l^2} \right)$$</p></li><li><p>$x_i$와 $x_j$의 거리가 같아도 $l$이 크면 $k$가 큽니다: 먼 거리의 데이터까지 연관성을 가진다는 뜻입니다.</p></li><li><p>$x_i = x_j$ 일때 공분산은 최대값으로 1을 가집니다.</p></li><li><p>그렇다면 $x_i$과 $x_j$ 사이의 한 점은 두 점 모두와의 공분산을 최대한 높이는 방향으로 결정될텐데</p></li><li><p>Gaussian Process는 결정변수가 아니라 확률변수이므로 <b>확률</b>이 높을 뿐 조금씩 변합니다.</p></li><li><p>이로 인해 아무런 관찰값이 입력되지 않아도(prior) <b>RBF</b>의 sample 함수는 <b>랜덤하게 매끈한 곡선</b>을 이룹니다.</p></li></ul><ul><li>같은 이유로 참값으로 관측값이 지정되면(posterior) <b>관측값과 관측값 사이를 최대한 매끈하게 잇는 곡선의 존재 범위</b>가 도출됩니다.</li><li>그렇다면, <b>커널 함수가 바뀌면 예측값이 바뀔 것</b>이라는 것을 상상할 수 있으며</li><li><b>데이터의 성격에 맞는 커널 함수가 있음</b>을 예상할 수도 있습니다.</li><li>최적값을 얻는 방법으로 <b>MLE(Maximum Likelihood Estimation)</b>이 사용됩니다.</li><li><code>log_marginal_likelihood()</code> 메소드를 사용해 결과값을 추출할 수 있습니다.</li></ul><ul><li>커널 종류를 바꾸며 prior와 posterior를 관찰합니다.</li><li><b>커널을 입력받는 시각화 함수</b>를 아래와 같이 준비합니다.</li><li>코드가 길어 접어두었습니다.<details>  <summary><b>코드 보기/접기</b></summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">plt.rcParams[<span class="string">&#x27;mathtext.fontset&#x27;</span>] = <span class="string">&quot;cm&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_pp</span>(<span class="params">kernel, kernel_name=<span class="string">&quot;&quot;</span>, X_train=X_train, y_train=y_train, X_true=X, y_true=y, n_samples=<span class="number">5</span></span>):</span></span><br><span class="line">    gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, random_state=<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># prior</span></span><br><span class="line">    y_prior_mean, y_prior_std = gpr.predict(X_true, return_std=<span class="literal">True</span>)</span><br><span class="line">    y_prior_samples = gpr.sample_y(X_true, n_samples)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># posterior</span></span><br><span class="line">    gpr.fit(X_train, y_train)</span><br><span class="line">    y_posterior_mean, y_posterior_std = gpr.predict(X_true, return_std=<span class="literal">True</span>)</span><br><span class="line">    y_posterior_samples = gpr.sample_y(X_true, n_samples)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># kernel after fitting</span></span><br><span class="line">    kernel_ = gpr.kernel_</span><br><span class="line">    theta = gpr.kernel_.theta</span><br><span class="line">    ll = gpr.log_marginal_likelihood(theta)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># visualize</span></span><br><span class="line">    fig, axs = plt.subplots(nrows=<span class="number">2</span>, figsize=(<span class="number">6</span>, <span class="number">4</span>), sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>, constrained_layout=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> ax, y_mean, y_std, y_samples, title, k <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [y_prior_mean, y_posterior_mean], </span><br><span class="line">                                                           [y_prior_std, y_posterior_std], [y_prior_samples, y_posterior_samples],</span><br><span class="line">                                                           [<span class="string">&quot;prior&quot;</span>, <span class="string">&quot;posterior&quot;</span>], [kernel, kernel_]):</span><br><span class="line">        <span class="comment"># true</span></span><br><span class="line">        ax.plot(X_true, y_true, c=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">        ax.scatter(X_train, y_train, fc=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># pred</span></span><br><span class="line">        ax.plot(X_true.ravel(), y_mean, c=<span class="string">&quot;0.5&quot;</span>)</span><br><span class="line">        ax.fill_between(X_true.ravel(), y_mean-<span class="number">1.96</span>*y_std, y_mean+<span class="number">1.96</span>*y_std, alpha=<span class="number">0.5</span>, fc=<span class="string">&quot;lightgray&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># samples</span></span><br><span class="line">        <span class="keyword">for</span> y_sample <span class="keyword">in</span> y_samples.T:</span><br><span class="line">            ax.plot(X_true.ravel(), y_sample, lw=<span class="number">1</span>, ls=<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># title</span></span><br><span class="line">        ax.text(<span class="number">0.18</span>, <span class="number">0.97</span>, title, fontsize=<span class="string">&quot;large&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>, color=<span class="string">&quot;b&quot;</span>, ha=<span class="string">&quot;right&quot;</span>, va=<span class="string">&quot;top&quot;</span>, transform=ax.transAxes)</span><br><span class="line">        str_k = <span class="built_in">str</span>(k).replace(<span class="string">&#x27; ** &#x27;</span>,<span class="string">&#x27;^&#x27;</span>).replace(<span class="string">&#x27;**&#x27;</span>,<span class="string">&#x27;^&#x27;</span>).replace(<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;\cdot&#x27;</span>).replace(<span class="string">&#x27;length_scale&#x27;</span>,<span class="string">&#x27;l&#x27;</span>).replace(<span class="string">&#x27;alpha&#x27;</span>,<span class="string">&#x27;\\alpha&#x27;</span>).replace(<span class="string">&#x27;periodicity&#x27;</span>, <span class="string">&#x27;p&#x27;</span>).replace(<span class="string">&#x27;sigma&#x27;</span>,<span class="string">&#x27;\\sigma&#x27;</span>).replace(<span class="string">&#x27;nu&#x27;</span>,<span class="string">&#x27;\\nu&#x27;</span>)</span><br><span class="line">        ax.text(<span class="number">0.2</span>, <span class="number">0.97</span>, <span class="string">&quot;kernel: &quot;</span> + <span class="string">f&quot;$<span class="subst">&#123;str_k&#125;</span>$&quot;</span>, ha=<span class="string">&quot;left&quot;</span>, va=<span class="string">&quot;top&quot;</span>, color=<span class="string">&quot;darkblue&quot;</span>, transform=ax.transAxes)</span><br><span class="line">        </span><br><span class="line">    axs[<span class="number">1</span>].text(<span class="number">0.105</span>, <span class="number">0.84</span>, <span class="string">&quot;Log-likelihood: &quot;</span> + <span class="string">f&quot;$&#123;&#123;<span class="subst">&#123;ll:<span class="number">.3</span>f&#125;</span>&#125;&#125;$&quot;</span>, ha=<span class="string">&quot;left&quot;</span>, va=<span class="string">&quot;top&quot;</span>, color=<span class="string">&quot;darkblue&quot;</span>, transform=axs[<span class="number">1</span>].transAxes)</span><br><span class="line">    str_theta = <span class="string">&quot;, &quot;</span>.join([<span class="string">f&quot;<span class="subst">&#123;t:<span class="number">.3</span>f&#125;</span>&quot;</span> <span class="keyword">for</span> t <span class="keyword">in</span> theta])</span><br><span class="line">    axs[<span class="number">1</span>].text(<span class="number">0.265</span>, <span class="number">0.71</span>, <span class="string">f&quot;$\\theta: (&#123;&#123;<span class="subst">&#123;str_theta&#125;</span>&#125;&#125;)$&quot;</span>, ha=<span class="string">&quot;left&quot;</span>, va=<span class="string">&quot;top&quot;</span>, color=<span class="string">&quot;darkblue&quot;</span>, transform=axs[<span class="number">1</span>].transAxes)</span><br><span class="line">    fig.suptitle(kernel_name, fontsize=<span class="string">&quot;x-large&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fig</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2-Radial-Basis-Function"><a href="#2-2-Radial-Basis-Function" class="headerlink" title="2.2. Radial Basis Function"></a>2.2. Radial Basis Function</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.RBF.html">scikit-learn: RBF Kernel</a></p></blockquote><ul><li>Gaussian Process의 가장 기본이 되는 커널입니다.</li><li>매끈한 곡선이 우리가 알고 있는 가장 기본적인 모양입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;Radial Basis Function&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_6.png"><br></li></ul><h2 id="2-2-White-Kernel"><a href="#2-2-White-Kernel" class="headerlink" title="2.2. White Kernel"></a>2.2. White Kernel</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.WhiteKernel.html">scikit-learn: White Kernel</a></p></blockquote><p>$$k(x_i, x_j) = noise \_ level \text{ if } x_i == x_j \text{ else } 0$$</p><ul><li>단독으로 사용되기보다 다른 커널에 더해져 노이즈 레벨을 측정하는데 활용됩니다.</li><li>아래 예제에서는 RBF와의 합으로 사용되었으며, posterior에서 noise level = $1.13 \times 10^{-8}$에 불과합니다.</li><li>prior의 noise level이 데이터를 만나 0에 가깝게 수렴한 것입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> WhiteKernel</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>)) + WhiteKernel(noise_level=<span class="number">1</span>, noise_level_bounds=(<span class="number">1e-8</span>, <span class="number">1e1</span>))</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;Radial Basis Function + White Noise&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_11.png"><br></li></ul><h2 id="2-3-Radial-Quadratic-Kernel"><a href="#2-3-Radial-Quadratic-Kernel" class="headerlink" title="2.3. Radial Quadratic Kernel"></a>2.3. Radial Quadratic Kernel</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.RationalQuadratic.html">scikit-learn: Rational Quadratic Kernel</a></p></blockquote><p>$$k(x_i, x_j) = \left(1 + \frac{d(x_i, x_j)^2 }{ 2\alpha  l^2}\right)^{-\alpha}$$</p><ul><li>RBF Kernel과 다른 거리 스케일링의 혼합 척도(scale mixture)로 볼 수 있습니다.</li><li>prior에서는 RBF 커널에 비해 곧게 펴진 듯한 모습이지만 posterior는 RBF와 잘 구분되지 않습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> RationalQuadratic</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1.0</span> * RationalQuadratic(length_scale=<span class="number">1.0</span>, alpha=<span class="number">0.1</span>, alpha_bounds=(<span class="number">1e-5</span>, <span class="number">1e15</span>))</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;Radial Quadratic Function&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_7.png"><br></li></ul><h2 id="2-4-Constant-Kernel"><a href="#2-4-Constant-Kernel" class="headerlink" title="2.4. Constant Kernel"></a>2.4. Constant Kernel</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.ConstantKernel.html">scikit-learn: Constant Kernel</a></p></blockquote><p>$$k(x_1, x_2) = constant\_value ;\forall; x_1, x_2$$</p><ul><li>글자 그대로 상수 커널입니다.</li><li>White Kernel과 유사하게 다른 커널과 함께 사용됩니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> ConstantKernel</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1.0</span> * ConstantKernel(constant_value=<span class="number">1.0</span>, constant_value_bounds=(<span class="number">1e-5</span>, <span class="number">1e15</span>))</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;Constant Kernel&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_15.png"><br></li></ul><h2 id="2-5-Exp-Sine-Squared-Kernel-periodic-kernel"><a href="#2-5-Exp-Sine-Squared-Kernel-periodic-kernel" class="headerlink" title="2.5. Exp-Sine-Squared Kernel (periodic kernel)"></a>2.5. Exp-Sine-Squared Kernel (periodic kernel)</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.ExpSineSquared.html">scikit-learn: ExpSineSquared</a></p></blockquote><p>$$k(x_i, x_j) = \text{exp}\left(-\frac{ 2\sin^2(\pi d(x_i, x_j)/p) }{ l^ 2} \right)$$</p><ul><li>지수함수에 sine함수의 제곱이 포함된 형태입니다.</li><li>주기성을 갖는 데이터를 묘사하기 좋으며 length scale $l &gt; 0$과 함께 periodicity $p &gt; 0$를 매개변수로 가집니다.</li><li>$p$는 Euclidean distance입니다.</li><li>prior와 posterior 모두 자세히 보면 주기성을 띄고 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> ExpSineSquared</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1.0</span> * ExpSineSquared(</span><br><span class="line">    length_scale=<span class="number">1.0</span>,</span><br><span class="line">    periodicity=<span class="number">3.0</span>,</span><br><span class="line">    length_scale_bounds=(<span class="number">0.1</span>, <span class="number">10.0</span>),</span><br><span class="line">    periodicity_bounds=(<span class="number">1.0</span>, <span class="number">10.0</span>),</span><br><span class="line">)</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;ExpSineSquared&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_8.png"><br></li></ul><h2 id="2-6-Dot-Product"><a href="#2-6-Dot-Product" class="headerlink" title="2.6. Dot Product"></a>2.6. Dot Product</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.DotProduct.html?highlight=dotproduct#sklearn.gaussian_process.kernels.DotProduct">scikit-learn: Dot Product</a></p></blockquote><p>$$k(x_i, x_j) = \sigma_0 ^ 2 + x_i \cdot x_j$$</p><ul><li><p>앞에서 본 커널들은 형태는 달라도 두 점 사이의 거리 $d(x_i, x_j)$를 주요 인자로 가집니다.</p></li><li><p>이런 커널을 <b>stationary kernel</b>이라고 합니다.</p></li><li><p>반면 $x_i$, $x_j$ 값 자체에 의해 좌우되는 커널을 <b>non-stationary kernel</b>이라고 합니다.</p></li><li><p>dot product로 정의되기 때문에 원점으로부터의 회전에는 무관하지만 transition에는 민감하게 반응합니다.</p></li><li><p>$\sigma_0 = 0$이라면 homogeneous linear kernel, $\sigma_0 \neq 0$이라면 inhomogeneous가 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1st degree</span></span><br><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> DotProduct</span><br><span class="line"></span><br><span class="line">kernel = DotProduct(sigma_0=<span class="number">1.0</span>, sigma_0_bounds=(<span class="number">0.1</span>, <span class="number">100.0</span>))</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;DotProduct&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="122_gpr2_9.png"><br></p></li><li><p>제곱식을 통해 다항식을 만들 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3rd degree</span></span><br><span class="line">kernel = DotProduct(sigma_0=<span class="number">1.0</span>, sigma_0_bounds=(<span class="number">0.1</span>, <span class="number">100.0</span>))**<span class="number">3</span></span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;DotProduct&quot;</span>)</span><br><span class="line">fig.axes[<span class="number">1</span>].set_ylim(-<span class="number">25</span>, <span class="number">25</span>)</span><br></pre></td></tr></table></figure><p><img src="122_gpr2_16.png"><br></p></li></ul><h2 id="2-7-Matern-Kernel"><a href="#2-7-Matern-Kernel" class="headerlink" title="2.7. Matérn Kernel"></a>2.7. Matérn Kernel</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.Matern.html#sklearn.gaussian_process.kernels.Matern">scikit-learn: Matern</a></p></blockquote><p>$$k(x_i, x_j) =  \frac{1}{\Gamma(\nu)2^{\nu-1}}\Bigg(\frac{\sqrt{2\nu}}{l} d(x_i , x_j )\Bigg)^\nu K_\nu\Bigg(\frac{\sqrt{2\nu}}{l} d(x_i , x_j )\Bigg)$$</p><ul><li>RBF의 일반화된 버전입니다.</li><li>$\nu$로 결과 함수의 smoothness를 조절하는데 $\nu$가 $\infty$에 접근할수록 RBF에 가까워집니다.</li><li>위 식의 $K_{\nu}(\cdot)$는 modified Bessel function, $\Gamma(\cdot)$는 gamma function입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> Matern</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1.0</span> * Matern(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-1</span>, <span class="number">10.0</span>), nu=<span class="number">1.5</span>)</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;Matérn&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_10.png"><br></li></ul><h2 id="3-결론"><a href="#3-결론" class="headerlink" title="3. 결론"></a>3. 결론</h2><ul><li>Gaussian Process는 임의의 적은 데이터로 멋진 결과물을 만들어내지만 Kernel function에 크게 좌우됩니다.</li><li>문제의 성격과 데이터의 특성에 맞는 적절한 Kernel 선택이 매우 중요합니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/gaussian-process/">gaussian process</category>
      
      <category domain="https://jehyunlee.github.io/tags/bayesian/">bayesian</category>
      
      <category domain="https://jehyunlee.github.io/tags/scikit-learn/">scikit-learn</category>
      
      
    </item>
    
    <item>
      <title>Gaussian Process Practice (1) 1D</title>
      <link>https://jehyunlee.github.io/2022/11/16/Python-DS-121-gpr1/</link>
      <guid>https://jehyunlee.github.io/2022/11/16/Python-DS-121-gpr1/</guid>
      <pubDate>Wed, 16 Nov 2022 12:38:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;Gaussian Process 연습입니다.&lt;/li&gt;
&lt;li&gt;scikit-learn을 비롯한 예제를 재구성하여 연습합니다.&lt;/li&gt;
&lt;li&gt;오차가 없을 때와 있을 때를 비교합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-Data-Prepa</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>Gaussian Process 연습입니다.</li><li>scikit-learn을 비롯한 예제를 재구성하여 연습합니다.</li><li>오차가 없을 때와 있을 때를 비교합니다.</li></ul><h1 id="1-Data-Preparation"><a href="#1-Data-Preparation" class="headerlink" title="1. Data Preparation"></a>1. Data Preparation</h1><blockquote><p><a href="https://scikit-learn.org/stable/auto_examples/gaussian_process/plot_gpr_noisy_targets.html#sphx-glr-auto-examples-gaussian-process-plot-gpr-noisy-targets-py">scikit-learn: Gaussian Process Regression: basic introductory example</a></p></blockquote><h2 id="1-1-example-data"><a href="#1-1-example-data" class="headerlink" title="1.1. example data"></a>1.1. example data</h2><ul><li><p>Gaussian Process 연습을 위한 데이터를 준비합니다.</p></li><li><p><a href="https://scikit-learn.org/stable/auto_examples/gaussian_process/plot_gpr_noisy_targets.html#sphx-glr-auto-examples-gaussian-process-plot-gpr-noisy-targets-py">scikit-learn의 예제</a>를 일부 변형합니다.</p></li><li><p>1000개로 이루어진 매끈한 곡선을 만듭니다. </p></li><li><p>이번 글에서는 랜덤 함수를 많이 사용합니다. <b>random number generator</b>를 정의해 재현성을 확보합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 라이브러리 및 random number generator</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">rng = np.random.RandomState(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># example data visualization</span></span><br><span class="line">X = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">1000</span>).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">y = np.squeeze(X*np.sin(X))</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">ax.plot(X, y)</span><br></pre></td></tr></table></figure><p><img src="121_gpr1_1.png"><br></p></li><li><p>지금 그린 그래프는 우리가 Gaussian Process로 찾아야 할 참값입니다.</p></li></ul><h2 id="1-2-6-training-points"><a href="#1-2-6-training-points" class="headerlink" title="1.2. 6 training points"></a>1.2. 6 training points</h2><ul><li>임의의 x 좌표 6개를 골라 예제 데이터를 뽑습니다. <b>측정값(evidence)</b>이라 볼 수 있습니다.</li><li>두 가지 상황을 가정해 이 지점들로 참값 곡선을 찾아갈 것입니다.</li><li><b>① 측정을 하면 정확한 값을 찾아내는 경우:</b> 딱 6개만 뽑으면 됩니다.</li><li><b>② 측정이 불확실성을 안고 있는 경우: </b> x 하나당 10번씩 측정했다고 하겠습니다. 표준 편차 = 1입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">training_indices = rng.choice(np.arange(y.size), size=<span class="number">6</span>, replace=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ① exact observation</span></span><br><span class="line">X_train = X[training_indices]</span><br><span class="line">y_train = y[training_indices]</span><br><span class="line"></span><br><span class="line"><span class="comment"># ② noisy situation</span></span><br><span class="line">noise_std = <span class="number">1</span></span><br><span class="line">X_train_noisy = np.array(X[training_indices].tolist()*<span class="number">10</span>)</span><br><span class="line">y_train_noisy = np.array(<span class="built_in">list</span>(y[training_indices])*<span class="number">10</span>) + rng.normal(<span class="number">0</span>, noise_std, size=y_train.shape[<span class="number">0</span>]*<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">ax.plot(X, y, c=<span class="string">&quot;lightgray&quot;</span>, label=<span class="string">&quot;true&quot;</span>)</span><br><span class="line">ax.scatter(X_train, y_train, label=<span class="string">&quot;sample without noise&quot;</span>)</span><br><span class="line">ax.scatter(X_train_noisy, y_train_noisy, label=<span class="string">&quot;sample with noise&quot;</span>, s=<span class="number">5</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">ax.legend()</span><br></pre></td></tr></table></figure><img src="121_gpr1_2.png"><br></li></ul><h1 id="2-Gaussian-Process"><a href="#2-Gaussian-Process" class="headerlink" title="2. Gaussian Process"></a>2. Gaussian Process</h1><h2 id="2-1-Without-Noise"><a href="#2-1-Without-Noise" class="headerlink" title="2.1. Without Noise"></a>2.1. Without Noise</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.RBF.html">scikit-learn: Radial basis function kernel</a><br><a href="https://thegradient.pub/gaussian-process-not-quite-for-dummies/">The Gradient: Gaussian Process, not quite for dummies</a></p></blockquote><ul><li><p>evidence가 참값인 경우의 Gaussian Process를 실행합니다.</p></li><li><p>커널에는 Radial Bassis Function 커널을 사용합니다.</p></li><li><p>length_scale 초기값은 1, 범위는 0.01부터 100 안에서 fitting합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process <span class="keyword">import</span> GaussianProcessRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> RBF</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>)</span><br><span class="line">gpr.fit(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(gpr.kernel_)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5.02**2 * RBF(length_scale=1.43)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>fitting 결과 1로 지정했던 계수와 <code>length_scale</code>이 변경되었습니다.</p></li><li><p>계수는 신뢰구간의 폭, <code>length_scale</code>은 곡선의 매끈함(smoothness)에 해당합니다.<br><br><img src="121_gpr1_10.png" alt="The Gradient"><br><br><img src="121_gpr1_11.png" alt="The Gradient"><br></p></li><li><p>다음 명령으로 추가 정보를 얻을 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpr.kernel_.theta</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([3.22768806, 0.36021977])</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>gpr.kernel_theta</code>는 <code>(flattened, log-transformed) non-fixed hyperparameters</code>입니다.</p></li><li><p>전체 X를 넣고 Gaussian Process 결과를 그림으로 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prediction</span></span><br><span class="line">y_pred_mean, y_pred_std = gpr.predict(X, return_std=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="121_gpr1_3.png"><br></p></li><li><p>확대를 해도 측정값은 신뢰구간의 폭이 0임을 확인할 수 있습니다.</p></li><li><p>측정된 데이터를 참값으로 가정했으므로 측정값의 분산은 0입니다.</p></li></ul><h2 id="2-2-With-Noise"><a href="#2-2-With-Noise" class="headerlink" title="2.2. With Noise"></a>2.2. With Noise</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.GaussianProcessRegressor.html#sklearn.gaussian_process.GaussianProcessRegressor">scikit-learn: GaussianProcessRegressor</a></p></blockquote><ul><li>이번에는 측정 데이터에 오차가 포함된 경우를 살펴봅니다.</li><li>오차가 있는 데이터는 <code>GaussianProcessRegressor()</code>에 측정 오차를 의미하는 매개변수 <code>alpha</code>를 추가해야 합니다.</li><li>수식에서는 커널 행렬의 대각 요소에 추가되는 값으로 fitting시 발생하는 numerical issue를 예방합니다. </li></ul><h3 id="2-2-1-오차-데이터-직접-입력"><a href="#2-2-1-오차-데이터-직접-입력" class="headerlink" title="2.2.1. 오차 데이터 직접 입력"></a>2.2.1. 오차 데이터 직접 입력</h3><ul><li><p>아까와 동일하게 Gaussian Process fitting을 수행합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">gpr.fit(X_train_noisy, y_train_noisy)</span><br><span class="line"><span class="built_in">print</span>(gpr.kernel_)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.92**2 * RBF(length_scale=1.37)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>아까와는 다른 값으로 수렴했습니다.</p></li><li><p>다시 전체 X를 넣고 예측 결과를 확인합니다.</p></li><li><p>참값은 입력하지 않았지만 대조를 위해 함께 도시합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prediction</span></span><br><span class="line">y_pred_mean, y_pred_std = gpr.predict(X, return_std=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="121_gpr1_4.png"><br></p></li><li><p>데이터를 확보한 곳에서도 불확실성에 의해 신뢰구간이 한 점으로 수렴하지 않습니다.</p></li><li><p>아울러 전체의 평균값도 참값에서 조금씩 어긋나 있음을 확인할 수 있습니다.</p></li></ul><h3 id="2-2-2-오차-분산-입력"><a href="#2-2-2-오차-분산-입력" class="headerlink" title="2.2.2. 오차 분산 입력"></a>2.2.2. 오차 분산 입력</h3><ul><li>이번에는 모든 데이터를 입력하는 대신 <b>참값</b>데이터와 함께 <b>분산</b>을 입력합니다.</li><li>앞서 noise를 만들 때 표준 편차 = 1을 입력했는데 정말 그런지 확인합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df_noisy = pd.DataFrame(&#123;<span class="string">&quot;X_noisy&quot;</span>:X_train_noisy.ravel(), <span class="string">&quot;y_noisy&quot;</span>:y_train_noisy&#125;)</span><br><span class="line">dfg_noisy = df_noisy.groupby(<span class="string">&quot;X_noisy&quot;</span>).std()</span><br><span class="line">std = dfg_noisy.mean().values[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(std)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.0616168585081918</span><br></pre></td></tr></table></figure></li></ul></li><li>의도한 바와 같이 데이터의 평균 분산은 1과 유사한 값으로 나왔습니다.</li><li>애초에 의도한 값 1을 제곱하여 <code>alpha</code>에 입력하고 Gaussian Process를 진행합니다.</li><li>계수가 아까보다 작게 나왔습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, alpha=<span class="number">1</span>**<span class="number">2</span>)</span><br><span class="line">gpr.fit(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(gpr.kernel_)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.39**2 * RBF(length_scale=1.16)</span><br></pre></td></tr></table></figure></li></ul></li><li>같은 코드로 그림을 그려 확인합니다.</li><li>줄어든 계수가 무색하게 전체적으로 신뢰구간이 더 넓은 듯한 느낌입니다.<br><img src="121_gpr1_5.png"><br></li></ul><h3 id="2-2-3-alpha가-같을-때-데이터-수에-따른-비교"><a href="#2-2-3-alpha가-같을-때-데이터-수에-따른-비교" class="headerlink" title="2.2.3. alpha가 같을 때 데이터 수에 따른 비교"></a>2.2.3. alpha가 같을 때 데이터 수에 따른 비교</h3><ul><li><p>noisy data를 직접 입력했을 때와 모양이 달라진 것이 데이터에 무관한, alpha에 따른 차이가 아닐까 의구심이 듭니다.</p></li><li><p><code>alpha=1</code>로 설정하고 noisy data로 학습시킨 후 양상을 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, alpha=<span class="number">1</span>)</span><br><span class="line">gpr.fit(X_train_noisy, y_train_noisy)</span><br><span class="line"><span class="built_in">print</span>(gpr.kernel_)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.84**2 * RBF(length_scale=1.34)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>값이 조금 다르기는 하지만 noisy data를 입력했을 때에 가깝습니다.</p></li><li><p>그래프 모양을 보면 더 확연하게 드러납니다.<br><img src="121_gpr1_8.png"><br></p></li></ul><h3 id="2-2-4-커널-parameter-범위에-따른-결과"><a href="#2-2-4-커널-parameter-범위에-따른-결과" class="headerlink" title="2.2.4. 커널 parameter 범위에 따른 결과"></a>2.2.4. 커널 parameter 범위에 따른 결과</h3><ul><li><p>앞서 kernel을 다음과 같이 정의했습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br></pre></td></tr></table></figure></li><li><p>RBF kernel의 length scale이 가질 수 있는 범위를 0.01 ~ 100으로 지정한 것입니다.</p></li><li><p>그리고 결과적으로 입력된 데이터에 의해 <code>length scale = 1.16</code>로 결정되었습니다.</p></li><li><p>그런데 초기값의 범위가 이 밖에 있으면 전혀 다른 결과가 얻어집니다.</p></li><li><p>먼저, length scale이 너무 클 때입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">100</span>, length_scale_bounds=(<span class="number">10</span>, <span class="number">1e3</span>))</span><br></pre></td></tr></table></figure></li><li><p>초기값을 100, 범위를 10~1000으로 잡으면 결과적으로 <code>316**2 * RBF(length_scale=10)</code>에 수렴합니다.</p></li><li><p>이 때 결과는 다음과 같습니다.</p></li><li><p>지나친 과소적합(underfitting)으로 인해 x=0 부근에서 참값을 따라가지 못하고 평균값이 40 가까이 발산해 버렸습니다.<br><img src="121_gpr1_6.png"><br></p></li></ul><ul><li><p>이번에는 거꾸로 kernel의 length_scale이 너무 작은 경우입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">0.01</span>, length_scale_bounds=(<span class="number">1e-4</span>, <span class="number">1e-1</span>))</span><br></pre></td></tr></table></figure></li><li><p>학습 결과 kernel이 <code>4.16**2 * RBF(length_scale=0.01)</code>로, length scale이 입력된 범위의 최대값에 닿았습니다.</p></li><li><p>결과적으로 과대적합(overfitting)이라고 불러야 할지 애매하지만 측정값 외에는 미동도 하지 않았습니다.<br><img src="121_gpr1_7.png"><br></p></li></ul><h1 id="3-결론"><a href="#3-결론" class="headerlink" title="3. 결론"></a>3. 결론</h1><ul><li>Gaussian Process는 적은 데이터로 오차를 포함한 결과를 효과적으로 추론합니다.</li><li>그러나 커널의 제약에 민감하기 때문에 주의깊게 살펴볼 필요가 있습니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/gaussian-process/">gaussian process</category>
      
      <category domain="https://jehyunlee.github.io/tags/bayesian/">bayesian</category>
      
      <category domain="https://jehyunlee.github.io/tags/scikit-learn/">scikit-learn</category>
      
      
    </item>
    
    <item>
      <title>딥러닝 공개 모델 활용 정보 수집 효율화</title>
      <link>https://jehyunlee.github.io/2022/11/11/Python-DS-120-eost2022/</link>
      <guid>https://jehyunlee.github.io/2022/11/11/Python-DS-120-eost2022/</guid>
      <pubDate>Fri, 11 Nov 2022 13:13:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;&lt;a href=&quot;https://www.etri.re.kr/&quot;&gt;한국전자통신연구원&lt;/a&gt;&lt;/b&gt; 오픈소스센터가 주축이 되어 &lt;b&gt;ETRI Open Source Tech Day&lt;/b&gt;가 열렸습니다.&lt;ul&gt;
&lt;li&gt;과학기술정보통신부가 주</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b><a href="https://www.etri.re.kr/">한국전자통신연구원</a></b> 오픈소스센터가 주축이 되어 <b>ETRI Open Source Tech Day</b>가 열렸습니다.<ul><li>과학기술정보통신부가 주최하고</li><li>한국전자통신연구원, 한국과학기술정보연구원, 한국식품연구원, 한국에너지기술연구원, 한국원자력연구원, 한국화학연구원, 한국항공우주연구원이 공동 주관했습니다.<br></li></ul></li></ul><ul><li>2021년 <b><a href="https://www.youtube.com/watch?v=X3FjEzfHsyc">내가 해온 연구에 데이터 분석 끼얹기</a></b>라는 제목으로 온라인 발표를 했고,</li><li>올해는 오프라인으로 <b>딥러닝 공개 모델 활용 정보 수집 효율화</b> 발표를 진행했습니다.<ul><li>저희 연구원 글로벌전략실과 협업을 진행하는 내용을 공개했습니다.</li><li>해외 연구원과 효과적인 협업을 위해 현황과 양측의 상대적 장단점을 파악했습니다.<br></li></ul></li></ul><ul><li>발표 영상 : <a href="https://youtu.be/epOab26Zsas">Youtube Link</a><br><p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/epOab26Zsas" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><img src="kier.PNG"><br><br></p><ul><li>행사 홈페이지: <a href="https://eostday.kr/">https://eostday.kr/</a><br><br><img src="EOST2022-EDM-v1.3.jpg" alt="EOST2022 일정표"></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/EOST/">EOST</category>
      
      <category domain="https://jehyunlee.github.io/tags/natural-language-processing/">natural language processing</category>
      
      <category domain="https://jehyunlee.github.io/tags/ETRI/">ETRI</category>
      
      
    </item>
    
    <item>
      <title>gaussian process</title>
      <link>https://jehyunlee.github.io/2022/11/04/Python-DS-119-kierlecture7/</link>
      <guid>https://jehyunlee.github.io/2022/11/04/Python-DS-119-kierlecture7/</guid>
      <pubDate>Fri, 04 Nov 2022 07:18:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;한국에너지기술연구원 AI 학습조직&lt;/b&gt;에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.&lt;ul&gt;
&lt;li&gt;실험을 계획하고 최적 실험 조건을 탐색하는 방법들을 살펴봅니다.&lt;/li&gt;
&lt;li&gt;전통적인 실험계획법(design of</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b>한국에너지기술연구원 AI 학습조직</b>에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.<ul><li>실험을 계획하고 최적 실험 조건을 탐색하는 방법들을 살펴봅니다.</li><li>전통적인 실험계획법(design of experiment), 반응표면법(response surface method)을 살펴보고,</li><li>효과적인 실험 설계를 도와주는 Gaussian Process와 이 바탕에 깔린 베이즈 법칙(Bayes’ Rule)을 살펴봅니다.</li><li><a href="221104_%EC%9D%B4%EC%A0%9C%ED%98%84_8%EC%B0%A8%EB%AA%A8%EC%9E%84_GaussianProcess.pdf">강의 자료는 여기에서 다운받으실 수 있습니다</a></li></ul></li></ul><ul><li><p>발표 영상 : (<a href="https://youtu.be/9vIPzpzfw-o">Youtube Link</a>)<br></p></li><li><p>실습 코드 : (<a href="https://bit.ly/3NvEwIO">https://bit.ly/3NvEwIO</a>)<br></p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/9vIPzpzfw-o" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><img src="gp.gif"><br></p><p><ul><li>바쁜 연구원 일정 속에 변동이 있겠지만, 최대한 일정을 지켜보고자 합니다.</li></ul><p><img src="schedule.png" alt="학습조직 일정"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/machine-learning/">machine learning</category>
      
      <category domain="https://jehyunlee.github.io/tags/KIER/">KIER</category>
      
      <category domain="https://jehyunlee.github.io/tags/gaussian-process/">gaussian process</category>
      
      <category domain="https://jehyunlee.github.io/tags/bayesian/">bayesian</category>
      
      <category domain="https://jehyunlee.github.io/tags/design-of-experiment/">design of experiment</category>
      
      <category domain="https://jehyunlee.github.io/tags/response-surface-method/">response surface method</category>
      
      
    </item>
    
    <item>
      <title>Auto Contrast on SEM image</title>
      <link>https://jehyunlee.github.io/2022/10/29/Python-DS-118-autocontrast/</link>
      <guid>https://jehyunlee.github.io/2022/10/29/Python-DS-118-autocontrast/</guid>
      <pubDate>Fri, 28 Oct 2022 19:58:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;영상 촬영을 하다 보면 결과물이 마음에 들지 않는 여러 이유가 있습니다.&lt;/li&gt;
&lt;li&gt;애초에 잘 찍으면 되겠지만 장비나 숙련도 등의 문제로 한계가 있습니다.&lt;/li&gt;
&lt;li&gt;전자현미경 사진은 여기에 시료의 상태까지 한 몫 합니다.&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>영상 촬영을 하다 보면 결과물이 마음에 들지 않는 여러 이유가 있습니다.</li><li>애초에 잘 찍으면 되겠지만 장비나 숙련도 등의 문제로 한계가 있습니다.</li><li>전자현미경 사진은 여기에 시료의 상태까지 한 몫 합니다.</li><li>방해 요소를 제외하고 자동 명도 및 대비 보정을 하는 방법을 알아봅니다.</li></ul><h1 id="1-예제-이미지"><a href="#1-예제-이미지" class="headerlink" title="1. 예제 이미지"></a>1. 예제 이미지</h1><p><img src="118_autocontrast_0.png"><br></p><ul><li>위와 같은 전자현미경 사진을 얻었다고 합시다.</li><li>전자현미경은 빛 대신 전자빔을 쏘아 매우 작은 시료를 찍는 도구입니다.</li><li>전자빔을 충분히 강하게 쬐면 밝고 좋은 영상을 얻을 수 있지만 시료에 따라 망가지기도 합니다.</li></ul><h1 id="2-ImageJ-사용-보정"><a href="#2-ImageJ-사용-보정" class="headerlink" title="2. ImageJ 사용 보정"></a>2. ImageJ 사용 보정</h1><blockquote><p><a href="https://imagej.net/">ImageJ</a></p></blockquote><ul><li><p>이미지 보정 프로그램에서 대비를 높일 수 있습니다.</p></li><li><p><a href="https://imagej.net/software/fiji/">ImageJ Fiji</a>를 사용해 개선을 시도합니다.</p></li><li><p><b>File &gt; Open</b>으로 파일을 불러온 후 <b>Image &gt; Adjust &gt; Bright &amp; Contrast</b>를 실행합니다.<br><br><img src="118_autocontrast_1.png"><br></p></li><li><p><b>B&amp;C</b>라는 이름의 작은 창에 이미지를 구성하는 픽셀들의 히스토그램이 보입니다.</p></li><li><p><b>Auto</b>를 두 번 누르면 아래와 같이 밝아지지만 대비가 개선되지 않습니다.<br><br><img src="118_autocontrast_2.png"><br></p></li><li><p>이미지 하단에 촬영 조건과 스케일바가 검정과 흰색 부분으로 붙어 있어 이 부분이 걸림돌이 됩니다.</p></li><li><p>이미지를 구성하는 음영 중 최대값(white)와 최소값(black)이 정해져 있는 바람에 가운데 몰린 분포가 개선되지 않는 것입니다.</p></li><li><p>하단을 잘라내고 재시도합니다. 메뉴 바 왼쪽의 사각형을 골라 이미지 부분만 선택합니다.<br><br><img src="118_autocontrast_3.png"><br></p></li><li><p><b>Image &gt; Crop</b>을 실행하면 아래처럼 하단이 사라집니다.<br><br><img src="118_autocontrast_4.png"><br></p></li><li><p>다시 <b>Image &gt; Adjust &gt; Bright &amp; Contrast</b>에서 Auto를 실행하면 비로소 선명해집니다.<br><br><img src="118_autocontrast_5.png"><br></p></li><li><p>하지만 스케일 바를 비롯한 중요 정보를 잃어버린 상태입니다.</p></li><li><p>논문에 싣거나 내부 발표라도 하려면 스케일 바를 다시 붙여야 합니다.</p></li><li><p>몹시 귀찮아지고, 잘 하더라도 실수가 생길 수 있습니다.</p></li><li><p>무엇보다 대개 이런 이미지는 한 두 장으로 끝나지 않습니다. 자동화가 필요합니다.</p></li></ul><h1 id="3-scikit-image-사용-보정"><a href="#3-scikit-image-사용-보정" class="headerlink" title="3. scikit-image 사용 보정"></a>3. <code>scikit-image</code> 사용 보정</h1><blockquote><p><a href="https://scikit-image.org/">scikit-image</a></p></blockquote><h2 id="3-1-scikit-image-설치"><a href="#3-1-scikit-image-설치" class="headerlink" title="3.1. scikit-image 설치"></a>3.1. <code>scikit-image</code> 설치</h2><ul><li>파이썬에는 이미지 처리 라이브러리가 여럿 있습니다.</li><li>오늘은 <a href="https://scikit-image.org/">scikit-image</a>를 사용해 작업합니다.</li><li><code>pip</code>를 사용해 설치할 수 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!pip install scikit-image -U</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-2-이미지-불러오기"><a href="#3-2-이미지-불러오기" class="headerlink" title="3.2. 이미지 불러오기"></a>3.2. 이미지 불러오기</h2><ul><li><p><code>skimage.io</code>의 <code>imread</code> 모듈을 사용해 이미지를 읽고 <code>imshow</code>로 출력합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage.io <span class="keyword">import</span> imread, imshow</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">infilename = <span class="string">&quot;sample.jpg&quot;</span></span><br><span class="line"></span><br><span class="line">img_ = imread(infilename)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(img_))</span><br><span class="line">imshow(img_)</span><br></pre></td></tr></table></figure><p><img src="118_autocontrast_6.png"><br></p></li><li><p><code>imread</code>로 읽은 이미지의 정체는 <code>numpy.ndarray</code>입니다.</p></li><li><p>출력된 이미지의 정체는 사실 <code>matplotlib.image.AxesImage</code>입니다.</p></li><li><p><code>scikit-image</code> 내부에서 <code>matplotlib</code>을 호출하는 것입니다.</p></li><li><p><code>imshow(img_)</code> 대신 <code>plt.imshow(img_, cmap=&quot;Greys_r&quot;)</code>를 실행해도 같은 결과를 얻을 수 있습니다.</p></li></ul><h2 id="3-3-이미지-및-하단-영역-크기-분리"><a href="#3-3-이미지-및-하단-영역-크기-분리" class="headerlink" title="3.3. 이미지 및 하단 영역 크기 분리"></a>3.3. 이미지 및 하단 영역 크기 분리</h2><ul><li><p>이미지 크기는 <code>.shape</code>을 출력해 확인할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_.shape</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(480, 640)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>이제 하단 영역의 높이를 알아볼 차례입니다.</p></li><li><p>x = 300 지점에서 세로로 나열된 픽셀들의 line profile을 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">0</span>].imshow(img_, cmap=<span class="string">&quot;Greys_r&quot;</span>)   <span class="comment"># 왼쪽 Axes에 Image 출력</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># x = 300을 추출해서 오른쪽 Axes에 line profile 출력, 왼쪽에 선 표시</span></span><br><span class="line">x = <span class="number">300</span></span><br><span class="line">axs[<span class="number">1</span>].plot(img_[:, x], c=<span class="string">&quot;orange&quot;</span>)   <span class="comment"># 오른쪽 Axes에 line profile 출력</span></span><br><span class="line">axs[<span class="number">0</span>].axvline(x, c=<span class="string">&quot;orange&quot;</span>)         <span class="comment"># 왼쪽 image 위에 해당 line 출력   </span></span><br></pre></td></tr></table></figure><p><img src="118_autocontrast_7.png"><br></p></li><li><p>450 부근부터의 데이터 값이 모두 0입니다. </p></li><li><p>여기가 하단 메타데이터 영역입니다.</p></li><li><p>말단 50개 데이터를 출력해 0을 세어 보면 0이 31개 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_[-<span class="number">50</span>:, x]</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array([118, 112, 115, 113, 111, 122, 122, 118, 111, 114, 111, 116, 122,</span><br><span class="line">      120, 120, 123, 124, 101,  25,   0,   0,   0,   0,   0,   0,   0,</span><br><span class="line">      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,</span><br><span class="line">      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0], dtype=uint8)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>480행 중 31행이면 16분의 1을 조금 넘습니다.</p></li><li><p>여유 있게 하단 15분의 1을 잘라내고 위쪽을 <code>img</code>, 아래쪽을 <code>desc</code>(description)라고 부릅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">h, w = img_.shape</span><br><span class="line"></span><br><span class="line">imgfrac = <span class="number">14</span>/<span class="number">15</span></span><br><span class="line">img = img_[:<span class="built_in">int</span>(h*imgfrac), :]</span><br><span class="line">desc = img_[<span class="built_in">int</span>(h*imgfrac):, :]</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">axs[<span class="number">0</span>].imshow(img, cmap=<span class="string">&quot;Greys_r&quot;</span>)</span><br><span class="line">axs[<span class="number">1</span>].imshow(desc, cmap=<span class="string">&quot;Greys_r&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig.savefig(<span class="string">&quot;118_autocontrast_8.png&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="118_autocontrast_8.png"><br></p></li><li><p>잘라낸 것만으로 왼쪽 그림이 선명해졌습니다.</p></li><li><p>Matplotlib이 그림을 보여주면서 데이터의 최소값과 최대값을 자동으로 적용했기 때문입니다.</p></li><li><p>원본 <code>img_</code>와 하단을 잘라낸 <code>img</code>의 데이터 분포를 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>,</span><br><span class="line">                       sharex=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, im, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [img_, img], [<span class="string">&quot;original&quot;</span>, <span class="string">&quot;image only&quot;</span>]):</span><br><span class="line">    ax.hist(im.flatten(), bins=np.linspace(<span class="number">0</span>, <span class="number">255</span>, <span class="number">30</span>))</span><br><span class="line">    ax.text(<span class="number">0.7</span>, <span class="number">0.95</span>, <span class="string">f&quot;min = <span class="subst">&#123;im.<span class="built_in">min</span>()&#125;</span>\nmax = <span class="subst">&#123;im.<span class="built_in">max</span>()&#125;</span>&quot;</span>, va=<span class="string">&quot;top&quot;</span>,</span><br><span class="line">           fontsize=<span class="string">&quot;x-large&quot;</span>, transform=ax.transAxes)</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;x-large&quot;</span>, pad=<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p><img src="118_autocontrast_9.png"><br></p></li><li><p>원본이 0<del>252까지 범위를 가지는 데 비해 이미지 영역만 따지면 75</del>187에 분포하고 있습니다.</p></li></ul><h2 id="3-4-이미지-영역에-auto-contrast-적용"><a href="#3-4-이미지-영역에-auto-contrast-적용" class="headerlink" title="3.4. 이미지 영역에 auto contrast 적용"></a>3.4. 이미지 영역에 auto contrast 적용</h2><blockquote><p><a href="https://en.wikipedia.org/wiki/Salt-and-pepper_noise">wikipedia: salt and pepper noise</a></p></blockquote><ul><li><p>이미지의 최대값과 최소값을 0~255로 폅니다.</p></li><li><p>그 전에, 전자현미경 같은 디지털 영상에 흔한 <b>salt and pepper noise</b> 대응책을 마련합니다.</p></li><li><p><a href="https://en.wikipedia.org/wiki/Salt-and-pepper_noise">salt and pepper noise</a>는 영상 위에 희고 검은 점이 흩뿌려지는 현상입니다.</p></li><li><p>전기 신호가 불안정하거나 원본의 대비가 잡음보다 약할 때 주로 생깁니다.<br><br><img src="118_autocontrast_10.png" alt="wikipedia: salt and pepper noise"><br></p></li><li><p><code>numpy.percentile()</code>로 전체 데이터의 상하위 0.2%씩을 제거한 뒤,</p></li><li><p><code>skimage.exposure.rescale_intensity()</code>를 사용해 0부터 255까지 데이터의 범위를 늘려줍니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> exposure</span><br><span class="line"></span><br><span class="line"><span class="comment"># salt and pepper noise 제거</span></span><br><span class="line">v_min, v_max = np.percentile(img, (<span class="number">0.2</span>, <span class="number">99.8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># auto contrast 적용</span></span><br><span class="line">img_ac = exposure.rescale_intensity(img, in_range=(v_min, v_max), out_range=(<span class="number">0</span>, <span class="number">255</span>)).astype(np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 전후 비교</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, im, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [img, img_ac], [<span class="string">&quot;original&quot;</span>, <span class="string">&quot;auto contrast&quot;</span>]):</span><br><span class="line">    ax.imshow(im, cmap=<span class="string">&quot;Greys_r&quot;</span>, vmin=<span class="number">0</span>, vmax=<span class="number">255</span>)</span><br><span class="line">    x_pos = <span class="number">0.045</span></span><br><span class="line">    <span class="keyword">if</span> ax == axs[<span class="number">1</span>]:</span><br><span class="line">        x_pos += <span class="number">0.5</span></span><br><span class="line">    ax_inset = fig.add_axes([x_pos, <span class="number">0.69</span>, <span class="number">0.15</span>, <span class="number">0.2</span>])</span><br><span class="line">    ax_inset.hist(im.flatten(), fc=<span class="string">&quot;orange&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, bins=np.linspace(<span class="number">0</span>, <span class="number">255</span>, <span class="number">30</span>))</span><br><span class="line">    ax_inset.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">255</span>), yticks=[], xticks=[])</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;x-large&quot;</span>, pad=<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p><img src="118_autocontrast_11.png"><br></p></li></ul><h2 id="3-4-하단-영역-결합"><a href="#3-4-하단-영역-결합" class="headerlink" title="3.4. 하단 영역 결합"></a>3.4. 하단 영역 결합</h2><ul><li>이제 처음에 분리해 둔 하단 영역을 결합할 차례입니다.</li><li><code>numpy.vstack()</code>을 사용합니다.</li><li>파일 저장은 <code>skimage.io</code>의 <code>imsave</code>로 실행합니다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage.io <span class="keyword">import</span> imsave</span><br><span class="line"></span><br><span class="line">img_merge = np.vstack((img_ac, desc))</span><br><span class="line">imsave(<span class="string">&quot;img_autocontrast.png&quot;</span>, img_merge)</span><br></pre></td></tr></table></figure><p><img src="img_autocontrast.png"><br></p><ul><li>스케일바를 비롯한 정보가 돌아왔습니다.</li></ul><h1 id="4-주의-사항"><a href="#4-주의-사항" class="headerlink" title="4. 주의 사항"></a>4. 주의 사항</h1><ul><li><p>분석을 열심히 하다 보면 크기를 재거나 중요 지점을 표시할 때가 있습니다.<br><br><img src="sample_annot.png"><br></p></li><li><p>여기에 위 코드를 동일하게 적용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">infilename = <span class="string">&quot;sample_annot.png&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># read image</span></span><br><span class="line">img_ = imread(infilename)</span><br><span class="line"></span><br><span class="line"><span class="comment"># image split: img + desc</span></span><br><span class="line">imgfrac = <span class="number">14</span>/<span class="number">15</span></span><br><span class="line">img = img_[:<span class="built_in">int</span>(h*imgfrac), :]</span><br><span class="line">desc = img_[<span class="built_in">int</span>(h*imgfrac):, :]</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove salt and pepper noise</span></span><br><span class="line">v_min, v_max = np.percentile(img, (<span class="number">0.2</span>, <span class="number">99.8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># apply auto contrast</span></span><br><span class="line">img_ac = exposure.rescale_intensity(img, in_range=(v_min, v_max), out_range=(<span class="number">0</span>, <span class="number">255</span>)).astype(np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># merge images</span></span><br><span class="line">img_merge = np.vstack((img_ac, desc))</span><br><span class="line"></span><br><span class="line"><span class="comment"># save file</span></span><br><span class="line">imsave(<span class="string">&quot;annot_autocontrast.png&quot;</span>, img_merge)</span><br></pre></td></tr></table></figure></li><li><p>그리고 결과를 확인해 보면 대비 보정이 적용되지 않았습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, im, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [img_, img_merge], [<span class="string">&quot;original&quot;</span>, <span class="string">&quot;auto contrast&quot;</span>]):</span><br><span class="line">    ax.imshow(im, cmap=<span class="string">&quot;Greys_r&quot;</span>, vmin=<span class="number">0</span>, vmax=<span class="number">255</span>)</span><br><span class="line">    x_pos = <span class="number">0.045</span></span><br><span class="line">    <span class="keyword">if</span> ax == axs[<span class="number">1</span>]:</span><br><span class="line">        x_pos += <span class="number">0.5</span></span><br><span class="line">    ax_inset = fig.add_axes([x_pos, <span class="number">0.69</span>, <span class="number">0.15</span>, <span class="number">0.2</span>])</span><br><span class="line">    ax_inset.hist(im.flatten(), fc=<span class="string">&quot;orange&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, bins=np.linspace(<span class="number">0</span>, <span class="number">255</span>, <span class="number">30</span>))</span><br><span class="line">    ax_inset.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">255</span>), yticks=[], xticks=[])</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;x-large&quot;</span>, pad=<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p><img src="118_autocontrast_12.png"><br></p></li><li><p><b>이미지 영역에 추가한 표지가 문제</b>가 되는 경우입니다.</p></li><li><p>salt and pepper noise를 제거하기 위해 상하위 0.2%만 제거했는데, 이 그림에는 <b>하양과 검정으로 표현된 화살표와 글자들이 0.2%를 넘어섰기 때문에 제거되지 않고 명도의 최대값고 최소값으로 인지된 것</b>입니다. </p></li><li><p>이러한 보정은 추가 정보를 기입하지 않은 상태에서 적용해야 올바르게 적용되니 주의해야 합니다.</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/imagej/">imagej</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/image/">image</category>
      
      <category domain="https://jehyunlee.github.io/tags/scikit-image/">scikit-image</category>
      
      
    </item>
    
    <item>
      <title>혼란한 Matplotlib에서 질서 찾기</title>
      <link>https://jehyunlee.github.io/2022/10/16/Python-DS-117-pycon2022/</link>
      <guid>https://jehyunlee.github.io/2022/10/16/Python-DS-117-pycon2022/</guid>
      <pubDate>Sun, 16 Oct 2022 12:49:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://2022.pycon.kr/&quot;&gt;&lt;b&gt;PyCon Korea 2022&lt;/b&gt;&lt;/a&gt;에서 한 발표 영상입니다.&lt;ul&gt;
&lt;li&gt;Matplotlib을 데이터를 그리는 도구로 많이 알고 계십니다.&lt;/li&gt;
&lt;li&gt;하지</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><a href="https://2022.pycon.kr/"><b>PyCon Korea 2022</b></a>에서 한 발표 영상입니다.<ul><li>Matplotlib을 데이터를 그리는 도구로 많이 알고 계십니다.</li><li>하지만 Matplotlib은 시각화 라이브러리 이상의 생태계입니다. </li><li>seaborn을 사용해 데이터 시각화 결과물의 퀄리티를 높일 수 있고,</li><li>생태계의 다른 라이브러리를 사용해 그린 그림을 Matplotlib으로 편집할 수 있습니다.</li></ul></li></ul><ul><li>발표 영상 : (<a href="https://youtu.be/ZTRKojTLE8M">Youtube Link</a>)<br></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/ZTRKojTLE8M" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><img src="117_pycon2022_1.png"><br></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/pycon/">pycon</category>
      
      
    </item>
    
    <item>
      <title>Python Script in Power BI Desktop</title>
      <link>https://jehyunlee.github.io/2022/10/14/Python-DS-116-powerbi/</link>
      <guid>https://jehyunlee.github.io/2022/10/14/Python-DS-116-powerbi/</guid>
      <pubDate>Fri, 14 Oct 2022 00:47:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;Microsoft가 출시한 Power BI는 강력합니다.&lt;ul&gt;
&lt;li&gt;윈도 환경에서 데이터를 쉽게 시각화할 수 있을 뿐 아니라&lt;/li&gt;
&lt;li&gt;온라인 배포를 통해 동료와 공유하기도 쉽습니다.&lt;/li&gt;
&lt;li&gt;한편으로 데이터 불러오기,</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>Microsoft가 출시한 Power BI는 강력합니다.<ul><li>윈도 환경에서 데이터를 쉽게 시각화할 수 있을 뿐 아니라</li><li>온라인 배포를 통해 동료와 공유하기도 쉽습니다.</li><li>한편으로 데이터 불러오기, 전처리, 시각화를 python script로 할 수도 있습니다.</li><li>공식 문서도 풍부하여 익히기 좋습니다.</li></ul></li></ul><h1 id="1-Power-BI-설치"><a href="#1-Power-BI-설치" class="headerlink" title="1. Power BI 설치"></a>1. Power BI 설치</h1><blockquote><p><a href="https://learn.microsoft.com/ko-kr/power-bi/fundamentals/desktop-get-the-desktop">Microsoft Learn: Power BI Desktop 다운로드</a></p></blockquote><ul><li><p>Power BI Desktop은 <b>무료</b>로 <b>Microsoft Store</b>에서 설치합니다.<br><br><img src="116_powerbi_04.png" alt="Microsoft Store Power BI 설치 화면"></p></li><li><p>파일을 다운받아 설치할 수도 있지만 직접 다운받으면 다음과 같은 이점이 있다고 합니다.</p></li></ul><ol><li><b>자동 업데이트:</b> 최신 버전이 제공되는 즉시, Windows가 백그라운드에서 자동으로 다운로드하므로 항상 최신 버전이 유지됩니다.</li><li><b>필요한 파일만 다운로드:</b> Microsoft Store는 각 업데이트에서 변경된 구성 요소만 사용자 머신에 다운로드하므로 각 업데이트에 필요한 파일만 다운로드됩니다.</li><li><b>관리자 권한이 필요하지 않음:</b> 패키지를 직접 다운로드하고 설치하는 경우 설치가 성공적으로 완료되려면 관리자여야 합니다. Microsoft Store에서 Power BI Desktop을 가져오는 경우에는 관리자 권한이 필요하지 ‘않습니다’.</li><li><b>IT 롤아웃 사용:</b> 비즈니스용 Microsoft Store를 통해 조직의 모든 사용자에게 Power BI Desktop을 보다 쉽게 배포하거나 ‘롤아웃’할 수 있습니다.</li><li><b>언어 감지:</b> Microsoft Store 버전은 지원되는 언어를 모두 포함하며, 시작할 때마다 컴퓨터에서 사용되는 언어를 확인합니다. 이 언어 지원은 Power BI Desktop에서 만든 모델의 지역화에도 영향을 줍니다. 예를 들어 기본 제공 날짜 계층 구조는 .pbix 파일을 만들 때 Power BI Desktop에서 사용 중인 언어와 일치합니다.</li></ol><h1 id="2-데이터-불러오기"><a href="#2-데이터-불러오기" class="headerlink" title="2. 데이터 불러오기"></a>2. 데이터 불러오기</h1><ul><li><p>그림으로 표현할 데이터를 불러옵니다. </p></li><li><p><b>엑셀 파일</b>, <b>SQL 서버</b>, <b>붙여넣기</b>를 제공하고 <b>샘플 데이터</b>를 사용할 수 있습니다.<br><br><img src="116_powerbi_05.png"><br></p></li><li><p>또한 <b>파이썬 스크립트</b>를 사용해 데이터를 불러올 수 있습니다.</p></li><li><p>엑셀 파일과 파이썬 스크립트를 사용해 데이터를 불러 scatter plot을 그리겠습니다.</p></li></ul><h2 id="2-1-엑셀-파일-불러오기"><a href="#2-1-엑셀-파일-불러오기" class="headerlink" title="2.1. 엑셀 파일 불러오기"></a>2.1. 엑셀 파일 불러오기</h2><ul><li><p><b>Excel 파일에서 데이터 가져오기</b>를 클릭하고 파일을 선택합니다.</p></li><li><p>seaborn의 <a href="penguins.xlsx"><b>펭귄 데이터셋</b>을 추출한 파일</a>을 선택합니다.<br><br><img src="116_powerbi_06.png"><br></p></li><li><p>Sheet를 선택하면 데이터 일부가 화면에 출력됩니다.</p></li><li><p>결측치는 <em>null</em> 이라고 표현됩니다.</p></li><li><p><b>[로드]</b>를 누르면 <b>PowerQuery</b>로 넘어갑니다.<br></p></li></ul><p><img src="116_powerbi_07.png"><br></p><ul><li>Power Query에서 전처리를 적용할 수 있습니다.</li><li>여기서는 매뉴의 맨 왼쪽, <b>[닫기 및 적용]</b>을 눌러 그대로 가져옵니다.</li><li>창을 닫아도 마찬가지로 동작하며, 이제 그림을 그릴 준비가 되었습니다.<br></li></ul><p><img src="116_powerbi_08.png"><br></p><ul><li>그림이 그려질 공간과 함께 <b>[시각화]</b> 메뉴에 다양한 선택지가 보입니다.</li><li>왼쪽 위부터 3행 3열에 있는 버튼을 클릭해 산점도를 그립시다.</li><li>산점도를 클릭하면 왼쪽에 네모난 공간이 생깁니다. 마우스로 크기와 위치를 정합니다.<br></li></ul><p><img src="116_powerbi_10.png"><br></p><ul><li>데이터를 지정할 차례입니다.</li><li><b>[시각화]</b> 메뉴 아래 있는<b>[X축]</b>, <b>[Y축]</b>에 인자를 끌어다 놓습니다.</li><li>여기서는 <b><code>bill_length_mm</code></b>와 <b><code>bill_depth_mm</code></b>를 선택했습니다.</li><li>기본값으로 <b>합계</b>가 선택되어 점이 하나밖에 나오지 않습니다. </li><li>우클릭을 하거나 <b>v</b> 버튼을 눌러 <b>[요약 안함]</b>을 누릅니다.<br></li></ul><p><img src="116_powerbi_11.png"><br></p><ul><li><b>범례</b>에 <b><code>species</code></b>를 추가하면 종에 따라 다른 색이 입혀집니다.</li></ul><p><img src="116_powerbi_12.png"><br></p><ul><li>일단 여기에서 정리하고 파이썬으로 불러보겠습니다.</li><li>화면 왼쪽 하단 <b>1 페이지</b> 옆에 있는 <b>+</b>를 눌러 새 페이지를 엽니다.</li></ul><h2 id="2-2-파이썬으로-불러오기"><a href="#2-2-파이썬으로-불러오기" class="headerlink" title="2.2. 파이썬으로 불러오기"></a>2.2. 파이썬으로 불러오기</h2><blockquote><p><a href="https://learn.microsoft.com/ko-kr/power-bi/connect-data/desktop-python-scripts">Microsoft Learn: Power BI, Power BI Desktop에서 Python 스크립트 실행</a></p></blockquote><ul><li>먼저 파이썬이 설치되어 있어야 합니다.</li><li><b>[파일] &gt; [옵션 및 설정] &gt; [옵션] &gt; [Python 스크립팅]</b>을 선택합니다.<br></li></ul><p><img src="116_powerbi_14.png"><br></p><ul><li>설정이 되어 있다면 자동으로 검색된 경로를 가져옵니다. 필요하다면 다른 경로를 지정할 수 있습니다.</li><li>상단 메뉴의 <b>[데이터 가져오기] &gt; [기타] &gt; [Python 스크립트]</b>를 선택합니다.<br></li></ul><p><img src="116_powerbi_15.png"><br></p><ul><li>데이터를 로딩하는 파이썬 스크립트를 작성합니다.</li><li><code>seaborn</code>을 읽어들여 내장된 펭귄 데이터셋을 부릅니다.<br></li></ul><p><img src="116_powerbi_16.png"><br></p><ul><li>엑셀로 불렀을 때와 동일한 화면이 나옵니다.<br></li></ul><p><img src="116_powerbi_17.png"><br></p><ul><li>앞에서 진행한 것과 같은 단계를 거치면 동일한 결과를 얻을 수 있습니다.<br></li></ul><p><img src="116_powerbi_19.png"><br></p><h1 id="3-파이썬-데이터-처리"><a href="#3-파이썬-데이터-처리" class="headerlink" title="3. 파이썬 데이터 처리"></a>3. 파이썬 데이터 처리</h1><blockquote><p><a href="https://learn.microsoft.com/ko-kr/power-bi/connect-data/desktop-python-in-query-editor?source=recommendations">Microsoft Learn: Power BI, 쿼리 편집기에서 Python 사용</a></p></blockquote><ul><li>내장 파이썬 스크립트를 사용해 데이터를 처리하겠습니다.</li><li><code>bill_length_mm</code>와 <code>bill_depth_mm</code>의 비율을 구해 <b><code>bill_ratio</code></b>라는 새 인자를 만듭니다.<br></li><li>데이터 이름인 <code>df_peng</code>에서 오른쪽 클릭을 한 후 <b>쿼리 편집</b>을 선택합니다.<br></li></ul><p><img src="116_powerbi_20.png"><br></p><ul><li>데이터를 처음 불렀을 때와 마찬가지로 Power Query가 실행됩니다.<br></li></ul><p><img src="116_powerbi_21.png"><br></p><ul><li>상단 메뉴에서 <b>[변환] &gt; [스크립트] 중 [Python 스크립트 실행]</b>을 선택합니다.</li><li>파이썬 스크립트를 입력합니다.</li><li>Power BI 내부의 데이터 이름은 <b>dataset</b>입니다.</li><li><code>bill_ratio</code>를 구하는 코드를 다음과 같이 입력합니다.<br></li></ul><p><img src="116_powerbi_28.png"><br></p><ul><li><b>[확인]</b>을 누르면 스크립트가 실행됩니다.<br></li></ul><p><img src="116_powerbi_29.png"><br></p><ul><li><b>[Table]</b>을 클릭하면 하단에 데이터가 펼쳐집니다.</li><li><b>[Table]</b>을 우클릭 후 <b>[새 쿼리로 추가]</b>를 선택합니다.</li></ul><p><img src="116_powerbi_30.png"><br></p><ul><li>새로 추가된 쿼리에서 <b>데이터 형식을 지정</b>할 차례입니다.</li><li>수치 데이터를 선택한 후 <b>[형식 변경]</b>에서 적절한 형식을 선택합니다. </li><li>여기서는 <b>10진수</b>를 선택해 수치형으로 변경했습니다.</li><li>상단의 수식에서 <code>type number</code>를 추가해도 좋습니다. 변수가 많을 경우 이게 더 편합니다.</li></ul><p><img src="116_powerbi_31.png"><br></p><ul><li>처리한 데이터를 그림으로 표현할 차례입니다.</li><li>Power Query를 닫고 돌아온 창에서 x축에 <code>bill_ratio</code>, y축에 <code>body_mass_g</code>, 그리고 범례에 <code>species</code>를 입력하면 아래와 같은 그림이 그려집니다.</li></ul><p><img src="116_powerbi_32.png"><br></p><h1 id="4-결론"><a href="#4-결론" class="headerlink" title="4. 결론"></a>4. 결론</h1><ul><li>Power BI는 상당히 많은 기능을 가지고 있습니다.</li><li>저도 이제 막 시작했지만 차분히 알아가려고 합니다.</li><li>파이썬도 함께 활용할 수 있으니 많은 분들이 잘 사용하시면 좋겠습니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/power-platform/">power platform</category>
      
      <category domain="https://jehyunlee.github.io/tags/data-visualization/">data visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/power-bi/">power bi</category>
      
      
    </item>
    
    <item>
      <title>모듈(.py) 안에서 library 설치</title>
      <link>https://jehyunlee.github.io/2022/10/12/Python-General-13-install/</link>
      <guid>https://jehyunlee.github.io/2022/10/12/Python-General-13-install/</guid>
      <pubDate>Tue, 11 Oct 2022 21:34:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;Colab 같은 클라우드 환경 사용 비중이 늘어나고 있습니다.&lt;/li&gt;
&lt;li&gt;클라우드에 기본으로 설치되지 않은 라이브러리를 설치하는 방법을 알아봅니다.&lt;/li&gt;
&lt;li&gt;pip도 import 해서 사용할 수 있습니다.&lt;/li&gt;
&lt;/ul</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>Colab 같은 클라우드 환경 사용 비중이 늘어나고 있습니다.</li><li>클라우드에 기본으로 설치되지 않은 라이브러리를 설치하는 방법을 알아봅니다.</li><li>pip도 import 해서 사용할 수 있습니다.</li></ul><h1 id="1-클라우드-환경"><a href="#1-클라우드-환경" class="headerlink" title="1. 클라우드 환경"></a>1. 클라우드 환경</h1><ul><li>Google Colab이나 Streamlit cloud 처럼 클라우드 기반 서비스 활용 비율이 늘어납니다.</li><li>장점이 많지만 서버가 물리적으로 고정되어 있지 않다 보니 필요한 라이브러리가 없을 때가 많습니다.</li><li>일일이 확인하면서 <code>!pip install &#123;library&#125;</code>를 실행하기가 번거롭습니다.</li><li>그렇다고 <code>requirements.txt</code>를 쓸 만큼 큰 일도 아닐 때 간단하게 처리하고 싶습니다.</li></ul><h1 id="2-import-pip"><a href="#2-import-pip" class="headerlink" title="2. import pip"></a>2. <code>import pip</code></h1><ul><li>라이브러리 설치에 사용하는 <code>pip</code>는 import도 가능합니다.</li><li>노트북 환경이건 모듈로 사용되는 .py 파일이건 무관합니다.</li><li>프로그램 시작 부분에 아래 코드를 삽입해 import가 안 되어 있는 라이브러리를 설치할 수 있습니다.</li><li>아래는 geopandas를 사용하고자 설치하는 코드입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pip</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">install</span>(<span class="params">package, upgrade=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="comment"># package install with upgrade or not</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(pip, <span class="string">&#x27;main&#x27;</span>):</span><br><span class="line">        <span class="keyword">if</span> upgrade:</span><br><span class="line">            pip.main([<span class="string">&#x27;install&#x27;</span>, <span class="string">&#x27;--upgrade&#x27;</span>, package])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pip.main([<span class="string">&#x27;install&#x27;</span>, package])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> upgrade:</span><br><span class="line">            pip._internal.main([<span class="string">&#x27;install&#x27;</span>, <span class="string">&#x27;--upgrade&#x27;</span>, package])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pip._internal.main([<span class="string">&#x27;install&#x27;</span>, package])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># import package</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">eval</span>(<span class="string">f&quot;import <span class="subst">&#123;package&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> ModuleNotFoundError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;# Package name might be differnt. please check it again.&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure></li></ul><h1 id="3-GeoPandas-예제-Choro-legends"><a href="#3-GeoPandas-예제-Choro-legends" class="headerlink" title="3. GeoPandas 예제: Choro legends"></a>3. GeoPandas 예제: Choro legends</h1><blockquote><p><a href="https://geopandas.org/en/stable/gallery/choro_legends.html">GeoPandas Example Gallery: Choro legends</a></p></blockquote><ul><li>같은 요령으로 Colab 기본 설치 라이브러리가 아닌 <code>mapclassify</code>와 <code>libpysal</code>을 설치합니다.</li><li>이후 아래 코드를 실행하면 깔끔하게 실행됩니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> geopandas <span class="keyword">import</span> read_file</span><br><span class="line"></span><br><span class="line">_ = libpysal.examples.load_example(<span class="string">&#x27;South&#x27;</span>)</span><br><span class="line">pth = libpysal.examples.get_path(<span class="string">&#x27;south.shp&#x27;</span>)</span><br><span class="line">df = read_file(pth)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">df.plot(column=<span class="string">&#x27;HR60&#x27;</span>, scheme=<span class="string">&#x27;QUANTILES&#x27;</span>, k=<span class="number">4</span>, \</span><br><span class="line">             cmap=<span class="string">&#x27;BuPu&#x27;</span>, legend=<span class="literal">True</span>,</span><br><span class="line">             legend_kwds=&#123;<span class="string">&#x27;loc&#x27;</span>: <span class="string">&#x27;center left&#x27;</span>, <span class="string">&#x27;bbox_to_anchor&#x27;</span>:(<span class="number">1</span>,<span class="number">0.5</span>)&#125;,</span><br><span class="line">             ax=ax)</span><br><span class="line"></span><br><span class="line">fig.savefig(<span class="string">&quot;13_install_01.png&quot;</span>)</span><br></pre></td></tr></table></figure><img src="13_install_01.png"><br></li></ul><ul><li><a href="https://colab.research.google.com/drive/1_oF9RkHi_XADp9m9UJMD4383YnDSosCF?usp=sharing">위 코드는 여기에서 확인 가능합니다 (링크)</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/pip/">pip</category>
      
      
    </item>
    
    <item>
      <title>Nature Methods- Points of significance</title>
      <link>https://jehyunlee.github.io/2022/10/02/Python-DS-115-pointsofsignificance/</link>
      <guid>https://jehyunlee.github.io/2022/10/02/Python-DS-115-pointsofsignificance/</guid>
      <pubDate>Sun, 02 Oct 2022 12:33:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.nature.com/&quot;&gt;&lt;b&gt;Nature지&lt;/b&gt;&lt;/a&gt;에서는 연구자들의 올바른 통계 분석 역량을 배양하고자 컬럼을 연재했습니다.&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.nature.c</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><a href="https://www.nature.com/"><b>Nature지</b></a>에서는 연구자들의 올바른 통계 분석 역량을 배양하고자 컬럼을 연재했습니다.<ul><li><a href="https://www.nature.com/collections/qghhqm/pointsofsignificance"><b>Points of Significance</b></a>라는 이름으로 연재했으며, </li><li>데이터의 올바른 해석과 실험 계획에 대한 가이드를 주고 있습니다.</li><li>주로 정해진 필진이 길지 않은 기사를 쓰는데 <a href="https://www.nature.com/nmeth/">Nature Methods</a>에 실립니다.</li><li>간간이 Nature 자매지에 투고되는 분석이 얼마나 틀렸는지를 지적합니다.<br></li><li><a href="https://www.nature.com/collections/qghhqm">Statistics in biology</a>라는 제목으로 더 많은 기사가 모여 있습니다.</li></ul></li></ul><p><img src="115_pos_01.png"><br></p><blockquote><p><a href="https://www.nature.com/">Nature</a><br><a href="https://www.nature.com/collections/qghhqm/pointsofsignificance">Points of Significance</a><br><a href="https://www.nature.com/collections/qghhqm">Statistics in biology</a></p></blockquote><ul><li>오차 막대같은 <b>기본기</b>부터 다룹니다.<ul><li>학부에서 배웠어야 했을, </li><li>적어도 대학원에서는 배웠어야 했을 지식이지만 제대로 배운 적이 없는 것들입니다.</li><li><b>데이터 시각화</b> 이야기도 많습니다. </li><li>잘못된 그림은 오해를 불러 일으키기 때문입니다.<br></li></ul></li></ul><p><img src="115_pos_02.png"><br></p><ul><li>라이센스가 풀려 있습니다.<ul><li>자택처럼 네이처 구독 라이센스가 없어도 읽을 수 있습니다.</li><li><b>총 42편</b>의 기사를 <a href="Points_of_Significance.enlx"><b>EndNote Library로 정리</b>했습니다.(다운로드 링크)</a></li><li>EndNote 사용자들은 다운받아 본인 연구에 마음껏 인용하시기 바랍니다.<br></li></ul></li></ul><p><img src="115_pos_03.png"><br></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/data-visualization/">data visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/statistics/">statistics</category>
      
      <category domain="https://jehyunlee.github.io/tags/experiment-design/">experiment design</category>
      
      
    </item>
    
    <item>
      <title>nonlinear models</title>
      <link>https://jehyunlee.github.io/2022/09/16/Python-DS-114-kierlecture6/</link>
      <guid>https://jehyunlee.github.io/2022/09/16/Python-DS-114-kierlecture6/</guid>
      <pubDate>Fri, 16 Sep 2022 10:49:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;한국에너지기술연구원 AI 학습조직&lt;/b&gt;에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.&lt;ul&gt;
&lt;li&gt;이번 시간에는 가장 기초가 되는 선형 모델과 함께 위한 비선형 모델을 소개했습니다.&lt;/li&gt;
&lt;li&gt;대부분의 데이터가</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b>한국에너지기술연구원 AI 학습조직</b>에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.<ul><li>이번 시간에는 가장 기초가 되는 선형 모델과 함께 위한 비선형 모델을 소개했습니다.</li><li>대부분의 데이터가 비선형이기 때문에 선형의 한계를 벗어나기 위해 다항변환과 커널을 이용합니다.</li><li>강의에서 하나를 빼먹었는데요, PCA는 데이터 값의 영향을 크게 받기 때문에 Standard Scaling 등이 필수입니다.</li><li><a href="220916_%EC%9D%B4%EC%A0%9C%ED%98%84_KIERML_2206_nonlinear.pdf">강의 자료는 여기에서 다운받으실 수 있습니다</a></li></ul></li></ul><ul><li><p>발표 영상 : (<a href="https://youtu.be/NQ5vcDV3-RU">Youtube Link</a>)<br></p></li><li><p>실습 코드 : (<a href="https://bit.ly/3DC80BA">https://bit.ly/3DC80BA</a>)<br></p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/NQ5vcDV3-RU" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><img src="thumbnail2.PNG"><br></p><p><ul><li>바쁜 연구원 일정 속에 변동이 있겠지만, 최대한 일정을 지켜보고자 합니다.</li></ul><p><img src="schedule.png" alt="학습조직 일정"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/machine-learning/">machine learning</category>
      
      <category domain="https://jehyunlee.github.io/tags/KIER/">KIER</category>
      
      <category domain="https://jehyunlee.github.io/tags/PCA/">PCA</category>
      
      
    </item>
    
    <item>
      <title>glowing full moon</title>
      <link>https://jehyunlee.github.io/2022/09/09/Python-DS-113-moon/</link>
      <guid>https://jehyunlee.github.io/2022/09/09/Python-DS-113-moon/</guid>
      <pubDate>Thu, 08 Sep 2022 21:34:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;추석입니다.&lt;/li&gt;
&lt;li&gt;빛나는 보름달을 그립니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-추석-달&quot;&gt;&lt;a href=&quot;#1-추석-달&quot; class=&quot;headerlink&quot; title=&quot;1. 추석 달&quot;&gt;&lt;/a&gt;1. 추석 달&lt;/h1&gt;&lt;blo</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>추석입니다.</li><li>빛나는 보름달을 그립니다.</li></ul><h1 id="1-추석-달"><a href="#1-추석-달" class="headerlink" title="1. 추석 달"></a>1. 추석 달</h1><blockquote><p><a href="http://www.ohmynews.com/NWS_Web/View/at_pg.aspx?CNTN_CD=A0002145580">오마이뉴스: 이번 추석, ‘초 슈퍼문’ 볼 수 있다 (2015.09.22.)</a></p></blockquote><ul><li>보름달 주위로 빛이 살짝 스며나올 때가 있습니다.</li><li>구름이 옅게 끼거나 공기가 습할 때 일부가 굴절되는 것입니다.<br><br><img src="113_moon_11.jpg"><br></li></ul><h1 id="2-빛이-스미는-보름달"><a href="#2-빛이-스미는-보름달" class="headerlink" title="2. 빛이 스미는 보름달"></a>2. 빛이 스미는 보름달</h1><h2 id="2-1-보름달"><a href="#2-1-보름달" class="headerlink" title="2.1. 보름달"></a>2.1. 보름달</h2><ul><li>빛이 하늘에 번지는 보름달을 그립니다.</li><li>먼저, 2022 x 2022 크기의 공간을 만들고 한 가운데 반지름이 800인 원을 그립니다.</li><li>2022 x 2022 numpy array를 만든 후 가운데만 255, 나머지는 0으로 지정합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">moon = np.zeros((<span class="number">2022</span>, <span class="number">2022</span>), dtype=<span class="built_in">int</span>)</span><br><span class="line">r = <span class="number">800</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2022</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2022</span>):</span><br><span class="line">        d = np.sqrt(np.power(i-<span class="number">1011</span>, <span class="number">2</span>) + np.power(j-<span class="number">1011</span>, <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">if</span> d &lt; r:</span><br><span class="line">            moon[i, j] = <span class="number">255</span></span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.imshow(moon)</span><br></pre></td></tr></table></figure><img src="113_moon_01.png"><br></li></ul><h2 id="2-2-빛-번짐"><a href="#2-2-빛-번짐" class="headerlink" title="2.2. 빛 번짐"></a>2.2. 빛 번짐</h2><blockquote><p><a href="https://github.com/rougier/scientific-visualization-book/blob/master/code/showcases/contour-dropshadow.py">Nicolas P. Rougier, Contour-Dropshadow</a><br><a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.gaussian_filter.html">scipy: gaussian_filter</a></p></blockquote><ul><li><p>빛이 번지는 효과를 구현합니다.</p></li><li><p><code>scipy</code>의 <code>gaussian_filter</code>를 사용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> gaussian_filter</span><br><span class="line">glow = gaussian_filter(moon, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.imshow(glow)</span><br></pre></td></tr></table></figure><p><img src="113_moon_02.png"><br></p></li><li><p>붉은 달이 떴습니다.</p></li><li><p>색은 <code>cmap</code>에 적절한 컬러맵을 입력해 조정합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">ax.imshow(glow, origin=<span class="string">&quot;upper&quot;</span>, zorder=<span class="number">0</span>, cmap=<span class="string">&quot;viridis&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="113_moon_03.png"><br></p></li></ul><h2 id="2-3-컬러맵-제작"><a href="#2-3-컬러맵-제작" class="headerlink" title="2.3. 컬러맵 제작"></a>2.3. 컬러맵 제작</h2><blockquote><p><a href="https://seaborn.pydata.org/generated/seaborn.color_palette.html">seaborn.color_palette</a><br><a href="https://matplotlib.org/stable/tutorials/colors/colormap-manipulation.html#sphx-glr-tutorials-colors-colormap-manipulation-py">matplotlib: Creating Colormaps in Matplotlib</a></p></blockquote><ul><li><p>검정에 가까운 어두운 색부터 밝은 노랑을 거쳐 흰색으로 이어지는 컬러맵이 필요합니다.</p></li><li><p>이런 컬러맵이 없으니 새로 만듭니다.</p></li><li><p>매우 어두운 노랑 ~ 조금 어두운 노랑(<code>y</code>)까지 이어지는 팔레트를 먼저 만들고,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmap0 = sns.color_palette(<span class="string">&quot;dark:y&quot;</span>, <span class="number">20</span>)</span><br><span class="line">cmap0</span><br></pre></td></tr></table></figure><p><img src="113_moon_04.png"><br></p></li><li><p>조금 어두운 노랑(<code>y</code>)에서 흰색으로 이어지는 팔레트를 새로 만듭니다.</p></li><li><p>seaborn의 <code>color_palette()</code>를 사용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmap1 = sns.color_palette(<span class="string">&quot;blend:y,w&quot;</span>, <span class="number">20</span>)</span><br><span class="line">cmap1</span><br></pre></td></tr></table></figure><p><img src="113_moon_05.png"><br></p></li><li><p>이 두 팔레트를 합쳐 Matplotlib colormap으로 출력합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"></span><br><span class="line">cmap = ListedColormap(cmap0 + cmap1)</span><br><span class="line">cmap</span><br></pre></td></tr></table></figure><p><img src="113_moon_06.png"><br></p></li><li><p>이렇게 만든 컬러맵을 번진 달빛에 적용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">ax.imshow(glow, origin=<span class="string">&quot;upper&quot;</span>, zorder=<span class="number">0</span>, cmap=cmap)</span><br></pre></td></tr></table></figure><p><img src="113_moon_08.png"><br></p></li></ul><h2 id="2-4-보름달-빛-번짐"><a href="#2-4-보름달-빛-번짐" class="headerlink" title="2.4. 보름달 + 빛 번짐"></a>2.4. 보름달 + 빛 번짐</h2><blockquote><p><a href="https://numpy.org/doc/stable/reference/maskedarray.generic.html">Numpy: ma module</a></p></blockquote><ul><li><p>보름달 사진을 보면, 웬만큼 구름이 끼지 않고서야 달의 동그란 경계가 선명합니다.</p></li><li><p>빛 번짐 그림은 경계가 흐릿합니다.</p></li><li><p>여기 달 그림을 반투명하게 씌워 선명한 경계를 구현합니다.</p></li><li><p>달 그림 중에서 배경에 해당하는 부분은 <code>numpy masked_array</code>를 사용해 그리지 않습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">ax.imshow(glow, origin=<span class="string">&quot;upper&quot;</span>, zorder=<span class="number">0</span>, cmap=cmap)</span><br><span class="line">ax.imshow(np.ma.masked_array(moon, moon &lt;<span class="number">1</span>), origin=<span class="string">&quot;upper&quot;</span>, zorder=<span class="number">0</span>, </span><br><span class="line">          vmin=<span class="number">0</span>, vmax=<span class="number">255</span>, cmap=cmap, alpha=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p><img src="113_moon_10.png"><br></p></li><li><p>달의 경계가 살아났습니다</p></li><li><p>마지막으로, x 축과 y 축을 없애고 그림만 남깁니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig.set_size_inches((<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">ax.axis(<span class="literal">False</span>)</span><br><span class="line">fig.set_facecolor(cmap0[<span class="number">0</span>])</span><br><span class="line">fig.tight_layout()</span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure><p><img src="113_moon_09.png"><br></p></li><li><p>모두 즐거운 한가위 되시기 바랍니다.</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualziation/">visualziation</category>
      
      
    </item>
    
    <item>
      <title>Emphasis on main data</title>
      <link>https://jehyunlee.github.io/2022/09/05/Python-DS-112-sethls/</link>
      <guid>https://jehyunlee.github.io/2022/09/05/Python-DS-112-sethls/</guid>
      <pubDate>Mon, 05 Sep 2022 05:04:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;시각화에서 색은 매우 중요한 요소입니다.&lt;/li&gt;
&lt;li&gt;중요 데이터를 강조하기 위해 특정 영역의 색을 다르게 지정하기도 합니다.&lt;/li&gt;
&lt;li&gt;HLS 색공간을 사용해 특정 데이터만 강조합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>시각화에서 색은 매우 중요한 요소입니다.</li><li>중요 데이터를 강조하기 위해 특정 영역의 색을 다르게 지정하기도 합니다.</li><li>HLS 색공간을 사용해 특정 데이터만 강조합니다.</li></ul><h1 id="1-중요-데이터-강조"><a href="#1-중요-데이터-강조" class="headerlink" title="1. 중요 데이터 강조"></a>1. 중요 데이터 강조</h1><blockquote><p><a href="http://m.yes24.com/goods/detail/87631760">Claus Wikle, “데이터 시각화 교과서”</a></p></blockquote><ul><li><p>아래 그림은 <b><a href="http://m.yes24.com/goods/detail/87631760">데이터 시각화 교과서</a></b>에 수록된 데이터 강조 사례입니다.</p></li><li><p>여러 항공사 중 <b>Delta</b>와 <b>American</b>만 강조되어 있습니다.</p></li><li><p>중요한 데이터만 <b>유채색</b>으로, 그렇지 않으면 <b>무채색</b>으로 처리하면 우리 눈에 잘 들어옵니다.<br><br><img src="112_sethls_01.png"><br></p></li><li><p>데이터를 강조하는 가장 간단하면서도 정석적인 방법입니다.</p></li><li><p>하지만 막상 코드로 구현하려면 다소 성가십니다. bar마다 다른 색을 지정해야 하기 때문입니다.</p></li></ul><h1 id="2-HLS-color-space"><a href="#2-HLS-color-space" class="headerlink" title="2. HLS color space"></a>2. HLS color space</h1><h2 id="2-1-유채색과-무채색"><a href="#2-1-유채색과-무채색" class="headerlink" title="2.1. 유채색과 무채색"></a>2.1. 유채색과 무채색</h2><blockquote><p><a href="https://jehyunlee.github.io/2022/01/04/Python-DS-95-tiger/">Pega Devlog: colorsys-Conversion between Color systems</a></p></blockquote><ul><li>유채색과 무채색의 차이는 간단합니다.</li><li>색을 이루는 구성 요소, <b>명도(Lightness)</b>, <b>색상(Hue)</b>, <b>채도(Saturation)</b> 중 명도만 있으면 무채색입니다.</li><li>조금 더 정확히 말하면, 채도가 0이 되어 색상이 드러나지 않으면 무채색이 됩니다.</li><li>채도를 아주 살짝 남기면 색상만 약하게 전달할 수 있습니다.<br><br><img src="112_sethls_02.png"><br></li></ul><h2 id="2-2-set-hls"><a href="#2-2-set-hls" class="headerlink" title="2.2. set_hls()"></a>2.2. <code>set_hls()</code></h2><p><img src="112_sethls_11.png"><br></p><ul><li><p>색 데이터와 함께 HLS 공간에서의 수정 내역을 입력받아 바뀐 색을 출력하는 함수를 만듭니다.</p></li><li><p>색을 제어하는 <code>matplotlib.colors</code>모듈과 함께 python 기본 라이브러리 <code>colorsys</code>를 사용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.colors <span class="keyword">as</span> mcolors</span><br><span class="line"><span class="keyword">import</span> colorsys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_hls</span>(<span class="params">c, dh=<span class="number">0</span>, dl=<span class="number">0</span>, ds=<span class="number">0</span>, dalpha=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    c : (array -like, str) color in RGB space</span></span><br><span class="line"><span class="string">    dh : (float) change in Hue</span></span><br><span class="line"><span class="string">        default = 0</span></span><br><span class="line"><span class="string">    dl : (float) change in Lightness</span></span><br><span class="line"><span class="string">        default = 0</span></span><br><span class="line"><span class="string">    ds : (float) change in Saturation</span></span><br><span class="line"><span class="string">        default = 0</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 입력된 color를 RGBA numpy array로 변환</span></span><br><span class="line">    c_rgba = mcolors.to_rgba(c)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># RGB와 alpha 분리</span></span><br><span class="line">    c_rgb = c_rgba[:<span class="number">3</span>]</span><br><span class="line">    alpha = c_rgba[<span class="number">3</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># RGB 색공간을 HLS 색공간으로 변환 후 입력된 변화 적용</span></span><br><span class="line">    c_hls = colorsys.rgb_to_hls(*c_rgb)</span><br><span class="line">    h = c_hls[<span class="number">0</span>] + dh</span><br><span class="line">    l = <span class="built_in">max</span>(<span class="built_in">min</span>(c_hls[<span class="number">1</span>] + dl, <span class="number">1</span>), <span class="number">0</span>)     <span class="comment"># 0~1 범위를 넘지 않도록 제어</span></span><br><span class="line">    s = <span class="built_in">max</span>(<span class="built_in">min</span>(c_hls[<span class="number">2</span>] + ds, <span class="number">1</span>), <span class="number">0</span>)     <span class="comment"># 0~1 범위를 넘지 않도록 제어</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># HLS 색공간에서 변경된 색을 RGB 색공간으로 변환</span></span><br><span class="line">    c_rgb_new = colorsys.hls_to_rgb(h, l, s)</span><br><span class="line">    alpha = <span class="built_in">max</span>(<span class="built_in">min</span>(alpha+dalpha, <span class="number">1</span>), <span class="number">0</span>)  <span class="comment"># 0~1 범위를 넘지 않도록 제어</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> np.append(c_rgb_new, alpha) <span class="comment"># alpha 추가하여 return</span></span><br></pre></td></tr></table></figure></li><li><p>구성은 간단합니다. </p></li><li><p>RGB 색공간에서 정의된 색을 색상, 명도, 채도 변화량과 함께 입력받고,</p></li><li><p>HLS 공간으로 변환해서 원하는 변화를 적용하고, 다시 RGB 색공간으로 변환시켜 <code>return</code>합니다.</p></li><li><p><b><code>mcolors.to_rgba()</code></b>명령으로 색 이름을 처리했기 때문에 <b>array-like</b>, <b>string</b>, <b>hex code</b>를 모두 인식합니다.</p></li><li><p>Hue는 무한 순환하지만 Lightness와 Saturation은 그렇지 않습니다. 범위를 넘지 않도록 제어합니다.</p></li><li><p>만약 입력 색에 alpha 채널이 있어 불투명도가 지정되어 있다면, 이를 따로 떼었다가 마지막에 다시 붙입니다.<br><br><img src="bobross.jpg" alt="어때요, 참 쉽죠?"><br></p></li></ul><h2 id="2-3-bar-plot-적용"><a href="#2-3-bar-plot-적용" class="headerlink" title="2.3. bar plot 적용"></a>2.3. bar plot 적용</h2><ul><li><p>펭귄 데이터셋을 예제로 bar plot을 이렇게 강조해 봅니다.</p></li><li><p>Adelie, Chinstrap, Gentoo 세 펭귄의 데이터 수를 seaborn의 <code>countplot</code> 함수로 표현합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df_peng = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">sns.countplot(y=<span class="string">&quot;species&quot;</span>, data=df_peng, ax=ax)</span><br></pre></td></tr></table></figure><p><img src="112_sethls_04.png"><br></p></li><li><p><b>Gentoo</b> 데이터만 강조합시다.</p></li><li><p>우리의 <code>set_hls()</code>를 사용할 차례입니다.</p></li><li><p><b>세 개의 bar 중 처음 두 개는 명도+0.5, 채도-0.3를 적용</b>하고, <b>Gentoo는 채도+0.2</b>를 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(ax.patches):</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">2</span>:</span><br><span class="line">        fc = set_hls(p.get_fc(), dl=<span class="number">0.4</span>, ds=-<span class="number">0.3</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        fc = set_hls(p.get_fc(), ds=<span class="number">0.2</span>)</span><br><span class="line">    p.set_fc(fc)</span><br><span class="line">    </span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure><p><img src="112_sethls_05.png"><br></p></li><li><p><code>sns.countplot()</code>에 <code>palette</code>매개변수로 각 bar별 색을 따로 지정할 수도 있습니다.</p></li><li><p>그러나 이 경우 <b>bar가 많으면 일일이 입력하기 어렵고</b>,</p></li><li><p><b>sorting 등으로 순서가 바뀌면 일일이 순서를 바꿔줘야 하고</b></p></li><li><p>회색을 쓰지 않고 <b>색상을 살짝 남기려면 RGB 공간에서 적당한 색을 찾기가 어렵습니다.</b></p></li></ul><ul><li><p>하는 김에 한 단계 더 들어갑니다.</p></li><li><p>불필요한 spines와 ticks를 제거하고 데이터 값을 bar에 직접 박아 넣습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ax.spines[[<span class="string">&quot;top&quot;</span>, <span class="string">&quot;right&quot;</span>, <span class="string">&quot;bottom&quot;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line">ax.<span class="built_in">set</span>(xticks=[], xlabel=<span class="string">&quot;&quot;</span>, ylabel=<span class="string">&quot;&quot;</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;count (species)&quot;</span>, color=<span class="string">&quot;gray&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(ax.patches):</span><br><span class="line">    x, width = p.get_x(), p.get_width()</span><br><span class="line">    c = <span class="string">&quot;gray&quot;</span> <span class="keyword">if</span> i &lt; <span class="number">2</span> <span class="keyword">else</span> <span class="string">&quot;w&quot;</span></span><br><span class="line">    ax.text(width-<span class="number">3</span>, i, <span class="string">f&quot;<span class="subst">&#123;width&#125;</span>&quot;</span>, c=c,</span><br><span class="line">            ha=<span class="string">&quot;right&quot;</span>, va=<span class="string">&quot;center&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line"></span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure><p><img src="112_sethls_06.png"><br></p></li><li><p>시각화 지침서에 나오는 모범 사례에 조금은 더 가까워진 듯 합니다.</p></li></ul><h2 id="2-4-KDE-plot-적용"><a href="#2-4-KDE-plot-적용" class="headerlink" title="2.4. KDE plot 적용"></a>2.4. KDE plot 적용</h2><blockquote><p><a href="http://m.yes24.com/goods/detail/87631760">Claus Wikle, “데이터 시각화 교과서”</a></p></blockquote><ul><li><p>같은 책에는 이런 그림도 있습니다.</p></li><li><p>승객의 연령과 성별을 누적 분포로 그린 그림입니다.</p></li><li><p>bar plot보다 난이도가 조금 더 높게 느껴집니다.<br><br><img src="112_sethls_03.png"><br></p></li><li><p>이번에는 이런 그림에 도전합니다.</p></li><li><p><code>seaborn</code>의 <code>kdeplot()</code>을 사용해 Male과 Female이 아래에 위치한 누적 분포를 그립니다.</p></li><li><p>윤곽선을 없애기 위해 <code>linewidth=0</code>을 입력하고, </p></li><li><p>배색과 hue_order를 데이터가 위에서 아래로 쌓이는 순서대로 입력합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>,</span><br><span class="line">                       sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, multiple=<span class="string">&quot;stack&quot;</span>,</span><br><span class="line">            palette=[<span class="string">&quot;lightgray&quot;</span>, <span class="string">&quot;C0&quot;</span>], alpha=<span class="number">1</span>, linewidths=<span class="number">0</span>,</span><br><span class="line">            hue=<span class="string">&quot;sex&quot;</span>, hue_order=[<span class="string">&quot;Female&quot;</span>, <span class="string">&quot;Male&quot;</span>], ax=axs[<span class="number">0</span>])</span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, multiple=<span class="string">&quot;stack&quot;</span>,</span><br><span class="line">            palette=[<span class="string">&quot;lightgray&quot;</span>, <span class="string">&quot;C1&quot;</span>], alpha=<span class="number">1</span>, linewidths=<span class="number">0</span>,</span><br><span class="line">            hue=<span class="string">&quot;sex&quot;</span>, ax=axs[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><img src="112_sethls_07.png"><br></p></li><li><p>ticklabels, label, title, spines, grid 등을 차례로 수정합니다.</p></li><li><p>불필요한 요소는 제거하고 필요한 요소는 추가합니다.</p></li><li><p>애초에 <code>sns.kdeplot()</code> 안에 <code>legend=False</code>를 입력하면 legend가 생기지 않습니다.</p></li><li><p>그러나 일단 생성된 legend를 제거하려면 <code>Axes.get_legend()</code>로 접근해서 <code>.remove()</code>를 실행해야 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">titles = [<span class="string">&quot;male penguins&quot;</span>, <span class="string">&quot;female penguins&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, titles):</span><br><span class="line">    <span class="comment"># ticklabels, x/y label, title, facecolor</span></span><br><span class="line">    ax.<span class="built_in">set</span>(xlim=(<span class="number">2001</span>, <span class="number">6999</span>), yticklabels=[], xlabel=<span class="string">&quot;&quot;</span>, ylabel=<span class="string">&quot;&quot;</span>, title=title, facecolor=<span class="string">&quot;none&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ytick length = 0</span></span><br><span class="line">    ax.tick_params(axis=<span class="string">&quot;y&quot;</span>, length=<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># spines 제거</span></span><br><span class="line">    ax.spines[[<span class="string">&quot;left&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;right&quot;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># grid</span></span><br><span class="line">    ax.yaxis.set_zorder(-<span class="number">1</span>)</span><br><span class="line">    ax.grid(axis=<span class="string">&quot;y&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># legend 제거</span></span><br><span class="line">    legend = ax.get_legend()</span><br><span class="line">    legend.remove()</span><br></pre></td></tr></table></figure><p><img src="112_sethls_08.png"><br></p></li><li><p>xlabel을 두 Axes에 공통으로 추가합니다.</p></li><li><p>Figure 레벨에 붙이는 공통 Axes는 <code>fig.supxlabel()</code>을 사용합니다.</p></li><li><p>예제 그림처럼 뒤쪽에 있는 회색 밀도함수에만 투명도를 0.7로 지정합니다.</p></li><li><p>seaborn에서 생성한 색칠된 KDE plot은 collection 객체로 지정됩니다.</p></li></ul><ul><li><p>Legend를 새로 만들 차례입니다.</p></li><li><p>Legend를 지정할 요소를 list로 모아 <code>handles</code>로 지정하고,</p></li><li><p>이를 가리킬 이름들을 <code>labels</code>로 지정해 오른쪽 Axes 우측 상단에 추가합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># common xlabel</span></span><br><span class="line">fig.supxlabel(<span class="string">&quot;body mass (g)&quot;</span>, fontsize=<span class="string">&quot;large&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 투명도 설정</span></span><br><span class="line">all_sexs = [axs[<span class="number">0</span>].collections[<span class="number">1</span>], axs[<span class="number">1</span>].collections[<span class="number">1</span>]]</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> all_sexs:</span><br><span class="line">    a.set_alpha(<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 새 legend 추가</span></span><br><span class="line">handles = [axs[<span class="number">0</span>].collections[<span class="number">1</span>], axs[<span class="number">0</span>].collections[<span class="number">0</span>], axs[<span class="number">1</span>].collections[<span class="number">0</span>]]</span><br><span class="line">labels = [<span class="string">&quot;all sexs&quot;</span>, <span class="string">&quot;males&quot;</span>, <span class="string">&quot;females&quot;</span>]</span><br><span class="line">axs[<span class="number">1</span>].legend(handles=handles, labels=labels, loc=<span class="string">&quot;upper right&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="112_sethls_09.png"><br></p></li><li><p>여기까지 했으면 모두 완료입니다.</p></li><li><p>그런데 수컷과 암컷에 지정된 색을 바꿔보고 싶다면 <code>set_hls()</code>를 적용할 수 있습니다.</p></li><li><p><code>dh</code>로 색상을 바꾸고 <code>ds</code>로 채도를 낮춥니다.</p></li><li><p>handles 변경 후에는 legend도 새로 만듭니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 성별 밀도 함수 객체 색상 변경</span></span><br><span class="line">sexs = [axs[<span class="number">0</span>].collections[<span class="number">0</span>], axs[<span class="number">1</span>].collections[<span class="number">0</span>]]</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> sexs:</span><br><span class="line">    fc = p.get_facecolor()</span><br><span class="line">    p.set_facecolor(set_hls(fc, dh=<span class="number">0.8</span>, ds=-<span class="number">0.3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># handles 변경을 legend에 반영    </span></span><br><span class="line">handles = [axs[<span class="number">0</span>].collections[<span class="number">1</span>], axs[<span class="number">0</span>].collections[<span class="number">0</span>], axs[<span class="number">1</span>].collections[<span class="number">0</span>]]</span><br><span class="line">labels = [<span class="string">&quot;all sexs&quot;</span>, <span class="string">&quot;males&quot;</span>, <span class="string">&quot;females&quot;</span>]</span><br><span class="line">axs[<span class="number">1</span>].legend(handles=handles, labels=labels, loc=<span class="string">&quot;upper right&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="112_sethls_10.png"><br></p></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualziation/">visualziation</category>
      
      <category domain="https://jehyunlee.github.io/tags/color/">color</category>
      
      
    </item>
    
  </channel>
</rss>
