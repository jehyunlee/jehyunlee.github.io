<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Pega Devlog</title>
    <link>https://jehyunlee.github.io/</link>
    
    <atom:link href="https://jehyunlee.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Pega&#39;s Development log for myself and others</description>
    <pubDate>Fri, 12 Aug 2022 07:12:33 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>1001 days commit Q&amp;A (2)</title>
      <link>https://jehyunlee.github.io/2022/08/12/Python-General-12-1001commit2/</link>
      <guid>https://jehyunlee.github.io/2022/08/12/Python-General-12-1001commit2/</guid>
      <pubDate>Fri, 12 Aug 2022 04:59:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;2019년 11월 9일부터 기록된 일일커밋이 2022년 8월 5일자로 1001일을 달성했습니다.&lt;/li&gt;
&lt;li&gt;스스로 조금 뿌듯해서 관련된 기록을 남겨보고 싶었습니다.&lt;/li&gt;
&lt;li&gt;커뮤니티 등을 통해 47분에게 받은 응답을 가상 </description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>2019년 11월 9일부터 기록된 일일커밋이 2022년 8월 5일자로 1001일을 달성했습니다.</li><li>스스로 조금 뿌듯해서 관련된 기록을 남겨보고 싶었습니다.</li><li>커뮤니티 등을 통해 47분에게 받은 응답을 가상 인터뷰 형식으로 정리합니다.</li></ul><h1 id="2-데이터-분석-amp-커리어"><a href="#2-데이터-분석-amp-커리어" class="headerlink" title="2.데이터 분석 &amp; 커리어"></a>2.데이터 분석 &amp; 커리어</h1><ul><li><p><b>Q10. 지금 하는 일은 무엇인지?</b><br><code>목승찬</code></p></li><li><p><b>A10. 정부출연연구소에서 데이터, AI등을 담당하고 있습니다.</b><br><br>여러 부서로부터 분석 지원 요청을 받아 공동연구를 합니다.<br>다양한 도메인을 접할 수 있다는 것이 장점과 단점으로 존재합니다.<br>요청을 하시는 분들께서는 도메인 전문가셔서, 분석 기법은 시행착오를 거치며 스스로 판단해야 합니다.<br><b>적용을 요청하신 기법과 최종적으로 적용한 기법이 상이</b>한 경우가 대부분입니다.</p><br></li><li><p><b>Q11. 딥러닝 활용한 프로젝트도 실무에서 하는지? 개인용 딥러닝 서버 스펙?</b><br><code>우드득</code></p></li><li><p><b>A11. 현재 진행하는 업무 중 하나만 딥러닝이고 나머지는 트리 모델을 씁니다.</b><br><br>딥러닝을 일부러 사용하지 않는 건 아닙니다.<br>제게 오는 데이터의 양이 적고 image, 자연어 처리를 하지 않기 때문입니다.<br><b>도메인 연구</b>의 일환이다 보니 <b>예측력보다 설명력이 중요</b>하기도 합니다.<br>간혹 필요할 때는 데스크탑에 설치된 GeForce RTX 2070을 사용합니다.<br></p><br></li><li><p><b>Q12. 지금의 모습을 언제부터 꿈꿨는지? 꿈을 이루기 위해 무엇을 했는지? 머신 러닝 입문 계기?</b><br><code>TY</code>, <code>라이언</code>, <code>제이</code></p></li><li><p><b>A12. 꿈꾼 적 없습니다. 코딩을 하며 숫자와 살 거라고는 상상도 못했습니다.</b><br><br>말씀드리자면 길지만 제가 꿈꾸던 모습과 지금의 모습은 아주 많이 다릅니다.<br>박사학위를 받은 분야도 다르고, 코딩을 조금씩 하게 된 것도 <b>박사학위를 받은 뒤</b>입니다.<br>당시는 시뮬레이션을 했는데 데이터를 복붙하며 처리하다 밤을 새고 나서 <b>이러느니 코딩하겠다</b>고 시작했습니다.<br>머신 러닝도 전 직장에서 알파고 이후, 2017년 부서가 만들어지면서 관리자(파트장)로 시작했습니다.<br>결국 수락했지만 이미 새로 시작되는 일마다 투입되는 일이 4년간 반복되어 지쳐있어 두 번을 거절했습니다.<br><b>“제가 뭘 안다고 하나요”</b>라는 항변에 당시 그룹장님의 <b>“넌 빨리 배우잖아.”</b>라는 말씀이 기억에 남습니다.<br></p><br></li><li><p><b>Q13. 실패의 기억?</b><br><code>신명진</code></p></li><li><p><b>A13. 성공과 실패를 뭐라고 정의하면 좋을까요?</b><br><br><b>내 의지대로 됐는지 여부</b>라면 대학원 졸업 이후 실패의 연속입니다.<br>애초에 한 분야의 전문가가 되고자 대학원에 진학했는데 그러지 못했기 때문입니다.<br>아무리 생각해봐도 저 개인의 힘으로는 어쩔 수 없는 큰 파도에 쓸린 느낌입니다.<br><br><img src="112_1001commit2_05.png" alt="박사학위 이후 인생유전"><br>하지만 <b>결과적으로 행복해졌는지</b> 여부를 따진다면 실패라고 부르기는 어려울지도 모릅니다.<br>본의 아니게 이런저런 변화를 겪었지만 한쪽 문이 닫히면서 다른 쪽 문이 열렸습니다.<br>여러 분야를 걸치면서 시야가 넓어졌고, 저쪽에서 배운 기술을 이쪽에서 발휘합니다.<br>지금도 같은 부서에 동료가 없는 것은 아쉽지만 외부에서 좋은 인연을 만나고 있습니다.<br><br><br><img src="112_1001commit2_04.png" alt="life flow"><br></p></li></ul><blockquote><p><a href="https://jehyunlee.github.io/2020/12/12/Python-DS-47-debun/">Pega x Codestates: 이세계에서 시작하는 데분러 생활</a><br><br></p></blockquote><ul><li><p><b>Q14. 데이터 분석 및 시각화를 하게 된 이유?</b><br><code>융</code></p></li><li><p><b>A14. 일이니까 했습니다.</b><br><br>제가 하는 일은 결과만 잘 나온다고 끝이 아닙니다. <b>원인을 파악하고 인사이트를 발굴해야 합니다.</b><br>그러다 보니 자연스럽게 머신 러닝보다 데이터 분석에 집중하게 되었습니다.<br>머신 러닝도 제게는 서비스보다 데이터 분석의 일환입니다.<br><b>데이터 시각화</b>도 머신 러닝과 데이터 분석을 하면서 자연스럽게 발을 들였습니다.<br>데이터 시각화에 쓰는 시간이 아깝다는 생각이 들면서 <b>익숙해지자</b>고 결심했습니다.<br>지금은 생각에서 그림으로 옮겨지는 시간이 제법 줄었습니다.<br></p><br></li><li><p><b>Q15. 태블로도 다루는지?</b><br><code>Jonsnow</code></p></li><li><p><b>A15. 아닙니다.</b><br><br>하지만 분석 결과 배포에 유리할 것으로 생각되어 관심을 가지고 있습니다.<br>아직은 아니지만 조만간 interactive plot을 많이 할 것 같습니다.<br></p><br></li><li><p><b>Q15. 다시 대학생이 된다면 무엇을 위해 어떤 준비를 할 것인지? 어릴 적으로 돌아간다면 어떤 업으로 살고 싶은지?</b><br><code>신명진</code>, <code>라이언</code></p></li><li><p><b>A15. 컴퓨터 그래픽스를 배우고 싶습니다.</b><br><br>어쩌면 당시 독학으로 <b>CAD</b>와 <b>포토샵</b>을 배웠던 덕에 여러 기회를 거쳐 여기까지 온 것 같습니다.<br>재미로 했던 CAD 3D 모델링 덕에 대학원 시절 FEM(유한요소) 모델을 어렵지 않게 만들 수 있었고,<br><b>전자현미경으로 직접 관찰한 결과를 시뮬레이션</b>할 수 있었습니다.<br><img src="112_1001commit2_02.png" alt="Jehyun Lee et al., Appl. Phys. Lett. 2011 (DOI: 10.1063/1.3623752)"><br><br>그런데 근본이 없이 눈과 손으로 배워서 하다 보니 기본기가 부족함을 자주 느낍니다.<br>학문의 초창기 신학을 포함한 <b>철학</b>, <b>과학</b>, <b>의학</b>이 구분되지 않았던 것 처럼,<br>컴퓨터과학의 초창기에는 <b>물리 시뮬레이션</b>과 <b>컴퓨터 그래픽스</b>가 구분되지 않았습니다.<br>근본을 제대로 익혔다면 더 나은 제가 되어 있을 것 같습니다.<br><br><img src="112_1001commit2_01.jpg" alt="Boeing man by William Fetter, an art director of the Boeing Company (1964)"><br></p><br></li><li><p>그런데, 생각을 해보니 그 때도 <b>데이터를 모아서 분석하는 연구</b>를 했네요.</p></li><li><p>당시 저 분야에서 물성의 분포를 확률적으로 다루기 시작하는 분들이 있었습니다.</p></li><li><p>그 영향을 받아서 시도했던 것으로 기억이 납니다.<br><img src="112_1001commit2_03.png" alt="Jehyun Lee et al., Appl. Phys. Lett. 2011 (DOI: 10.1063/1.3623752)"><br></p></li><li><p><b>Q16. 깃헙을 통해서 포지션 제안이 온 적이 있는지?</b><br><code>츄로오스</code></p></li><li><p><b>A16. 있습니다.</b><br></p><br></li><li><p><b>Q17. 분석가로서 커리어를 어떻게 정리하는지? 신입 데이터 사이언티스트에게 조언. 여러 프로젝트를 단기간씩 하는 것에 대한 조언?</b><br><code>김성호</code>, <code>김영동</code>, <code>난키</code></p></li><li><p><b>A17. 제가 조언을 할 수 있는 입장은 아닌 것 같습니다.</b><br><br>저도 과거의 경력과 사실상 단절하고 데이터 분석가로서 새로운 경력을 쌓아가는 중이기 때문입니다.<br><b>연구자</b>로서 논문을 출판하기도 해야겠지만 <b>개발자</b>속성을 띄고 있습니다.<br>모든 분야에서 동시에 인정받으면 좋겠지만 그러기 어려워서 나름의 순서를 정했습니다.<br>이 순서에서 딥러닝은 가장 뒤에 있습니다. 점점 더 문턱이 낮아지고 있다고 느껴서입니다.<br><b>그런데 여러 프로젝트를 동시에 하는 것은 좋지 않은 것 같습니다.</b><br>데이터 분석의 특성상 데이터에 코를 박고 모든 감각으로 흡수해서 단기 기억을 동원해야 합니다.<br>그러다보니 여러 프로젝트를 동시에 하면 효율이 극심하게 떨어집니다.<br>이것도 훈련이라면 훈련이라고, 연습이라면 연습이라고 생각하고 있습니다.<br></p><br></li><li><p><b>Q18. 데이터 사이언스에서 기본적으로 갖춰야 할 개념</b><br><code>우왕</code></p></li><li><p><b>A18. 역시 제가 조언을 할 수 있는 입장은 아닌 것 같습니다.</b><br><br>제 생각만 말씀드리자면, <b>데이터 분포</b>와 <b>확률</b>에 대한 개념이 가장 중요할 것 같습니다.<br>하나를 더 보태면 분석가의 성격이 조금 <b>집요</b>할 필요가 있다고 생각합니다.<br>노이즈에 묻힌 데이터의 본 모습을 끄집어 내는게 간단하지는 않다고 느끼기 때문입니다.<br></p></li></ul><h1 id="3-생활"><a href="#3-생활" class="headerlink" title="3.생활"></a>3.생활</h1><ul><li><p><b>Q19. 하루 일과, 일-삶-배움의 균형은 괜찮은지? 업무 시간과 우선 순위는 어떻게 관리하는지?</b><br><code>게으른파이썬</code>, <code>김영동</code>, <code>냥</code>, <code>이종원</code>, <code>황성주</code></p></li><li><p><b>A19. 가족에게 어느 정도 희생을 강요하고 있다고 느낍니다.</b><br><br>아침 루틴을 마치고 출근해서 일을 한 뒤, 퇴근해서 가족과 시간을 보냅니다.<br>일주일에 두 번 아침식사 전에 전화 영어를 하고, 아침식사와 점심식사 후 30분 산책을 합니다.<br>이직 이후 가족과 보내는 시간이 크게 늘어난 것은 사실이지만, 바쁘면 여전히 야근과 주말 근무를 합니다.<br>업무 시간과 우선 순위는 <b>마감에 맞춰 정해진다</b>고 보는게 맞을 것입니다.<br>아침에 출근하면서 <b>하루를 시뮬레이션</b>하는데, 시간 관리 능력이 많이 부족하다고 느끼고 있습니다.<br>가족과 보내는 시간과 함께 <b>실무 능력</b>을 확보하고자 이직을 했습니다.<br>그래서 <b>술</b>을 거의 먹지 않습니다. 술을 먹으면 먹는 시간 + 회복 시간까지 손실이 생기기 때문입니다.<br>한 달에 맥주 한 두 캔 정도가 보통인 것 같고, 그나마 집에서 먹습니다.<br><b>술자리에서 오가는 말을 믿지 않기 때문</b>일지도 모릅니다.<br><br><img src="112_1001commit2_07.png" alt="이제현, Galaxy S2 (맨 왼쪽), Galaxy Note2 (두번째부터) + Autodesk Sketchbook (2013-2014)"></p><br></li><li><p><b>Q20. 명절, 육아 등 체력 관리</b><br><code>시나몬</code></p></li><li><p><b>A20. 체력은 타고난 면이 큰 것 같습니다.</b><br><br>하루에 다섯 시간만 자도 충분하다고 느끼고 며칠 무리를 해도 괜찮다고 느낍니다.<br><b>느낀다</b>고 말하는 것은, 그 때는 괜찮은데 마감이 지나면 후폭풍이 없지 않기 때문입니다.<br>전문가에게 받은 TCI(기질 및 성격 검사)에서 <b>인내심이 상위 3%라고 나왔습니다.</b><br>어쩌면 고통에 둔감한 건지도 모릅니다.<br></p><br></li><li><p><b>Q21. 페가에게 커피란?</b><br><code>엘카인</code></p></li><li><p><b>A21. 업무 전환 스위치입니다.</b><br><br>일을 시작할 때, 하는 일의 종목을 바꿀 때 커피를 마시면서 주위를 환기합니다.<br>하루를 시작할 때 정신을 차리는 <b>영약</b>이기도 합니다.<br><br><img src="112_1001commit2_06.png" alt="이제현, Galaxy S2 (세번째까지), Galaxy Note2 (맨 오른쪽) + Autodesk Sketchbook (2012-2013)"></p><br></li><li><p><b>Q22. 독서의 계기와 독서의 방법?</b><br><code>바로잡기</code></p></li><li><p><b>A22. 책에 따라 다릅니다.</b><br><br><b>즐기기 위해 읽는 책</b>이 있고 <b>살아남기 위해 읽는 책</b>이 있습니다.<br>즐기기 위해 읽는 책은 글자 그대로 재밌어서 보는 책입니다. 소설을 오래 못 읽어서 아쉽습니다.<br>살아남기 위해 읽는 책은 업무 관련한 책입니다.<br>두 번 볼 새가 없다는 것을 알고 있기 때문에 <b>한 번 읽을 때 머리에 넣으려고</b> 합니다.<br>슬렁슬렁 읽어서는 머리에 들어오지 않는 걸 경험으로 압니다. 새벽에 집중해서 읽습니다.<br></p><br></li><li><p><b>Q23. 인생에서 이루고 싶은 꿈/삶의 지향점?</b><br><code>최우성</code></p></li><li><p><b>A23. 있었는데 잊었습니다. 다시 찾고 있습니다.</b><br><br>약 10년간 급류에 휘말려서 눈앞의 목적이 <b>생존</b>이었습니다.<br>숨을 쉴 때마다 물을 먹으면서 괴로워하다가 정신을 차린지 얼마 되지 않습니다.<br>그 전에 뭔가 있었는데 잊어버렸습니다. 새로 찾아야 합니다. 좋은 게 있겠죠? :)<br><br><img src="112_1001commit2_08.png" alt="이제현, &quot;Gravity&quot;, Galaxy Note2 + Autodesk Sketchbook (2013.12.11)"></p><br></li></ul><h1 id="4-기타"><a href="#4-기타" class="headerlink" title="4. 기타"></a>4. 기타</h1><ul><li>공개적으로 답하기 어려운 질문, 제가 답하기에 지식과 생각이 너무 짧은 부분을 질문주신 분들이 있습니다.</li><li>이 분들께는 제가 <b>개인적으로 답을 드리겠습니다.</b></li><li>이 블로그에 이렇게 개인적인 글을 올리는 것은 처음입니다. 마지막일지도 모릅니다. </li><li>언젠가 소리소문 없이 지워질 수도 있습니다.</li><li>읽어주셔서 감사합니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/life/">life</category>
      
      
    </item>
    
    <item>
      <title>1001 days commit Q&amp;A (1)</title>
      <link>https://jehyunlee.github.io/2022/08/06/Python-General-11-1001commit/</link>
      <guid>https://jehyunlee.github.io/2022/08/06/Python-General-11-1001commit/</guid>
      <pubDate>Sat, 06 Aug 2022 06:59:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;2019년 11월 9일부터 기록된 일일커밋이 2022년 8월 5일자로 1001일을 달성했습니다.&lt;/li&gt;
&lt;li&gt;스스로 조금 뿌듯해서 관련된 기록을 남겨보고 싶었습니다.&lt;/li&gt;
&lt;li&gt;커뮤니티 등을 통해 47분에게 받은 응답을 가상 </description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>2019년 11월 9일부터 기록된 일일커밋이 2022년 8월 5일자로 1001일을 달성했습니다.</li><li>스스로 조금 뿌듯해서 관련된 기록을 남겨보고 싶었습니다.</li><li>커뮤니티 등을 통해 47분에게 받은 응답을 가상 인터뷰 형식으로 정리합니다.</li></ul><h1 id="1-천일커밋"><a href="#1-천일커밋" class="headerlink" title="1.천일커밋"></a>1.천일커밋</h1><blockquote><p><a href="https://github.com/jehyunlee/">Pega: github</a><br><a href="https://huggingface.co/spaces/dalle-mini/dalle-mini">craiyon.com: DALL.E mini</a></p></blockquote><p><img src="111_1001commit_03.png" alt="Created by DALL.E mini @Huggingface"></p><ul><li><b>Q1. 커밋은 언제부터 시작했습니까?</b></li><li><b>A1. 공식적으로 2019년 11월 9일입니다.</b><br></li></ul><p><img src="111_1001commit_01.png" alt="https://github.com/jehyunlee/"><br><img src="111_1001commit_02.png" alt="네이버 날짜 계산기"><br></p><ul><li><b>Q2. 천일커밋을 하게 된 계기는 무엇입니까?</b><br><code>tapecopyman</code>, <code>김둘기</code>, <code>김택완</code>, <code>목승찬</code>, <code>손성민</code>, <code>안세홋</code>, <code>우왕</code>, <code>이상원</code>, <code>이정원</code>, <code>이준형</code>, <code>최우성</code>, <code>페가님 발뒤꿈치도 못따라가는 개발자 🥲</code></li><li><b>A2. PyCon KR 2019에서 두 분의 발표를 듣고 시작했습니다.</b><br><br>2017년까지 삼성전자 반도체연구소에서 근무하다 2018년 현재의 한국에너지기술연구원으로 이직했습니다.<br>2016~2017 2년간 관리자(파트장)로 살다가 실무 역량을 기르겠다고 이직을 했는데,<br>과제제안서와 발표자료 등을 만들다 보면 2주간 코딩 한 줄을 안하기도 했습니다.<br>게다가 당시 매우 어린 아이들까지 돌보다 보니 <b>이래서 나이가 들면 실무 안하고 관리를 해야되나</b> 생각까지 했습니다.<br><br><img src="111_1001commit_04.png" alt="당시 심경을 담은 슬라이드"><br><br>그러던 차에 공부를 해보겠다고 PyCon KR에 참석했다가 여러 분들의 발표를 들으며 한껏 고무되었습니다.<br>특히 라이트닝토크에서 들었던 두 분의 발표가 제 방향을 완전히 바꾸었습니다.<br>아들 둘의 어머니인 <b>박조은</b>님과 군대에서 코딩하는 <b>이준영</b>님이었습니다.<br>군대 사지방에 개발 환경을 구축하시고 당일도 휴가를 내고 파이콘에 참석하신 이준영님도 대단하셨고,<br>경단녀로서 육아를 하며 (거의) 매일 잔디를 심고 유튜브를 찍어 올리신 박조은님을 보고 <b>핑계가 없다</b>고 느꼈습니다.<br><br><img src="111_1001commit_05.png" alt="터닝포인트를 제공해주신 두 분"><br><br>마침 github에 잔디를 간간이 심기 시작한 직후라 <b>그 날부터 일일커밋을 시작했습니다.</b><br>그 날이 <b>2019년 8월 17일</b>이었습니다.<br>위 이야기를 <a href="https://www.youtube.com/watch?v=s8yBnEcOYN8&t=568s">PyCon KR 2020 라이트닝토크 영상</a>으로 제출했습니다. 온라인이라 아쉬웠습니다.<br><br>그런데 일일커밋 시작 날짜가 기록이 시작된 2019년 11월 9일과는 석달쯤 차이가 있습니다.<br>200일쯤 연속커밋을 했던 날 <b>더 이상 필요없는 레포를 지웠다가 11월 8일까지 구멍이 여러 개 생겼습니다.</b><br><b>1001일 중 가장 멘탈이 흔들렸던 날입니다. </b><br>억지로 커밋 날짜를 바꾸어 잔디를 메우기보다 100일쯤 손해를 보더라도 기준일을 바꾸기로 했습니다.</li></ul><blockquote><p><a href="https://www.youtube.com/watch?v=dwRP-J6OPI8&t=1020s">PyCon KR 2019: 박조은님 라이트닝토크 영상</a><br><a href="https://www.youtube.com/watch?v=Za05A9fiQ3U&t=2520s">PyCon KR 2019: 이준영님 라이트닝토크 영상</a><br><a href="https://www.youtube.com/watch?v=s8yBnEcOYN8&t=568s">PyCon KR 2020: 이제현 라이트닝토크 영상</a></p></blockquote><ul><li><b>Q3. 주제가 어떤 것들이었나요? 커밋하는 코드의 수준은?</b><br><code>iilii</code>, <code>우왕</code>, <code>코쟁이</code>, <code>목승찬</code>, <code>손성민</code>, <code>이형도</code></li><li><b>A3. 현업과 개인 공부를 가리지 않았습니다. (적어도 초기에는) 코드 수준이 높다고 보기 힘듭니다.</b><br><br>목적이 <b>하루에 한 줄이라도 매일 코딩하는 것</b>이었습니다.<br>업무를 하면서 발생하는 코드도 커밋을 했고 (다행히 github에 올리지 말라는 규정이 없습니다. private으로 올렸습니다)<br>업무상 코딩할 일이 없는 날은 일부러 거리를 만들어서라도 커밋을 했습니다.<br>당시 제가 하던 커밋은 CLI 환경에서 <code>git commit</code> 명령어를 실행하는 방식이 아니었습니다.<br>git 자체도 낯선 수준이었기 때문에 로컬에서 작업한 파일을 github 웹페이지에 올렸습니다.<br>자주 검색하는 코드를 정리해서 만든 <b>code snippet</b>을 올리는 것으로 시작했습니다.<br><br><img src="111_1001commit_06.png" alt="https://github.com/jehyunlee/code-snippet"><br><br>PyCon에서 <b>전상환</b>님께 배운 <b>geopandas tutorial</b>도 정리했고,<br>pandas를 사용하면서 알게 된 팁, Matplotlib 명령어 등도 정리했습니다.<br><br>이후 코드가 조금씩 손가락 근육에 스며들면서 private에 있는 <b>업무 코드의 수준이 조금씩 좋아짐을 느낍니다.</b><br>2019년 12월 <b>깃헙 블로그</b>를 시작한 이후 블로그 글도 커밋의 소재가 되었습니다.<br>코드를 정리하는 tech blog라 다행히 일일코딩 원칙에는 위배되지 않습니다.<br>오늘처럼 코드가 없는 글을 올리는 날도 있지만 Colab이나 내부 서버 등에서 코딩을 합니다.<br><br><img src="111_1001commit_09.png" alt="seaborn countplot clone coding (작업중)"><br></li></ul><blockquote><p><a href="https://jehyunlee.github.io/">Pega Devlog</a></p></blockquote><ul><li><p><b>Q4. 공개 가능한지?</b><br><code>iilii</code></p></li><li><p><b>A4. 공개 가능한 코드는 주로 블로그 형태로 공개합니다. 업무 관련은 적어도 당장은 불가합니다.</b><br><br>2020년 12월부터 시행되는 <b>소프트웨어 진흥법 25조</b>에 의거,<br><b>국가연구개발사업을 하는 경우 공개소프트웨어 방식으로 개발하고 결과물을 배포</b>해야 맞습니다.<br>그러나 공개 대상인 분석 코드 및 모델링과 공개가 어려운 데이터가 뒤섞여 있어 정리가 필요합니다.<br>ETRI 오픈 소스 센터에서 중심이 되어 <b>출연연 오픈소스 협의체</b>가 발족했습니다.<br>출연연이 함께 사용할 수 있는플랫폼을 개발중이라고 하니 쓸만한 코드를 머잖아 공개할 수 있게 될 듯 합니다.<br></p><br> </li><li><p><b>Q5. 의무적인 코딩이 유익했다 보는가? 천일커밋 전과 현재를 비교했을 때 달라진 점?</b><br><code>tapecopyman, 바로잡기, 안세홋, 쏘군</code></p></li><li><p><b>A5. 매우 그렇습니다. 커뮤니티에서 받는 응원과 자신감이 가장 큰 자산입니다.</b><br><br>일일커밋을 하지 않던 시절 내가 짠 코드를 3일, 일주일, 보름만에 다시 보는 것이 일상이었습니다.<br>내 새끼도 못알아보는 지경인데 더 나은 새끼를 낳을 수 있을 리가 없습니다.<br>일일코딩 전까지는 <b>어떻게든 굴러가는 코드</b>를 짰다면, 지금은 생각이라는 걸 조금 할 수 있게 되었습니다.<br>물론 아직 갈 길이 멉니다.<br><br>무엇보다 회의, 전화, 버그랑 씨름하느라 생산적인 일은 하나도 못했다는 날도 많습니다.<br>그런 날조차 <b>오늘도 커밋을 했다</b>는 사실은 자기효능감을 지켜줍니다.<br><br>천일커밋을 시작하던 시점, 저는 도메인에만 있다가 IT 관련 필드에 발을 디딘지 1년이 넘게 뭘 할지 모르는 상황이었습니다.<br>어찌 보면 파티에 어울리지 못하고 구석에서 혼자 과자나 주워 먹는 외톨이 느낌이 강했습니다.<br>그런데 커밋이 100일을 넘어 수백일, 천일에 이르는 동안 간간이 <b>커밋 소식에 관심을 보여주시는 분들</b>이 생겼습니다.<br>여러분들의 응원이 작아보일지 몰라도 큰 위안이 됩니다.<br>이 자리를 빌어 감사 말씀을 드립니다.<br></p><br></li><li><p><b>Q6. 여행이나 주말, 명절에는 어떻게 커밋을 했나? 너무 하기 싫은 날도 있었을텐데? 번아웃은 없나? 포기하고 싶을 때 마음은 어떻게 잡는지?</b><br><code>마민정</code>, <code>목승찬</code>, <code>손성민</code>, <code>쏘군</code>, <code>안세홋</code>, <code>이땡땡</code>, <code>이형도</code>, <code>츄로오스</code>, <code>커밋은습관</code>, <code>한우철</code></p></li><li><p><b>A6. 낮에 어려우면 새벽에 합니다.</b><br><br>일일커밋의 자기효능감을 맛본 입장에서, 이걸 깨트리기는 정말 싫습니다.<br>어려서 같은 반 여자애들이 <b>기른 머리 자르기 아깝다</b>는 말을 하더군요.<br>당시엔 여기에 담긴 감정을 몰랐는데 이제는 조금 이해하게 된 것 같습니다.<br>가족이 있는 입장에서 명절과 주말은 위기인 것이 사실이지만, 2년 넘게 <b>새벽 기상</b>을 하고 있습니다.<br><br><img src="111_1001commit_07.png" alt="https://www.instagram.com/jehyunlee20/ (비공개 계정)"><br>모두 자고 있는 <b>새벽은 누구에게도 방해받지 않는 시간입니다.</b><br>이 시간이라면 주말이나 명절에도 코딩을 하고, 커밋을 할 수 있습니다.<br>커밋 후에 자전거도 한 바퀴 타고 올 여유가 됩니다.<br><br><img src="111_1001commit_08.png" alt="아내와의 카톡 대화 일부"><br><br>번아웃은 아쉽게도 몇 년째 지속되고 있는 것 같습니다.<br>간혹 무기력하고 이거 해서 뭐하나 싶을 때가 분명히 있지만 <b>그냥 합니다.</b><br>경험상, 생각을 하면 핑계만 만들게 됩니다.<br></p><br></li><li><p><b>Q7. 급한 일이 들어왔을 때 연속 커밋이 깨진다. 컨트롤하는 방법은? 일일커밋에 도전하는 후배들에게 주고 싶은 팁?</b><br><code>iilii</code>, <code>게으른파이썬</code>, <code>안세홋</code>, <code>이땡땡</code>, <code>이준형</code></p></li><li><p><b>A7. 아침에 일어나면 커밋부터 합니다.</b><br><br>저는 아침에 일어나면 책상에서 휴대폰을 집어들고 부엌으로 갑니다.<br>찬물을 한 컵 마시고, 창 밖 사진을 찍고, 인스타에 인증하고, <b>그 다음에</b> 세수를 합니다.<br>그리고 주말이라면 방에 앉아서 시간이 허락하는 대로 코딩을 하고 커밋을 합니다.<br>주중이라면 출근을 하고 커밋을 합니다.<br></p><br></li><li><p><b>Q8. 애초의 목표는 연속 며칠이었습니까?</b><br><code>이정원</code></p></li><li><p><b>A8. 100일이었습니다.</b><br><br>그런데 막상 100일이 금방 오더군요. 달성이 쉬웠던 만큼 감흥이 없었고 현타만 왔습니다.<br>그만 둘까하는 생각이 없지 않았지만 일단 계속 가 보기로 했습니다. </p><br></li><li><p><b>Q9. 가족들의 반응은? 300일, 600일, 900일 되었을 때 주변 반응은?</b><br><code>이정도</code>, <code>커밋은습관</code></p></li><li><p><b>A9. “대단하다”는 말씀을 주십니다.</b><br><br>사실 일일커밋은 IT 관련자가 아니면 잘 모르는 것이 정상입니다.<br>학창시절 commit이란 단어는 <b>commit suicide (자살하다)</b>로 배운 게 전부입니다.<br>아이들은 아빠가 뭘 하는지 이해하기엔 어리고 (아빠 직업을 <b>화가</b>로 아는 것 같습니다),<br>아내에게는 <b>응원</b>을 받습니다. 뭐가 되었건 꾸준하게 오래 하는 것을 대견하게 여겨주는 듯 해서 감사합니다.<br>같은 직장에 다니는 분들께는 일일 커밋을 알린 적이 없습니다.<br>이번을 계기로 알리게 될 것 같습니다.<br></p></li></ul><h1 id="to-be-continued…"><a href="#to-be-continued…" class="headerlink" title="to be continued…"></a>to be continued…</h1><ul><li>생각보다 질문을 많이 주셨습니다. 관심에 감사드립니다. :)</li><li>데이터 분석 관련된 질문과 커리어, 생활에 대한 질문이 있습니다.</li><li>다음 글에서 이어서 답변을 드리겠습니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/life/">life</category>
      
      
    </item>
    
    <item>
      <title>Matplotlib Animation</title>
      <link>https://jehyunlee.github.io/2022/08/05/Python-DS-110-anim/</link>
      <guid>https://jehyunlee.github.io/2022/08/05/Python-DS-110-anim/</guid>
      <pubDate>Fri, 05 Aug 2022 10:45:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;정지된 그림으로는 볼 수 없는 것들이 있습니다.&lt;/li&gt;
&lt;li&gt;시간에 따른 변화나 입체 도형의 뒷면이 그것입니다.&lt;/li&gt;
&lt;li&gt;애니메이션을 활용해 이를 보완합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-Matplotlib-anim</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>정지된 그림으로는 볼 수 없는 것들이 있습니다.</li><li>시간에 따른 변화나 입체 도형의 뒷면이 그것입니다.</li><li>애니메이션을 활용해 이를 보완합니다.</li></ul><h1 id="1-Matplotlib-animation"><a href="#1-Matplotlib-animation" class="headerlink" title="1. Matplotlib animation"></a>1. Matplotlib animation</h1><blockquote><p><a href="https://matplotlib.org/stable/api/animation_api.html">matplotlib.animation</a></p></blockquote><p><img src="110_anim_4.png"></p><ul><li>Matplotlib에서 사용할 수 있는 애니메이션은 두 가지가 있습니다.</li><li>Artist 객체 변화를 저장하는 <code>ArtistAnimation</code>,</li><li>Figure 전체의 변화를 저장하는 <code>FuncAnimation</code>이 그 것입니다.</li></ul><h2 id="1-1-base-figure"><a href="#1-1-base-figure" class="headerlink" title="1.1. base figure"></a>1.1. base figure</h2><ul><li><p>간단한 그림을 그려서 애니메이션으로 만듭니다.</p></li><li><p>가운데 동그라미를 하나 그리고, 이 동그라미가 점점 커지는 모습을 구현합니다.</p></li><li><p>기본 명령어를 사용해 화면 한가운데 동그라미를 그립니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 기본 설정</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line">sns.set_style(<span class="string">&quot;ticks&quot;</span>)</span><br><span class="line">sns.set_palette(<span class="string">&quot;colorblind&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 가운데 동그라미 점 하나</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(-<span class="number">1</span>, <span class="number">1</span>), ylim=(-<span class="number">1</span>, <span class="number">1</span>), xticks=[], yticks=[])</span><br><span class="line"></span><br><span class="line">circle = ax.scatter(<span class="number">0</span>, <span class="number">0</span>, s=<span class="number">10</span>, lw=<span class="number">1</span>, ec=<span class="string">&quot;b&quot;</span>, fc=<span class="string">&quot;none&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="110_anim_1.png"><br></p></li><li><p>객체 지향 방식을 사용해 이 객체의 크기를 바꾸겠습니다.</p></li><li><p>circle이라는 이름으로 저장한 marker 하나는 collections로 다루어집니다.</p></li><li><p><code>.set_sizes()</code>에 list 형태로 새로운 size를 전달하여 크기를 변경합니다.</p></li><li><p>marker가 하나밖에 없으므로 원소가 하나뿐인 list를 입력합니다.</p></li><li><p>이를 <code>update()</code>라는 이름의 함수로 만들어 적용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># marker 크기 변경 함수</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">frame_number</span>):</span></span><br><span class="line">    circle.set_sizes([frame_number*<span class="number">30</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># marker 크기</span></span><br><span class="line">update(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 화면 출력</span></span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure><p><img src="110_anim_2.png"><br></p></li><li><p>화면 가운데 있는 원이 커졌습니다.</p></li><li><p>이제 연속적으로 적용하고 .gif 파일로 적용하면 애니메이션이 됩니다.</p></li></ul><h2 id="1-2-FuncAnimation"><a href="#1-2-FuncAnimation" class="headerlink" title="1.2. FuncAnimation"></a>1.2. <code>FuncAnimation</code></h2><blockquote><p><a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.animation.FuncAnimation.html">matplotlib.animation.FuncAnimation</a></p></blockquote><ul><li>frame마다 변하는 Figure 차례로 저장해 애니메이션으로 만듭니다.</li><li>Figure 객체에 위에서 만든 <code>update()</code>같은 함수를 연속적으로 적용합니다.</li><li>이 때 사용하는 함수가 <code>FuncAnimation</code>이고, Figure 객체, 함수와 함께 <code>frames</code>에 총 프레임을 넣고,</li><li><code>intervals</code>에 frame 사이 시간 간격을 ms단위로 입력합니다.</li><li>위 두 코드 뒤에 <code>FuncAnimation</code> 한 줄을 추가하고, <code>.save()</code>로 파일로 저장합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.animation <span class="keyword">import</span> FuncAnimation</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Axes 주변부 요소 삭제</span></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(-<span class="number">1</span>, <span class="number">1</span>), ylim=(-<span class="number">1</span>, <span class="number">1</span>), xticks=[], yticks=[])</span><br><span class="line"></span><br><span class="line"><span class="comment"># scatter marker 생성</span></span><br><span class="line">circle = ax.scatter(<span class="number">0</span>, <span class="number">0</span>, s=<span class="number">10</span>, lw=<span class="number">3</span>, ec=<span class="string">&quot;b&quot;</span>, fc=<span class="string">&quot;none&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># animation frame마다 적용되는 변화</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">frame_number</span>):</span></span><br><span class="line">    <span class="comment"># size 변경</span></span><br><span class="line">    circle.set_sizes([frame_number*<span class="number">500</span>])                    </span><br><span class="line"></span><br><span class="line"><span class="comment"># animation 객체 생성</span></span><br><span class="line">anim = FuncAnimation(fig, update, frames=<span class="number">120</span>, interval=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># animation을 gif로 저장</span></span><br><span class="line">anim.save(<span class="string">&quot;FuncAni0.gif&quot;</span>, fps=<span class="number">24</span>)</span><br></pre></td></tr></table></figure><img src="FuncAni0.gif"><br></li></ul><h2 id="1-3-ArtistAnimation"><a href="#1-3-ArtistAnimation" class="headerlink" title="1.3. ArtistAnimation"></a>1.3. <code>ArtistAnimation</code></h2><blockquote><p><a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.animation.ArtistAnimation.html#matplotlib.animation.ArtistAnimation">matplotlib.animation.ArtistAnimation</a></p></blockquote><ul><li><p>조금 다른 방식으로 artist 객체의 변화를 저장해 animation을 만들 수 있습니다.</p></li><li><p>Artist에 변화를 준 내용을 list로 저장해서 <code>ArtistAnimation()</code>에 전달하는 방식입니다.</p></li><li><p><code>FuncAnimation()</code>에는 함수를 전달했던 것과 다른 방식입니다.</p></li><li><p>함수로 표현하기 어려운 급격한 변화도 담을 수 있지만 리스트가 담길 메모리는 다소 부담이 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.animation <span class="keyword">import</span> ArtistAnimation</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Axes 주변부 요소 삭제</span></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(-<span class="number">1</span>, <span class="number">1</span>), ylim=(-<span class="number">1</span>, <span class="number">1</span>), xticks=[], yticks=[])</span><br><span class="line"></span><br><span class="line"><span class="comment"># animation frame마다 적용되는 변화</span></span><br><span class="line">circles = []</span><br><span class="line"><span class="keyword">for</span> frame_number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">120</span>):</span><br><span class="line">    <span class="comment"># scatter marker 생성</span></span><br><span class="line">    circle = ax.scatter(<span class="number">0</span>, <span class="number">0</span>, s=<span class="number">10</span>, lw=<span class="number">3</span>, ec=<span class="string">&quot;b&quot;</span>, fc=<span class="string">&quot;none&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># size 변경</span></span><br><span class="line">    circle.set_sizes([frame_number*<span class="number">500</span>])                    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># artist list 추가</span></span><br><span class="line">    circles.append([circle])</span><br><span class="line"></span><br><span class="line"><span class="comment"># animation 객체 생성</span></span><br><span class="line">anim = ArtistAnimation(fig, circles, interval=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># animation을 gif로 저장</span></span><br><span class="line">anim.save(<span class="string">&quot;ArtistAni0.gif&quot;</span>, fps=<span class="number">24</span>)</span><br></pre></td></tr></table></figure><p><img src="ArtistAni0.gif"><br></p></li><li><p>같은 애니메이션을 구현했습니다.</p></li></ul><h1 id="2-3D-도형-시각화-적용"><a href="#2-3D-도형-시각화-적용" class="headerlink" title="2. 3D 도형 시각화 적용"></a>2. 3D 도형 시각화 적용</h1><h2 id="2-1-z-axis-주변-회전"><a href="#2-1-z-axis-주변-회전" class="headerlink" title="2.1. z axis 주변 회전"></a>2.1. z axis 주변 회전</h2><ul><li><p>원래의 목적인 3D 도형의 뒷면을 보여주는 시각화를 수행합니다.</p></li><li><p>Matplotlib 공식 홈페이지에 있는 구조를 가져와 다른 방식으로 그립니다.</p></li><li><p><code>Axes.contourf()</code>를 3D Axes에 표현해보고,</p></li><li><p>다른 공간에는 <code>Axes.plot_surface()</code>와 함께 아래 면을 사용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2D mesh grid</span></span><br><span class="line">xx, yy = np.mgrid[-<span class="number">2</span>:<span class="number">2</span>:<span class="number">20j</span>, -<span class="number">2</span>:<span class="number">2</span>:<span class="number">20j</span>]</span><br><span class="line">zz = xx*np.exp(-(xx)**<span class="number">2</span>-yy**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3D visualization</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">7</span>), constrained_layout=<span class="literal">True</span>, </span><br><span class="line">                        subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (A): filled 3D contour</span></span><br><span class="line">axs[<span class="number">0</span>].contourf(xx, yy, zz, cmap=<span class="string">&quot;inferno&quot;</span>, levels=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (B): 3D surface plot + 2D contour</span></span><br><span class="line">axs[<span class="number">1</span>].plot_surface(xx, yy, zz, cmap=<span class="string">&quot;inferno&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, linewidths=<span class="number">0.5</span>)</span><br><span class="line">axs[<span class="number">1</span>].contourf(xx, yy, zz, zdir=<span class="string">&quot;z&quot;</span>, offset=-<span class="number">0.6</span>)</span><br><span class="line">axs[<span class="number">1</span>].contour(xx, yy, zz, zdir=<span class="string">&quot;z&quot;</span>, offset=-<span class="number">0.6</span>, linewidths=<span class="number">2</span>, colors=[<span class="string">&quot;w&quot;</span>])</span><br><span class="line"></span><br><span class="line">titles = [<span class="string">&quot;(A): Axes.contourf()&quot;</span>, <span class="string">&quot;(B): Axes.plot_surface() + 2D contours&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, titles):</span><br><span class="line">    ax.view_init(azim=<span class="number">225</span>, elev=<span class="number">20</span>)</span><br><span class="line">    ax.set_zlim(-<span class="number">0.6</span>, <span class="number">0.5</span>)</span><br><span class="line">    ax.set_title(title, pad=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="110_anim_5.png"><br></p></li><li><p>제법 멋진 그림이 그려졌지만 뒷부분이 보이지 않습니다.</p></li><li><p>한 frame에 2도씩, 두 그림 모두 회전시킵니다. 180 frame을 적용해 한바퀴를 돌립니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># animation frame마다 적용되는 변화</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">frame_number</span>):</span></span><br><span class="line">    axs[<span class="number">0</span>].view_init(azim=<span class="number">225</span> + frame_number*<span class="number">2</span>)</span><br><span class="line">    axs[<span class="number">1</span>].view_init(azim=<span class="number">225</span> + frame_number*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># animation 객체 생성</span></span><br><span class="line">anim = FuncAnimation(fig, update, frames=<span class="number">180</span>, interval=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># animation을 gif로 저장</span></span><br><span class="line">anim.save(<span class="string">&quot;FuncAni1.gif&quot;</span>, fps=<span class="number">24</span>)</span><br></pre></td></tr></table></figure><p><img src="FuncAni1.gif"><br></p></li><li><p>빙글빙글 돌아가는 모습이 표현됩니다.</p></li></ul><h2 id="2-2-3D-회전"><a href="#2-2-3D-회전" class="headerlink" title="2.2. 3D 회전"></a>2.2. 3D 회전</h2><blockquote><p><a href="https://jehyunlee.github.io/2021/09/03/Python-DS-84-sphere/">Pega Devlog: 3D curved surfaces</a></p></blockquote><ul><li><p>이번에는 조금 더 자유롭게 회전시켜보겠습니다.</p></li><li><p><code>Axes.view_init()</code>에 들어가는 두 개의 인자, <code>elev</code>와 <code>azim</code>에 랜덤으로 만든 array를 입력하면 됩니다.</p></li><li><p>돌려보는 재미가 있는 3D 객체를 생성합니다. 오른쪽 Ni 그림을 사용합니다.<br></p></li><li><p><a href="https://jehyunlee.github.io/2021/09/03/Python-DS-84-sphere/">과거 글</a>에 있는 그림을 사용합니다.<br><img src="https://jehyunlee.github.io/2021/09/03/Python-DS-84-sphere/84_sphere_13.png"></p></li><li><p>핵심 코드만 가져옵니다.</p></li><li><p>잘려진 부분 없이 온전한 모습으로 그립니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> LightSource</span><br><span class="line"></span><br><span class="line"><span class="comment"># angles</span></span><br><span class="line">polars = np.linspace(<span class="number">0</span>, <span class="number">179</span>, <span class="number">37</span>)</span><br><span class="line">azimuths = np.linspace(<span class="number">0</span>, <span class="number">360</span>, <span class="number">73</span>)</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(product(polars, azimuths), columns=[<span class="string">&quot;azi&quot;</span>, <span class="string">&quot;polar&quot;</span>])</span><br><span class="line">df[<span class="string">&quot;x&quot;</span>] = df.apply(<span class="keyword">lambda</span> x: np.cos(np.deg2rad(x[<span class="number">1</span>]))*np.sin(np.deg2rad(x[<span class="number">0</span>])), axis=<span class="number">1</span>)</span><br><span class="line">df[<span class="string">&quot;y&quot;</span>] = df.apply(<span class="keyword">lambda</span> x: np.sin(np.deg2rad(x[<span class="number">1</span>]))*np.sin(np.deg2rad(x[<span class="number">0</span>])), axis=<span class="number">1</span>)</span><br><span class="line">df[<span class="string">&quot;z&quot;</span>] = df.apply(<span class="keyword">lambda</span> x: np.cos(np.deg2rad(x[<span class="number">0</span>])), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3D 객체 생성</span></span><br><span class="line">K1_Ni = -<span class="number">0.5</span> </span><br><span class="line">K2_Ni = -<span class="number">0.2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_uni</span>(<span class="params">K1, K2, df</span>):</span></span><br><span class="line">    <span class="keyword">return</span> K1*(df[<span class="string">&quot;x&quot;</span>]**<span class="number">2</span> + df[<span class="string">&quot;y&quot;</span>]**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_cubic</span>(<span class="params">K1, K2, df</span>):</span></span><br><span class="line">    <span class="keyword">return</span> K1*(df[<span class="string">&quot;x&quot;</span>]**<span class="number">2</span> * df[<span class="string">&quot;y&quot;</span>]**<span class="number">2</span> + \</span><br><span class="line">               df[<span class="string">&quot;y&quot;</span>]**<span class="number">2</span> * df[<span class="string">&quot;z&quot;</span>]**<span class="number">2</span> + \</span><br><span class="line">               df[<span class="string">&quot;z&quot;</span>]**<span class="number">2</span> * df[<span class="string">&quot;x&quot;</span>]**<span class="number">2</span>) + \</span><br><span class="line">           K2*(df[<span class="string">&quot;x&quot;</span>]**<span class="number">2</span> * df[<span class="string">&quot;y&quot;</span>]**<span class="number">2</span> * df[<span class="string">&quot;z&quot;</span>]**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">df[<span class="string">&quot;E_Ni&quot;</span>] = df.apply(<span class="keyword">lambda</span> x: calc_cubic(K1_Ni, K2_Ni, x), axis=<span class="number">1</span>)*<span class="number">3</span> +<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 극좌표계를 직교좌표계로 변환</span></span><br><span class="line">df[<span class="string">&quot;x_Ni&quot;</span>] = df[<span class="string">&quot;E_Ni&quot;</span>] * df[<span class="string">&quot;x&quot;</span>]</span><br><span class="line">df[<span class="string">&quot;y_Ni&quot;</span>] = df[<span class="string">&quot;E_Ni&quot;</span>] * df[<span class="string">&quot;y&quot;</span>]</span><br><span class="line">df[<span class="string">&quot;z_Ni&quot;</span>] = df[<span class="string">&quot;E_Ni&quot;</span>] * df[<span class="string">&quot;z&quot;</span>]</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>,</span><br><span class="line">                       subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>: <span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line">ax.plot_surface(df[<span class="string">f&quot;x_Ni&quot;</span>].values.reshape((<span class="number">37</span>, <span class="number">73</span>)), </span><br><span class="line">                    df[<span class="string">f&quot;y_Ni&quot;</span>].values.reshape((<span class="number">37</span>, <span class="number">73</span>)), </span><br><span class="line">                    df[<span class="string">f&quot;z_Ni&quot;</span>].values.reshape((<span class="number">37</span>, <span class="number">73</span>)), </span><br><span class="line">                    ec=<span class="string">&quot;k&quot;</span>, lw=<span class="number">0.2</span>,</span><br><span class="line">                    color=<span class="string">&quot;w&quot;</span>, lightsource=LightSource(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">ax.set_box_aspect((<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">elev0, azim0 = <span class="number">20</span>, -<span class="number">60</span></span><br><span class="line">ax.view_init(elev0, azim0)</span><br><span class="line">ax.axis(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="110_anim_3.png"><br></p></li><li><p><code>elev</code>와 <code>azim</code>을 미리 array로 만들어 두고,</p></li><li><p>frame_number를 index로 사용해 하나씩 꺼내는 함수를 만듭니다.</p></li><li><p>그리고, <code>FuncAnimation()</code>에서 이들을 호출해 애니메이션을 생성합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">frames = <span class="number">360</span></span><br><span class="line">elev = elev0 + np.random.normal(loc=<span class="number">3</span>, scale=<span class="number">1</span>, size=frames).cumsum()</span><br><span class="line">azim = azim0 + np.random.normal(loc=<span class="number">3</span>, scale=<span class="number">1</span>, size=frames).cumsum()</span><br><span class="line"></span><br><span class="line"><span class="comment"># animation frame마다 적용되는 변화</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">frame_number</span>):</span></span><br><span class="line">    ax.view_init(elev[frame_number],</span><br><span class="line">                 azim[frame_number])</span><br><span class="line"></span><br><span class="line"><span class="comment"># animation 객체 생성</span></span><br><span class="line">anim = FuncAnimation(fig, update, frames=<span class="number">360</span>, interval=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># animation을 gif로 저장</span></span><br><span class="line">anim.save(<span class="string">&quot;FuncAni2.gif&quot;</span>, fps=<span class="number">24</span>)</span><br></pre></td></tr></table></figure><p><img src="FuncAni2.gif"><br></p></li><li><p>3차원 공간을 자유롭게 회전하는 영상이 되었습니다.</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/3D/">3D</category>
      
      
    </item>
    
    <item>
      <title>hyperparameter</title>
      <link>https://jehyunlee.github.io/2022/08/05/Python-DS-109-kierlecture5/</link>
      <guid>https://jehyunlee.github.io/2022/08/05/Python-DS-109-kierlecture5/</guid>
      <pubDate>Fri, 05 Aug 2022 07:09:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;한국에너지기술연구원 AI 학습조직&lt;/b&gt;에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.&lt;ul&gt;
&lt;li&gt;이번 시간에는 머신러닝 성능 막판 끌어올리기, hyperparameter tuning을 소개했습니다.&lt;/li&gt;
&lt;li</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b>한국에너지기술연구원 AI 학습조직</b>에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.<ul><li>이번 시간에는 머신러닝 성능 막판 끌어올리기, hyperparameter tuning을 소개했습니다.</li><li>문제, 데이터, 모델 선정에 최선을 다했다면 학습 환경을 최적화할 차례입니다.</li><li><a href="220805_%EC%9D%B4%EC%A0%9C%ED%98%84_KIERML_2205_hyperparameters.pdf">강의 자료는 여기에서 다운받으실 수 있습니다</a></li></ul></li></ul><ul><li><p>발표 영상 : (<a href="https://youtu.be/7GqBlDlr4Uc">Youtube Link</a>)<br></p></li><li><p>실습 코드 : (<a href="https://bit.ly/3PkGBHc">https://bit.ly/3PkGBHc</a>)<br></p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/7GqBlDlr4Uc" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><img src="thumbnail4.PNG"><br></p><p><ul><li>바쁜 연구원 일정 속에 변동이 있겠지만, 최대한 일정을 지켜보고자 합니다.</li></ul><p><img src="109-kierlecture5_01.png" alt="학습조직 일정"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/machine-learning/">machine learning</category>
      
      <category domain="https://jehyunlee.github.io/tags/KIER/">KIER</category>
      
      <category domain="https://jehyunlee.github.io/tags/hyperparameter/">hyperparameter</category>
      
      
    </item>
    
    <item>
      <title>Matplotlib 3D Plots (3)</title>
      <link>https://jehyunlee.github.io/2022/08/01/Python-DS-108-mpl3d3/</link>
      <guid>https://jehyunlee.github.io/2022/08/01/Python-DS-108-mpl3d3/</guid>
      <pubDate>Mon, 01 Aug 2022 02:52:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;Matplotlib으로 3D Plot을 할 수 있습니다.&lt;/li&gt;
&lt;li&gt;많은 분들이 알고 있는 사실이지만 적극적으로 쓰이지 않습니다.&lt;/li&gt;
&lt;li&gt;seaborn KDE plot을 3D로 표현합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>Matplotlib으로 3D Plot을 할 수 있습니다.</li><li>많은 분들이 알고 있는 사실이지만 적극적으로 쓰이지 않습니다.</li><li>seaborn KDE plot을 3D로 표현합니다.</li></ul><h1 id="5-KDE-plot"><a href="#5-KDE-plot" class="headerlink" title="5. KDE plot"></a>5. KDE plot</h1><ul><li>2D KDE plot은 전달력이 좋고, 은근 예쁘기도 합니다.</li><li>두 인자의 상관 분포를 표현하는 그림으로, 데이터의 밀도를 선이나 색으로 나타냅니다.</li><li>2D 공간을 벗어나 3D로 데이터를 표현합니다.</li></ul><h2 id="5-1-2D-KDE-plot"><a href="#5-1-2D-KDE-plot" class="headerlink" title="5.1. 2D KDE plot"></a>5.1. 2D KDE plot</h2><blockquote><p><a href="https://matplotlib.org/stable/tutorials/colors/colormaps.html">matplotlib: Choosing Colormaps in Matplotlib</a></p></blockquote><ul><li><p>라이브러리 및 시각화 환경을 초기화합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">sns.set_style(<span class="string">&quot;ticks&quot;</span>)</span><br><span class="line">sns.set_palette(<span class="string">&quot;colorblind&quot;</span>)</span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>]=<span class="string">&#x27;NanumGothic&#x27;</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><p>펭귄 데이터셋을 이용해 2D KDE plot을 그립니다.</p></li><li><p>colormap은 inferno를 선택합니다.</p></li><li><p>이미지를 다시 2D data로 변환하려면 lightness가 data 값에 비례하야 하는데</p></li><li><p>perceptual uniform colormap 중 inferno의 범위가 가장 넓기 때문입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df_peng = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, ax=ax,</span><br><span class="line">            fill=<span class="literal">True</span>, levels=<span class="number">100</span>, cmap=<span class="string">&quot;inferno&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>실행 결과<br><img src="108_mpl3d3_01.png"><br></p></li></ul><h2 id="5-2-2D-image-to-2D-data"><a href="#5-2-2D-image-to-2D-data" class="headerlink" title="5.2. 2D image to 2D data"></a>5.2. 2D image to 2D data</h2><ul><li><p>x, y limit가 데이터 값에 따라 자동으로 설정되었지만 값을 다듬습니다.</p></li><li><p>향후 2D 데이터를 불러왔을 때 x, y 범위를 사용해야 하는데, 유효숫자가 너무 많으면 불편합니다.</p></li><li><p>소숫점 둘째 자리까지 반올림을 합니다.</p></li><li><p>Axes spines 등 불필요한 요소를 모두 제거합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x, y 범위 반올림 재설정</span></span><br><span class="line">xmin, xmax = np.<span class="built_in">round</span>(ax.get_xlim(),<span class="number">2</span>)</span><br><span class="line">ymin, ymax = np.<span class="built_in">round</span>(ax.get_ylim(),<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;xmin, xmax = <span class="subst">&#123;xmin&#125;</span>, <span class="subst">&#123;xmax&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;ymin, ymax = <span class="subst">&#123;ymin&#125;</span>, <span class="subst">&#123;ymax&#125;</span>&quot;</span>)</span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(xmin, xmax), ylim=(ymin, ymax))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 윤곽선 눈금</span></span><br><span class="line">ax.axvline(xmin, lw=<span class="number">0.01</span>, c=<span class="string">&quot;green&quot;</span>)</span><br><span class="line">ax.axvline(xmax, lw=<span class="number">0.01</span>, c=<span class="string">&quot;green&quot;</span>)</span><br><span class="line">ax.axhline(ymin, lw=<span class="number">0.01</span>, c=<span class="string">&quot;green&quot;</span>)</span><br><span class="line">ax.axhline(ymax, lw=<span class="number">0.01</span>, c=<span class="string">&quot;green&quot;</span>)</span><br><span class="line">ax.axis(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">fig.savefig(<span class="string">&quot;KDE_peng.png&quot;</span>)</span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmin, xmax = 25.91, 65.79</span><br><span class="line">ymin, ymax = 10.86, 23.74</span><br></pre></td></tr></table></figure><p><img src="KDE_peng.png"><br></p></li><li><p>x, y 데이터의 최소와 최대 범위에 green line을 그렸습니다.</p></li><li><p>image를 file로 저장할 때 몇 픽셀 가량의 여백이 생기기 때문에 이를 확인하고 제거하기 위함입니다.</p></li><li><p>그림파일을 <code>im_pengkde</code>라는 이름으로 불러온 뒤, [:10, :10] 영역의 데이터를 출력해 green line을 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(im_pengkde[:<span class="number">10</span>, :<span class="number">10</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>실행 결과<br><img src="108_mpl3d3_02.png"><br></li></ul></li></ul><ul><li><p>pixel을 눈으로 볼 수 있을 만큼 확대를 해보니 green line 두께는 1 pixel입니다.</p></li><li><p>그리고 그 밖으로 약간의 여백이 있습니다.</p></li><li><p>이 여백의 폭을 확인한 후 1 pixel을 더한 범위만큼 사방에서 잘라냅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.colors <span class="keyword">as</span> mcolors</span><br><span class="line"></span><br><span class="line">idx_gx, idx_gy, _ =  np.where(im_pengkde[:<span class="number">5</span>, :<span class="number">5</span>] != mcolors.to_rgba(<span class="string">&quot;w&quot;</span>))</span><br><span class="line">im_pengkde= im_pengkde[idx_gx[<span class="number">0</span>]+<span class="number">1</span>:-idx_gx[<span class="number">0</span>]-<span class="number">2</span>, idx_gy[<span class="number">0</span>]+<span class="number">1</span>:-idx_gx[<span class="number">0</span>]-<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(im_pengkde[:<span class="number">2</span>, :<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(im_pengkde.shape)</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[[1. 1. 1. 1.]</span><br><span class="line">  [1. 1. 1. 1.]]</span><br><span class="line"></span><br><span class="line"> [[1. 1. 1. 1.]</span><br><span class="line">  [1. 1. 1. 1.]]]</span><br><span class="line">(351, 351, 4)</span><br></pre></td></tr></table></figure></li><li><p>image size가 <b>(351, 351)</b>로 확인됩니다.</p></li><li><p>잘 제거되었나 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(im_pengkde[:<span class="number">10</span>, :<span class="number">10</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="108_mpl3d3_03.png"><br></p></li></ul><h2 id="5-3-data-colormap-intensity"><a href="#5-3-data-colormap-intensity" class="headerlink" title="5.3. data = colormap intensity"></a>5.3. data = colormap intensity</h2><ul><li><p>inferno colormap에서 data intensity는 lightness에 비례합니다.</p></li><li><p><code>colorspacious</code> 라이브러리의 <code>cspace_converter</code>를 사용해 RGB를 Lab으로 변환합니다.</p></li><li><p>Lab color space의 첫 번째 요소가 lightness입니다.</p></li><li><p>데이터가 없는 하얀 색 구간이 있습니다. 여기는 데이터가 있는 부분과 구별되도록 -1을 입력합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> colorspacious <span class="keyword">import</span> cspace_converter</span><br><span class="line"></span><br><span class="line">im_pengkde_L = np.zeros(im_pengkde.shape[:<span class="number">2</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(im_pengkde.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(im_pengkde.shape[<span class="number">1</span>]):</span><br><span class="line">        RGB = im_pengkde[i, j][:<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(RGB - np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])) == <span class="number">0</span>:</span><br><span class="line">            im_pengkde_L[i, j] = -<span class="number">1</span>   </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            lab = cspace_converter(<span class="string">&quot;sRGB1&quot;</span>, <span class="string">&quot;CAM02-UCS&quot;</span>)(RGB)</span><br><span class="line">            im_pengkde_L[i, j] = lab[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li><li><p>im_pengkde_L에 lightness를 입력했습니다.</p></li><li><p>확인을 위해 inferno colormap을 적용해 image로 출력합니다.</p></li><li><p>아까 저장해 둔 xmin, xmax, ymin, ymax를 <code>extent</code>에 넣어 범위를 올바르게 표현하고</p></li><li><p><code>aspect</code>에 x, y 범위의 비율을 입력해 그림이 정사각형으로 표현되도록 조정합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(im_pengkde_L, cmap=<span class="string">&quot;inferno&quot;</span>,</span><br><span class="line">           extent=[xmin, xmax, ymin, ymax], </span><br><span class="line">           aspect=(xmax-xmin)/(ymax-ymin))</span><br></pre></td></tr></table></figure><p><img src="108_mpl3d3_04.png"><br></p></li><li><p>정상적으로 출력되었습니다.</p></li><li><p>하얀 색 부분이 검게 표현되었는데, 이 부분에 입력한 -1이 inferno colormap에서 최소값으로 감지되었기 때문입니다.</p></li></ul><h1 id="6-3D-plot"><a href="#6-3D-plot" class="headerlink" title="6. 3D plot"></a>6. 3D plot</h1><blockquote><p><a href="https://jehyunlee.github.io/2021/07/10/Python-DS-80-mpl3d2/">Pega Devlog: Matplotlib 3D Plots(2)</a><br><a href="https://matplotlib.org/stable/api/_as_gen/mpl_toolkits.mplot3d.axes3d.Axes3D.html?highlight=plot_surface#mpl_toolkits.mplot3d.axes3d.Axes3D.plot_surface">matplotlib: Axes.plot_surface()</a></p></blockquote><ul><li>데이터를 추출했으므로 3D plot을 시작할 차례입니다.</li></ul><h2 id="6-1-plot-surface"><a href="#6-1-plot-surface" class="headerlink" title="6.1. plot_surface()"></a>6.1. <code>plot_surface()</code></h2><ul><li><p><code>Axes.plot_surface()</code>등 명령어가 받아들이는 형식으로 데이터를 마련해야 합니다.</p></li><li><p><code>np.meshgrid()</code>로 데이터 범위에서 mesh grid를 생성합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mesh grid 생성</span></span><br><span class="line">xs = np.linspace(xmin, xmax, im_pengkde.shape[<span class="number">1</span>])</span><br><span class="line">ys = np.linspace(ymin, ymax, im_pengkde.shape[<span class="number">0</span>])</span><br><span class="line">xx, yy = np.meshgrid(xs, ys)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3D plot</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>,</span><br><span class="line">                       subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line">ax.plot_surface(xx, yy, im_pengkde_L)</span><br></pre></td></tr></table></figure><p><img src="108_mpl3d3_05.png"><br></p></li><li><p>mesh로 이루어진 3D surface plot이 생성되었습니다.</p></li><li><p>앞에서 (351, 351)로 확인한 것 치고는 mesh 밀도가 너무 낮습니다.</p></li></ul><h2 id="6-2-rstride-cstride"><a href="#6-2-rstride-cstride" class="headerlink" title="6.2. rstride, cstride"></a>6.2. rstride, cstride</h2><ul><li><p><code>Axes.plot_surface()</code>는 모든 mesh를 보여주지 않스빈다.</p></li><li><p>row를 <code>rstride</code>만큼 건너뛰고 column을 <code>cstride</code>만큼 건너뛰는데 기본값이 10입니다. </p></li><li><p><code>rstride=1</code>, <code>cstride=1</code>을 입력해 모든 mesh를 출력합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>,</span><br><span class="line">                       subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line">ax.plot_surface(xx, yy, im_pengkde_L, rstride=<span class="number">1</span>, cstride=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="108_mpl3d3_06.png"><br></p></li><li><p>mesh가 너무 많아 하얗게 뒤덮여 버렸습니다.</p></li><li><p>우리가 원하는 것은 매끈한 표면이지 복잡한 mesh가 아닙니다. <code>lw=0</code>으로 mesh를 지웁니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>,</span><br><span class="line">                       subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line">ax.plot_surface(xx, yy, im_pengkde_L, rstride=<span class="number">1</span>, cstride=<span class="number">1</span>, lw=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="108_mpl3d3_07.png"><br></p></li><li><p>이제 형태가 좀 잘 보입니다.</p></li></ul><h2 id="6-3-colormap"><a href="#6-3-colormap" class="headerlink" title="6.3. colormap"></a>6.3. colormap</h2><ul><li><p>데이터 값이 z축에 드러나있지만 어디까지나 상대적인 밀도입니다.</p></li><li><p>절대적인 수치는 별 의미가 없지만 상대적인 대소는 의미가 있습니다.</p></li><li><p><code>cmap</code>매개변수로 colormap을 적용해서 높은 봉우리가 잘 드러나게 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>,</span><br><span class="line">                       subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line">ax.plot_surface(xx, yy, im_pengkde_L, rstride=<span class="number">1</span>, cstride=<span class="number">1</span>, lw=<span class="number">0</span>, cmap=<span class="string">&quot;inferno&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="108_mpl3d3_08.png"><br></p></li><li><p>colormap이 적용된 결고 왼쪽 봉우리가 오른쪽보다 높다는 사실이 한 눈에 드러납니다.</p></li><li><p>왠지 뒤쪽이 비쳐보이는 바람에 다소 혼란스럽기도 합니다.</p></li><li><p><code>antialiased=False</code>를 적용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>,</span><br><span class="line">                       subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line">ax.plot_surface(xx, yy, im_pengkde_L, rstride=<span class="number">1</span>, cstride=<span class="number">1</span>, lw=<span class="number">0</span>, cmap=<span class="string">&quot;inferno&quot;</span>, </span><br><span class="line">                antialiased=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="108_mpl3d3_09.png"><br></p></li></ul><h2 id="6-4-mask"><a href="#6-4-mask" class="headerlink" title="6.4. mask"></a>6.4. mask</h2><blockquote><p><a href="np.ma.masked_array">numpy: The numpy.ma module</a><br><a href="https://scipy-cookbook.readthedocs.io/items/Matplotlib_Plotting_values_with_masked_arrays.html">scipy: Matplotlib: plotting values with masked arrays</a><br><a href="https://matplotlib.org/stable/gallery/lines_bars_and_markers/masked_demo.html">matplotlib: Plotting masked and NaN values</a></p></blockquote><ul><li>우리가 사용하는 데이터는 penguins dataset의 2D KDE plot에서 온 것이고,</li><li>데이터 값이 존재하지 않는 범위가 적지 않습니다.</li><li>이 부분이 데이터 밀도가 매우 작은 부분과 혼동되기 때문에, 제거하는 편이 깔끔합니다.</li><li><code>np.ma.masked_array()</code>를 사용해 데이터 값이 0 이하인 부분을 제거합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">im_pengkde_L_masked = np.ma.masked_array(im_pengkde_L, im_pengkde_L &lt;= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>,</span><br><span class="line">                       subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line">ax.plot_surface(xx, yy, im_pengkde_L_masked, rstride=<span class="number">1</span>, cstride=<span class="number">1</span>, lw=<span class="number">0</span>, </span><br><span class="line">                cmap=<span class="string">&quot;inferno&quot;</span>, antialiased=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><img src="108_mpl3d3_10.png"><br></li></ul><h2 id="6-5-LightSource"><a href="#6-5-LightSource" class="headerlink" title="6.5. LightSource"></a>6.5. LightSource</h2><blockquote><p><a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.colors.LightSource.html?highlight=lightsource#matplotlib.colors.LightSource">matplotlib: matplotlib.colors.LightSource</a></p></blockquote><ul><li>3D 객체는 빛이 들어오는 방향과 빛을 가리는 물체에 의해 밝은 부분과 그림자가 생깁니다.</li><li>이를 계산해 적용해주는 모듈이 <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.colors.LightSource.html?highlight=lightsource#matplotlib.colors.LightSource"><code>LightSource</code></a>입니다.</li><li><code>ls = LightSource()</code>에 <code>azdeg</code>과 <code>altdeg</code>으로 방위각과 고도각을 입력한 후,</li><li><code>rgb = ls.shade()</code>로 face마다 그림자를 계산합니다.</li><li>마지막으로 <code>Axes.plot_surface()</code>에 <code>facecolors=rgb</code>를 넣어 계산된 값을 면에 입혀 출력합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> LightSource</span><br><span class="line"></span><br><span class="line"><span class="comment"># Light Source object 생성</span></span><br><span class="line">ls = LightSource(azdeg=-<span class="number">45</span>, altdeg=<span class="number">30</span>)</span><br><span class="line"><span class="comment"># shade 생성</span></span><br><span class="line">rgb = ls.shade(im_pengkde_L, plt.get_cmap(<span class="string">&quot;inferno&quot;</span>))</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>, </span><br><span class="line">                       subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line">ax.plot_surface(xx, yy, im_pengkde_L_masked, rstride=<span class="number">1</span>, cstride=<span class="number">1</span>, lw=<span class="number">0</span>, antialiased=<span class="literal">False</span>, </span><br><span class="line">                facecolors=rgb)</span><br></pre></td></tr></table></figure><img src="108_mpl3d3_11.png"><br></li></ul><h2 id="6-6-rotation"><a href="#6-6-rotation" class="headerlink" title="6.6. rotation"></a>6.6. rotation</h2><ul><li><p>3D 객체는 일부분이 필연적으로 가려져 데이터 전달 효율이 떨어집니다.</p></li><li><p>이를 보완하기 위해 회전을 시키는 방법이 많이 사용됩니다.</p></li><li><p>방위각을 나타내는 <code>azim</code>에 기본값인 -60 외에 -30과 0을 입력한 결과를 함께 그립니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>, </span><br><span class="line">                       subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line">elev = <span class="number">30</span></span><br><span class="line">azims = [-<span class="number">60</span>, -<span class="number">30</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, azim <span class="keyword">in</span> <span class="built_in">zip</span>(axs, azims):</span><br><span class="line">    ax.plot_surface(xx, yy, im_pengkde_L_masked, rstride=<span class="number">2</span>, cstride=<span class="number">2</span>, lw=<span class="number">0</span>, antialiased=<span class="literal">False</span>, </span><br><span class="line">                    facecolors=rgb)</span><br><span class="line">    ax.view_init(elev, azim)</span><br><span class="line">    ax.set_title(<span class="string">f&quot;azim = <span class="subst">&#123;azim&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="108_mpl3d3_12.png"><br></p></li><li><p>방위각에 따라 보이지 않던 부분이 드러나고 있습니다.</p></li><li><p>종이에 인쇄되는 환경이 아닌 웹 등으로 데이터를 전달한다면 애니메이션을 만들어 전달할 수 있습니ㅏㄷ.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> animation </span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>, </span><br><span class="line">                       subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">fontlabel = &#123;<span class="string">&quot;fontsize&quot;</span>:<span class="string">&quot;large&quot;</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span>():</span></span><br><span class="line">    ls = LightSource(azdeg=-<span class="number">45</span>, altdeg=<span class="number">30</span>)</span><br><span class="line">    rgb = ls.shade(im_pengkde_L, plt.get_cmap(<span class="string">&quot;inferno&quot;</span>))</span><br><span class="line">    ax.set_xlabel(<span class="string">&quot;bill length (mm)&quot;</span>, fontdict=fontlabel, labelpad=<span class="number">16</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">&quot;bill depth (mm)&quot;</span>, fontdict=fontlabel, labelpad=<span class="number">16</span>)</span><br><span class="line">    ax.set_title(<span class="string">&quot;Kernel Density&quot;</span>, fontdict=fontlabel)</span><br><span class="line">    ax.plot_surface(xx, yy, im_pengkde_L_masked, rstride=<span class="number">1</span>, cstride=<span class="number">1</span>, lw=<span class="number">0</span>, antialiased=<span class="literal">False</span>, </span><br><span class="line">                facecolors=rgb)</span><br><span class="line">    <span class="keyword">return</span> fig,</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">animate</span>(<span class="params">i</span>):</span></span><br><span class="line">    ax.view_init(elev=<span class="number">30</span>, azim=i)</span><br><span class="line">    <span class="keyword">return</span> fig,</span><br><span class="line"></span><br><span class="line"><span class="comment"># Animate</span></span><br><span class="line">anim = animation.FuncAnimation(fig, animate, init_func=init,</span><br><span class="line">                               frames=<span class="number">360</span>, interval=<span class="number">20</span>, blit=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save</span></span><br><span class="line">anim.save(<span class="string">&#x27;108_mpl3d3_rot_01.gif&#x27;</span>, fps=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p><img src="108_mpl3d3_rot_01.gif"><br></p></li></ul><h1 id="7-결론"><a href="#7-결론" class="headerlink" title="7. 결론"></a>7. 결론</h1><ul><li>2D KDE plot을 3D로 바꾸어 표현할 수 있음을 확인했습니다.</li><li>3D plot은 데이터의 정확한 전달력보다 독자의 주의를 끄는 데 유리합니다.</li><li>적절한 순간에 필요한 기능을 능동적으로 사용할 수 있기 바랍니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/3D/">3D</category>
      
      
    </item>
    
    <item>
      <title>트리 모델</title>
      <link>https://jehyunlee.github.io/2022/07/15/Python-DS-107-kierlecture4/</link>
      <guid>https://jehyunlee.github.io/2022/07/15/Python-DS-107-kierlecture4/</guid>
      <pubDate>Fri, 15 Jul 2022 07:35:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;한국에너지기술연구원 AI 학습조직&lt;/b&gt;에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.&lt;ul&gt;
&lt;li&gt;이번 시간에는 decision tree와 random forest, xgboost를 비롯한 tree model을 공부</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b>한국에너지기술연구원 AI 학습조직</b>에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.<ul><li>이번 시간에는 decision tree와 random forest, xgboost를 비롯한 tree model을 공부하고</li><li>AutoML의 예시로 PyCaret을 소개했습니다.</li><li><a href="220714_%EC%9D%B4%EC%A0%9C%ED%98%84_KIERML_2203_treemodels.pdf">강의 자료는 여기에서 다운받으실 수 있습니다</a></li></ul></li></ul><ul><li><p>발표 영상 : (<a href="https://youtu.be/h-m9wQywW_Q">Youtube Link</a>)<br></p></li><li><p>실습 코드 : (<a href="https://bit.ly/3PkGBHc">https://bit.ly/3PkGBHc</a>)<br></p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/h-m9wQywW_Q" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><img src="107-kierlecture4_02.png"><br></p><p><ul><li>바쁜 연구원 일정 속에 변동이 있겠지만, 최대한 일정을 지켜보고자 합니다.</li></ul><p><img src="107-kierlecture4_01.png" alt="학습조직 일정"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/machine-learning/">machine learning</category>
      
      <category domain="https://jehyunlee.github.io/tags/KIER/">KIER</category>
      
      <category domain="https://jehyunlee.github.io/tags/tree-models/">tree models</category>
      
      <category domain="https://jehyunlee.github.io/tags/ensemble/">ensemble</category>
      
      
    </item>
    
    <item>
      <title>Open API를 이용한 고속 논문 분석</title>
      <link>https://jehyunlee.github.io/2022/07/02/Python-DS-106-aaicon/</link>
      <guid>https://jehyunlee.github.io/2022/07/02/Python-DS-106-aaicon/</guid>
      <pubDate>Sat, 02 Jul 2022 02:19:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;저는 데이터, AI 담당자로서 &lt;b&gt;낯선 분야&lt;/b&gt;의 업무를 맡아 &lt;b&gt;논문 작성&lt;/b&gt;을 요구받고 있습니다. &lt;ul&gt;
&lt;li&gt;공저자로서 데이터 분석이나 AI 모델링 파트만 작성하라면 그냥 하면 됩니다.&lt;/li&gt;
&lt;li&gt;그러나 주저자</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>저는 데이터, AI 담당자로서 <b>낯선 분야</b>의 업무를 맡아 <b>논문 작성</b>을 요구받고 있습니다. <ul><li>공저자로서 데이터 분석이나 AI 모델링 파트만 작성하라면 그냥 하면 됩니다.</li><li>그러나 주저자로서 서론부터 작성하는 일은 너무 어렵습니다.</li><li>이 분야의 흐름을 파악하고 다른 이들의 연구를 언급해야 하는데 대량의 논문을 읽기엔 단어부터 낯설기 때문입니다.</li></ul></li></ul><ul><li><b>처음 보는 논문을 요약해주는 모델</b>을 만들었습니다.<ul><li>문서 요약과 번역은 Open API로 접근할 수 있는 딥러닝 모델에게 맡겼습니다.</li><li>제가 쓰려고 시작한 일입니다. 논문 외 다른 문서도 요약됩니다.</li><li>그러나 만들고 보니 웹이나 앱 등 GUI 환경으로 공유를 드려도 좋을 것 같습니다.</li><li><b>관련 특허를 출원했습니다.</b> 서비스를 만든 뒤에 순차적으로 공유드리겠습니다.</li></ul></li></ul><ul><li><b>실용인공지능학회(AAiCON: Applied AI Conference)</b>에서 발표했습니다.<ul><li>AI에 관심 있는 대전 지역 사람들의 모임, <b>AI 프렌즈</b>가 커졌습니다.</li><li>지금은 <a href="https://aifrenz.notion.site/"><b>사단법인 에이아이프렌즈 학회</b></a>입니다.</li><li>많은 분들께서 좋은 강의를 해 주셨습니다. 점점 성장하기를 바랍니다.</li></ul></li></ul><ul><li>발표 영상 : <a href="https://youtu.be/watch?v=js4Lh2RJ5YM&t=20804s">Youtube Link</a><br><ul><li>초반 리모컨 사용이 매끄럽지 않았습니다.</li><li>2페이지를 넘어간 뒤에는 괜찮습니다. 조금만 봐주세요. :)</li><li><b>제 발표는 5:46:49에 시작합니다.</b></li></ul></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/js4Lh2RJ5YM" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <ul><li>2022 실용 AI 학술대회 프로그램<ul><li><a href="https://aaicon.aifrenz.org/">https://aaicon.aifrenz.org/</a></li></ul></li></ul><p><img src="106_aaicon_01.png"></p><p><img src="106_aaicon_04.png"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/open-API/">open API</category>
      
      <category domain="https://jehyunlee.github.io/tags/text-mining/">text mining</category>
      
      <category domain="https://jehyunlee.github.io/tags/AI-Frenz/">AI Frenz</category>
      
      <category domain="https://jehyunlee.github.io/tags/AI-festival/">AI festival</category>
      
      <category domain="https://jehyunlee.github.io/tags/AAiCON/">AAiCON</category>
      
      
    </item>
    
    <item>
      <title>improvement- COVID antibody holder</title>
      <link>https://jehyunlee.github.io/2022/06/26/Python-DS-105-covid_immune/</link>
      <guid>https://jehyunlee.github.io/2022/06/26/Python-DS-105-covid_immune/</guid>
      <pubDate>Sun, 26 Jun 2022 00:44:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;최근 무작위 조사 결과 95%의 사람들에게서 코로나19 항체가 발견되었다고 합니다.&lt;/li&gt;
&lt;li&gt;한 뉴스에서 이 기사가 보도되었는데 시각화가 적절치 못했습니다.&lt;/li&gt;
&lt;li&gt;이를 나름대로 바로잡아 새로 그려봅니다.&lt;/li&gt;
&lt;/</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>최근 무작위 조사 결과 95%의 사람들에게서 코로나19 항체가 발견되었다고 합니다.</li><li>한 뉴스에서 이 기사가 보도되었는데 시각화가 적절치 못했습니다.</li><li>이를 나름대로 바로잡아 새로 그려봅니다.</li></ul><blockquote><p><a href="https://youtu.be/I2leB14Cbuw">채널A: 무작위 조사했더니…국민 100명 중 95명은 코로나 항체 보유</a></p></blockquote><h1 id="1-언론-보도"><a href="#1-언론-보도" class="headerlink" title="1. 언론 보도"></a>1. 언론 보도</h1><p><img src="105_covid_immune_01.jpg" alt="2022.06.14. 채널A 보도 화면"><br></p><ul><li><p>2022년 6월 14일, 1612명을 대상으로 코로나19 항체 보유를 조사한 결과가 보도되었습니다.</p></li><li><p><b>전체의 95%에서 항체가 발견</b>되었고 <b>15.7%는 자연 감염 경력</b>이 있다고 합니다.<br><br><img src="105_covid_immune_02.jpg"><br></p></li><li><p>그런데 문제가 있습니다.</p></li><li><p><b>자연 감염 15.7%</b>와 <b>항체 보유 94.9%</b>가 나란히 놓이는 바람에 별개의 데이터로 보입니다.</p></li><li><p>심지어 <b>색상을 다르게 사용</b>하는 바람에 정말 다른 종류의 데이터로 느껴집니다.</p></li></ul><h1 id="2-다시-그리기"><a href="#2-다시-그리기" class="headerlink" title="2. 다시 그리기"></a>2. 다시 그리기</h1><blockquote><p><a href="https://bit.ly/3NiADVZ">강의 활용 코드</a></p></blockquote><ul><li>동명대학교에서의 강의를 계기로 새로 그려보기로 했습니다.</li><li>사실 당일 새벽에 코드를 급하게 작성했기 때문에 강의를 하다가도 아쉬운 부분이 느껴졌고,</li><li>한 단계 다시 정리를 하기로 했습니다.</li><li>Google Colab 코드를 다시 정리합니다.</li></ul><h2 id="2-1-환경-설정"><a href="#2-1-환경-설정" class="headerlink" title="2.1. 환경 설정"></a>2.1. 환경 설정</h2><ul><li><p>Colab에 기본으로 설정된 폰트가 좀 아쉬워서 <b>외부 폰트를 설치했습니다.</b></p></li><li><p>초반 Matplotlib 버전 업그레이드와 함께 진행했습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Step 1. Matplotlib 업그레이드</span></span><br><span class="line">!pip install matplotlib -U </span><br><span class="line">!pip install seaborn -U</span><br><span class="line">!pip install pandas -U</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 2. 한글 설치 및 사용 설정</span></span><br><span class="line">!apt-get -qq install -y fonts-nanum</span><br><span class="line">!fc-cache -fv  </span><br><span class="line">!rm ~/.cache/matplotlib -rf</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 3. 추가 폰트 설치</span></span><br><span class="line">!apt-get -qq install fonts-freefont-ttf</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 3. 셀 실행 후 런타임 재시작</span></span><br></pre></td></tr></table></figure></li><li><p>라이브러리를 불러오고 환경을 설정합니다.</p></li><li><p>색맹에게도 데이터를 잘 전달할 수 있도록 seaborn의 <b><code>colorblind</code></b> palette를 기본으로 사용합니다.</p></li><li><p><code>NanumGothic</code>을 기본으로 지정해 그림에 한글을 출력할 수 있도록 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Step 4. 라이브러리 호출</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 5. 시각화 설정</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line">sns.set_palette(<span class="string">&quot;colorblind&quot;</span>)</span><br><span class="line">sns.set_style(<span class="string">&quot;white&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 6. Linux 한글 사용 설정</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>]=[<span class="string">&#x27;NanumGothic&#x27;</span>, <span class="string">&#x27;sans-serif&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2-데이터-정리"><a href="#2-2-데이터-정리" class="headerlink" title="2.2. 데이터 정리"></a>2.2. 데이터 정리</h2><ul><li>그림에서 데이터를 추출합니다.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1612</span>              <span class="comment"># 조사 대상 수</span></span><br><span class="line">r_ab = <span class="number">0.949</span>            <span class="comment"># 항체 보유자 비율</span></span><br><span class="line">r_ni = <span class="number">0.157</span>            <span class="comment"># 자연 감염자 비율</span></span><br><span class="line">r_vc = r_ab - r_ni      <span class="comment"># 백신 접종자(?) 비율</span></span><br><span class="line">r_no = <span class="number">1</span>-r_ab           <span class="comment"># 항체 미보유자 비율</span></span><br><span class="line"></span><br><span class="line">n_ab = <span class="built_in">int</span>(num * r_ab)  <span class="comment"># 항체 보유자 수</span></span><br><span class="line">n_ni = <span class="built_in">int</span>(num * r_ni)  <span class="comment"># 자연 감염자 수</span></span><br><span class="line">n_vc = <span class="built_in">int</span>(num * r_vc)  <span class="comment"># 백신 접종자(?) 비율</span></span><br><span class="line">n_no = <span class="built_in">int</span>(num - n_ab)  <span class="comment"># 항체 미보유자 비율</span></span><br><span class="line"></span><br><span class="line">df_covid = pd.DataFrame(&#123;<span class="string">&quot;수&quot;</span>: [n_ab, n_ni, n_vc, n_no],</span><br><span class="line">                         <span class="string">&quot;비율&quot;</span>: [r_ab, r_ni, r_vc, r_no]&#125;,</span><br><span class="line">                        index=[<span class="string">&quot;항체 보유자&quot;</span>, <span class="string">&quot;자연 감염자&quot;</span>, <span class="string">&quot;백신 접종자(?)&quot;</span>, <span class="string">&quot;항체 미보유자&quot;</span>])</span><br><span class="line"></span><br><span class="line">df_covid</span><br></pre></td></tr></table></figure><img src="105_covid_immune_06.png"><br></li></ul><h2 id="2-2-항체-보유-자연-감염-시각화"><a href="#2-2-항체-보유-자연-감염-시각화" class="headerlink" title="2.2. 항체 보유, 자연 감염 시각화"></a>2.2. 항체 보유, 자연 감염 시각화</h2><ul><li><b>항체 보유 94.9%</b> 내에 <b>자연 감염 15.7%</b>를 포함시켜 그리기로 합니다.</li><li>항체 보유와 미보유만 먼저 그린 후, 항체 미보유는 삭제합니다.</li><li>해당 wedge와 text를 함께 삭제합니다.<br><details>  <summary><b>코드 보기/접기</b></summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">6</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 색상 지정</span></span><br><span class="line">c_ah = <span class="string">&quot;navy&quot;</span>       <span class="comment"># 항체 보유자 (antibody holder)</span></span><br><span class="line">c_ni = <span class="string">&quot;royalblue&quot;</span>  <span class="comment"># 자연 감염자 (naturally infested)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pie chart : 항체 보유자</span></span><br><span class="line">ax.pie(df_covid[<span class="string">&quot;수&quot;</span>].values[[<span class="number">0</span>, <span class="number">3</span>]],                       <span class="comment"># [항체 보유자, 항체 미보유자]</span></span><br><span class="line">       startangle=<span class="number">90</span>, counterclock=<span class="literal">False</span>,                   <span class="comment"># pie chart 위쪽에서 시작, 시계방향으로</span></span><br><span class="line">       colors=[c_ab], autopct=<span class="string">&quot;%.1f%%&quot;</span>, pctdistance=<span class="number">0.8</span>,    <span class="comment"># 색, 비율 표시 조정</span></span><br><span class="line">       wedgeprops=&#123;<span class="string">&quot;width&quot;</span>:<span class="number">0.5</span>, <span class="string">&quot;ec&quot;</span>:c_ni&#125;,                 <span class="comment"># wedge properties</span></span><br><span class="line">       textprops=&#123;<span class="string">&quot;fontfamily&quot;</span>:<span class="string">&quot;FreeSans&quot;</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;w&quot;</span>,     <span class="comment"># text propeerties</span></span><br><span class="line">                  <span class="string">&quot;fontsize&quot;</span>:<span class="number">50</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 항체 미보유자 부분 wedge 제거</span></span><br><span class="line">ax.patches[-<span class="number">1</span>].remove()</span><br><span class="line">ax.texts[-<span class="number">1</span>].remove()</span><br></pre></td></tr></table></figure></li></ul><p><img src="105_covid_immune_04.png"><br></p><ul><li>자연 감염, 백신 접종자(?), 항체 미보유자를 기준으로 pie chart를 새로 그리고,</li><li>자연 감염자를 제외한 나머지를 제거합니다.<br><details>  <summary><b>코드 보기/접기</b></summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">6</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 색상 지정</span></span><br><span class="line">c_ah = <span class="string">&quot;navy&quot;</span>       <span class="comment"># 항체 보유자 (antibody holder)</span></span><br><span class="line">c_ni = <span class="string">&quot;royalblue&quot;</span>  <span class="comment"># 자연 감염자 (naturally infested)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pie chart : 항체 보유자</span></span><br><span class="line">ax.pie(df_covid[<span class="string">&quot;수&quot;</span>].values[[<span class="number">0</span>, <span class="number">3</span>]],                       <span class="comment"># [항체 보유자, 항체 미보유자]</span></span><br><span class="line">       startangle=<span class="number">90</span>, counterclock=<span class="literal">False</span>,                   <span class="comment"># pie chart 위쪽에서 시작, 시계방향으로</span></span><br><span class="line">       colors=[c_ab], autopct=<span class="string">&quot;%.1f%%&quot;</span>, pctdistance=<span class="number">0.8</span>,    <span class="comment"># 색, 비율 표시 조정</span></span><br><span class="line">       wedgeprops=&#123;<span class="string">&quot;width&quot;</span>:<span class="number">0.5</span>, <span class="string">&quot;ec&quot;</span>:c_ni&#125;,                 <span class="comment"># wedge properties</span></span><br><span class="line">       textprops=&#123;<span class="string">&quot;fontfamily&quot;</span>:<span class="string">&quot;FreeSans&quot;</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;w&quot;</span>,     <span class="comment"># text propeerties</span></span><br><span class="line">                  <span class="string">&quot;fontsize&quot;</span>:<span class="number">50</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 항체 미보유자 부분 wedge 제거</span></span><br><span class="line">ax.patches[-<span class="number">1</span>].remove()</span><br><span class="line">ax.texts[-<span class="number">1</span>].remove()</span><br><span class="line"></span><br><span class="line"><span class="comment"># pie chart : 자연감염</span></span><br><span class="line">ax.pie(df_covid[<span class="string">&quot;수&quot;</span>].values[<span class="number">1</span>:],                           <span class="comment"># 자연 감염자 등 비율 시각화</span></span><br><span class="line">       startangle=<span class="number">90</span>, counterclock=<span class="literal">False</span>, </span><br><span class="line">       colors = [c_ni], autopct=<span class="string">&quot;%.1f%%&quot;</span>, pctdistance=<span class="number">0.7</span>,  </span><br><span class="line">       radius=<span class="number">0.95</span>,                                         <span class="comment"># 전체 그림보다 5% 작게</span></span><br><span class="line">       wedgeprops=&#123;<span class="string">&quot;width&quot;</span>:<span class="number">0.4</span>, <span class="string">&quot;ec&quot;</span>:c_ni&#125;,</span><br><span class="line">       textprops=&#123;<span class="string">&quot;fontfamily&quot;</span>:<span class="string">&quot;FreeSans&quot;</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;w&quot;</span>, </span><br><span class="line">                  <span class="string">&quot;fontsize&quot;</span>:<span class="number">50</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 항체보유, 자연감염 이외 wedge 제거</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> ax.patches[<span class="number">2</span>:]:</span><br><span class="line">    p.remove()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 항체 보유자, 자연 감염자 text외 나머지 제거</span></span><br><span class="line">text_ab, text_ni, text_vc, text_no = [text <span class="keyword">for</span> text <span class="keyword">in</span> ax.texts <span class="keyword">if</span> text.get_text() != <span class="string">&quot;&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">set</span>(ax.texts) - <span class="built_in">set</span>([text_ab, text_ni]):</span><br><span class="line">    t.remove()</span><br></pre></td></tr></table></figure></li></ul><p><img src="105_covid_immune_05.png"><br></p><h2 id="2-3-항체-미보유자-선-그리기"><a href="#2-3-항체-미보유자-선-그리기" class="headerlink" title="2.3. 항체 미보유자 선 그리기"></a>2.3. 항체 미보유자 선 그리기</h2><ul><li>원본과 마찬가지로 항체 미보유자에 선을 그립니다.</li><li>곡선은 pie chart 뒤에 원을 그려 표현합니다.<br><details>  <summary><b>코드 보기/접기</b></summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Circle</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">6</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 색상 지정</span></span><br><span class="line">c_ah = <span class="string">&quot;navy&quot;</span>       <span class="comment"># 항체 보유자 (antibody holder)</span></span><br><span class="line">c_ni = <span class="string">&quot;royalblue&quot;</span>  <span class="comment"># 자연 감염자 (naturally infested)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pie chart : 항체 보유자</span></span><br><span class="line">ax.pie(df_covid[<span class="string">&quot;수&quot;</span>].values[[<span class="number">0</span>, <span class="number">3</span>]],                       <span class="comment"># [항체 보유자, 항체 미보유자]</span></span><br><span class="line">       startangle=<span class="number">90</span>, counterclock=<span class="literal">False</span>,                   <span class="comment"># pie chart 위쪽에서 시작, 시계방향으로</span></span><br><span class="line">       colors=[c_ab], autopct=<span class="string">&quot;%.1f%%&quot;</span>, pctdistance=<span class="number">0.8</span>,    <span class="comment"># 색, 비율 표시 조정</span></span><br><span class="line">       wedgeprops=&#123;<span class="string">&quot;width&quot;</span>:<span class="number">0.5</span>, <span class="string">&quot;ec&quot;</span>:c_ni&#125;,                 <span class="comment"># wedge properties</span></span><br><span class="line">       textprops=&#123;<span class="string">&quot;fontfamily&quot;</span>:<span class="string">&quot;FreeSans&quot;</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;w&quot;</span>,     <span class="comment"># text propeerties</span></span><br><span class="line">                  <span class="string">&quot;fontsize&quot;</span>:<span class="number">50</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 항체 미보유자 부분 wedge 제거</span></span><br><span class="line">ax.patches[-<span class="number">1</span>].remove()</span><br><span class="line">ax.texts[-<span class="number">1</span>].remove()</span><br><span class="line"></span><br><span class="line"><span class="comment"># pie chart : 자연감염</span></span><br><span class="line">ax.pie(df_covid[<span class="string">&quot;수&quot;</span>].values[<span class="number">1</span>:],                           <span class="comment"># 자연 감염자 등 비율 시각화</span></span><br><span class="line">       startangle=<span class="number">90</span>, counterclock=<span class="literal">False</span>, </span><br><span class="line">       colors = [c_ni], autopct=<span class="string">&quot;%.1f%%&quot;</span>, pctdistance=<span class="number">0.7</span>,  </span><br><span class="line">       radius=<span class="number">0.95</span>,                                         <span class="comment"># 전체 그림보다 5% 작게</span></span><br><span class="line">       wedgeprops=&#123;<span class="string">&quot;width&quot;</span>:<span class="number">0.4</span>, <span class="string">&quot;ec&quot;</span>:c_ni&#125;,</span><br><span class="line">       textprops=&#123;<span class="string">&quot;fontfamily&quot;</span>:<span class="string">&quot;FreeSans&quot;</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;w&quot;</span>, </span><br><span class="line">                  <span class="string">&quot;fontsize&quot;</span>:<span class="number">50</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 항체보유, 자연감염 이외 wedge 제거</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> ax.patches[<span class="number">2</span>:]:</span><br><span class="line">    p.remove()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 항체 보유자, 자연 감염자 text외 나머지 제거</span></span><br><span class="line">text_ab, text_ni, text_vc, text_no = [text <span class="keyword">for</span> text <span class="keyword">in</span> ax.texts <span class="keyword">if</span> text.get_text() != <span class="string">&quot;&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">set</span>(ax.texts) - <span class="built_in">set</span>([text_ab, text_ni]):</span><br><span class="line">    t.remove()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 항체 미보유자 부분 원 표시</span></span><br><span class="line">circle = Circle((<span class="number">0</span>, <span class="number">0</span>), radius=<span class="number">0.75</span>, fc=<span class="string">&quot;none&quot;</span>, </span><br><span class="line">                lw=<span class="number">15</span>, ec=<span class="string">&quot;0.7&quot;</span>, zorder=-<span class="number">1</span>)</span><br><span class="line">ax.add_artist(circle)</span><br></pre></td></tr></table></figure></li></ul><p><img src="105_covid_immune_07.png"><br></p><h2 id="2-4-폰트-위치-및-크기-조정"><a href="#2-4-폰트-위치-및-크기-조정" class="headerlink" title="2.4. 폰트 위치 및 크기 조정"></a>2.4. 폰트 위치 및 크기 조정</h2><ul><li>결국 전달하고 싶은 내용은 <b>항체 보유자 94.9%</b>입니다.</li><li>이 안에 있는 <b>자연 감염 15.7%</b>는 중요한 부차 정보입니다.</li><li>자연 감염은 폰트 크기를 줄이고, “자연 감염”을 위에 붙입니다.<details>  <summary><b>코드 보기/접기</b></summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Circle</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">6</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 색상 지정</span></span><br><span class="line">c_ah = <span class="string">&quot;navy&quot;</span>       <span class="comment"># 항체 보유자 (antibody holder)</span></span><br><span class="line">c_ni = <span class="string">&quot;royalblue&quot;</span>  <span class="comment"># 자연 감염자 (naturally infested)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pie chart : 항체 보유자</span></span><br><span class="line">ax.pie(df_covid[<span class="string">&quot;수&quot;</span>].values[[<span class="number">0</span>, <span class="number">3</span>]],                       <span class="comment"># [항체 보유자, 항체 미보유자]</span></span><br><span class="line">       startangle=<span class="number">90</span>, counterclock=<span class="literal">False</span>,                   <span class="comment"># pie chart 위쪽에서 시작, 시계방향으로</span></span><br><span class="line">       colors=[c_ab], autopct=<span class="string">&quot;%.1f%%&quot;</span>, pctdistance=<span class="number">0.8</span>,    <span class="comment"># 색, 비율 표시 조정</span></span><br><span class="line">       wedgeprops=&#123;<span class="string">&quot;width&quot;</span>:<span class="number">0.5</span>, <span class="string">&quot;ec&quot;</span>:c_ni&#125;,                 <span class="comment"># wedge properties</span></span><br><span class="line">       textprops=&#123;<span class="string">&quot;fontfamily&quot;</span>:<span class="string">&quot;FreeSans&quot;</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;w&quot;</span>,     <span class="comment"># text propeerties</span></span><br><span class="line">                  <span class="string">&quot;fontsize&quot;</span>:<span class="number">50</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 항체 미보유자 부분 wedge 제거</span></span><br><span class="line">ax.patches[-<span class="number">1</span>].remove()</span><br><span class="line">ax.texts[-<span class="number">1</span>].remove()</span><br><span class="line"></span><br><span class="line"><span class="comment"># pie chart : 자연감염</span></span><br><span class="line">ax.pie(df_covid[<span class="string">&quot;수&quot;</span>].values[<span class="number">1</span>:],                           <span class="comment"># 자연 감염자 등 비율 시각화</span></span><br><span class="line">       startangle=<span class="number">90</span>, counterclock=<span class="literal">False</span>, </span><br><span class="line">       colors = [c_ni], autopct=<span class="string">&quot;%.1f%%&quot;</span>, pctdistance=<span class="number">0.7</span>,  </span><br><span class="line">       radius=<span class="number">0.95</span>,                                         <span class="comment"># 전체 그림보다 5% 작게</span></span><br><span class="line">       wedgeprops=&#123;<span class="string">&quot;width&quot;</span>:<span class="number">0.4</span>, <span class="string">&quot;ec&quot;</span>:c_ni&#125;,</span><br><span class="line">       textprops=&#123;<span class="string">&quot;fontfamily&quot;</span>:<span class="string">&quot;FreeSans&quot;</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;w&quot;</span>, </span><br><span class="line">                  <span class="string">&quot;fontsize&quot;</span>:<span class="number">50</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 항체보유, 자연감염 이외 wedge 제거</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> ax.patches[<span class="number">2</span>:]:</span><br><span class="line">    p.remove()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 항체 보유자, 자연 감염자 text외 나머지 제거</span></span><br><span class="line">text_ab, text_ni, text_vc, text_no = [text <span class="keyword">for</span> text <span class="keyword">in</span> ax.texts <span class="keyword">if</span> text.get_text() != <span class="string">&quot;&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">set</span>(ax.texts) - <span class="built_in">set</span>([text_ab, text_ni]):</span><br><span class="line">    t.remove()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 항체 미보유자 부분 원 표시</span></span><br><span class="line">circle = Circle((<span class="number">0</span>, <span class="number">0</span>), radius=<span class="number">0.75</span>, fc=<span class="string">&quot;none&quot;</span>, </span><br><span class="line">                lw=<span class="number">15</span>, ec=<span class="string">&quot;0.7&quot;</span>, zorder=-<span class="number">1</span>)</span><br><span class="line">ax.add_artist(circle)</span><br><span class="line"></span><br><span class="line"><span class="comment"># texts colored boundary</span></span><br><span class="line"><span class="keyword">for</span> t, c <span class="keyword">in</span> <span class="built_in">zip</span>([text_ab, text_ni], [c_ab, c_ni]):</span><br><span class="line">    t.set_path_effects([path_effects.Stroke(linewidth=<span class="number">5</span>, foreground=c),</span><br><span class="line">                        path_effects.SimplePatchShadow(),</span><br><span class="line">                        path_effects.Normal()])</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 자연 감염 폰트 크기 조정</span></span><br><span class="line">text_ni_size = text_ni.get_size()</span><br><span class="line">text_ni.set_size(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 자연 감염 폰트 위치 </span></span><br><span class="line">text_ni_pos = <span class="built_in">list</span>(text_ni.get_position())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 자연 감염 text 입력</span></span><br><span class="line">text_ni_word = ax.text(text_ni_pos[<span class="number">0</span>], text_ni_pos[<span class="number">1</span>]+<span class="number">0.15</span>, <span class="string">&quot;자연감염&quot;</span>, fontsize=<span class="number">23</span>, </span><br><span class="line">                       fontweight=<span class="string">&quot;bold&quot;</span>, ha=<span class="string">&quot;center&quot;</span>, color=<span class="string">&quot;w&quot;</span>, alpha=<span class="number">1</span>)</span><br><span class="line">text_ni_word.set_path_effects([path_effects.Stroke(linewidth=<span class="number">5</span>, foreground=c_ni),</span><br><span class="line">                               path_effects.Normal()])</span><br></pre></td></tr></table></figure></li></ul><p><img src="105_covid_immune_08.png"><br></p><h2 id="2-5-항체-보유자-비율-이동"><a href="#2-5-항체-보유자-비율-이동" class="headerlink" title="2.5. 항체 보유자 비율 이동"></a>2.5. 항체 보유자 비율 이동</h2><ul><li>항체 보유자 비율을 상단으로 옮깁니다.</li><li>“항체 있음”을 항체 보유자 비율 앞에 붙입니다.<br><details>  <summary><b>코드 보기/접기</b></summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Circle</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">6</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 색상 지정</span></span><br><span class="line">c_ah = <span class="string">&quot;navy&quot;</span>       <span class="comment"># 항체 보유자 (antibody holder)</span></span><br><span class="line">c_ni = <span class="string">&quot;royalblue&quot;</span>  <span class="comment"># 자연 감염자 (naturally infested)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pie chart : 항체 보유자</span></span><br><span class="line">ax.pie(df_covid[<span class="string">&quot;수&quot;</span>].values[[<span class="number">0</span>, <span class="number">3</span>]],                       <span class="comment"># [항체 보유자, 항체 미보유자]</span></span><br><span class="line">       startangle=<span class="number">90</span>, counterclock=<span class="literal">False</span>,                   <span class="comment"># pie chart 위쪽에서 시작, 시계방향으로</span></span><br><span class="line">       colors=[c_ab], autopct=<span class="string">&quot;%.1f%%&quot;</span>, pctdistance=<span class="number">0.8</span>,    <span class="comment"># 색, 비율 표시 조정</span></span><br><span class="line">       wedgeprops=&#123;<span class="string">&quot;width&quot;</span>:<span class="number">0.5</span>, <span class="string">&quot;ec&quot;</span>:c_ni&#125;,                 <span class="comment"># wedge properties</span></span><br><span class="line">       textprops=&#123;<span class="string">&quot;fontfamily&quot;</span>:<span class="string">&quot;FreeSans&quot;</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;w&quot;</span>,     <span class="comment"># text propeerties</span></span><br><span class="line">                  <span class="string">&quot;fontsize&quot;</span>:<span class="number">50</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 항체 미보유자 부분 wedge 제거</span></span><br><span class="line">ax.patches[-<span class="number">1</span>].remove()</span><br><span class="line">ax.texts[-<span class="number">1</span>].remove()</span><br><span class="line"></span><br><span class="line"><span class="comment"># pie chart : 자연감염</span></span><br><span class="line">ax.pie(df_covid[<span class="string">&quot;수&quot;</span>].values[<span class="number">1</span>:],                           <span class="comment"># 자연 감염자 등 비율 시각화</span></span><br><span class="line">       startangle=<span class="number">90</span>, counterclock=<span class="literal">False</span>, </span><br><span class="line">       colors = [c_ni], autopct=<span class="string">&quot;%.1f%%&quot;</span>, pctdistance=<span class="number">0.7</span>,  </span><br><span class="line">       radius=<span class="number">0.95</span>,                                         <span class="comment"># 전체 그림보다 5% 작게</span></span><br><span class="line">       wedgeprops=&#123;<span class="string">&quot;width&quot;</span>:<span class="number">0.4</span>, <span class="string">&quot;ec&quot;</span>:c_ni&#125;,</span><br><span class="line">       textprops=&#123;<span class="string">&quot;fontfamily&quot;</span>:<span class="string">&quot;FreeSans&quot;</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;w&quot;</span>, </span><br><span class="line">                  <span class="string">&quot;fontsize&quot;</span>:<span class="number">50</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 항체보유, 자연감염 이외 wedge 제거</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> ax.patches[<span class="number">2</span>:]:</span><br><span class="line">    p.remove()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 항체 보유자, 자연 감염자 text외 나머지 제거</span></span><br><span class="line">text_ab, text_ni, text_vc, text_no = [text <span class="keyword">for</span> text <span class="keyword">in</span> ax.texts <span class="keyword">if</span> text.get_text() != <span class="string">&quot;&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">set</span>(ax.texts) - <span class="built_in">set</span>([text_ab, text_ni]):</span><br><span class="line">    t.remove()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 항체 미보유자 부분 원 표시</span></span><br><span class="line">circle = Circle((<span class="number">0</span>, <span class="number">0</span>), radius=<span class="number">0.75</span>, fc=<span class="string">&quot;none&quot;</span>, </span><br><span class="line">                lw=<span class="number">15</span>, ec=<span class="string">&quot;0.7&quot;</span>, zorder=-<span class="number">1</span>)</span><br><span class="line">ax.add_artist(circle)</span><br><span class="line"></span><br><span class="line"><span class="comment"># texts colored boundary</span></span><br><span class="line"><span class="keyword">for</span> t, c <span class="keyword">in</span> <span class="built_in">zip</span>([text_ab, text_ni], [c_ab, c_ni]):</span><br><span class="line">    t.set_path_effects([path_effects.Stroke(linewidth=<span class="number">5</span>, foreground=c),</span><br><span class="line">                        path_effects.SimplePatchShadow(),</span><br><span class="line">                        path_effects.Normal()])</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 자연 감염 폰트 크기 조정</span></span><br><span class="line">text_ni_size = text_ni.get_size()</span><br><span class="line">text_ni.set_size(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 자연 감염 폰트 위치 </span></span><br><span class="line">text_ni_pos = <span class="built_in">list</span>(text_ni.get_position())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 자연 감염 text 입력</span></span><br><span class="line">text_ni_word = ax.text(text_ni_pos[<span class="number">0</span>], text_ni_pos[<span class="number">1</span>]+<span class="number">0.15</span>, <span class="string">&quot;자연감염&quot;</span>, fontsize=<span class="number">23</span>, </span><br><span class="line">                       fontweight=<span class="string">&quot;bold&quot;</span>, ha=<span class="string">&quot;center&quot;</span>, color=<span class="string">&quot;w&quot;</span>, alpha=<span class="number">1</span>)</span><br><span class="line">text_ni_word.set_path_effects([path_effects.Stroke(linewidth=<span class="number">5</span>, foreground=c_ni),</span><br><span class="line">                               path_effects.Normal()])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 항체 보유 위치 조정</span></span><br><span class="line">text_ab.set_position([<span class="number">0</span>, <span class="number">1.1</span>])</span><br><span class="line">text_ab.set_ha(<span class="string">&quot;left&quot;</span>)</span><br><span class="line">text_ab.set_va(<span class="string">&quot;baseline&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 항체 보유 text 입력</span></span><br><span class="line">text_ab_word = ax.text(-<span class="number">0.05</span>, <span class="number">1.17</span>, <span class="string">&quot;항체 있음&quot;</span>, fontsize=<span class="number">30</span>, </span><br><span class="line">                       fontweight=<span class="string">&quot;bold&quot;</span>,ha=<span class="string">&quot;right&quot;</span>, va=<span class="string">&quot;center&quot;</span>, color=c_ab)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 총 인원 수</span></span><br><span class="line">ax.text(<span class="number">0</span>, <span class="number">0</span>, <span class="string">f&quot;<span class="subst">&#123;num&#125;</span>   &quot;</span>, fontsize=<span class="number">45</span>, fontweight=<span class="string">&quot;bold&quot;</span>,</span><br><span class="line">        fontfamily=<span class="string">&quot;FreeSans&quot;</span>, ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>, color=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">ax.text(<span class="number">0.22</span>, -<span class="number">0.05</span>, <span class="string">&quot;명&quot;</span>, fontsize=<span class="number">30</span>, fontweight=<span class="string">&quot;bold&quot;</span>,</span><br><span class="line">        ha=<span class="string">&quot;left&quot;</span>, va=<span class="string">&quot;baseline&quot;</span>, color=<span class="string">&quot;gray&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><p><img src="105_covid_immune_03.png"><br></p><h1 id="3-결론"><a href="#3-결론" class="headerlink" title="3. 결론"></a>3. 결론</h1><ul><li><p>약간의 코딩으로 왼쪽 그림을 오른쪽처럼 바꿨습니다.</p></li><li><p>적어도 자연감염이 94.9% 안에 포함되어 있다는 것은 전달되는 듯 합니다.<br><br><img src="105_covid_immune_00.png"><br></p></li><li><p><b>최선이라고는 생각지 않습니다.</b><p></p></li></ul><ul><li>지금도 왠지 맘에 쏙 들지는 않지만 나중에 보면 마음에 더 안들지도 모릅니다.</li><li>방망이를 깎는 노인의 심정으로 계속 붙들고 싶지만 현실적으로 마감 등 한계가 있습니다.</li><li>기본기가 튼튼해지면 이런 제약에서도 더 좋은 결과를 낼 수 있을 것 같습니다.</li><li><b>오늘도 방망이를 깎습니다.</b> 같은 마음을 가진 모든 분들을 응원합니다.<br><br><img src="105_covid_immune_09.png"><br></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/pie-chart/">pie chart</category>
      
      
    </item>
    
    <item>
      <title>Scheduling without CRON</title>
      <link>https://jehyunlee.github.io/2022/06/22/Python-General-10-schedule_no_cron/</link>
      <guid>https://jehyunlee.github.io/2022/06/22/Python-General-10-schedule_no_cron/</guid>
      <pubDate>Tue, 21 Jun 2022 20:50:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;윈도에서 반복 작업은 작업 스케줄러를 사용합니다.&lt;/li&gt;
&lt;li&gt;리눅스에서는 cron을 사용합니다.&lt;/li&gt;
&lt;li&gt;그런데 cron을 사용할 수 없어서 다른 방법을 찾았습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-crontab&quot;&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>윈도에서 반복 작업은 작업 스케줄러를 사용합니다.</li><li>리눅스에서는 cron을 사용합니다.</li><li>그런데 cron을 사용할 수 없어서 다른 방법을 찾았습니다.</li></ul><h1 id="1-crontab"><a href="#1-crontab" class="headerlink" title="1. crontab"></a>1. crontab</h1><blockquote><p><a href="https://en.wikipedia.org/wiki/Cron">wikipedia: cron</a><br><a href="https://ojava.tistory.com/154">O! JAVA: [Linux]crontab 설정 및 로그 확인</a></p></blockquote><ul><li>Unix 계열에서 주기적으로 수행될 작업을 등록하여 실행하는 도구입니다.</li><li>1975년에 AT&amp;T Bell 연구소에서 만들어졌습니다.</li><li>여러 분들이 사용법을 잘 정리하셨으니 여기에는 간단하게만 정리합니다.</li><li>cron을 설정하려면 crontab(cron table)에 등록하거나 등록된 내용을 수정합니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -l    <span class="comment"># 등록 작업 리스트 출력</span></span><br><span class="line">$ crontab -e    <span class="comment"># 등록 작업 편집</span></span><br><span class="line">$ crontab -d    <span class="comment"># 등록 작업 삭제</span></span><br><span class="line">$ crontab -r    <span class="comment"># 현재 사용자가 등록한 crontab 전체 삭제</span></span><br></pre></td></tr></table></figure><p></li><li>이와 같이 crontab을 설정하면, 데몬을 재시작해야 적용됩니다.</li><li><code>restart</code>로 재시작할 수 있고, <code>stop</code>후 <code>start</code>를 할 수도 있습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">$ service cron restart    <span class="comment"># 재시작</span></span><br><span class="line">$ service cron stop       <span class="comment"># 현재 cron 중지</span></span><br><span class="line">$ service cron start      <span class="comment"># cron 시작</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS</span></span><br><span class="line">$ service crond restart   <span class="comment"># 재시작</span></span><br><span class="line">$ service crond stop      <span class="comment"># 현재 cron 중지</span></span><br><span class="line">$ service crond start     <span class="comment"># cron 시작</span></span><br></pre></td></tr></table></figure><p></li><li>cron이 잘 실행되는지는 log 파일을 모니터링하면 알 수 있습니다.</li><li><code>tail -f</code>를 사용하면 실시간으로 파일이 업데이트되는 모습을 볼 수 있습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">$ tail -f /var/<span class="built_in">log</span>/syslog | grep CRON</span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS</span></span><br><span class="line">$ tail -f /var/<span class="built_in">log</span>/cron</span><br></pre></td></tr></table></figure></li></ul><h1 id="2-shell-script"><a href="#2-shell-script" class="headerlink" title="2. shell script"></a>2. shell script</h1><blockquote><p><a href="https://coderwall.com/p/eilosa/scheduling-jobs-in-unix-without-cron">Coderwall: Scheduling jobs in UNIX without cron</a><br><a href="https://wikidocs.net/29981">while 루프</a></p></blockquote><ul><li><p>약간의 불행을 겪고 있습니다.</p></li><li><p>cron을 어떻게 조작해도 오류가 발생하고, 작업 스케줄링이 되지 않습니다.<br><img src="Python-General-10-schedule_no_cron_1.png" alt="PAM은 왜..."><br></p></li><li><p>오류를 해결하고자 구글링을 한 결과 여러 시도를 찾았습니다.</p></li><li><p><a href="https://coderwall.com/p/eilosa/scheduling-jobs-in-unix-without-cron">shell script를 사용</a>해서 작업을 할 수 있더군요.</p></li><li><p><code>while do</code>만 사용해서 더 간단한 반복 코드를 작성했습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>;<span class="comment"># 무한 반복</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> `date`<span class="comment"># 실행 코드. 파이썬 실행이라면 `date` 대신 `python 파일명.py`</span></span><br><span class="line">sleep 10<span class="comment"># 10초 대기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>실행 결과: 10초마다 시간이 출력됩니다.<br><img src="Python-General-10-schedule_no_cron_3.png"><br></p></li></ul><ul><li><code>nohup</code>과 <code>&amp;</code>를 붙여 백그라운드 실행을 하면 다른 작업을 할 수 있습니다.</li><li>이 때 화면 출력(standard output)은 기본적으로 nohup.out에 기록됩니다.<br><img src="Python-General-10-schedule_no_cron_4.png"><br></li></ul><h1 id="3-nohup-task-관리"><a href="#3-nohup-task-관리" class="headerlink" title="3. nohup task 관리"></a>3. nohup task 관리</h1><ul><li><p>nohup으로 던져진 작업은 터미널 창을 닫아도 유지됩니다.</p></li><li><p>자칫하면 무한 반복에 빠질 수 있습니다. <code>kill</code>명령을 사용하기 위해서라도 PID를 알아야 합니다.</p></li><li><p>아래 명령으로 현재 실행중인 nohup 작업의 PID를 알 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep nohup</span><br></pre></td></tr></table></figure></li><li><p>하지만 더 좋은 것은 작업을 시작할 때 PID를 기록하는 것입니다.</p></li><li><p>여러 nohup작업을 관리하려면 각각의 PID를 정리할 필요가 있기 때문입니다.</p></li><li><p>nohup을 다음과 같이 실행해서 기록할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup script파일.sh &gt; 로그파일.<span class="built_in">log</span> 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="built_in">echo</span> $! &gt; PID파일.txt</span><br></pre></td></tr></table></figure></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/shell-script/">shell script</category>
      
      <category domain="https://jehyunlee.github.io/tags/job-schedule/">job schedule</category>
      
      
    </item>
    
    <item>
      <title>데이터 분할과 교차 검증</title>
      <link>https://jehyunlee.github.io/2022/06/15/Python-DS-104-kierlecture3/</link>
      <guid>https://jehyunlee.github.io/2022/06/15/Python-DS-104-kierlecture3/</guid>
      <pubDate>Wed, 15 Jun 2022 00:46:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;한국에너지기술연구원 AI 학습조직&lt;/b&gt;에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.&lt;ul&gt;
&lt;li&gt;scikit-learn 기능 중 데이터를 class 비율대로 분류하는 stratified K fold를 소개하고,&lt;/</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b>한국에너지기술연구원 AI 학습조직</b>에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.<ul><li>scikit-learn 기능 중 데이터를 class 비율대로 분류하는 stratified K fold를 소개하고,</li><li>모든 데이터를 학습과 검증에 활용하는 cross validation을 다룹니다.</li><li><a href="220614_%EC%9D%B4%EC%A0%9C%ED%98%84_KIERML_2202_bestmodel.pdf">강의 자료는 여기에서 다운받으실 수 있습니다</a></li></ul></li></ul><ul><li><p>발표 영상 : (<a href="https://youtu.be/JX6tSOaUKuI">Youtube Link</a>)<br></p></li><li><p>실습 코드 : (<a href="https://bit.ly/3QdGwGq">https://bit.ly/3QdGwGq</a>)<br></p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/JX6tSOaUKuI" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <h3 id="Cross-Validation-set-generator"><a href="#Cross-Validation-set-generator" class="headerlink" title="Cross Validation set generator"></a>Cross Validation set generator</h3><ul><li><p><code>cross_val_score</code>와 <code>cross_val_predict</code>에 사전에 만든 dataset을 넣을 수 있습니다.</p></li><li><p>training set과 validation set의 index를 출력하는 generator를 사용하면 됩니다.</p></li><li><p>발표 영상에는 없지만 해당 코드를 추가합니다.</p></li><li><p>먼저, <code>cross_val_score</code>예시입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 사전에 분할한 cross validation set 사용</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_train_valid</span>(<span class="params">idx_trains, idx_vals</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(idx_trains) == <span class="built_in">len</span>(idx_vals) <span class="comment"># train data index와 validation data index가 다르면 중단</span></span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count &lt; <span class="built_in">len</span>(idx_trains):</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> idx_trains[count-<span class="number">1</span>], idx_vals[count-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">idx_cv = generate_train_valid(idx_trains, idx_vals) <span class="comment"># CV set generator</span></span><br><span class="line">-cross_val_score(model1, X, y, cv=idx_cv, scoring=<span class="string">&quot;neg_root_mean_squared_error&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([290.47491999, 332.31676581, 268.35748775, 304.48637819,</span><br><span class="line">       262.42934634])</span><br></pre></td></tr></table></figure></li><li><p><code>cross_val_predict</code>예시입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_predict</span><br><span class="line"></span><br><span class="line"><span class="comment"># y_pred_cv = cross_val_predict(model1, X, y, cv=5)</span></span><br><span class="line">idx_cv = generate_train_valid(idx_trains, idx_vals)  <span class="comment"># CV set generator</span></span><br><span class="line">y_pred_cv = cross_val_predict(model1, X, y, cv=idx_cv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization and print</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.scatter(y, y_pred_cv, c=<span class="string">&quot;gray&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;true&quot;</span>, color=<span class="string">&quot;gray&quot;</span>, labelpad=<span class="number">12</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;predict&quot;</span>, color=<span class="string">&quot;gray&quot;</span>, labelpad=<span class="number">12</span>)</span><br><span class="line">mean_squared_error(y, y_pred_cv, squared=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">292.76401468664585</span><br></pre></td></tr></table></figure><p><img src="104_kierlecture3_01.png"><br></p></li></ul><p>* 바쁜 연구원 일정 속에 변동이 있겠지만, 최대한 일정을 지켜보고자 합니다.<p><img src="thumbnail_012.PNG" alt="학습조직 일정"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/machine-learning/">machine learning</category>
      
      <category domain="https://jehyunlee.github.io/tags/KIER/">KIER</category>
      
      <category domain="https://jehyunlee.github.io/tags/data-split/">data split</category>
      
      <category domain="https://jehyunlee.github.io/tags/validation/">validation</category>
      
      
    </item>
    
    <item>
      <title>skorch callbacks (3) ML Pipeline</title>
      <link>https://jehyunlee.github.io/2022/06/09/Python-DL-10-skorch_callback3/</link>
      <guid>https://jehyunlee.github.io/2022/06/09/Python-DL-10-skorch_callback3/</guid>
      <pubDate>Thu, 09 Jun 2022 10:50:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;PyTorch는 현재 가장 인기있는 딥러닝 라이브러리 중 하나입니다.&lt;/li&gt;
&lt;li&gt;학습 세부 사항을 지정하기 위해 Callback으로 다양한 기능을 지원합니다.&lt;/li&gt;
&lt;li&gt;skorch는 PyTorch를 scikit-learn과</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>PyTorch는 현재 가장 인기있는 딥러닝 라이브러리 중 하나입니다.</li><li>학습 세부 사항을 지정하기 위해 Callback으로 다양한 기능을 지원합니다.</li><li>skorch는 PyTorch를 scikit-learn과 함께 사용할 수 있게 해 줍니다.</li><li>skorch도 PyTorch callback을 이용할 수 있습니다.</li></ul><ul><li>글이 길어 세 개로 나눕니다. </li><li>세 번째로, skorch를 사용해 ML Pipeline을 완성합니다.</li><li>여러 callback으로 자세한 설정을 반영합니다.</li></ul><h2 id="3-2-skorch"><a href="#3-2-skorch" class="headerlink" title="3.2. skorch"></a>3.2. skorch</h2><blockquote><p><a href="https://bit.ly/3xxznt8">Colab code: skorch callbacks</a></p></blockquote><ul><li>Colab에는 skorch가 기본으로 설치되어 있지 않습니다.</li><li>간단한 명령으로 skorch를 설치합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!pip install skorch</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-1-preprocessor-포함-pipeline-작성"><a href="#3-2-1-preprocessor-포함-pipeline-작성" class="headerlink" title="3.2.1. preprocessor 포함 pipeline 작성"></a>3.2.1. preprocessor 포함 pipeline 작성</h3><blockquote><p><a href="https://skorch.readthedocs.io/en/stable/regressor.html">skorch: skorch.regressor</a></p></blockquote><ul><li>앞에서 만든 <code>get_preprocessor()</code>함수는 전처리 Pipeline을 출력합니다.</li><li>Pipeline을 연장해 이 뒤에 PyTorch로 만든 Neural Network를 덧붙입니다.</li><li>우리가 푸는 문제는 펭귄의 체중을 구하는 <b>regression</b>문제입니다.</li></ul><ul><li><p>skorch에서 제공하는 <a href="https://skorch.readthedocs.io/en/stable/regressor.html"><code>NeuralNetRegressor()</code></a>로 PyTorch 신경망을 감쌉니다.</p></li><li><p>loss function, optimizer 등은 <code>NeuralNetRegressor()</code> 안에 <code>criterion</code>, <code>optimizer</code> 등의 매개변수를 사용해 입력합니다.</p></li><li><p><code>optimizer=optim.Adam</code>으로 Adam을 선택했습니다. </p></li><li><p>PyTorch에서 Adam()안에 들어가던 매개변수 <code>lr=1e-3</code>은 <code>optimizer__lr=1e-3</code>으로 바뀌어 들어갑니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> skorch</span><br><span class="line"><span class="keyword">from</span> skorch <span class="keyword">import</span> NeuralNetRegressor</span><br><span class="line"></span><br><span class="line"><span class="comment"># skorch로 PyTorch neural network wrapping</span></span><br><span class="line">net_sk = NeuralNetRegressor(Net(), device=device, verbose=<span class="number">1</span>,</span><br><span class="line">                            criterion=RMSELoss,         <span class="comment"># loss function</span></span><br><span class="line">                            optimizer=optim.Adam,       <span class="comment"># optimizer</span></span><br><span class="line">                            optimizer__lr=<span class="number">1e-3</span>)         <span class="comment"># learning rate of the optimizer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># training</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">300</span>):</span><br><span class="line">    net_sk.fit(X_train_np, y_train.astype(np.float32).values.reshape(-<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><ul><li>실행 결과 : 너무 길어서 out of memory 오류가 뜰 수 있습니다. 침착하게 새로 고침을 누르시면 됩니다.</li><li>또는, <code>verbose=1</code>을 <code>verbose=0</code>으로 바꾸시는 것도 방법입니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">... (생략) ...</span><br><span class="line"></span><br><span class="line">     10      271.1115      286.5908  0.0111</span><br><span class="line">Re-initializing module.</span><br><span class="line">Re-initializing criterion.</span><br><span class="line">Re-initializing optimizer.</span><br><span class="line">  epoch    train_loss    valid_loss     dur</span><br><span class="line">-------  ------------  ------------  ------</span><br><span class="line">      1      272.8632      286.3571  0.0108</span><br><span class="line">      2      267.6815      285.4084  0.0145</span><br><span class="line">      3      268.0632      284.9375  0.0106</span><br><span class="line">      4      269.3830      284.9683  0.0104</span><br><span class="line">      5      270.7425      285.2378  0.0101</span><br><span class="line">      6      271.6377      285.5552  0.0108</span><br><span class="line">      7      271.9493      285.8589  0.0082</span><br><span class="line">      8      271.8214      286.1465  0.0080</span><br><span class="line">      9      271.4798      286.4032  0.0087</span><br><span class="line">     10      271.1165      286.5942  0.0088</span><br></pre></td></tr></table></figure></li></ul></li><li><p><b>학습이 <code>model.fit()</code>으로 잘 됩니다.</b></p></li><li><p><code>NeuralNetRegressor</code>로 한 번 감싼 것 만으로 scikit-learn API를 사용할 수 있게 되었습니다.</p></li><li><p><code>X_train</code>대신 전처리를 거친 <code>X_train_np</code>를 입력했습니다.</p></li><li><p><code>y_train</code>대신으로는 <code>y_train.astype(np.float32).values.reshape(-1, 1)</code>이 들어갔습니다.</p></li><li><p>pandas Series에서 데이터 타입을 바꾸고, 값을 추출해서, shape을 바꾼 것입니다.</p></li></ul><ul><li><b>예측도 <code>model.forward()</code> 대신 <code>model.predict()</code>로 진행합니다.</b><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prediction</span></span><br><span class="line">y_pred_train = net_sk.predict(X_train_np)</span><br><span class="line">y_pred_val = net_sk.predict(X_val_np)</span><br><span class="line">y_pred_test = net_sk.predict(X_test_np)</span><br><span class="line"></span><br><span class="line"><span class="comment"># parity plot</span></span><br><span class="line">plot_parity3(net_sk, Xs=[X_train_np, X_val_np, X_test_np])</span><br></pre></td></tr></table></figure><img src="10_sc_01.png"><br></li></ul><h3 id="3-2-2-ML-pipeline-작성"><a href="#3-2-2-ML-pipeline-작성" class="headerlink" title="3.2.2. ML pipeline 작성"></a>3.2.2. ML pipeline 작성</h3><blockquote><p><a href="https://skorch.readthedocs.io/en/stable/callbacks.html?highlight=input_dim#skorch.callbacks.InputShapeSetter">skorch: skorch.callbacks.InputShapeSetter</a><br><a href="https://stackoverflow.com/questions/60005715/how-to-pass-input-dim-from-fit-method-to-skorch-wrapper/60170023#60170023">stackoverflow: How to pass input dim from fit method to skorch wrapper?</a></p></blockquote><ul><li>앞에서 만든 전처리기, <code>get_preprocessor()</code>를 포함하는 Pipeline을 만듭니다.</li><li><code>method</code>매개변수로 neural network 뿐 아니라 linear regression, random forest를 선택할 수 있게 합니다.</li></ul><ul><li><p>Neural network는 이들 방법들과 달리 <b>input dimension이 중요</b>합니다. </p></li><li><p>신경망 구조를 만들 때 필요한 변수이기 때문입니다.</p></li><li><p>callback은 여러 설정을 지정할 수 있는 방법입니다. <code>InputShapeSetter</code>를 callback에 기본값으로 박아 넣습니다.</p></li><li><p>그 외에 여러 keyword arguments를 입력할 수 있도록 <b><code>**kwargs</code></b>를 <code>NeuralNetRegressor()</code>에 추가합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># machine learning models</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line"></span><br><span class="line"><span class="comment"># embedding pytorch model in scikit-learn Pipeline</span></span><br><span class="line"><span class="keyword">from</span> skorch <span class="keyword">import</span> NeuralNetRegressor</span><br><span class="line"><span class="keyword">from</span> skorch.helper <span class="keyword">import</span> predefined_split</span><br><span class="line"><span class="keyword">from</span> skorch.callbacks <span class="keyword">import</span> Callback</span><br><span class="line"></span><br><span class="line"><span class="comment"># dynamic input size of the PyTorch module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputShapeSetter</span>(<span class="params">Callback</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_train_begin</span>(<span class="params">self, net, X, y</span>):</span></span><br><span class="line">        net.set_params(module__ninput=X.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_model</span>(<span class="params">method=<span class="string">&quot;lr&quot;</span>, device=device, cols_cat=cols_cat, cols_num=cols_num, degree=<span class="number">1</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">              callbacks=[InputShapeSetter(<span class="params"></span>)], **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">&quot;lr&quot;</span>:</span><br><span class="line">        ml = LinearRegression(fit_intercept=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&quot;rf&quot;</span>:</span><br><span class="line">        ml = RandomForestRegressor(random_state=rng)</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&quot;nn&quot;</span>:</span><br><span class="line">        ml = NeuralNetRegressor(Net(), device=device, callbacks=callbacks, **kwargs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;# &#x27;method&#x27; should be in [&#x27;lr&#x27;, &#x27;rf&#x27;, &#x27;nn&#x27;].&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    preprocessor = get_preprocessor(cols_cat=cols_cat, cols_num=cols_num, degree=degree)</span><br><span class="line">    model = Pipeline([(<span class="string">&quot;preprocessor&quot;</span>, preprocessor), </span><br><span class="line">                      (<span class="string">&quot;ml&quot;</span>, ml)])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure></li><li><p>이제 <code>get_model()</code>을 사용해 ML pipeline을 제작할 수 있습니다.</p></li><li><p><code>method</code>에 입력하는 값에 따라 선형 회귀, 앙상블 트리, 신경망을 선택할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = get_model(<span class="string">&quot;nn&quot;</span>, max_epochs=epochs, verbose=<span class="number">1</span>, criterion=RMSELoss, optimizer=optim.Adam, optimizer__lr = <span class="number">1e-3</span>)</span><br><span class="line">model</span><br></pre></td></tr></table></figure><p><img src="10_sc_02.png"><br></p></li><li><p>웬만한 매개변수는 모두 <code>NeuralNetRegressor()</code>에 들어갑니다.</p></li><li><p>어떤 매개변수들이 있는지 출력해서 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model[<span class="string">&quot;ml&quot;</span>].get_params()</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;_kwargs&#x27;</span>: &#123;<span class="string">&#x27;optimizer__lr&#x27;</span>: 0.001&#125;,</span><br><span class="line"> <span class="string">&#x27;batch_size&#x27;</span>: 128,</span><br><span class="line"> <span class="string">&#x27;callbacks&#x27;</span>: [&lt;__main__.InputShapeSetter at 0x7f4911406cd0&gt;],</span><br><span class="line"> <span class="string">&#x27;callbacks__epoch_timer&#x27;</span>: &lt;skorch.callbacks.logging.EpochTimer at 0x7f49745b2a50&gt;,</span><br><span class="line"> <span class="string">&#x27;callbacks__print_log&#x27;</span>: &lt;skorch.callbacks.logging.PrintLog at 0x7f49701261d0&gt;,</span><br><span class="line"> <span class="string">&#x27;callbacks__print_log__floatfmt&#x27;</span>: <span class="string">&#x27;.4f&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;callbacks__print_log__keys_ignored&#x27;</span>: None,</span><br><span class="line"> <span class="string">&#x27;callbacks__print_log__sink&#x27;</span>: &lt;<span class="keyword">function</span> <span class="built_in">print</span>&gt;,</span><br><span class="line"> <span class="string">&#x27;callbacks__print_log__stralign&#x27;</span>: <span class="string">&#x27;right&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;callbacks__print_log__tablefmt&#x27;</span>: <span class="string">&#x27;simple&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;callbacks__train_loss&#x27;</span>: &lt;skorch.callbacks.scoring.PassthroughScoring at 0x7f49745b2450&gt;,</span><br><span class="line"> <span class="string">&#x27;callbacks__train_loss__lower_is_better&#x27;</span>: True,</span><br><span class="line"> <span class="string">&#x27;callbacks__train_loss__name&#x27;</span>: <span class="string">&#x27;train_loss&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;callbacks__train_loss__on_train&#x27;</span>: True,</span><br><span class="line"> <span class="string">&#x27;callbacks__valid_loss&#x27;</span>: &lt;skorch.callbacks.scoring.PassthroughScoring at 0x7f49745b24d0&gt;,</span><br><span class="line"> <span class="string">&#x27;callbacks__valid_loss__lower_is_better&#x27;</span>: True,</span><br><span class="line"> <span class="string">&#x27;callbacks__valid_loss__name&#x27;</span>: <span class="string">&#x27;valid_loss&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;callbacks__valid_loss__on_train&#x27;</span>: False,</span><br><span class="line"> <span class="string">&#x27;criterion&#x27;</span>: __main__.RMSELoss,</span><br><span class="line"> <span class="string">&#x27;dataset&#x27;</span>: skorch.dataset.Dataset,</span><br><span class="line"> <span class="string">&#x27;device&#x27;</span>: <span class="string">&#x27;cuda:0&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;iterator_train&#x27;</span>: torch.utils.data.dataloader.DataLoader,</span><br><span class="line"> <span class="string">&#x27;iterator_valid&#x27;</span>: torch.utils.data.dataloader.DataLoader,</span><br><span class="line"> <span class="string">&#x27;lr&#x27;</span>: 0.01,</span><br><span class="line"> <span class="string">&#x27;max_epochs&#x27;</span>: 1000,</span><br><span class="line"> <span class="string">&#x27;module&#x27;</span>: Net(</span><br><span class="line">   (layer0): Linear(in_features=12, out_features=16, bias=True)</span><br><span class="line">   (layer1): Linear(in_features=16, out_features=16, bias=True)</span><br><span class="line">   (layer2): Linear(in_features=16, out_features=12, bias=True)</span><br><span class="line">   (layer3): Linear(in_features=12, out_features=8, bias=True)</span><br><span class="line">   (layer4): Linear(in_features=8, out_features=1, bias=True)</span><br><span class="line">   (activation): ReLU()</span><br><span class="line"> ),</span><br><span class="line"> <span class="string">&#x27;optimizer&#x27;</span>: torch.optim.adam.Adam,</span><br><span class="line"> <span class="string">&#x27;optimizer__lr&#x27;</span>: 0.001,</span><br><span class="line"> <span class="string">&#x27;predict_nonlinearity&#x27;</span>: <span class="string">&#x27;auto&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;train_split&#x27;</span>: &lt;skorch.dataset.ValidSplit object at 0x7f497434cc90&gt;,</span><br><span class="line"> <span class="string">&#x27;verbose&#x27;</span>: 1,</span><br><span class="line"> <span class="string">&#x27;warm_start&#x27;</span>: False&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-2-3-train-and-validate-self"><a href="#3-2-3-train-and-validate-self" class="headerlink" title="3.2.3. train and validate (self)"></a>3.2.3. train and validate (self)</h3><blockquote><p><a href="https://skorch.readthedocs.io/en/stable/user/neuralnet.html#train-split">skorch: NeuralNet#train_split</a></p></blockquote><ul><li><p>X_train과 y_train만 사용해서 학습시킵니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.fit(X_train, y_train.values.reshape(-<span class="number">1</span>, <span class="number">1</span>).astype(np.float32))</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Re-initializing module because the following parameters were re-set: module__ninput.</span><br><span class="line">Re-initializing criterion.</span><br><span class="line">Re-initializing optimizer.</span><br><span class="line">  epoch    train_loss    valid_loss     dur</span><br><span class="line">-------  ------------  ------------  ------</span><br><span class="line">      1     4280.8532     4388.5093  0.0188</span><br><span class="line">      2     4280.8443     4388.4990  0.0129</span><br><span class="line">      </span><br><span class="line">      ... (생략) ...</span><br><span class="line">      </span><br><span class="line">    998      295.5285      270.6504  0.0106</span><br><span class="line">    999      295.5276      270.6288  0.0153</span><br><span class="line">   1000      295.5247      270.6030  0.0102</span><br></pre></td></tr></table></figure></li></ul></li><li><p>validation set을 입력하지 않았음에도 valid_loss가 출력됩니다.</p></li><li><p><b>train data의 20%를 validation set으로 따로 떼어 놓기 때문입니다.</b></p></li><li><p><a href="https://jehyunlee.github.io/2022/06/09/Python-DL-8-skorch_callback/">맨 처음</a> 전체 데이터의 60%만 train set으로 지정했습니다.</p></li><li><p>여기서 다시 80%만 학습에 투입되었으니 <b>총 48%.</b> 반도 안되는 데이터로 학습한 셈입니다.</p></li><li><p><code>train_split=None</code>을 입력하면 모든 데이터를 다 학습에 투입하지만 validation 결과가 출력되지 않습니다.</p></li></ul><ul><li><p><b>learning curve</b>는 신경망에서 <b><code>.history</code></b> 속성을 추출해 확인할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">history = model[<span class="string">&quot;ml&quot;</span>].history</span><br><span class="line">train_loss = history[:, <span class="string">&quot;train_loss&quot;</span>]</span><br><span class="line">valid_loss = history[:, <span class="string">&quot;valid_loss&quot;</span>]</span><br><span class="line"></span><br><span class="line">plot_epoch(train_loss, valid_loss)</span><br></pre></td></tr></table></figure><p><img src="10_sc_03.png"><br></p></li><li><p>학습도 정상적으로 이루어졌습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot_parity3(model)</span><br></pre></td></tr></table></figure><p><img src="10_sc_04.png"><br></p></li></ul><h3 id="3-2-4-train-and-validate-predefined-validation-set"><a href="#3-2-4-train-and-validate-predefined-validation-set" class="headerlink" title="3.2.4. train and validate (predefined validation set)"></a>3.2.4. train and validate (predefined validation set)</h3><blockquote><p><a href="https://skorch.readthedocs.io/en/stable/dataset.html">skorch: skorch.dataset.Dataset</a></p></blockquote><ul><li><p>먼저 준비한 validation set을 사용하려면 <code>train_split</code>에 validation set을 입력합니다.</p></li><li><p>validation set은 skorch의 <a href="https://skorch.readthedocs.io/en/stable/dataset.html"><code>Dataset</code></a>을 사용해 만듭니다.</p></li><li><p>내친 김에 y data도 ML Pipeline에 만들기 좋은 형태, 즉 float32, (-1, 1) shape으로 변경해서 모아놓습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skorch.dataset <span class="keyword">import</span> Dataset</span><br><span class="line"></span><br><span class="line"><span class="comment"># ys (numpy)</span></span><br><span class="line">y_train_np = y_train.values.reshape(-<span class="number">1</span>, <span class="number">1</span>).astype(np.float32)</span><br><span class="line">y_val_np = y_val.values.reshape(-<span class="number">1</span>, <span class="number">1</span>).astype(np.float32)</span><br><span class="line">y_test_np = y_test.values.reshape(-<span class="number">1</span>, <span class="number">1</span>).astype(np.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># predefined validation set</span></span><br><span class="line">preprocessor = get_preprocessor()</span><br><span class="line">X_val_pp = preprocessor.fit(X_train).transform(X_val)</span><br><span class="line">valid_dataset = Dataset(X_val_pp, y_val_np)</span><br><span class="line"></span><br><span class="line"><span class="comment"># model training</span></span><br><span class="line">model = get_model(<span class="string">&quot;nn&quot;</span>, max_epochs=epochs, verbose=<span class="number">1</span>, criterion=RMSELoss, optimizer=optim.Adam, optimizer__lr = <span class="number">1e-3</span>,</span><br><span class="line">                  <span class="comment"># predefined validataion set</span></span><br><span class="line">                  train_split=predefined_split(valid_dataset))  </span><br><span class="line">model.fit(X_train, y_train_np)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Re-initializing module because the following parameters were re-set: module__ninput.</span><br><span class="line">Re-initializing criterion.</span><br><span class="line">Re-initializing optimizer.</span><br><span class="line">  epoch    train_loss    valid_loss     dur</span><br><span class="line">-------  ------------  ------------  ------</span><br><span class="line">      1     4302.1941     4250.5781  0.0160</span><br><span class="line">      2     4302.1851     4250.5693  0.0175</span><br><span class="line">      </span><br><span class="line">      ... (생략) ...</span><br><span class="line">      </span><br><span class="line">    998      280.9618      267.7317  0.0121</span><br><span class="line">    999      280.9596      267.7302  0.0122</span><br><span class="line">   1000      280.9580      267.7280  0.0141</span><br></pre></td></tr></table></figure></li></ul></li><li><p><b>learning curve</b>를 확인합니다.</p></li><li><p>여기서 얻은 learning curve를 reference로 사용하겠습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">history = model[<span class="string">&quot;ml&quot;</span>].history</span><br><span class="line">train_loss_0 = history[:, <span class="string">&quot;train_loss&quot;</span>]</span><br><span class="line">valid_loss_0 = history[:, <span class="string">&quot;valid_loss&quot;</span>]</span><br><span class="line"></span><br><span class="line">plot_epoch(train_loss_0, valid_loss_0)</span><br></pre></td></tr></table></figure><p><img src="10_sc_05.png"><br></p></li><li><p><b>parity plot</b>도 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot_parity3(model)</span><br></pre></td></tr></table></figure><p><img src="10_sc_06.png"><br></p></li></ul><h3 id="3-2-5-learning-rate-scheduler"><a href="#3-2-5-learning-rate-scheduler" class="headerlink" title="3.2.5. learning rate scheduler"></a>3.2.5. learning rate scheduler</h3><blockquote><p><a href="https://skorch.readthedocs.io/en/stable/user/callbacks.html#learning-rate-schedulers">skorch: Learning rate schedulers</a><br><a href="https://jehyunlee.github.io/2020/03/28/Python-DL-3-1cycle-learning-rate-policy/">Pega Devlog: Fast.ai의 fit_one_cycle 방법론 이해</a></p></blockquote><ul><li><p>callbacks에 learning late scheduler를 추가해 learning rate를 조정할 수 있습니다.</p></li><li><p>input dimension 조정을 위해 <b>callbacks 기본값으로 InputShapeSetter()가 들어가 있습니다.</b></p></li><li><p>이를 삭제하지 않도록 유의하면서 learning rate scheduler를 추가합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skorch.callbacks <span class="keyword">import</span> LRScheduler</span><br><span class="line"></span><br><span class="line">model = get_model(<span class="string">&quot;nn&quot;</span>, max_epochs=epochs, verbose=<span class="number">1</span>, criterion=RMSELoss, optimizer=optim.Adam, optimizer__lr = <span class="number">1e-3</span>,</span><br><span class="line">                  train_split=predefined_split(valid_dataset),               <span class="comment"># predefined validataion set                </span></span><br><span class="line">                  callbacks=[<span class="comment"># input dimension setter</span></span><br><span class="line">                             (<span class="string">&quot;input_shape_setter&quot;</span>, InputShapeSetter()),</span><br><span class="line">                             </span><br><span class="line">                             <span class="comment"># LR scheduler</span></span><br><span class="line">                             (<span class="string">&quot;lr_scheduler&quot;</span>, LRScheduler(policy=OneCycleLR, <span class="comment"># LR scheduler</span></span><br><span class="line">                                                         max_lr=<span class="number">0.1</span>,</span><br><span class="line">                                                         total_steps=epochs))])</span><br><span class="line">model.fit(X_train, y_train_np)</span><br></pre></td></tr></table></figure></li><li><p>학습 과정은 생략하고 learning curve를 비교해서 봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ax = plot_epoch(train_loss_0, valid_loss_0)</span><br><span class="line">lines = ax.lines</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    line.set_alpha(<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">history = model[<span class="string">&quot;ml&quot;</span>].history</span><br><span class="line">train_loss = history[:, <span class="string">&quot;train_loss&quot;</span>]</span><br><span class="line">valid_loss = history[:, <span class="string">&quot;valid_loss&quot;</span>]</span><br><span class="line"></span><br><span class="line">ax = plot_epoch(train_loss, valid_loss, ax=ax)</span><br><span class="line">handles, labels = ax.get_legend_handles_labels()</span><br><span class="line">ax.legend(handles=handles, labels=labels, ncol=<span class="number">2</span>, title=<span class="string">&quot;base      OneCycleLR&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="10_sc_07.png"><br></p></li><li><p>learning rate scheduler가 적용되어 학습 양상이 바뀌었습니다.</p></li><li><p>parity plot도 여전히 좋습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot_parity3(model)</span><br></pre></td></tr></table></figure><p><img src="10_sc_08.png"><br></p></li></ul><h3 id="3-2-6-early-stopping"><a href="#3-2-6-early-stopping" class="headerlink" title="3.2.6. early stopping"></a>3.2.6. early stopping</h3><blockquote><p><a href="https://skorch.readthedocs.io/en/stable/callbacks.html#skorch.callbacks.EarlyStopping">skorch: skorch.callbacks.EarlyStopping</a></p></blockquote><ul><li><p>불필요하게 학습을 길게 하는 경향을 줄이고자 early stopping을 적용합니다.</p></li><li><p><code>EarlyStopping()</code>을 callbacks에 추가하고 기준을 설정합니다.</p></li><li><p>valid_loss가 20번 줄어들지 않으면 학습을 중단하도록 <code>monitor=&quot;valid_loss&quot;</code>, <code>patience=20</code>을 설정했습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skorch.callbacks <span class="keyword">import</span> EarlyStopping</span><br><span class="line"></span><br><span class="line">model = get_model(<span class="string">&quot;nn&quot;</span>, max_epochs=epochs, verbose=<span class="number">1</span>, criterion=RMSELoss, optimizer=optim.Adam, optimizer__lr = <span class="number">1e-3</span>,</span><br><span class="line">                  train_split=predefined_split(valid_dataset),               <span class="comment"># predefined validataion set        </span></span><br><span class="line"></span><br><span class="line">                  callbacks=[<span class="comment"># input dimension setter</span></span><br><span class="line">                             (<span class="string">&quot;input_shape_setter&quot;</span>, InputShapeSetter()),</span><br><span class="line"></span><br><span class="line">                             <span class="comment"># LR scheduler</span></span><br><span class="line">                             (<span class="string">&quot;lr_scheduler&quot;</span>, LRScheduler(policy=OneCycleLR, </span><br><span class="line">                                                         max_lr=<span class="number">0.1</span>,</span><br><span class="line">                                                         total_steps=epochs)),</span><br><span class="line"></span><br><span class="line">                             <span class="comment"># early stopping</span></span><br><span class="line">                             (<span class="string">&quot;early_stopping&quot;</span>, EarlyStopping(monitor=<span class="string">&quot;valid_loss&quot;</span>,</span><br><span class="line">                                                              patience=<span class="number">20</span>))])</span><br><span class="line">model.fit(X_train, y_train.values.reshape(-<span class="number">1</span>, <span class="number">1</span>).astype(np.float32))</span><br></pre></td></tr></table></figure></li><li><p><b>learning curve</b>를 비교합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ax = plot_epoch(train_loss_0, valid_loss_0)</span><br><span class="line">lines = ax.lines</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    line.set_alpha(<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">history = model[<span class="string">&quot;ml&quot;</span>].history</span><br><span class="line">train_loss = history[:, <span class="string">&quot;train_loss&quot;</span>]</span><br><span class="line">valid_loss = history[:, <span class="string">&quot;valid_loss&quot;</span>]</span><br><span class="line"></span><br><span class="line">ax = plot_epoch(train_loss, valid_loss, ax=ax)</span><br><span class="line">handles, labels = ax.get_legend_handles_labels()</span><br><span class="line">ax.legend(handles=handles, labels=labels, ncol=<span class="number">2</span>, title=<span class="string">&quot;base      LRS+ES&quot;</span>)</span><br><span class="line">ax.set_xlim(<span class="number">0</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><p><img src="10_sc_09.png"><br></p></li><li><p>parity plot도 정상적입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot_parity3(model)</span><br></pre></td></tr></table></figure><p><img src="10_sc_10.png"><br></p></li></ul><h3 id="3-2-7-Saving-and-Loading-manual"><a href="#3-2-7-Saving-and-Loading-manual" class="headerlink" title="3.2.7. Saving and Loading (manual)"></a>3.2.7. Saving and Loading (manual)</h3><blockquote><p><a href="https://skorch.readthedocs.io/en/stable/user/save_load.html">skorch: Saving and Loading</a></p></blockquote><ul><li><p>모델 파라미터를 pickle 형식으로 저장하고 불러올 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># save parameters</span></span><br><span class="line">model[<span class="string">&quot;ml&quot;</span>].save_params(f_params=<span class="string">&quot;nn_params.pkl&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>모델을 새로 만들면 paramter를 불러오기 전에 초기화하는 과정이 필요합니다.</p></li><li><p><code>.initialize()</code>를 사용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># load parameters</span></span><br><span class="line">model_new = get_model(method=<span class="string">&quot;nn&quot;</span>)</span><br><span class="line">model_new[<span class="string">&quot;ml&quot;</span>].initialize()</span><br><span class="line">model_new[<span class="string">&quot;ml&quot;</span>].load_params(f_params=<span class="string">&quot;nn_params.pkl&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>새로 만든 모델에 parameter를 불러와서 적용합니다.</p></li><li><p>단, 신경망 parameter에만 해당하는 상황이므로 preprocessor는 기존 모델의 preprocessor를 사용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># check reproducibility</span></span><br><span class="line">y_pred_train = model_new[<span class="string">&quot;ml&quot;</span>].predict(model[<span class="string">&quot;preprocessor&quot;</span>].transform(X_train))</span><br><span class="line">y_pred_val = model_new[<span class="string">&quot;ml&quot;</span>].predict(model[<span class="string">&quot;preprocessor&quot;</span>].transform(X_val))</span><br><span class="line">y_pred_test = model_new[<span class="string">&quot;ml&quot;</span>].predict(model[<span class="string">&quot;preprocessor&quot;</span>].transform(X_test))</span><br><span class="line"></span><br><span class="line">plot_parity3(model_new, preds=[y_pred_train, y_pred_val, y_pred_test])</span><br></pre></td></tr></table></figure><p><img src="10_sc_11.png"></p></li><li><p>학습을 하지 않았음에도 parity plot이 똑같이 재현되었습니다.</p></li></ul><h3 id="3-2-8-Saving-and-Loading-callbacks"><a href="#3-2-8-Saving-and-Loading-callbacks" class="headerlink" title="3.2.8. Saving and Loading (callbacks)"></a>3.2.8. Saving and Loading (callbacks)</h3><blockquote><p><a href="https://skorch.readthedocs.io/en/stable/user/save_load.html#using-callbacks">skorch: Saving and Loading Using Callbacks</a></p></blockquote><ul><li><p>callback을 이용하면 valid loss가 줄어들때마다 저장할 수 있습니다.</p></li><li><p>valid loss가 줄어들때마다 저장하는 <code>cp</code>와 epoch마다 저장하는 <code>train_end_cp</code>를 동시에 지정합니다.</p></li><li><p><code>exp1</code> 폴더를 만들어 여기에 함께 저장하도록 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skorch.callbacks <span class="keyword">import</span> Checkpoint, TrainEndCheckpoint</span><br><span class="line"></span><br><span class="line"><span class="comment"># save the model parameters, optimizer, and history</span></span><br><span class="line">cp = Checkpoint(dirname=<span class="string">&#x27;exp1&#x27;</span>)</span><br><span class="line">train_end_cp = TrainEndCheckpoint(dirname=<span class="string">&#x27;exp1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">model = get_model(<span class="string">&quot;nn&quot;</span>, max_epochs=epochs, verbose=<span class="number">1</span>, criterion=RMSELoss, optimizer=optim.Adam, optimizer__lr = <span class="number">1e-3</span>,</span><br><span class="line">                  train_split=predefined_split(valid_dataset),                               </span><br><span class="line"></span><br><span class="line">                  callbacks=[<span class="comment"># input dimension setter</span></span><br><span class="line">                             (<span class="string">&quot;input_shape_setter&quot;</span>, InputShapeSetter()),</span><br><span class="line"></span><br><span class="line">                             <span class="comment"># LR scheduler</span></span><br><span class="line">                             (<span class="string">&quot;lr_scheduler&quot;</span>, LRScheduler(policy=OneCycleLR, </span><br><span class="line">                                                         max_lr=<span class="number">0.1</span>,</span><br><span class="line">                                                         total_steps=epochs)),</span><br><span class="line"></span><br><span class="line">                             <span class="comment"># early stopping</span></span><br><span class="line">                             (<span class="string">&quot;early_stopping&quot;</span>, EarlyStopping(monitor=<span class="string">&quot;valid_loss&quot;</span>,</span><br><span class="line">                                                              patience=<span class="number">20</span>)),</span><br><span class="line">                             </span><br><span class="line">                             <span class="comment"># Checkpoints</span></span><br><span class="line">                             (<span class="string">&quot;checkpoint&quot;</span>, cp),</span><br><span class="line">                             (<span class="string">&quot;train_end_checkpoint&quot;</span>, train_end_cp)</span><br><span class="line">                             ])</span><br><span class="line">model.fit(X_train, y_train.values.reshape(-<span class="number">1</span>, <span class="number">1</span>).astype(np.float32))</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Re-initializing module because the following parameters were re-set: module__ninput.</span><br><span class="line">Re-initializing criterion.</span><br><span class="line">Re-initializing optimizer.</span><br><span class="line">  epoch    train_loss    valid_loss    cp      lr     dur</span><br><span class="line">-------  ------------  ------------  ----  ------  ------</span><br><span class="line">      1     4301.9097     4250.2661     +  0.0040  0.0093</span><br><span class="line">      2     4301.8677     4250.2241     +  0.0040  0.0107</span><br><span class="line">      3     4301.8278     4250.1914     +  0.0040  0.0083</span><br><span class="line">      4     4301.7949     4250.1577     +  0.0040  0.0111</span><br><span class="line">      </span><br><span class="line">      ... (생략) ...</span><br><span class="line">      </span><br><span class="line">     96      294.3520      265.7108        0.0260  0.0112</span><br><span class="line">     97      296.6454      273.7495        0.0264  0.0098</span><br><span class="line">     98      290.3884      289.0570        0.0268  0.0071</span><br><span class="line">     99      289.6089      273.4566        0.0273  0.0093</span><br><span class="line">    100      284.6194      261.8893     +  0.0277  0.0092</span><br><span class="line">    101      290.8631      262.4448        0.0281  0.0107</span><br><span class="line">    102      289.3116      275.2869        0.0286  0.0077</span><br><span class="line">    103      286.5198      278.3972        0.0290  0.0075</span><br><span class="line">    104      283.5437      266.5125        0.0295  0.0106</span><br></pre></td></tr></table></figure></li></ul></li><li><p><b>cp</b>라는 열이 하나 생겼고, 여기 +가 붙은 곳들이 있습니다.</p></li><li><p>valid_loss가 기존 기록보다 작아진 지점입니다.</p></li></ul><ul><li><p>History도 파일에서 불러와서 그립니다.</p></li><li><p>부를 때는 <code>skorch.history.History</code>를 사용합니다.</p></li><li><p>세 개의 learning curve를 겹쳐 그리느라 코드가 다소 복잡해졌습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skorch.history <span class="keyword">import</span> History</span><br><span class="line"></span><br><span class="line"><span class="comment"># base plot</span></span><br><span class="line">ax = plot_epoch(train_loss_0, valid_loss_0)</span><br><span class="line">lines = ax.lines</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    line.set_alpha(<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># history</span></span><br><span class="line">history = History().from_file(<span class="string">&quot;./exp1/history.json&quot;</span>)</span><br><span class="line">train_loss = history[:, <span class="string">&quot;train_loss&quot;</span>]</span><br><span class="line">valid_loss = history[:, <span class="string">&quot;valid_loss&quot;</span>]</span><br><span class="line">ax = plot_epoch(train_loss, valid_loss, ax=ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># event_cp : cp == True</span></span><br><span class="line">epoch = history[:, <span class="string">&quot;epoch&quot;</span>]</span><br><span class="line">event_cp = history[:, <span class="string">&quot;event_cp&quot;</span>]</span><br><span class="line">df_cp = pd.DataFrame(&#123;<span class="string">&quot;epoch&quot;</span>:epoch, <span class="string">&quot;event_cp&quot;</span>:event_cp, <span class="string">&quot;train_loss&quot;</span>:train_loss, <span class="string">&quot;valid_loss&quot;</span>:valid_loss&#125;)</span><br><span class="line">df_cp = df_cp.loc[df_cp[<span class="string">&quot;event_cp&quot;</span>]==<span class="literal">True</span>]</span><br><span class="line"></span><br><span class="line">ax.scatter(df_cp[<span class="string">&quot;epoch&quot;</span>], df_cp[<span class="string">&quot;train_loss&quot;</span>], fc=c_train, alpha=<span class="number">0.5</span>, label=<span class="string">&quot;train_cp&quot;</span>)</span><br><span class="line">ax.scatter(df_cp[<span class="string">&quot;epoch&quot;</span>], df_cp[<span class="string">&quot;valid_loss&quot;</span>], fc=c_val, alpha=<span class="number">0.5</span>, label=<span class="string">&quot;valid_cp&quot;</span>)</span><br><span class="line"></span><br><span class="line">ax.legend(ncol=<span class="number">3</span>, title=<span class="string">&quot;base      LRS+ES           checkpoint&quot;</span>, loc=<span class="string">&quot;center right&quot;</span>)</span><br><span class="line">ax.set_xlim(<span class="number">0</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><p><img src="10_sc_12.png"><br></p></li><li><p>희미하게 그려진 것은 skorch에 validation set을 사용한 base line입니다.</p></li><li><p>그리고 Learning Rate Scheduler와 Early Stopping을 적용한 것을 LRS + ES로 표기했습니다.</p></li><li><p>앞에서와 같이 학습이 훨씬 빨리 끝났습니다.</p></li><li><p>그리고 이 중 <b>checkpoint가 적용된 것</b>을 scatter plot으로 표현했습니다.</p></li><li><p>one-cycle-fit의 영향으로 learning curve가 요동치는 와중에서도 train과 valid에서 단조 감소하는 모습만이 기록되었습니다.</p></li></ul><h3 id="3-2-9-valid-loss가-가장-적었던-checkpoint-불러서-learning-rate-낮추기"><a href="#3-2-9-valid-loss가-가장-적었던-checkpoint-불러서-learning-rate-낮추기" class="headerlink" title="3.2.9. valid loss가 가장 적었던 checkpoint 불러서 learning rate 낮추기"></a>3.2.9. valid loss가 가장 적었던 checkpoint 불러서 learning rate 낮추기</h3><blockquote><p><a href="https://skorch.readthedocs.io/en/stable/callbacks.html#skorch.callbacks.LoadInitState">skorch: skorch.callbacks.LoadInitState</a></p></blockquote><ul><li><p>각 checkpoint에서는 history 외에도 criterion, optimizer, parameter 등의 상태를 저장합니다.</p></li><li><p>Colab 왼쪽의 폴더 모양을 클릭해 저장한 파일을 확인하면 볼 수 있습니다.<br><br><img src="10_sc_13.png"><br></p></li><li><p>학습이 과하게 진행되어 overfitting이 되면 지나가버린 과거의 최적점이 아쉽습니다.</p></li><li><p>지나친 최적점을 불러와서 훨씬 낮은 learning rate로 살살 학습시키면 더 좋을 것 같습니다.</p></li></ul><ul><li>이 때 skorch에서 제공하는 <a href="https://skorch.readthedocs.io/en/stable/callbacks.html#skorch.callbacks.LoadInitState">LoadInitState</a>를 사용할 수 있습니다.</li><li><code>cp = Checkpoint()</code>로 저장된 위치를 지정하고,</li><li><code>load_state = LoadInitState(cp)</code>로 불러와 상태를 불러옵니다.</li><li>마지막으로 <code>callbacks</code>에 <code>cp</code>와 <code>load_state</code>를 추가합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skorch.callbacks <span class="keyword">import</span> LoadInitState</span><br><span class="line"></span><br><span class="line">cp = Checkpoint(dirname=<span class="string">&#x27;exp1&#x27;</span>)</span><br><span class="line">load_state = LoadInitState(cp)</span><br><span class="line"></span><br><span class="line">model = get_model(<span class="string">&quot;nn&quot;</span>, max_epochs=epochs, verbose=<span class="number">1</span>, criterion=RMSELoss, optimizer=optim.Adam, </span><br><span class="line">                  <span class="comment"># learning rate 조정</span></span><br><span class="line">                  optimizer__lr = <span class="number">1e-5</span>,</span><br><span class="line"></span><br><span class="line">                  <span class="comment"># predefined validataion set</span></span><br><span class="line">                  train_split=predefined_split(valid_dataset),                               </span><br><span class="line"></span><br><span class="line">                  callbacks=[<span class="comment"># input dimension setter</span></span><br><span class="line">                             (<span class="string">&quot;input_shape_setter&quot;</span>, InputShapeSetter()),</span><br><span class="line"></span><br><span class="line">                             <span class="comment"># early stopping</span></span><br><span class="line">                             (<span class="string">&quot;early_stopping&quot;</span>, EarlyStopping(monitor=<span class="string">&quot;valid_loss&quot;</span>,</span><br><span class="line">                                                              patience=<span class="number">100</span>)),</span><br><span class="line">                             </span><br><span class="line">                             <span class="comment"># Checkpoints</span></span><br><span class="line">                             (<span class="string">&quot;checkpoint&quot;</span>, cp),</span><br><span class="line">                             (<span class="string">&quot;load_initial_state&quot;</span>, load_state)</span><br><span class="line">                             ])</span><br><span class="line">model.fit(X_train, y_train.values.reshape(-<span class="number">1</span>, <span class="number">1</span>).astype(np.float32))</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-10-Saving-and-Loading-model-itself"><a href="#3-2-10-Saving-and-Loading-model-itself" class="headerlink" title="3.2.10. Saving and Loading (model itself)"></a>3.2.10. Saving and Loading (model itself)</h3><ul><li><p>모델 전체를 저장할 때는 pickle을 권장하고 있습니다.</p></li><li><p><code>pickle.dump()</code>와 <code>pickle.load()</code>를 사용해 모델을 읽고 씁니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># saving</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;skorch_dl.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    pickle.dump(model, f)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># loading</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;skorch_dl.pkl&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    model_pkl = pickle.load(f)</span><br></pre></td></tr></table></figure></li><li><p>저장한 모델을 불러오면서 이름을 model_pkl로 바꿨습니다.</p></li><li><p>이 모델의 parity plot을 그려서 잘 저장되었고 불러졌는지 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># check reproducibility</span></span><br><span class="line">plot_parity3(model=model_pkl)</span><br></pre></td></tr></table></figure><p><img src="10_sc_14.png"><br></p></li><li><p>추가 학습 없이도 원래의 성능이 확인되었습니다.</p></li></ul><h1 id="4-정리-skorch-ML-pipeline"><a href="#4-정리-skorch-ML-pipeline" class="headerlink" title="4. 정리 : skorch ML pipeline"></a>4. 정리 : skorch ML pipeline</h1><ul><li>이제까지 세 편의 글에 걸쳐 데이터를 정리한 후,</li><li><b>scikit-learn preprocessor</b>를 만들고,</li><li><b>PyTorch neural network</b>를 구축한 후,</li><li><b>skorch로 이들을 엮은 뒤 callbacks로 여러 옵션을 뿌렸습니다.</b></li></ul><ul><li>최종적으로 사용한 코드가 여기 저기 흩뿌려져 있어 활용이 어려울 듯도 싶습니다.</li><li>skorch ML pipeline 코드를 아래에 정리합니다.</li><li><b>목적은 Ctrl+C/V</b>와 약간의 수정으로 사용하는 것입니다.</li></ul><h2 id="4-1-skorch-ML-pipeline"><a href="#4-1-skorch-ML-pipeline" class="headerlink" title="4.1. skorch ML pipeline"></a>4.1. skorch ML pipeline</h2><ul><li><p>scikit-learn preprocessor</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># preprocessors</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> FunctionTransformer</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"></span><br><span class="line"><span class="comment"># pipeline</span></span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.compose <span class="keyword">import</span> ColumnTransformer</span><br><span class="line"><span class="keyword">from</span> sklearn.base <span class="keyword">import</span> BaseEstimator, TransformerMixin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Preprocessings for Categorical and Numerical features</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_concat</span>(<span class="params">cols_cat=cols_cat, cols_num=cols_num, degree=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="comment"># categorical features: one-hot encoding</span></span><br><span class="line">    cat_features = cols_cat</span><br><span class="line">    cat_transformer = OneHotEncoder(sparse=<span class="literal">False</span>, handle_unknown=<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># numerical features: standard scaling &amp; polynomial features</span></span><br><span class="line">    num_features = cols_num</span><br><span class="line">    num_transformer = Pipeline(steps=[(<span class="string">&quot;polynomial&quot;</span>, PolynomialFeatures(degree=degree)),</span><br><span class="line">                                      (<span class="string">&quot;scaler&quot;</span>, StandardScaler())])</span><br><span class="line">    </span><br><span class="line">    numcat = ColumnTransformer(transformers=[(<span class="string">&quot;categorical&quot;</span>, cat_transformer, cat_features),</span><br><span class="line">                                          (<span class="string">&quot;numerical&quot;</span>, num_transformer, num_features)])</span><br><span class="line">    <span class="keyword">return</span> numcat</span><br><span class="line"></span><br><span class="line"><span class="comment"># Float64 to Float32 for PyTorch</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FloatTransformer</span>(<span class="params">BaseEstimator, TransformerMixin</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span>(<span class="params">self, X, y=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.array(X, dtype=np.float32)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># preprocessing Pipeline</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_preprocessor</span>(<span class="params">cols_cat=cols_cat, cols_num=cols_num, degree=<span class="number">1</span></span>):</span></span><br><span class="line">    concat = get_concat(cols_cat=cols_cat, cols_num=cols_num, degree=degree)</span><br><span class="line">    ft = FloatTransformer()</span><br><span class="line"></span><br><span class="line">    pipeline= Pipeline(steps=[(<span class="string">&quot;concat&quot;</span>, concat), </span><br><span class="line">                              (<span class="string">&quot;float64to32&quot;</span>, ft)])</span><br><span class="line">    <span class="keyword">return</span> pipeline</span><br></pre></td></tr></table></figure></li><li><p>PyTorch Neural Network</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># neural network: ninput(12)-16-16-12-8-1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ninput=<span class="number">12</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.layer0 = nn.Linear(ninput, <span class="number">16</span>)</span><br><span class="line">        self.layer1 = nn.Linear(<span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">        self.layer2 = nn.Linear(<span class="number">16</span>, <span class="number">12</span>)</span><br><span class="line">        self.layer3 = nn.Linear(<span class="number">12</span>, <span class="number">8</span>)</span><br><span class="line">        self.layer4 = nn.Linear(<span class="number">8</span>, <span class="number">1</span>)</span><br><span class="line">        self.activation = nn.ReLU()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.activation(self.layer0(x))</span><br><span class="line">        x = self.activation(self.layer1(x))</span><br><span class="line">        x = self.activation(self.layer2(x))</span><br><span class="line">        x = self.activation(self.layer3(x))</span><br><span class="line">        x = self.layer4(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># loss: RMSE</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RMSELoss</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, eps=<span class="number">1e-6</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.mse = nn.MSELoss()</span><br><span class="line">        self.eps = eps</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, true, pred</span>):</span></span><br><span class="line">        loss = torch.sqrt(self.mse(true, pred) + self.eps)</span><br><span class="line">        <span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure></li><li><p>skorch ML Pipeline</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># machine learning models</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line"></span><br><span class="line"><span class="comment"># embedding pytorch model in scikit-learn Pipeline</span></span><br><span class="line"><span class="keyword">from</span> skorch <span class="keyword">import</span> NeuralNetRegressor</span><br><span class="line"><span class="keyword">from</span> skorch.helper <span class="keyword">import</span> predefined_split</span><br><span class="line"></span><br><span class="line"><span class="comment"># callbacks</span></span><br><span class="line"><span class="keyword">from</span> skorch.callbacks <span class="keyword">import</span> Callback</span><br><span class="line"><span class="keyword">from</span> skorch.callbacks <span class="keyword">import</span> LRScheduler</span><br><span class="line"><span class="keyword">from</span> skorch.callbacks <span class="keyword">import</span> EarlyStopping</span><br><span class="line"><span class="keyword">from</span> skorch.callbacks <span class="keyword">import</span> Checkpoint, TrainEndCheckpoint</span><br><span class="line"></span><br><span class="line"><span class="comment"># dynamic input size of the PyTorch module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputShapeSetter</span>(<span class="params">Callback</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_train_begin</span>(<span class="params">self, net, X, y</span>):</span></span><br><span class="line">        net.set_params(module__ninput=X.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># save the model parameters, optimizer, and history</span></span><br><span class="line">cp = Checkpoint(dirname=<span class="string">&#x27;exp_test&#x27;</span>)</span><br><span class="line">train_end_cp = TrainEndCheckpoint(dirname=<span class="string">&#x27;exp_test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># skorch ML pipeline</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_model</span>(<span class="params">method=<span class="string">&quot;lr&quot;</span>, device=device, cols_cat=cols_cat, cols_num=cols_num, degree=<span class="number">1</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">              callbacks=[(<span class="params"><span class="string">&quot;input_shape_setter&quot;</span>, InputShapeSetter(<span class="params"></span>)</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">                         (<span class="params"><span class="string">&quot;lr_scheduler&quot;</span>, LRScheduler(<span class="params">policy=OneCycleLR, max_lr=<span class="number">0.1</span>, total_steps=epochs</span>)</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">                         (<span class="params"><span class="string">&quot;early_stopping&quot;</span>, EarlyStopping(<span class="params">monitor=<span class="string">&quot;valid_loss&quot;</span>, patience=<span class="number">20</span></span>)</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">                         (<span class="params"><span class="string">&quot;checkpoint&quot;</span>, cp</span>), (<span class="params"><span class="string">&quot;train_end_checkpoint&quot;</span>, train_end_cp</span>)], </span></span></span><br><span class="line"><span class="params"><span class="function">              **kwargs</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">&quot;lr&quot;</span>:</span><br><span class="line">        ml = LinearRegression(fit_intercept=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&quot;rf&quot;</span>:</span><br><span class="line">        ml = RandomForestRegressor(random_state=rng)</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&quot;nn&quot;</span>:</span><br><span class="line">        ml = NeuralNetRegressor(Net(), device=device, callbacks=callbacks, **kwargs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;# &#x27;method&#x27; should be in [&#x27;lr&#x27;, &#x27;rf&#x27;, &#x27;nn&#x27;].&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    preprocessor = get_preprocessor(cols_cat=cols_cat, cols_num=cols_num, degree=degree)</span><br><span class="line">    model = Pipeline([(<span class="string">&quot;preprocessor&quot;</span>, preprocessor), </span><br><span class="line">                      (<span class="string">&quot;ml&quot;</span>, ml)])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-2-Visualizations"><a href="#4-2-Visualizations" class="headerlink" title="4.2. Visualizations"></a>4.2. Visualizations</h2><ul><li><p>learning curve</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_epoch</span>(<span class="params">history=<span class="literal">None</span>, loss_trains=<span class="literal">None</span>, loss_vals=<span class="literal">None</span>, ax=<span class="literal">None</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">any</span>([history, loss_trains]) == <span class="literal">False</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;# one of &#x27;history&#x27; and &#x27;loss_trains&#x27; has to be used!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ax</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ax == <span class="literal">None</span>:</span><br><span class="line">        fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> loss_trains == <span class="literal">None</span>:</span><br><span class="line">        loss_trains = history[:, <span class="string">&quot;train_loss&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> history != <span class="literal">None</span> <span class="keyword">and</span> loss_vals == <span class="literal">None</span>:</span><br><span class="line">        loss_vals = history[:, <span class="string">&quot;valid_loss&quot;</span>]</span><br><span class="line"></span><br><span class="line">    ax.plot(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(loss_trains)+<span class="number">1</span>)), loss_trains, c=c_train, label=<span class="string">&quot;train&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> loss_vals != <span class="literal">None</span>:</span><br><span class="line">        ax.plot(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(loss_vals)+<span class="number">1</span>)), loss_vals, c=c_val, label=<span class="string">&quot;valid&quot;</span>)</span><br><span class="line">    ax.grid(axis=<span class="string">&quot;y&quot;</span>)</span><br><span class="line">    ax.set_xlabel(<span class="string">&quot;epochs&quot;</span>, fontdict=font_label)</span><br><span class="line">    ax.legend()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ax</span><br></pre></td></tr></table></figure></li><li><p>parity plots</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_parity3</span>(<span class="params">model, target=[<span class="string">&quot;train&quot;</span>, <span class="string">&quot;val&quot;</span>, <span class="string">&quot;test&quot;</span>], figsize=(<span class="params"><span class="number">10</span>, <span class="number">4</span></span>),</span></span></span><br><span class="line"><span class="params"><span class="function">                 Xs=<span class="literal">None</span>, trues=<span class="literal">None</span>, preds=<span class="literal">None</span>, colors=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> Xs:</span><br><span class="line">        Xs = [<span class="built_in">eval</span>(<span class="string">f&quot;X_<span class="subst">&#123;t&#125;</span>&quot;</span>) <span class="keyword">for</span> t <span class="keyword">in</span> target]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> trues:</span><br><span class="line">        trues = [<span class="built_in">eval</span>(<span class="string">f&quot;y_<span class="subst">&#123;t&#125;</span>&quot;</span>) <span class="keyword">for</span> t <span class="keyword">in</span> target]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> preds:</span><br><span class="line">        preds = [model.predict(X) <span class="keyword">for</span> X <span class="keyword">in</span> Xs]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> colors:</span><br><span class="line">        colors = [<span class="built_in">eval</span>(<span class="string">f&quot;c_<span class="subst">&#123;t&#125;</span>&quot;</span>) <span class="keyword">for</span> t <span class="keyword">in</span> target]</span><br><span class="line"></span><br><span class="line">    fig, axs = plt.subplots(ncols=<span class="built_in">len</span>(target), figsize=figsize, constrained_layout=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> ax, true, pred, c, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, trues, preds, colors, titles):</span><br><span class="line">        plot_parity(true, pred, ax=ax, scatter_kws=&#123;<span class="string">&quot;fc&quot;</span>:c, <span class="string">&quot;ec&quot;</span>:c, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>&#125;, title=title)</span><br><span class="line">        <span class="keyword">if</span> ax != axs[<span class="number">0</span>]:</span><br><span class="line">            ax.set_ylabel(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-3-test-run"><a href="#4-3-test-run" class="headerlink" title="4.3. test run"></a>4.3. test run</h2><ul><li><p>정의한 함수들로 예제를 돌려봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># predefined validation set</span></span><br><span class="line">preprocessor = get_preprocessor()</span><br><span class="line">X_val_pp = preprocessor.fit(X_train).transform(X_val)</span><br><span class="line">valid_dataset = Dataset(X_val_pp, y_val_np)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ML pipeline preparation</span></span><br><span class="line">model_test = get_model(<span class="string">&quot;nn&quot;</span>, max_epochs=epochs, verbose=<span class="number">1</span>, criterion=RMSELoss, optimizer=optim.Adam, optimizer__lr = <span class="number">1e-3</span>,</span><br><span class="line">                       train_split=predefined_split(valid_dataset))</span><br><span class="line">model_test.fit(X_train, y_train_np)</span><br><span class="line"></span><br><span class="line"><span class="comment"># learning curve</span></span><br><span class="line">history = History().from_file(<span class="string">&quot;./exp_test/history.json&quot;</span>)</span><br><span class="line">ax = plot_epoch(history)</span><br><span class="line"></span><br><span class="line"><span class="comment"># parity plots</span></span><br><span class="line">plot_parity3(model_test)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Re-initializing module because the following parameters were re-set: module__ninput.</span><br><span class="line">Re-initializing criterion.</span><br><span class="line">Re-initializing optimizer.</span><br><span class="line">  epoch    train_loss    valid_loss    cp      lr     dur</span><br><span class="line">-------  ------------  ------------  ----  ------  ------</span><br><span class="line">      1     4301.9874     4250.3501     +  0.0040  0.0135</span><br><span class="line">      2     4301.9537     4250.3169     +  0.0040  0.0139</span><br><span class="line">      </span><br><span class="line">      ... (생략) ...</span><br><span class="line">      </span><br><span class="line">    110      283.9839      270.7625        0.0322  0.0108</span><br><span class="line">    111      282.3574      270.6689        0.0326  0.0145</span><br><span class="line">Stopping since valid_loss has not improved <span class="keyword">in</span> the last 20 epochs.</span><br></pre></td></tr></table></figure><img src="10_sc_15.png"><br><img src="10_sc_16.png"></li></ul></li><li><p><b>잘 돌아갑니다. :)</b></p></li><li><p>전체를 실행해볼 수 있는 코드는 여기 있습니다: <a href="https://bit.ly/3xxznt8">Notebook</a></p></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Deep-Learning/">Deep Learning</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/pytorch/">pytorch</category>
      
      <category domain="https://jehyunlee.github.io/tags/sklearn/">sklearn</category>
      
      <category domain="https://jehyunlee.github.io/tags/pipeline/">pipeline</category>
      
      <category domain="https://jehyunlee.github.io/tags/neural-network/">neural network</category>
      
      <category domain="https://jehyunlee.github.io/tags/callback/">callback</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      
    </item>
    
    <item>
      <title>skorch callbacks (2) sklearn preprocesing + PyTorch neural network</title>
      <link>https://jehyunlee.github.io/2022/06/09/Python-DL-9-skorch_callback2/</link>
      <guid>https://jehyunlee.github.io/2022/06/09/Python-DL-9-skorch_callback2/</guid>
      <pubDate>Thu, 09 Jun 2022 01:28:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;PyTorch는 현재 가장 인기있는 딥러닝 라이브러리 중 하나입니다.&lt;/li&gt;
&lt;li&gt;학습 세부 사항을 지정하기 위해 Callback으로 다양한 기능을 지원합니다.&lt;/li&gt;
&lt;li&gt;skorch는 PyTorch를 scikit-learn과</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>PyTorch는 현재 가장 인기있는 딥러닝 라이브러리 중 하나입니다.</li><li>학습 세부 사항을 지정하기 위해 Callback으로 다양한 기능을 지원합니다.</li><li>skorch는 PyTorch를 scikit-learn과 함께 사용할 수 있게 해 줍니다.</li><li>skorch도 PyTorch callback을 이용할 수 있습니다.</li></ul><ul><li>글이 길어 세 개로 나눕니다. </li><li>두 번째로, scikit-learn을 사용해 전처리 파이프라인을 구성하고</li><li>PyTorch neural network를 만들어 여기에서 나온 결과물을 학습시킵니다.</li></ul><h1 id="3-Neural-Network"><a href="#3-Neural-Network" class="headerlink" title="3. Neural Network"></a>3. Neural Network</h1><h2 id="3-1-PyTorch"><a href="#3-1-PyTorch" class="headerlink" title="3.1. PyTorch"></a>3.1. PyTorch</h2><blockquote><p><a href="https://bit.ly/3xxznt8">Colab code: skorch callbacks</a></p></blockquote><h3 id="3-1-1-network-and-loss"><a href="#3-1-1-network-and-loss" class="headerlink" title="3.1.1. network and loss"></a>3.1.1. network and loss</h3><blockquote><p><a href="http://alexlenail.me/NN-SVG/index.html">NN-SVG</a></p></blockquote><ul><li>skorch는 scikit-learn Pipeline 안에 PyTorch Neural Network를 담을 수 있게 해줍니다.</li><li>input node 수를 가변적으로 입력받을 수 있는, input-16-16-12-8-1 구조를 설계합니다.</li><li>loss function은 RMSE를 만들어 사용합니다.</li><li>PyTorch에서 MSE를 제공하긴 하지만, 오차의 범위가 직관적으로 보이는 RMSE를 더 선호합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neural network: ninput(12)-16-16-12-8-1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ninput=<span class="number">12</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.layer0 = nn.Linear(ninput, <span class="number">16</span>)</span><br><span class="line">        self.layer1 = nn.Linear(<span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">        self.layer2 = nn.Linear(<span class="number">16</span>, <span class="number">12</span>)</span><br><span class="line">        self.layer3 = nn.Linear(<span class="number">12</span>, <span class="number">8</span>)</span><br><span class="line">        self.layer4 = nn.Linear(<span class="number">8</span>, <span class="number">1</span>)</span><br><span class="line">        self.activation = nn.ReLU()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.activation(self.layer0(x))</span><br><span class="line">        x = self.activation(self.layer1(x))</span><br><span class="line">        x = self.activation(self.layer2(x))</span><br><span class="line">        x = self.activation(self.layer3(x))</span><br><span class="line">        x = self.layer4(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># loss: RMSE</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RMSELoss</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, eps=<span class="number">1e-6</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.mse = nn.MSELoss()</span><br><span class="line">        self.eps = eps</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, true, pred</span>):</span></span><br><span class="line">        loss = torch.sqrt(self.mse(true, pred) + self.eps)</span><br><span class="line">        <span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure><img src="9_sc_01.png" alt="이런 신경망을 만들 준비가 됐습니다. 그림은 NN-SVG로 그렸습니다."></li></ul><h3 id="3-1-2-preprocessor-using-Pipeline"><a href="#3-1-2-preprocessor-using-Pipeline" class="headerlink" title="3.1.2. preprocessor using Pipeline"></a>3.1.2. preprocessor using Pipeline</h3><blockquote><p><a href="https://jehyunlee.github.io/2021/09/29/Python-DL-7-skorch_pipeline/">Pega Devlog: pytorch &amp; sklearn pipeline</a><br><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html">scikit-learn: sklearn.preprocessing.OneHotEncoder</a><br><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.PolynomialFeatures.html">scikit-learn: sklearn.preprocessing.PolynomialFeatures</a><br><a href="https://scikit-learn.org/stable/modules/generated/sklearn.compose.ColumnTransformer.html">scikit-learn: sklearn.compose.ColumnTransformer</a></p></blockquote><ul><li>펭귄 데이터셋에는 <b>categorical feature</b>가 세 개나 있습니다.</li><li><code>species</code>, <code>island</code>, <code>sex</code>에는 숫자가 아닌 문자가 들어있기 때문에 신경망에 투입될 수 없습니다.</li><li>여러 방법을 사용해 숫자로 바꿔주어야 합니다. 여기서는 one-hot-encoder를 사용하기로 합니다.</li></ul><ul><li>한편 <b>numerical feature</b>는 scaling이 필요합니다. </li><li>신경망의 weight를 수렴시키는 gradient descent를 안정적으로 만들기 위해서입니다.</li><li>관련해서는 <a href="https://jehyunlee.github.io/2021/09/29/Python-DL-7-skorch_pipeline/">지난 글</a>에서 언급한 적이 있으니 여기서는 생략합니다.</li><li>다만, <b><a href="https://jehyunlee.github.io/2021/09/29/Python-DL-7-skorch_pipeline/">지난 글</a>보다 파이프라인을 분할해서 구성합니다.</b></li><li>부품이 잘 준비돼있으면 활용성이 높아지기 때문입니다.</li></ul><ul><li><p>categorical feature와 numerical feature에 각기 one-hot-encoding과 scaling을 적용해 합칩니다.</p></li><li><p>numerical feature에는 polymomial feature 생성기를 붙여 교호작용을 고려할 수 있는 장치를 만듭니다.</p></li><li><p>feature 유형에 따라 다른 길을 타고 들어간 데이터는 <code>ColumnTransformer</code>로 결합됩니다.</p></li><li><p>마지막으로, float64 데이터 타입으로 float32로 변환하는 <code>FloatTransformer</code>를 추가합니다.</p></li><li><p><code>OneHotEncoder</code>등에서 생성되는 데이터 타입이 float64인데, PyTorch은 float32만 입력받기 때문입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># preprocessors</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> FunctionTransformer</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"></span><br><span class="line"><span class="comment"># pipeline</span></span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.compose <span class="keyword">import</span> ColumnTransformer</span><br><span class="line"><span class="keyword">from</span> sklearn.base <span class="keyword">import</span> BaseEstimator, TransformerMixin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Preprocessings for Categorical and Numerical features</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_concat</span>(<span class="params">cols_cat=cols_cat, cols_num=cols_num, degree=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="comment"># categorical features: one-hot encoding</span></span><br><span class="line">    cat_features = cols_cat</span><br><span class="line">    cat_transformer = OneHotEncoder(sparse=<span class="literal">False</span>, handle_unknown=<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># numerical features: standard scaling &amp; polynomial features</span></span><br><span class="line">    num_features = cols_num</span><br><span class="line">    num_transformer = Pipeline(steps=[(<span class="string">&quot;polynomial&quot;</span>, PolynomialFeatures(degree=degree)),</span><br><span class="line">                                      (<span class="string">&quot;scaler&quot;</span>, StandardScaler())])</span><br><span class="line">    </span><br><span class="line">    numcat = ColumnTransformer(transformers=[(<span class="string">&quot;categorical&quot;</span>, cat_transformer, cat_features),</span><br><span class="line">                                          (<span class="string">&quot;numerical&quot;</span>, num_transformer, num_features)])</span><br><span class="line">    <span class="keyword">return</span> numcat</span><br><span class="line"></span><br><span class="line"><span class="comment"># Float64 to Float32 for PyTorch</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FloatTransformer</span>(<span class="params">BaseEstimator, TransformerMixin</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span>(<span class="params">self, X, y=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.array(X, dtype=np.float32)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># preprocessing Pipeline</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_preprocessor</span>(<span class="params">cols_cat=cols_cat, cols_num=cols_num, degree=<span class="number">1</span></span>):</span></span><br><span class="line">    concat = get_concat(cols_cat=cols_cat, cols_num=cols_num, degree=degree)</span><br><span class="line">    ft = FloatTransformer()</span><br><span class="line"></span><br><span class="line">    pipeline= Pipeline(steps=[(<span class="string">&quot;concat&quot;</span>, concat), </span><br><span class="line">                              (<span class="string">&quot;float64to32&quot;</span>, ft)])</span><br><span class="line">    <span class="keyword">return</span> pipeline</span><br></pre></td></tr></table></figure></li><li><p>작성한 전처리 파이프라인을 그림으로 출력해 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> set_config</span><br><span class="line">set_config(display=<span class="string">&#x27;diagram&#x27;</span>)</span><br><span class="line"></span><br><span class="line">preprocessor = get_preprocessor()</span><br><span class="line">preprocessor</span><br></pre></td></tr></table></figure><p><img src="9_sc_02.png"><br></p></li><li><p>preprocessor에 train, validation, test용으로 준비한 X 데이터를 투입합니다.</p></li><li><p>preprocessor를 통한 데이터는 <code>numpy.ndarray</code>로 변합니다.</p></li><li><p>PyTorch에 넣기 위해 <code>torch.Tensor</code>로 한번 더 바꿔줍니다.</p></li><li><p>y 데이터는 preprocessor에 넣을 필요가 없으니 <code>torch.Tensor()</code>에만 통과시킵니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Xs</span></span><br><span class="line">X_train_np = preprocessor.fit_transform(X_train)</span><br><span class="line">X_val_np = preprocessor.transform(X_val)</span><br><span class="line">X_test_np = preprocessor.transform(X_test)</span><br><span class="line"></span><br><span class="line">X_train_tensor = torch.Tensor(X_train_np).to(device)</span><br><span class="line">X_val_tensor = torch.Tensor(X_val_np).to(device)</span><br><span class="line">X_test_tensor = torch.Tensor(X_test_np).to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ys</span></span><br><span class="line">y_train_tensor = torch.Tensor(y_train.values).to(device)</span><br><span class="line">y_val_tensor = torch.Tensor(y_val.values).to(device)</span><br><span class="line">y_test_tensor = torch.Tensor(y_test.values).to(device)</span><br></pre></td></tr></table></figure></li><li><p>변환된 데이터의 타입을 확인합니다.</p></li><li><p>preprocessing후, 그리고 <code>torch.Tensor()</code>를 거치며 변하는 모습이 관찰됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Xs</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# dtype of X_train:\t\t<span class="subst">&#123;X_train.dtypes.values&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# dtype of X_train_np:\t\t<span class="subst">&#123;X_train_np.dtype&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# dtype of X_train_tensor:\t<span class="subst">&#123;X_train_tensor.dtype&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ys</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# dtype of y_train:\t\t<span class="subst">&#123;y_train.dtype&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# dtype of y_train_tensor:\t<span class="subst">&#123;y_train_tensor.dtype&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dtype of X_train:[dtype(&#x27;O&#x27;) dtype(&#x27;O&#x27;) dtype(&#x27;float64&#x27;) dtype(&#x27;float64&#x27;) dtype(&#x27;float64&#x27;) dtype(&#x27;O&#x27;)]</span></span><br><span class="line"><span class="comment"># dtype of X_train_np:float32</span></span><br><span class="line"><span class="comment"># dtype of X_train_tensor:torch.float32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dtype of y_train:float64</span></span><br><span class="line"><span class="comment"># dtype of y_train_tensor:torch.float32</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-1-3-training-amp-validation"><a href="#3-1-3-training-amp-validation" class="headerlink" title="3.1.3. training &amp; validation"></a>3.1.3. training &amp; validation</h3><ul><li>neural network와 preprocessor가 준비됐습니다.</li><li>loss_function, optimizer, 최대 epochs를 지정하고,</li><li>한편으로 leanring rate scheduler와 early stopping도 동원합니다.</li><li>train과 validation 함수와 함께 epoch에 따른 loss를 시각화하는 함수도 준비합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.optim.lr_scheduler <span class="keyword">import</span> OneCycleLR</span><br><span class="line"></span><br><span class="line">net = Net().to(device)                      <span class="comment"># Neural Network 생성</span></span><br><span class="line">loss_fn = RMSELoss()                        <span class="comment"># loss function 지정</span></span><br><span class="line">optimizer = optim.Adam(net.parameters(), </span><br><span class="line">                       lr=<span class="number">1e-3</span>)             <span class="comment"># learning rate = 0.001</span></span><br><span class="line">epochs = <span class="number">1000</span>                               <span class="comment"># number of max. epochs</span></span><br><span class="line">onecycle = OneCycleLR(optimizer,            <span class="comment"># learning rate scheduler</span></span><br><span class="line">                     max_lr=<span class="number">0.1</span>, total_steps=epochs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">device, model, epochs, loss_fn, optimizer, X_train, y_train, X_val=<span class="literal">None</span>, y_val=<span class="literal">None</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">          lr_scheduler=<span class="literal">None</span>, early_stopping=<span class="number">1</span>, patience=<span class="number">3</span>, plot=<span class="literal">True</span></span>):</span></span><br><span class="line">    loss_trains = []                            <span class="comment"># train loss </span></span><br><span class="line">    loss_vals = []                              <span class="comment"># validation loss</span></span><br><span class="line">    loss_last = np.inf</span><br><span class="line">    patience_ = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    val = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> X_val != <span class="literal">None</span> <span class="keyword">and</span> y_val != <span class="literal">None</span>:</span><br><span class="line">        val = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(epochs)):</span><br><span class="line">        model.train()                           <span class="comment"># sets the model in training mode</span></span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()                   <span class="comment"># gradient reset</span></span><br><span class="line">        y_pred = model.forward(X_train_tensor)  <span class="comment"># forward propagation</span></span><br><span class="line">        loss_ = loss_fn(y_pred, y_train_tensor.view(-<span class="number">1</span>, <span class="number">1</span>)) <span class="comment"># loss 계산</span></span><br><span class="line">        loss_.backward()                        <span class="comment"># back propagation</span></span><br><span class="line">        optimizer.step()                        <span class="comment"># weight update</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> lr_scheduler:</span><br><span class="line">            lr_scheduler.step()                 <span class="comment"># learning rate scheduler</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        loss = loss_.item()</span><br><span class="line">        loss_trains.append(loss)                <span class="comment"># collect train loss</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># progress message</span></span><br><span class="line">        prog_msg = <span class="string">f&quot;[<span class="subst">&#123;epoch&#125;</span>/<span class="subst">&#123;epochs&#125;</span>] train_loss: <span class="subst">&#123;loss&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># validation</span></span><br><span class="line">        <span class="keyword">if</span> val == <span class="literal">True</span>:</span><br><span class="line">            loss = validate(device, model, loss_fn, X_val, y_val)</span><br><span class="line">            loss_vals.append(loss)          <span class="comment"># collect validation loss</span></span><br><span class="line">            prog_msg += <span class="string">f&quot;,  valid_loss: <span class="subst">&#123;loss&#125;</span>&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> epoch % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(prog_msg)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># early stopping : patience회 이상 loss_val이 감소하지 않을 때</span></span><br><span class="line">        <span class="keyword">if</span> early_stopping &gt; <span class="number">0</span> <span class="keyword">and</span> (loss &gt; loss_last):</span><br><span class="line">            patience_ += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> patience_ &gt;= patience:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;early stopping: <span class="subst">&#123;loss_last&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        loss_last = loss</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> plot:</span><br><span class="line">        <span class="keyword">if</span> val:</span><br><span class="line">            plot_epoch(loss_trains, loss_vals)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            plot_epoch(loss_trains)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate</span>(<span class="params">device, model, loss_fn, X_val, y_val</span>):</span></span><br><span class="line">    model.<span class="built_in">eval</span>()                            <span class="comment"># sets the model in evaluating mode</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():                   <span class="comment"># gradient 계산 없이 진행</span></span><br><span class="line">        y_pred = net.forward(X_val)         <span class="comment"># forward propagation</span></span><br><span class="line">        loss = loss_fn(y_pred, y_val.view(-<span class="number">1</span>, <span class="number">1</span>))       <span class="comment"># loss 계산</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> loss.item()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_epoch</span>(<span class="params">loss_trains, loss_vals=<span class="literal">None</span>, ax=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> ax == <span class="literal">None</span>:</span><br><span class="line">        fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">        </span><br><span class="line">    ax.plot(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(loss_trains)+<span class="number">1</span>)), loss_trains, c=c_train, label=<span class="string">&quot;train&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> loss_vals != <span class="literal">None</span>:</span><br><span class="line">        ax.plot(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(loss_vals)+<span class="number">1</span>)), loss_vals, c=c_val, label=<span class="string">&quot;valid&quot;</span>)</span><br><span class="line">    ax.grid(axis=<span class="string">&quot;y&quot;</span>)</span><br><span class="line">    ax.set_xlabel(<span class="string">&quot;epochs&quot;</span>, fontdict=font_label)</span><br><span class="line">    ax.legend()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ax</span><br><span class="line"></span><br><span class="line">net = train(device, net, epochs, loss_fn, optimizer, X_train_tensor, y_train_tensor, X_val_tensor, y_val_tensor,</span><br><span class="line">            lr_scheduler=<span class="literal">None</span>, early_stopping=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">100% ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 1000/1000 [00:04&lt;00:00, 222.90it/s]</span><br><span class="line">[0/1000] train_loss: 4303.2822265625,  valid_loss: 4250.70068359375</span><br><span class="line">[100/1000] train_loss: 3756.332763671875,  valid_loss: 3660.7578125</span><br><span class="line">[200/1000] train_loss: 361.5039367675781,  valid_loss: 295.07098388671875</span><br><span class="line">[300/1000] train_loss: 289.6954650878906,  valid_loss: 275.11474609375</span><br><span class="line">[400/1000] train_loss: 282.8603210449219,  valid_loss: 271.21929931640625</span><br><span class="line">[500/1000] train_loss: 280.0774230957031,  valid_loss: 271.82470703125</span><br><span class="line">[600/1000] train_loss: 278.8686828613281,  valid_loss: 272.6382141113281</span><br><span class="line">[700/1000] train_loss: 278.05108642578125,  valid_loss: 273.4883728027344</span><br><span class="line">[800/1000] train_loss: 276.9803466796875,  valid_loss: 275.0303039550781</span><br><span class="line">[900/1000] train_loss: 276.1494140625,  valid_loss: 275.9771728515625</span><br></pre></td></tr></table></figure><img src="9_sc_03.png"><br></li></ul></li></ul><h3 id="3-1-4-parity-plot"><a href="#3-1-4-parity-plot" class="headerlink" title="3.1.4. parity plot"></a>3.1.4. parity plot</h3><ul><li>training, valiation, testing set의 학습 결과를 비교하는 함수를 만듭니다.</li><li>참값(<code>true</code>)과 예측값(<code>pred</code>)을 scatter plot으로 그립니다.</li><li>여기에 MAE, RMSE, R2를 동시에 출력하는 함수를 만듭니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.colors <span class="keyword">as</span> colors</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_absolute_error</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_metrics</span>(<span class="params">true, pred</span>):</span></span><br><span class="line">    mae = mean_absolute_error(true, pred)</span><br><span class="line">    rmse = mean_squared_error(true, pred, squared=<span class="literal">False</span>)</span><br><span class="line">    r2 = r2_score(true, pred)</span><br><span class="line">    <span class="keyword">return</span> mae, rmse, r2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_parity</span>(<span class="params">true, pred, kind=<span class="string">&quot;scatter&quot;</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                xlabel=<span class="string">&quot;true&quot;</span>, ylabel=<span class="string">&quot;predict&quot;</span>, title=<span class="string">&quot;&quot;</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                hist2d_kws=<span class="literal">None</span>, scatter_kws=<span class="literal">None</span>, kde_kws=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                equal=<span class="literal">True</span>, metrics=<span class="literal">True</span>, metrics_position=<span class="string">&quot;lower right&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                figsize=(<span class="params"><span class="number">5</span>, <span class="number">5</span></span>), ax=<span class="literal">None</span>, filename=<span class="literal">None</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    fig = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ax:</span><br><span class="line">        fig, ax = plt.subplots(figsize=figsize, constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># data range</span></span><br><span class="line">    val_min = <span class="built_in">min</span>(true.<span class="built_in">min</span>(), pred.<span class="built_in">min</span>())</span><br><span class="line">    val_max = <span class="built_in">max</span>(true.<span class="built_in">max</span>(), pred.<span class="built_in">max</span>())</span><br><span class="line">    data_range = val_max - val_min</span><br><span class="line"></span><br><span class="line">    <span class="comment"># data plot</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;scatter&quot;</span> <span class="keyword">in</span> kind:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> scatter_kws:</span><br><span class="line">            scatter_kws=&#123;<span class="string">&#x27;color&#x27;</span>:<span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;alpha&#x27;</span>:<span class="number">0.5</span>&#125;</span><br><span class="line">        ax.scatter(true, pred, **scatter_kws)</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&quot;hist2d&quot;</span> <span class="keyword">in</span> kind:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hist2d_kws:</span><br><span class="line">            hist2d_kws=&#123;<span class="string">&#x27;cmap&#x27;</span>:<span class="string">&#x27;Greens&#x27;</span>, <span class="string">&#x27;vmin&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;bins&#x27;</span>:<span class="number">30</span>&#125;</span><br><span class="line">        ax.hist2d(true, pred, **hist2d_kws)</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&quot;kde&quot;</span> <span class="keyword">in</span> kind:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> kde_kws:</span><br><span class="line">            kde_kws=&#123;<span class="string">&#x27;cmap&#x27;</span>:<span class="string">&#x27;viridis&#x27;</span>, <span class="string">&#x27;levels&#x27;</span>:<span class="number">5</span>&#125;</span><br><span class="line">        sns.kdeplot(x=true, y=pred, **kde_kws, ax=ax)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># x, y bounds</span></span><br><span class="line">    bounds = (val_min - data_range*<span class="number">0.1</span>, val_max + data_range*<span class="number">0.1</span>)</span><br><span class="line">    ax.set_xlim(bounds)</span><br><span class="line">    ax.set_ylim(bounds)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># x, y ticks, ticklabels</span></span><br><span class="line">    ticks = [<span class="built_in">int</span>(y) <span class="keyword">for</span> y <span class="keyword">in</span> ax.get_yticks() <span class="keyword">if</span> ((<span class="number">100</span>*y)%<span class="number">100</span> == <span class="number">0</span>) <span class="keyword">and</span> (val_min &lt;= y &lt;= val_max)]</span><br><span class="line">    ax.set_xticks(ticks, ticks)</span><br><span class="line">    ax.set_yticks(ticks, ticks)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># grid</span></span><br><span class="line">    ax.grid(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 기준선</span></span><br><span class="line">    ax.plot(bounds, bounds, c=<span class="string">&quot;k&quot;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># x, y label</span></span><br><span class="line">    font_label = &#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>&#125;</span><br><span class="line">    ax.set_xlabel(xlabel, fontdict=font_label, labelpad=<span class="number">12</span>)</span><br><span class="line">    ax.set_ylabel(ylabel, fontdict=font_label, labelpad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># title</span></span><br><span class="line">    font_title = &#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;gray&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;</span><br><span class="line">    ax.set_title(title, fontdict=font_title, pad=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># metrics</span></span><br><span class="line">    <span class="keyword">if</span> metrics:</span><br><span class="line">        rmse = mean_squared_error(true, pred, squared=<span class="literal">False</span>)</span><br><span class="line">        mae = mean_absolute_error(true, pred)</span><br><span class="line">        r2 = r2_score(true, pred)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> metrics_position == <span class="string">&quot;lower right&quot;</span>:</span><br><span class="line">            text_pos_x = <span class="number">0.98</span></span><br><span class="line">            text_pos_y = <span class="number">0.3</span></span><br><span class="line">            ha = <span class="string">&quot;right&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> metrics_position == <span class="string">&quot;upper left&quot;</span>:</span><br><span class="line">            text_pos_x = <span class="number">0.1</span></span><br><span class="line">            text_pos_y = <span class="number">0.9</span></span><br><span class="line">            ha = <span class="string">&quot;left&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            text_pos_x, text_pos_y = metrics_position</span><br><span class="line">            ha = <span class="string">&quot;left&quot;</span></span><br><span class="line"></span><br><span class="line">        ax.text(text_pos_x, text_pos_y, <span class="string">f&quot;RMSE = <span class="subst">&#123;rmse:<span class="number">.3</span>f&#125;</span>&quot;</span>, </span><br><span class="line">                transform=ax.transAxes, fontdict=font_metrics, ha=ha)</span><br><span class="line">        ax.text(text_pos_x, text_pos_y-<span class="number">0.1</span>, <span class="string">f&quot;MAE = <span class="subst">&#123;mae:<span class="number">.3</span>f&#125;</span>&quot;</span>, </span><br><span class="line">                transform=ax.transAxes, fontdict=font_metrics, ha=ha)</span><br><span class="line">        ax.text(text_pos_x, text_pos_y-<span class="number">0.2</span>, <span class="string">f&quot;R2 = <span class="subst">&#123;r2:<span class="number">.3</span>f&#125;</span>&quot;</span>, </span><br><span class="line">                transform=ax.transAxes, fontdict=font_metrics, ha=ha)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 파일로 저장</span></span><br><span class="line">    <span class="keyword">if</span> fig <span class="keyword">and</span> filename:</span><br><span class="line">            fig.savefig(filename)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ax</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-1-5-testing"><a href="#3-1-5-testing" class="headerlink" title="3.1.5. testing"></a>3.1.5. testing</h3><ul><li><p>training set으로 신경망을 학습시키고,</p></li><li><p>validation set으로 학습 현황을 모니터링하며</p></li><li><p>validation set의 성능이 마음에 들지 않을 경우 신경망의 구조나 learning rate와 같은 hyperparameter를 수정하여 성능을 높입니다.</p></li><li><p>이 과정을 거쳤다고 치고, training + validataion set으로 재학습을 시킨 후 testing data로 최종 결과를 얻습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># evaluate training and validataion set</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    y_pred_train = net.forward(X_train_tensor).cpu().numpy().flatten()</span><br><span class="line">    y_pred_val = net.forward(X_val_tensor).cpu().numpy().flatten()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># hyperparameter 업데이트 했다고 치고, training + validataion set으로 refit</span></span><br><span class="line">X_Train_pp = preprocessor.fit_transform(X_Train)</span><br><span class="line">X_Train_tensor = torch.Tensor(X_Train_pp).to(device)</span><br><span class="line">y_Train_tensor = torch.Tensor(y_Train).to(device)</span><br><span class="line"></span><br><span class="line">net = Net().to(device)</span><br><span class="line">loss_fn = RMSELoss()                        <span class="comment"># loss function 지정</span></span><br><span class="line">optimizer = optim.Adam(net.parameters(), </span><br><span class="line">                       lr=<span class="number">1e-3</span>)             <span class="comment"># learning rate = 0.001</span></span><br><span class="line">epochs = <span class="number">1000</span></span><br><span class="line">net = train(device, net, epochs, loss_fn, optimizer, X_Train_tensor, y_Train_tensor, X_val_tensor, y_val_tensor, early_stopping=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">100% ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 1000/1000 [00:04&lt;00:00, 270.43it/s]</span><br><span class="line">[0/1000] train_loss: 4303.0849609375,  valid_loss: 4250.50732421875</span><br><span class="line">[100/1000] train_loss: 4298.97021484375,  valid_loss: 4246.09326171875</span><br><span class="line">[200/1000] train_loss: 3950.37841796875,  valid_loss: 3884.753173828125</span><br><span class="line">[300/1000] train_loss: 606.517822265625,  valid_loss: 669.4122924804688</span><br><span class="line">[400/1000] train_loss: 320.8173828125,  valid_loss: 296.9498291015625</span><br><span class="line">[500/1000] train_loss: 306.0234069824219,  valid_loss: 281.5106506347656</span><br><span class="line">[600/1000] train_loss: 299.0507507324219,  valid_loss: 276.0859375</span><br><span class="line">[700/1000] train_loss: 294.1066589355469,  valid_loss: 272.7406921386719</span><br><span class="line">[800/1000] train_loss: 290.13287353515625,  valid_loss: 270.5881652832031</span><br><span class="line">[900/1000] train_loss: 287.00494384765625,  valid_loss: 269.0577697753906</span><br></pre></td></tr></table></figure><img src="9_sc_04.png"><br></li></ul></li><li><p>testing 결과까지 얻은 후, 최종적으로 parity plot 세 개를 같이 그립니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># evaluate testing set</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    y_pred_test = net.forward(X_test_tensor).cpu().numpy().flatten()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># parity plots</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">trues = [y_train, y_val, y_test]</span><br><span class="line">preds = [y_pred_train, y_pred_val, y_pred_test]</span><br><span class="line">colors = [c_train, c_val, c_test]</span><br><span class="line">titles = [<span class="string">&quot;train&quot;</span>, <span class="string">&quot;validation&quot;</span>, <span class="string">&quot;test&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> ax, true, pred, c, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, trues, preds, colors, titles):</span><br><span class="line">    plot_parity(true, pred, ax=ax, scatter_kws=&#123;<span class="string">&quot;fc&quot;</span>:c, <span class="string">&quot;ec&quot;</span>:c, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>&#125;, title=title)</span><br><span class="line">    <span class="keyword">if</span> ax != axs[<span class="number">0</span>]:</span><br><span class="line">        ax.set_ylabel(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="9_sc_05.png"><br></p></li><li><p>펭귄 체중이 제법 괜찮게 예측되고 있습니다.</p></li><li><p>scikit-learn Pipeline으로 categorical feature와 numerial feature에 적절한 처리를 마친 후, </p></li><li><p>PyTorch로 딥러닝 학습을 잘 시킨 것입니다.</p></li></ul><ul><li>Pipeline으로 전처리 과정을 모두 묶었고, PyTorch 딥러닝을 함수화 했습니다.</li><li>하지만 PyTorch로 따로 넘어가는 과정이 따로 노는 느낌이 듭니다.</li><li>이제 하나로 묶어볼 차례입니다.</li><li>넘어가기 전에, parity plot을 그린 명령도 함수로 정리합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_parity3</span>(<span class="params">model, target=[<span class="string">&quot;train&quot;</span>, <span class="string">&quot;val&quot;</span>, <span class="string">&quot;test&quot;</span>], figsize=(<span class="params"><span class="number">10</span>, <span class="number">4</span></span>),</span></span></span><br><span class="line"><span class="params"><span class="function">                 Xs=<span class="literal">None</span>, trues=<span class="literal">None</span>, preds=<span class="literal">None</span>, colors=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> Xs:</span><br><span class="line">        Xs = [<span class="built_in">eval</span>(<span class="string">f&quot;X_<span class="subst">&#123;t&#125;</span>&quot;</span>) <span class="keyword">for</span> t <span class="keyword">in</span> target]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> trues:</span><br><span class="line">        trues = [<span class="built_in">eval</span>(<span class="string">f&quot;y_<span class="subst">&#123;t&#125;</span>&quot;</span>) <span class="keyword">for</span> t <span class="keyword">in</span> target]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> preds:</span><br><span class="line">        preds = [model.predict(X) <span class="keyword">for</span> X <span class="keyword">in</span> Xs]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> colors:</span><br><span class="line">        colors = [<span class="built_in">eval</span>(<span class="string">f&quot;c_<span class="subst">&#123;t&#125;</span>&quot;</span>) <span class="keyword">for</span> t <span class="keyword">in</span> target]</span><br><span class="line"></span><br><span class="line">    fig, axs = plt.subplots(ncols=<span class="built_in">len</span>(target), figsize=figsize, constrained_layout=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> ax, true, pred, c, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, trues, preds, colors, titles):</span><br><span class="line">        plot_parity(true, pred, ax=ax, scatter_kws=&#123;<span class="string">&quot;fc&quot;</span>:c, <span class="string">&quot;ec&quot;</span>:c, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>&#125;, title=title)</span><br><span class="line">        <span class="keyword">if</span> ax != axs[<span class="number">0</span>]:</span><br><span class="line">            ax.set_ylabel(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Deep-Learning/">Deep Learning</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/pytorch/">pytorch</category>
      
      <category domain="https://jehyunlee.github.io/tags/sklearn/">sklearn</category>
      
      <category domain="https://jehyunlee.github.io/tags/pipeline/">pipeline</category>
      
      <category domain="https://jehyunlee.github.io/tags/neural-network/">neural network</category>
      
      <category domain="https://jehyunlee.github.io/tags/callback/">callback</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      
    </item>
    
    <item>
      <title>skorch callbacks (1) dataset preparation</title>
      <link>https://jehyunlee.github.io/2022/06/09/Python-DL-8-skorch_callback/</link>
      <guid>https://jehyunlee.github.io/2022/06/09/Python-DL-8-skorch_callback/</guid>
      <pubDate>Wed, 08 Jun 2022 21:16:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;PyTorch는 현재 가장 인기있는 딥러닝 라이브러리 중 하나입니다.&lt;/li&gt;
&lt;li&gt;학습 세부 사항을 지정하기 위해 Callback으로 다양한 기능을 지원합니다.&lt;/li&gt;
&lt;li&gt;skorch는 PyTorch를 scikit-learn과</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>PyTorch는 현재 가장 인기있는 딥러닝 라이브러리 중 하나입니다.</li><li>학습 세부 사항을 지정하기 위해 Callback으로 다양한 기능을 지원합니다.</li><li>skorch는 PyTorch를 scikit-learn과 함께 사용할 수 있게 해 줍니다.</li><li>skorch도 PyTorch callback을 이용할 수 있습니다.</li></ul><ul><li>글이 길어 세 개로 나눕니다. </li><li>첫 번째로, 데이터를 준비하는 과정입니다. 분할까지 확인합니다.</li></ul><h1 id="1-환경-설정"><a href="#1-환경-설정" class="headerlink" title="1. 환경 설정"></a>1. 환경 설정</h1><h2 id="1-1-Colab-환경-설정"><a href="#1-1-Colab-환경-설정" class="headerlink" title="1.1. Colab 환경 설정"></a>1.1. Colab 환경 설정</h2><blockquote><p><a href="https://colab.research.google.com/">Google Colaboratory</a><br><a href="https://bit.ly/3xxznt8">Colab code: skorch callbacks</a></p></blockquote><ul><li><p>먼저, Google Colab에 접속하셔서 노트북을 만들고 <b>GPU 사용 설정</b>을 합니다.</p></li><li><p>메뉴에서 <b>[런타임] ▶ [런타임 유형 변경] ▶ [하드웨어 가속기]: GPU 설정</b>을 선택합니다.<br><br><img src="8_sc_02.png"><br></p></li><li><p>간혹 <b>GPU를 할당할 수 없다</b>는 메시지가 나오기도 하지만 <b>GPU 없이 사용</b>을 선택해도 됩니다.</p></li><li><p>데이터셋과 우리가 만들 딥러닝 구조가 깊지 않아 CPU로도 충분히 빠른 결과를 볼 수 있기 때문입니다.<br><br><img src="8_sc_06.png"><br></p></li></ul><ul><li>이 밖에, Colab에서는 크게 두 가지 설정을 합니다.</li><li>Matplotlib 버전을 3.2.2에서 3.5.x로 업그레이드를 하고,</li><li>한글을 쓸 수 있도록 설정을 합니다.<details>  <summary><b>코드 보기/접기</b></summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Step 1. Matplotlib 업그레이드</span></span><br><span class="line">!pip install matplotlib -U </span><br><span class="line">!pip install seaborn -U</span><br><span class="line">!pip install pandas -U</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 2. 한글 설치 및 사용 설정</span></span><br><span class="line">!apt-get -qq install -y fonts-nanum</span><br><span class="line">!fc-cache -fv  </span><br><span class="line">!rm ~/.cache/matplotlib -rf</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 3. 셀 실행 후 런타임 재시작</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Step 4. seaborn 환경 설정</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">sns.set_style(<span class="string">&quot;ticks&quot;</span>)</span><br><span class="line">sns.set_palette(<span class="string">&quot;colorblind&quot;</span>)</span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 5. 한글 글꼴 설정</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>]=[<span class="string">&#x27;NanumGothic&#x27;</span>, <span class="string">&#x27;sans-serif&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 한글 설정 확인</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&quot;한글 테스트&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="8_sc_03.png"></li></ul><h2 id="1-2-필수-라이브러리-amp-시각화-기본-설정"><a href="#1-2-필수-라이브러리-amp-시각화-기본-설정" class="headerlink" title="1.2. 필수 라이브러리 &amp; 시각화 기본 설정"></a>1.2. 필수 라이브러리 &amp; 시각화 기본 설정</h2><ul><li>numpy를 비롯한 필수 라이브러리를 불러옵니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">from</span> tqdm.auto <span class="keyword">import</span> tqdm</span><br></pre></td></tr></table></figure></li></ul><ul><li>시각화 관련 설정도 미리 합니다.</li><li>label과 title 등에 들어갈 font 속성을 미리 설정하고,</li><li>이후 train, validation, test 데이터와 결과 출력 단계에서 사용할 색을 지정합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># font properties</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;mathtext.fontset&quot;</span>] = <span class="string">&quot;cm&quot;</span></span><br><span class="line">font_label = &#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>&#125;</span><br><span class="line">font_title = &#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;k&quot;</span>&#125;</span><br><span class="line">font_metrics = &#123;<span class="string">&#x27;color&#x27;</span>:<span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;fontsize&#x27;</span>:<span class="string">&quot;medium&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># colors</span></span><br><span class="line">c_train = <span class="string">&quot;green&quot;</span></span><br><span class="line">c_val = <span class="string">&quot;orange&quot;</span></span><br><span class="line">c_test = <span class="string">&quot;magenta&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="1-3-PyTorch-사용-준비-amp-Random-Seed"><a href="#1-3-PyTorch-사용-준비-amp-Random-Seed" class="headerlink" title="1.3. PyTorch 사용 준비 &amp; Random Seed"></a>1.3. PyTorch 사용 준비 &amp; Random Seed</h2><blockquote><p><a href="https://scikit-learn.org/stable/common_pitfalls.html">scikit-learn Common pitfalls and recommended practices</a></p></blockquote><ul><li>PyTorch 관련 라이브러리를 불러오고, GPU를 사용할 준비를 합니다.</li><li>일단 당장 필요한 것들만 import해놓고 나중에는 그 때 그 때 필요한 것을 추가로 import할 것입니다.</li><li>GPU를 사용할 수 없는 환경이라면 CPU를 사용하도록 설정됩니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PyTorch 라이브러리</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># GPU 사용 설정</span></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(torch.cuda.device_count()):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;# DEVICE <span class="subst">&#123;i&#125;</span>: <span class="subst">&#123;torch.cuda.get_device_name(i)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;- Memory Usage:&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  Allocated: <span class="subst">&#123;<span class="built_in">round</span>(torch.cuda.memory_allocated(i)/<span class="number">1024</span>**<span class="number">3</span>,<span class="number">1</span>)&#125;</span> GB&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  Cached:    <span class="subst">&#123;<span class="built_in">round</span>(torch.cuda.memory_reserved(i)/<span class="number">1024</span>**<span class="number">3</span>,<span class="number">1</span>)&#125;</span> GB\n&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;# GPU is not available&quot;</span>)</span><br><span class="line">    </span><br><span class="line">device = <span class="string">&#x27;cuda:0&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>실행 결과: GPU로 <b>Tesla T4</b>가 할당되었습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DEVICE 0: Tesla T4</span></span><br><span class="line">- Memory Usage:</span><br><span class="line">  Allocated: 0.0 GB</span><br><span class="line">  Cached:    0.0 GB</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>Random Seed도 미리 설정합니다. </li><li>재현성을 결정하는 <a href="https://scikit-learn.org/stable/common_pitfalls.html">생각보다 중요한 단계</a>이므로 주의깊게 챙깁니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">0</span>)</span><br><span class="line">torch.manual_seed(<span class="number">0</span>)</span><br><span class="line">torch.cuda.manual_seed(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li></ul><h1 id="2-Data"><a href="#2-Data" class="headerlink" title="2. Data"></a>2. Data</h1><p><img src="8_sc_01.png"></p><blockquote><p><a href="https://rpubs.com/julianlavila/penguins">penguins dataset</a><br><a href="https://bit.ly/3xxznt8">Colab code: skorch callbacks</a></p></blockquote><ul><li>펭귄의 종<code>species</code>, 서식지<code>island</code>, 성별<code>sex</code>을 비롯해</li><li>세 가지 신체 치수<code>bill length</code>, <code>bill depth</code>, <code>flipper length</code>로 체중<code>body_mass</code>을 예측하는 문제를 풀어보겠습니다.</li><li>이번에는 GPU를 사용하는 법을 포함하여 Colab에서 실행합니다.</li></ul><h2 id="2-1-Dataset-불러오기"><a href="#2-1-Dataset-불러오기" class="headerlink" title="2.1. Dataset 불러오기"></a>2.1. Dataset 불러오기</h2><ul><li>seaborn에 내장된 데이터를 사용합니다.</li><li>결측치를 미리 제거합니다.</li><li>여기서는 생략했지만 <b>실전에서는 결측치, 중복치, 이상치를 모두 따져봐야 합니다!</b><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_peng = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)  <span class="comment"># 펭귄 데이터셋</span></span><br><span class="line">df_peng = df_peng.dropna()              <span class="comment"># 결측치 제거</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2-X-y-분할-y-body-mass-g"><a href="#2-2-X-y-분할-y-body-mass-g" class="headerlink" title="2.2. $X$, $y$ 분할: $y$ = body_mass_g"></a>2.2. $X$, $y$ 분할: $y$ = <code>body_mass_g</code></h2><ul><li>문제에 맞게 펭귄 체중을 $y$로 놓고 데이터를 분할합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = df_peng[<span class="string">&quot;body_mass_g&quot;</span>]</span><br><span class="line">X = df_peng.drop(<span class="string">&quot;body_mass_g&quot;</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-3-training-validataion-testing-set-분할"><a href="#2-3-training-validataion-testing-set-분할" class="headerlink" title="2.3. training, validataion, testing set 분할"></a>2.3. training, validataion, testing set 분할</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html">scikit-learn: sklearn.model_selection.train_test_split</a></p></blockquote><ul><li><p>훈련, 검증, 시험에 쓰일 데이터를 각기 3:1:1로 분할합니다.</p></li><li><p>scikit-learn의 <a href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html"><code>train_test_split</code></a>기능을 사용하는데, 두 덩어리로만 나눌 수 있으므로 두 번에 걸쳐 나누어줍니다.</p></li><li><p>먼저 Train : test를 4:1로 나누고, 다시 Train을 train : val = 3:1로 나눕니다.</p></li><li><p><code>random_state=rng</code>를 넣어서 재현성을 확보하는 것을 잊지 맙시다.</p></li><li><p><code>_train</code>, <code>_val</code>, <code>_test</code>가 붙은 세 가지 목적의 $X$, $y$ 데이터셋이 마련되었습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">X_Train, X_test, y_Train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=rng, </span><br><span class="line">                                                    stratify=X[[<span class="string">&quot;species&quot;</span>, <span class="string">&quot;island&quot;</span>, <span class="string">&quot;sex&quot;</span>]])</span><br><span class="line">X_train, X_val, y_train, y_val = train_test_split(X_Train, y_Train, test_size=<span class="number">0.25</span>, random_state=rng, </span><br><span class="line">                                                    stratify=X_Train[[<span class="string">&quot;species&quot;</span>, <span class="string">&quot;island&quot;</span>, <span class="string">&quot;sex&quot;</span>]])</span><br></pre></td></tr></table></figure></li><li><p><code>stratify</code> 매개변수에 <code>[[&quot;species&quot;, &quot;island&quot;, &quot;sex&quot;]]</code>를 넣어 층화 추출을 구현했습니다.</p></li><li><p><b>층화 추출은 데이터를 분할할 때 categorical data의 class비율을 반영해 나누는 것을 의미합니다.</b></p></li><li><p>특정 class가 한 쪽에 쏠려 너무 많거나 적어지는 현상을 방지합니다.</p></li><li><p><b>categorical features`</b>가 잘 분할되었는지 살펴봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">cols_cat = [<span class="string">&quot;species&quot;</span>, <span class="string">&quot;island&quot;</span>, <span class="string">&quot;sex&quot;</span>]</span><br><span class="line">df_tmp = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, (X, col) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>([X_train, X_val, X_test], [<span class="string">&quot;train&quot;</span>, <span class="string">&quot;valid&quot;</span>, <span class="string">&quot;test&quot;</span>])):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(df_tmp, <span class="built_in">int</span>):</span><br><span class="line">        df_tmp = pd.DataFrame(X[cols_cat].value_counts(), columns=[col]).sort_index()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        df_tmp = pd.concat([df_tmp, pd.DataFrame(X[cols_cat].value_counts(), columns=[col]).sort_index()], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">df_tmp.plot.barh(ax=ax, color=&#123;<span class="string">&quot;train&quot;</span>:c_train, <span class="string">&quot;valid&quot;</span>:c_val, <span class="string">&quot;test&quot;</span>:c_test&#125;).invert_yaxis()</span><br></pre></td></tr></table></figure><p><img src="8_sc_04.png"><br></p></li></ul><ul><li>y축 눈금에 species, island, sex 조합이 나열되어 있습니다.</li><li>모든 섬에 살고 있는 Adelie 펭귄과 Dream에만 살고 있는 Chinstrap, Biscoe에만 살고 있는 Gentoo 펭귄이 보입니다.</li><li>각 조합에서 valid와 test가 거의 비슷하고 train은 이들의 3배입니다. </li><li>3:1:1로 골고루 잘 나뉘었습니다.</li></ul><ul><li><p>이번에는 <b>numerical features</b> <code>bill_length_mm</code>, <code>bill_depth_mm</code>, <code>flipper_length_mm</code>, <code>body_mass_g</code>분포를 살핍니다.</p></li><li><p>KDE plot을 통해서 전반적인 분포를 대략적으로 비교합니다.</p></li><li><p>$X$에 3개의 numerical feature가 있고 $y$에 하나가 있습니다. 한데 모아 보여줍니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(ncols=<span class="number">2</span>, nrows=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">cols_num = [<span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, <span class="string">&quot;flipper_length_mm&quot;</span>]</span><br><span class="line">axs = axes.ravel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># numerical X features</span></span><br><span class="line"><span class="keyword">for</span> ax, col <span class="keyword">in</span> <span class="built_in">zip</span>(axes.ravel(), cols_num):</span><br><span class="line">    <span class="keyword">for</span> X, c <span class="keyword">in</span> <span class="built_in">zip</span>([X_train, X_val, X_test], [c_train, c_val, c_test]):</span><br><span class="line">        sns.kdeplot(x=col, data=X, ax=ax, fill=<span class="literal">True</span>, alpha=<span class="number">0.3</span>, color=c)</span><br><span class="line">        ax.set_ylabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># y feature</span></span><br><span class="line"><span class="keyword">for</span> y, c <span class="keyword">in</span> <span class="built_in">zip</span>([y_train, y_val, y_test], [c_train, c_val, c_test]):</span><br><span class="line">    sns.kdeplot(y, ax=axes[<span class="number">1</span>, <span class="number">1</span>], fill=<span class="literal">True</span>, alpha=<span class="number">0.3</span>, color=c)</span><br><span class="line">    axes[<span class="number">1</span>, <span class="number">1</span>].set_ylabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">axes[<span class="number">0</span>, <span class="number">1</span>].legend(handles=axes[<span class="number">1</span>, <span class="number">1</span>].collections, labels=[<span class="string">&quot;train&quot;</span>, <span class="string">&quot;valid&quot;</span>, <span class="string">&quot;test&quot;</span>],</span><br><span class="line">                  loc=<span class="string">&quot;upper left&quot;</span>, bbox_to_anchor=(<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p><img src="8_sc_05.png"><br></p></li><li><p>training, validation, testing set에 모든 변수가 비슷하게 분포하여 크게 치우친 면이 없습니다.</p></li><li><p>이정도 되면 웬만큼 믿고 학습에 투입할 수 있을 듯 합니다.</p></li><li><p>$X$와 $y$간의 상관관계만 있다면 좋은 성능을 얻을 수 있을 것입니다.</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Deep-Learning/">Deep Learning</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/pytorch/">pytorch</category>
      
      <category domain="https://jehyunlee.github.io/tags/sklearn/">sklearn</category>
      
      <category domain="https://jehyunlee.github.io/tags/pipeline/">pipeline</category>
      
      <category domain="https://jehyunlee.github.io/tags/neural-network/">neural network</category>
      
      <category domain="https://jehyunlee.github.io/tags/callback/">callback</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      
    </item>
    
    <item>
      <title>seaborn regplot vs lmplot</title>
      <link>https://jehyunlee.github.io/2022/06/06/Python-DS-103-snsreglmplot/</link>
      <guid>https://jehyunlee.github.io/2022/06/06/Python-DS-103-snsreglmplot/</guid>
      <pubDate>Mon, 06 Jun 2022 09:51:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;seaborn에는 regplot이라는 기능이 있습니다.&lt;/li&gt;
&lt;li&gt;산점도, 회귀선, 신뢰 구간을 동시에 표현해주는 강력한 기능입니다.&lt;/li&gt;
&lt;li&gt;그리고 같은 결과를 출력하는 lmplot이 있습니다. 같은 점과 다른 점을 확인</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>seaborn에는 regplot이라는 기능이 있습니다.</li><li>산점도, 회귀선, 신뢰 구간을 동시에 표현해주는 강력한 기능입니다.</li><li>그리고 같은 결과를 출력하는 lmplot이 있습니다. 같은 점과 다른 점을 확인합니다.</li></ul><h1 id="1-seaborn-regplot"><a href="#1-seaborn-regplot" class="headerlink" title="1. seaborn regplot"></a>1. seaborn regplot</h1><blockquote><p><a href="https://seaborn.pydata.org/generated/seaborn.regplot.html">seaborn.regplot</a></p></blockquote><ul><li>seaborn에는 <code>regplot</code> 함수가 있습니다.</li><li><b>scatter plot, regression line, confidence band를 한 번에 그리는 기능</b>입니다.</li><li>따로 그리려면 매우 손이 많이 가기 때문에, seaborn이 Matplotlib보다 우월한 점을 말할 때 빠지지 않는 기능입니다.</li></ul><h2 id="1-1-예제-데이터"><a href="#1-1-예제-데이터" class="headerlink" title="1.1. 예제 데이터"></a>1.1. 예제 데이터</h2><ul><li>예제 데이터를 사용해서 직접 그려보겠습니다.</li><li>seaborn에 내장된 penguins dataset을 사용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 시각화 설정</span></span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line">sns.set_style(<span class="string">&quot;ticks&quot;</span>)</span><br><span class="line">sns.set_palette(<span class="string">&quot;colorblind&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 예제 데이터 불러오기</span></span><br><span class="line">df_peng = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)</span><br><span class="line">df_peng.head()</span><br></pre></td></tr></table></figure><img src="103_snsreglmplot_11.png"><br></li></ul><h2 id="1-2-sns-regplot"><a href="#1-2-sns-regplot" class="headerlink" title="1.2. sns.regplot()"></a>1.2. <code>sns.regplot()</code></h2><ul><li><p>seaborn의 다른 명령어들이 그렇듯 <b><code>sns.regplot</code>도 한 줄로 실행</b>합니다.</p></li><li><p>그림이 담길 Figure와 Axes를 Matplotlib으로 만들고 이 안에 regplot을 담습니다.</p></li><li><p>그림을 파일로 저장할 때는 Figure 객체 fig에 <b><code>fig.savefig()</code></b> 명령을 내립니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">sns.regplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, ax=ax)</span><br><span class="line"></span><br><span class="line">fig.savefig(<span class="string">&quot;103_snsreglmplot_01.png&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="103_snsreglmplot_01.png"><br></p></li><li><p><code>x</code>와 <code>y</code>에 각기 x, y축에 놓일 데이터를,</p></li><li><p><code>data</code>에 x와 y가 담긴 dataset을 입력합니다.</p></li><li><p>마지막으로 <code>ax</code>에 regplot이 들어갈 Axes 이름을 입력했습니다.</p></li></ul><h2 id="1-3-scatter-kws"><a href="#1-3-scatter-kws" class="headerlink" title="1.3. scatter_kws"></a>1.3. <code>scatter_kws</code></h2><ul><li>scatter plot의 속성을 지정할 때 <code>scatter_kws</code> 매개변수를 사용합니다.</li><li>dictionary 형식으로 scatter 객체의 속성 이름과 값을 key와 value로 만들어 넣습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">sns.regplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, ax=ax,</span><br><span class="line">            scatter_kws=&#123;<span class="string">&quot;fc&quot;</span>:<span class="string">&quot;b&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;b&quot;</span>, <span class="string">&quot;s&quot;</span>:<span class="number">100</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.3</span>&#125;)</span><br><span class="line"></span><br><span class="line">fig.savefig(<span class="string">&quot;103_snsreglmplot_02.png&quot;</span>)</span><br></pre></td></tr></table></figure><img src="103_snsreglmplot_02.png"><br></li></ul><h2 id="1-4-line-kws"><a href="#1-4-line-kws" class="headerlink" title="1.4. line_kws"></a>1.4. <code>line_kws</code></h2><ul><li>scatter 속성을 <code>scatter_kws</code>로 조정했듯,</li><li>line 속성은 <code>line_kws</code>로 조정합니다.</li><li>line width, line style, alpha를 설정할 수 있습니다.</li><li>다만 line과 confidence band의 색은 별도의 매개변수 <code>color</code>로 조정해야 합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">sns.regplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, ax=ax,</span><br><span class="line">            scatter_kws=&#123;<span class="string">&quot;fc&quot;</span>:<span class="string">&quot;b&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;b&quot;</span>, <span class="string">&quot;s&quot;</span>:<span class="number">100</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.3</span>&#125;,</span><br><span class="line">            color=<span class="string">&quot;r&quot;</span>, line_kws=&#123;<span class="string">&quot;lw&quot;</span>:<span class="number">3</span>, <span class="string">&quot;ls&quot;</span>:<span class="string">&quot;--&quot;</span>,<span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>&#125;)</span><br><span class="line"></span><br><span class="line">fig.savefig(<span class="string">&quot;103_snsreglmplot_03.png&quot;</span>)</span><br></pre></td></tr></table></figure><img src="103_snsreglmplot_03.png"><br></li></ul><h2 id="1-5-confidence-band"><a href="#1-5-confidence-band" class="headerlink" title="1.5. confidence band"></a>1.5. confidence band</h2><ul><li>confidence band 속성을 제어하기 위해서는 객체를 추출하고 속성을 개별 제어해야 합니다.</li><li>regplot이 그려지는 Axes의 세 번째 객체가 confidence band입니다. </li><li>첫 번째와 두 번째 객체는 scatter plot, regression line입니다.</li></ul><ul><li><code>ax.get_children()[2]</code>로 confidence band를 추출하고,</li><li><code>.set()</code> 메소드로 속성을 제어합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">sns.regplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, ax=ax,</span><br><span class="line">            scatter_kws=&#123;<span class="string">&quot;fc&quot;</span>:<span class="string">&quot;b&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;b&quot;</span>, <span class="string">&quot;s&quot;</span>:<span class="number">100</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.3</span>&#125;,</span><br><span class="line">            color=<span class="string">&quot;r&quot;</span>, line_kws=&#123;<span class="string">&quot;lw&quot;</span>:<span class="number">3</span>, <span class="string">&quot;ls&quot;</span>:<span class="string">&quot;--&quot;</span>,<span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>&#125;)</span><br><span class="line"></span><br><span class="line">ci = ax.get_children()[<span class="number">2</span>]                   <span class="comment"># confidence band 추출</span></span><br><span class="line">ci.<span class="built_in">set</span>(fc=<span class="string">&quot;yellow&quot;</span>, ec=<span class="string">&quot;orange&quot;</span>, alpha=<span class="number">0.8</span>) <span class="comment"># face &amp; edge color, alpha 조정</span></span><br><span class="line"></span><br><span class="line">fig.savefig(<span class="string">&quot;103_snsreglmplot_04.png&quot;</span>)</span><br></pre></td></tr></table></figure><img src="103_snsreglmplot_04.png"><br></li></ul><h2 id="1-6-sns-regplot-amp-hue"><a href="#1-6-sns-regplot-amp-hue" class="headerlink" title="1.6. sns.regplot &amp; hue"></a>1.6. <code>sns.regplot</code> &amp; <code>hue</code></h2><blockquote><p><a href="https://www.britannica.com/topic/Simpsons-paradox">Brinnica: Simpson’s paradox</a></p></blockquote><ul><li><p>seaborn의 여러 함수에는 <code>hue</code> 매개변수가 있습니다.</p></li><li><p>categorical feature의 class별로 다른 색이나 style을 적용해 구분하도록 해 줍니다.</p></li><li><p>그러나 불행히도 <b><code>sns.regplot</code>에는 <code>hue</code>매개변수가 없습니다.</b></p></li><li><p>예를 들어 species별로 다른 색과 회귀선으로 표현하려면 for loop 등으로 반복해 그림을 그려야 합니다.</p></li><li><p>Axes 두 개를 마련해 왼쪽에 전체를, 오른쪽에 species별로 hue를 수동으로 구현한 그림을 그립니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>, </span><br><span class="line">                        sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># (A) 전체 시각화</span></span><br><span class="line">sns.regplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, ax=axs[<span class="number">0</span>], color=<span class="string">&quot;k&quot;</span>,</span><br><span class="line">            scatter_kws=&#123;<span class="string">&quot;fc&quot;</span>:<span class="string">&quot;lightgray&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;s&quot;</span>:<span class="number">50</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (B) species별 그룹 시각화</span></span><br><span class="line">peng_species = df_peng[<span class="string">&quot;species&quot;</span>].unique()  <span class="comment"># 펭귄 데이터셋 중 species 종류 추출</span></span><br><span class="line"><span class="keyword">for</span> species <span class="keyword">in</span> peng_species:</span><br><span class="line">    df_s = df_peng.loc[df_peng[<span class="string">&quot;species&quot;</span>] == species]   <span class="comment"># species별 펭귄 데이터 추출</span></span><br><span class="line">    sns.regplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_s, ax=axs[<span class="number">1</span>], label=species,</span><br><span class="line">                scatter_kws=&#123;<span class="string">&quot;s&quot;</span>:<span class="number">50</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>&#125;)</span><br><span class="line">   </span><br><span class="line">    axs[<span class="number">1</span>].legend(loc=<span class="string">&quot;center left&quot;</span>, bbox_to_anchor=[<span class="number">1</span>, <span class="number">0.5</span>], frameon=<span class="literal">False</span>)</span><br><span class="line">    axs[<span class="number">1</span>].set_ylabel(<span class="string">&quot; \n&quot;</span>)                    <span class="comment"># gridspec_kw를 사용하지 않고 Axes 간격 띄우기</span></span><br><span class="line">    </span><br><span class="line">fig.savefig(<span class="string">&quot;103_snsreglmplot_05.png&quot;</span>)    </span><br></pre></td></tr></table></figure><p><img src="103_snsreglmplot_05.png"><br></p></li><li><p>전체와 부분의 경향이 다른 것을 <b><a href="https://www.britannica.com/topic/Simpsons-paradox">심슨의 역설(Simpson’s paradox)</a></b>이라 합니다.</p></li><li><p>펭귄 데이터셋 중 부리 길이(bill_length_mm)와 부리 폭(bill_depth_mm)에서 심슨의 역설이 관찰되었습니다.</p></li><li><p>생각보다 매우 흔한 일이지만 분석의 결론을 완전히 바꾸는 일입니다. </p></li><li><p>데이터를 분석할 때 분할(segmentation)에 주의를 기울여야 하는 이유입니다.</p></li></ul><ul><li><code>sns.regplot()</code>에는 <code>hue</code> 기능이 없어서 for loop을 불편하게 돌려야만 했습니다.</li><li>그러나 우리의 seaborn은 같은 기능을 하는 다른 함수로 <code>hue</code>를 제공합니다. </li><li><code>sns.lmplot()</code>이라는 이름입니다.</li></ul><h1 id="2-seaborn-lmplot"><a href="#2-seaborn-lmplot" class="headerlink" title="2. seaborn lmplot"></a>2. seaborn lmplot</h1><blockquote><p><a href="https://seaborn.pydata.org/generated/seaborn.lmplot.html">seaborn lmplot</a></p></blockquote><h2 id="2-1-sns-lmplot"><a href="#2-1-sns-lmplot" class="headerlink" title="2.1. sns.lmplot()"></a>2.1. <code>sns.lmplot()</code></h2><ul><li><p>seaborn lmplot은 본질적으로 regplot과 동일합니다. 내부에서 <code>sns.regplot()</code>을 호출하기 때문입니다.</p></li><li><p>그러나 <b><code>sns.regplot()</code>이 Axes-level function인 반면 <code>sns.lmplot()</code>은 Figure-level function</b>이라는 가장 큰 차이가 있습니다.</p></li><li><p>간단하게 그려서 확인해 보겠습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g = sns.lmplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, hue=<span class="string">&quot;species&quot;</span>, </span><br><span class="line">               height=<span class="number">5</span>, aspect=<span class="number">1</span>,</span><br><span class="line">               scatter_kws=&#123;<span class="string">&quot;s&quot;</span>:<span class="number">50</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>&#125;)</span><br><span class="line"></span><br><span class="line">fig = g.fig</span><br><span class="line">fig.savefig(<span class="string">&quot;103_snsreglmplot_06.png&quot;</span>)    </span><br></pre></td></tr></table></figure><p><img src="103_snsreglmplot_06.png"><br></p></li><li><p><code>sns.regplot</code>과 문법이 동일하면서도 <code>hue</code>가 적용된 plot이 한 줄로 그려졌습니다.</p></li><li><p>그러나 이 명령을 이용해 심슨의 역설을 그리려다가는 이런 일이 벌어집니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Axes 두 개 생성</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>, </span><br><span class="line">                        sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 전체 시각화</span></span><br><span class="line">sns.regplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, ax=axs[<span class="number">0</span>], color=<span class="string">&quot;k&quot;</span>,</span><br><span class="line">            scatter_kws=&#123;<span class="string">&quot;fc&quot;</span>:<span class="string">&quot;lightgray&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;s&quot;</span>:<span class="number">50</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sns.lmplot() 실행</span></span><br><span class="line">sns.lmplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, hue=<span class="string">&quot;species&quot;</span>,            </span><br><span class="line">           scatter_kws=&#123;<span class="string">&quot;s&quot;</span>:<span class="number">50</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>&#125;)</span><br></pre></td></tr></table></figure><p><img src="103_snsreglmplot_07.png"><br></p></li><li><p><code>sns.lmplot()</code>의 결과물이 미리 만들어 둔 Axes에 들어가지 않습니다.</p></li><li><p>이는 <code>sns.lmplot()</code>이 Figure-level function으로, Figure보다 상위에 있는 Grid라는 객체를 생성하기 때문입니다.</p></li><li><p>그렇기 때문에, 파일을 저장하기 위해서 figure 객체에 <code>g.fig</code>로 접근하는 과정이 필요합니다.</p></li></ul><h2 id="2-2-col-amp-row"><a href="#2-2-col-amp-row" class="headerlink" title="2.2. col &amp; row"></a>2.2. <code>col</code> &amp; <code>row</code></h2><ul><li><b>Figure-level function의 장점</b>은 따로 있습니다.</li><li><b>categorical feature의 class를 FacetGrid로 쉽게 구현할 수 있다는 것</b>입니다.</li><li><code>col</code>과 <code>row</code>에 열과 행을 나눌 categorical feature 이름을 입력합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g = sns.lmplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, </span><br><span class="line">           col=<span class="string">&quot;species&quot;</span>, row=<span class="string">&quot;sex&quot;</span>,                          <span class="comment"># species와 sex로 데이터 분할</span></span><br><span class="line">           truncate=<span class="literal">False</span>, scatter_kws=&#123;<span class="string">&quot;s&quot;</span>:<span class="number">50</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>&#125;) <span class="comment"># sns.regplot() 사용 매개변수 적용</span></span><br><span class="line"></span><br><span class="line">fig = g.fig</span><br><span class="line">fig.savefig(<span class="string">&quot;103_snsreglmplot_08.png&quot;</span>)    </span><br></pre></td></tr></table></figure><img src="103_snsreglmplot_08.png"><br></li></ul><ul><li>데이터가 sex와 species에 따라 나뉘어 그려졌습니다.</li></ul><h2 id="2-3-Figure-level-function-Axes-level-function"><a href="#2-3-Figure-level-function-Axes-level-function" class="headerlink" title="2.3. Figure-level function + Axes-level function"></a>2.3. Figure-level function + Axes-level function</h2><ul><li>Figure-level function의 결과물은 Axes에 들어갈 수 없지만,</li><li>Axes-level function의 결과물은 Figure-level function의 결과물에 들어갈 수 있습니다.</li><li><code>sns.lmplot()</code>으로 만들어진 FacetGrid에서 Axes를 추출해 <code>sns.regplot()</code>을 적용합니다.</li><li><code>sns.regplot()</code>으로 전체 데이터 범위를, <code>sns.lmplot()</code>으로 개별 데이터를 표현하는 식입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">g = sns.lmplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>,       <span class="comment"># sns.lmplot 생성 FacetGrid 출력</span></span><br><span class="line">               data=df_peng, </span><br><span class="line">               col=<span class="string">&quot;species&quot;</span>, row=<span class="string">&quot;sex&quot;</span>,                    <span class="comment"># species와 sex로 데이터 분할</span></span><br><span class="line">               scatter_kws=&#123;<span class="string">&quot;s&quot;</span>:<span class="number">50</span>&#125;)</span><br><span class="line">  </span><br><span class="line">axes = g.axes               <span class="comment"># FacetGrid에서 Axes 추출</span></span><br><span class="line"><span class="keyword">for</span> ax <span class="keyword">in</span> axes.ravel():     <span class="comment"># Axes 순회, 전체 데이터를 배경으로 표현</span></span><br><span class="line">    sns.regplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, </span><br><span class="line">                fit_reg=<span class="literal">False</span>, </span><br><span class="line">                scatter_kws=&#123;<span class="string">&quot;fc&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;none&quot;</span>, <span class="string">&quot;s&quot;</span>:<span class="number">50</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.3</span>&#125;, ax=ax)</span><br><span class="line"></span><br><span class="line">fig = g.fig</span><br><span class="line">fig.tight_layout()</span><br><span class="line">fig.savefig(<span class="string">&quot;103_snsreglmplot_09.png&quot;</span>)    </span><br></pre></td></tr></table></figure><img src="103_snsreglmplot_09.png"><br></li></ul><h2 id="2-4-sns-lmplot-결과마다-다른-색"><a href="#2-4-sns-lmplot-결과마다-다른-색" class="headerlink" title="2.4. sns.lmplot()결과마다 다른 색"></a>2.4. <code>sns.lmplot()</code>결과마다 다른 색</h2><ul><li><p><code>sns.lmplot()</code>에는 hue로 나뉘는 데이터에 적용하기 위한 <code>palette</code>매개변수가 있습니다.</p></li><li><p>그러나 Facet별로 다르게 들어간 데이터에는 <code>palette</code>매개변수가 적용되지 않습니다.</p></li><li><p><code>color</code>매개변수도 존재하지 않기 때문에, 개별 객체를 접근해야 합니다.</p></li><li><p>matplotlib 기능을 이용해 hue, lightness, saturation을 조정하는 <code>modify_hls()</code> 함수를 먼저 만듭니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.colors <span class="keyword">as</span> mcolors</span><br><span class="line"><span class="keyword">import</span> colorsys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify_hls</span>(<span class="params">c, dh=<span class="number">0</span>, dl=<span class="number">0</span>, ds=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(c, <span class="built_in">str</span>):</span><br><span class="line">        c = mcolors.to_rgb(c)</span><br><span class="line">    </span><br><span class="line">    h, l, s = colorsys.rgb_to_hls(*c)</span><br><span class="line">    h = h + dh</span><br><span class="line">    l = <span class="built_in">max</span>(<span class="built_in">min</span>(l + dl, <span class="number">1</span>), <span class="number">0</span>)</span><br><span class="line">    s = <span class="built_in">max</span>(<span class="built_in">min</span>(s + ds, <span class="number">1</span>), <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> colorsys.hls_to_rgb(h, l, s)</span><br></pre></td></tr></table></figure></li><li><p>위 Axes 순회 코드에 Axes마다 다른 facecolor와 edgecolor를 적용하는 코드를 추가합니다.</p></li><li><p>species에 따라서는 CN을 적용하고 (C0, C1, C2)</p></li><li><p>sex에 따라서는 hue를 5% 옮긴 색을 입힙니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">g = sns.lmplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>,       <span class="comment"># sns.lmplot 생성 FacetGrid 출력</span></span><br><span class="line">               data=df_peng, </span><br><span class="line">               col=<span class="string">&quot;species&quot;</span>, row=<span class="string">&quot;sex&quot;</span>,                    <span class="comment"># species와 sex로 데이터 분할</span></span><br><span class="line">               scatter_kws=&#123;<span class="string">&quot;s&quot;</span>:<span class="number">50</span>&#125;)</span><br><span class="line"></span><br><span class="line">axes = g.axes               <span class="comment"># FacetGrid에서 Axes 추출</span></span><br><span class="line"><span class="keyword">for</span> i, ax <span class="keyword">in</span> <span class="built_in">enumerate</span>(axes.ravel()):     <span class="comment"># Axes 순회, 전체 데이터를 배경으로 표현</span></span><br><span class="line">    scatter, reg, cb = ax.get_children()[:<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">2</span>:</span><br><span class="line">        i -= <span class="number">3</span></span><br><span class="line">        dh = -<span class="number">0.05</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dh = <span class="number">0</span></span><br><span class="line">    scatter.<span class="built_in">set</span>(fc=modify_hls(<span class="string">f&quot;C<span class="subst">&#123;i&#125;</span>&quot;</span>, dl=<span class="number">0.3</span>, dh=dh), ec=modify_hls(<span class="string">f&quot;C<span class="subst">&#123;i&#125;</span>&quot;</span>, dh=dh), alpha=<span class="number">1</span>)</span><br><span class="line">    reg.set_color(modify_hls(<span class="string">f&quot;C<span class="subst">&#123;i&#125;</span>&quot;</span>, dh=dh))</span><br><span class="line">    cb.<span class="built_in">set</span>(fc=modify_hls(<span class="string">f&quot;C<span class="subst">&#123;i&#125;</span>&quot;</span>, dl=<span class="number">0.3</span>, dh=dh), ec=modify_hls(<span class="string">f&quot;C<span class="subst">&#123;i&#125;</span>&quot;</span>, dh=dh))</span><br><span class="line">    sns.regplot(x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=df_peng, </span><br><span class="line">                fit_reg=<span class="literal">False</span>, </span><br><span class="line">                scatter_kws=&#123;<span class="string">&quot;fc&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;none&quot;</span>, <span class="string">&quot;s&quot;</span>:<span class="number">50</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.3</span>&#125;, ax=ax)</span><br><span class="line">    title = ax.get_title()</span><br><span class="line">    ax.set_title(title, color=modify_hls(<span class="string">f&quot;C<span class="subst">&#123;i&#125;</span>&quot;</span>, dh=dh))</span><br><span class="line">    </span><br><span class="line">fig = g.fig</span><br><span class="line">fig.tight_layout()</span><br><span class="line">fig.savefig(<span class="string">&quot;103_snsreglmplot_10.png&quot;</span>)    </span><br></pre></td></tr></table></figure><p><img src="103_snsreglmplot_10.png"><br></p></li></ul><h1 id="3-결론"><a href="#3-결론" class="headerlink" title="3. 결론"></a>3. 결론</h1><ul><li>seaborn의 Figure-level function은 매우 유용하지만 Grid를 출력하는 속성은 종종 간과됩니다.</li><li>seaborn을 사용할 때 발생하는 에러의 대부분이 바로 이 Grid입니다.</li><li>그리고 이 Grid가 Axes-level과 Figure-level을 결정짓는 가장 큰 차이입니다.</li><li>seaborn을 잘 사용하고자 한다면 주의깊게 살펴볼 필요가 있습니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/regplot/">regplot</category>
      
      <category domain="https://jehyunlee.github.io/tags/lmplot/">lmplot</category>
      
      
    </item>
    
    <item>
      <title>short discussions on KDE plot</title>
      <link>https://jehyunlee.github.io/2022/05/27/Python-DS-102-kdeplot/</link>
      <guid>https://jehyunlee.github.io/2022/05/27/Python-DS-102-kdeplot/</guid>
      <pubDate>Thu, 26 May 2022 23:51:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;경향신문과 언더스코어가 공동으로 조사한 ‘부모찬스’기사가 실렸습니다.&lt;/li&gt;
&lt;li&gt;기사 내용과 별개로, 이 기사에 활용된 KDE plot에 대해 여러 분들이 여러 의견을 표했습니다.&lt;/li&gt;
&lt;li&gt;KDE plot의 특징과 한계를 </description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>경향신문과 언더스코어가 공동으로 조사한 ‘부모찬스’기사가 실렸습니다.</li><li>기사 내용과 별개로, 이 기사에 활용된 KDE plot에 대해 여러 분들이 여러 의견을 표했습니다.</li><li>KDE plot의 특징과 한계를 살펴봅니다.</li></ul><blockquote><p><a href="http://underscore.kr/">언더스코어</a><br><a href="https://www.khan.co.kr/national/national-general/article/202205250600005">경향신문: 두 얼굴의 공정(1) 조국과 정호영, 누가 더 ‘불공정’합니까?</a><br><a href="https://youtu.be/5DzcKpgUva4">경향신문: 정치 성향에 따라 부모찬스에 들이댄 ‘공정 잣대’는 달랐다</a></p></blockquote><h1 id="1-시작"><a href="#1-시작" class="headerlink" title="1. 시작"></a>1. 시작</h1><ul><li>현대 대한민국의 가장 큰 화두 중 하나는 <b>공정</b>입니다.</li><li>기회의 공정, 결과의 공정, 또는 떨어질 때 떨어지더라도 이유라도 알자는 의미의 공정.</li><li>여러 면에서 여러 의미로 공정이 오르내리고 있으며 그 중 하나는 <b>부모찬스</b>입니다.</li><li><a href="https://www.khan.co.kr/national/national-general/article/202205250600005">경향신문</a>과 <a href="http://underscore.kr/">언더스코어</a>에서 의미있는 분석을 시도하고 있습니다.<br><br><img src="102_kdeplot_06.png"><br></li></ul><h1 id="2-KDE-plot"><a href="#2-KDE-plot" class="headerlink" title="2. KDE plot"></a>2. KDE plot</h1><blockquote><p><a href="https://en.wikipedia.org/wiki/Kernel_density_estimation">Kernel Density Estimation</a></p></blockquote><ul><li>설문 결과 분포를 표현하기 위해 기사에 사용된 이와 같은 시각화 기법을 <b>KDE plot</b>이라고 합니다.</li><li><b>Kernel Density Plot</b>의 약자이며, 히스토그램의 단점을 보완하기 위해 제안된 방식입니다.</li><li>히스토그램이 구간별 데이터 수를 bar plot으로 표현하는 방식이라면 KDE plot은 각 데이터로 밀도 분포를 추정하여 합산하는 방식입니다.<br><br><img src="102_kdeplot_07.png" alt="wikipedia, Kernel density estimation"><br></li></ul><h1 id="3-seaborn-histogram-vs-kdeplot"><a href="#3-seaborn-histogram-vs-kdeplot" class="headerlink" title="3. seaborn histogram vs kdeplot"></a>3. seaborn histogram vs kdeplot</h1><blockquote><p><a href="https://jehyunlee.github.io/2020/09/07/Python-DS-30-mpl_dists/">Pega Devlog: Ridgeline Plot</a><br><a href="https://seaborn.pydata.org/generated/seaborn.kdeplot.html">seaborn: kdeplot</a><br><a href="https://seaborn.pydata.org/generated/seaborn.histplot.html">seaborn: histplot</a></p></blockquote><ul><li><a href="https://jehyunlee.github.io/2020/09/07/Python-DS-30-mpl_dists/">Matplotlib과 scipy를 함께 사용해서 구현할 수도 있으나</a> </li><li><a href="https://seaborn.pydata.org/generated/seaborn.kdeplot.html">seaborn을 사용하면 간편하게 표현할 수 있습니다.</a></li><li>코드로 직접 seaborn histogram과 함께 비교해봅니다.<br></li></ul><h2 id="3-1-예제-데이터"><a href="#3-1-예제-데이터" class="headerlink" title="3.1. 예제 데이터"></a>3.1. 예제 데이터</h2><ul><li>seaborn에서 제공하는 Penguins dataset을 사용합니다.</li><li>펭귄들의 체중 데이터를 그림으로 그려보겠습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">sns.set_style(<span class="string">&quot;ticks&quot;</span>)</span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line">sns.set_palette(<span class="string">&quot;colorblind&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># penguins dataset 불러오기</span></span><br><span class="line">df_peng = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)</span><br><span class="line">df_peng.head(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><img src="102_kdeplot_08.png"></li></ul><h2 id="3-2-histogram-vs-KDE-plot"><a href="#3-2-histogram-vs-KDE-plot" class="headerlink" title="3.2. histogram vs KDE plot"></a>3.2. histogram vs KDE plot</h2><ul><li><p>histogram과 KDE plot을 차례로 그려 비교합니다.</p></li><li><p>histogram은 구간(bins) 수에 따라 모양이 변합니다.</p></li><li><p>이 글은 KDE plot의 특징에 집중하기 위해 코드 설명은 생략합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Circle</span><br><span class="line"></span><br><span class="line">vmin, vmax = df_peng[<span class="string">&quot;body_mass_g&quot;</span>].<span class="built_in">min</span>(), df_peng[<span class="string">&quot;body_mass_g&quot;</span>].<span class="built_in">max</span>() </span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">10</span>, <span class="number">3.5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, ax <span class="keyword">in</span> <span class="built_in">enumerate</span>(axs, <span class="number">1</span>):</span><br><span class="line">    sns.histplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, bins=<span class="number">10</span>*i, ax=ax)</span><br><span class="line">    ax.set_title(<span class="string">f&quot;bins=<span class="subst">&#123;<span class="number">10</span>*i&#125;</span>&quot;</span>, pad=<span class="number">12</span>, color=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    ymin, ymax = ax.get_ylim()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># changes</span></span><br><span class="line">    circle0 = Circle((<span class="number">0.5</span>, <span class="number">0.5</span>), <span class="number">0.17</span>, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;r&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>, transform=ax.transAxes)</span><br><span class="line">    circle1 = Circle((<span class="number">0.8</span>, <span class="number">0.27</span>), <span class="number">0.17</span>, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;r&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>, transform=ax.transAxes)</span><br><span class="line">    ax.add_patch(circle0)</span><br><span class="line">    ax.add_patch(circle1)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># data min, max</span></span><br><span class="line">    ax.axvline(vmin, c=<span class="string">&quot;orange&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">    ax.axvline(vmax, c=<span class="string">&quot;orange&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p><img src="102_kdeplot_01.png"><br></p></li><li><p>같은 데이터를 10, 20, 30개의 구간을 가진 histogram으로 표현했습니다.</p></li><li><p>bins 수가 늘어날 수록 보이지 않던 봉우리들이 보입니다. (붉은 원)</p></li><li><p>그런데 한편으로 bins 수를 데이터 수만큼 늘리는 경우를 생각하면, 그림이 별 의미가 없어질 것입니다.</p></li><li><p><b>y축 범위</b>에서 bins가 증가할수록 최대 count가 적어지는 것을 볼 수 있습니다.</p></li><li><p>바구니의 범위가 좁아지니 데이터가 덜 담기는 것이 당연합니다.</p></li></ul><ul><li><p>같은 데이터를 KDE plot으로 그립니다.</p></li><li><p><code>seaborn.kdeplot</code>에서는 Kernel size를 bw_adjust라는 매개변수로 조절할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">10</span>, <span class="number">3.5</span>), constrained_layout=<span class="literal">True</span>, </span><br><span class="line">                        sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, ax <span class="keyword">in</span> <span class="built_in">enumerate</span>(axs, <span class="number">1</span>):</span><br><span class="line">    sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, bw_adjust=i**<span class="number">2</span>/<span class="number">4</span>, fill=<span class="literal">True</span>, ax=ax)</span><br><span class="line">    ax.set_title(<span class="string">f&quot;bw_adjust=<span class="subst">&#123;i**<span class="number">2</span>/<span class="number">4</span>:<span class="number">.3</span>f&#125;</span>&quot;</span>, pad=<span class="number">12</span>, color=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    ymin, ymax = ax.get_ylim()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># changes</span></span><br><span class="line">    circle0 = Circle((<span class="number">0.5</span>, <span class="number">0.5</span>), <span class="number">0.1</span>, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;r&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>, transform=ax.transAxes)</span><br><span class="line">    circle1 = Circle((<span class="number">0.62</span>, <span class="number">0.3</span>), <span class="number">0.1</span>, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;r&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>, transform=ax.transAxes)</span><br><span class="line">    ax.add_patch(circle0)</span><br><span class="line">    ax.add_patch(circle1)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># data min, max</span></span><br><span class="line">    ax.axvline(vmin, c=<span class="string">&quot;orange&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">    ax.axvline(vmax, c=<span class="string">&quot;orange&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p><img src="102_kdeplot_02.png"><br></p></li><li><p><code>sharex=True</code>와 <code>sharey=True</code>로 그래프의 x와 y 범위를 통일시켰습니다.</p></li><li><p>bw_adjust가 커질수록 아이스크림이 녹듯 높이가 낮아지고 옆으로 퍼지는 모습이 보입니다.</p></li><li><p>붉은 원으로 표시한 <b>디테일도 점점 사라집니다.</b></p></li><li><p>또한, 오렌지색 선으로 표시한 데이터의 하한선과 상한선을 점점 더 많이 넘어가고 있습니다.</p></li></ul><ul><li><b>데이터 범위를 넘어선다</b>는 것이 KDE plot의 가장 큰 특징입니다.</li><li><b>제한된 데이터로 수집되지 않은 범위까지 추정을 해줄 수 있는 장점</b>으로 작용함과 동시에</li><li><b>존재할 수 없는 데이터를 생성하는 단점</b>으로 작용합니다. (ex. 나이 분포를 그리면 0보다 작은 범위가 생깁니다)</li><li><b>처음에 인용한 기사에서도 1~5점으로 조사했지만 1점이 안 되는 데이터와 5점이 넘는 데이터가 추정되었습니다.</b></li></ul><h2 id="3-3-KDE-plot-기본"><a href="#3-3-KDE-plot-기본" class="headerlink" title="3.3. KDE plot 기본"></a>3.3. KDE plot 기본</h2><ul><li>KDE plot의 특징을 조금 더 알아보겠습니다. </li><li>먼저, <b>밀도 분포</b>라는 개념을 사용하기 때문에 <b>전체 넓이는 1로 조정됩니다.</b><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, ax <span class="keyword">in</span> <span class="built_in">enumerate</span>(axs):</span><br><span class="line">    area = Polygon(axs[<span class="number">0</span>].collections[<span class="number">0</span>].get_paths()[<span class="number">0</span>].vertices).area</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;# area of KDE plot at axs[<span class="subst">&#123;i&#125;</span>] = <span class="subst">&#123;area:<span class="number">.3</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># area of KDE plot at axs[0]= 1.000</span></span><br><span class="line"><span class="comment"># area of KDE plot at axs[1]= 1.000</span></span><br><span class="line"><span class="comment"># area of KDE plot at axs[2]= 1.000</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>seaborn KDE plot 기능을 조금 더 알아봅니다.</p></li><li><p>펭귄 데이터셋에는 Adelie, Chinstrap, Gentoo 펭귄이 있습니다.</p></li><li><p>전체와 함께 이들 각각의 분포를 함께 살펴봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, fill=<span class="literal">True</span>, ax=ax, ec=<span class="string">&quot;gray&quot;</span>, fc=<span class="string">&quot;w&quot;</span>)</span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, fill=<span class="literal">True</span>, hue=<span class="string">&quot;species&quot;</span>, ax=ax)</span><br><span class="line"></span><br><span class="line">xmin, xmax = ax.get_xlim()</span><br><span class="line"></span><br><span class="line"><span class="comment"># legend</span></span><br><span class="line">handles = ax.get_children()[:<span class="number">4</span>]</span><br><span class="line">labels = [<span class="string">&quot;all species&quot;</span>, <span class="string">&quot;Adelie&quot;</span>, <span class="string">&quot;Chinstrap&quot;</span>, <span class="string">&quot;Gentoo&quot;</span>]</span><br><span class="line">ax.legend(handles=handles, labels=labels)</span><br></pre></td></tr></table></figure><p><img src="102_kdeplot_03.png"><br></p></li><li><p>세 종이 다른 분포를 보이며 겹쳐 그려져 있습니다.</p></li><li><p><b>Adelie 펭귄의 분포 일부가 전체의 합보다 높게 그려져 있습니다.</b></p></li><li><p>여기에서도 <b>KDE plot이 정량적으로 부정확할 수 있음을 알 수 있습니다.</b></p></li><li><p>이렇게 나누어 그리면 각각의 넓이가 데이터 비율만큼 표현됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">areas = []</span><br><span class="line"><span class="keyword">for</span> i, (p, label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(ax.get_children()[:<span class="number">4</span>], labels)):</span><br><span class="line">    area = Polygon(p.get_paths()[<span class="number">0</span>].vertices).area</span><br><span class="line">    areas.append(area)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;# area of KDE plot: <span class="subst">&#123;label&#125;</span> = <span class="subst">&#123;area:<span class="number">.3</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># area of KDE plot: all species = 1.000</span></span><br><span class="line"><span class="comment"># area of KDE plot: Adelie = 0.360</span></span><br><span class="line"><span class="comment"># area of KDE plot: Chinstrap = 0.199</span></span><br><span class="line"><span class="comment"># area of KDE plot: Gentoo = 0.441</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-4-데이터-범위-밖-잘라내기"><a href="#3-4-데이터-범위-밖-잘라내기" class="headerlink" title="3.4. 데이터 범위 밖 잘라내기"></a>3.4. 데이터 범위 밖 잘라내기</h2><ul><li>데이터 범위를 벗어나 그려지는 문제를 해결하기 위한 방법으로 <code>cut</code> 매개변수를 제시하고 있습니다.</li><li>smoothing bandwidth에 곱해지는 상수로 기본값은 3입니다.</li><li>크기를 줄이면 적어지는데, <code>cut=0</code>을 입력하면 입력된 데이터 범위까지만 끊습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, fill=<span class="literal">True</span>, ax=ax, ec=<span class="string">&quot;gray&quot;</span>, fc=<span class="string">&quot;w&quot;</span>, cut=<span class="number">0</span>)</span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, fill=<span class="literal">True</span>, hue=<span class="string">&quot;species&quot;</span>, ax=ax, cut=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlim(xmin, xmax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># legend</span></span><br><span class="line">handles = ax.get_children()[:<span class="number">4</span>]</span><br><span class="line">labels = [<span class="string">&quot;all species&quot;</span>, <span class="string">&quot;Adelie&quot;</span>, <span class="string">&quot;Chinstrap&quot;</span>, <span class="string">&quot;Gentoo&quot;</span>]</span><br><span class="line">ax.legend(handles=handles, labels=labels)</span><br></pre></td></tr></table></figure><img src="102_kdeplot_04.png"><br></li></ul><h2 id="3-5-가능한-데이터-범위-밖-잘라내기"><a href="#3-5-가능한-데이터-범위-밖-잘라내기" class="headerlink" title="3.5. 가능한 데이터 범위 밖 잘라내기"></a>3.5. 가능한 데이터 범위 밖 잘라내기</h2><ul><li>수집된 데이터가 가능한 데이터의 일부인 경우가 많습니다.</li><li>이 때 데이터 값으로 끊으면 이 또한 왜곡이 될 수 있기 때문에, 특정 범위를 지정할 수 있습니다.</li><li><code>clip</code>이라는 이름의 매개변수를 사용합니다. 여기서는 <b>2500 ~ 6500 범위</b>로 잘랐습니다. </li><li><code>cut</code>에 비해 덜 잘렸고, 이 범위 안에 있는 Chinstrap과 Gentoo의 오른쪽, 그리고 Adelie의 왼쪽은 전혀 잘리지 않았습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, fill=<span class="literal">True</span>, ax=ax, ec=<span class="string">&quot;gray&quot;</span>, fc=<span class="string">&quot;w&quot;</span>, clip=(<span class="number">2500</span>, <span class="number">6500</span>))</span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, fill=<span class="literal">True</span>, hue=<span class="string">&quot;species&quot;</span>, ax=ax, clip=(<span class="number">2500</span>, <span class="number">6500</span>))</span><br><span class="line"></span><br><span class="line">ax.set_xlim(xmin, xmax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># legend</span></span><br><span class="line">handles = ax.get_children()[:<span class="number">4</span>]</span><br><span class="line">labels = [<span class="string">&quot;all species&quot;</span>, <span class="string">&quot;Adelie&quot;</span>, <span class="string">&quot;Chinstrap&quot;</span>, <span class="string">&quot;Gentoo&quot;</span>]</span><br><span class="line">ax.legend(handles=handles, labels=labels)</span><br></pre></td></tr></table></figure><img src="102_kdeplot_09.png"><br></li></ul><h2 id="3-6-자른-이후의-넓이-확인"><a href="#3-6-자른-이후의-넓이-확인" class="headerlink" title="3.6. 자른 이후의 넓이 확인"></a>3.6. 자른 이후의 넓이 확인</h2><ul><li><p>KDE plot은 밀도 함수이기 때문에 넓이 = 1로 설정된다고 했습니다.</p></li><li><p>그렇지만 <code>cut</code>이나 <code>clip</code>을 적용하면 잘리는 만큼 넓이가 작아집니다.</p></li><li><p><code>cut</code> 적용 전과 뒤를 겹쳐서 확인합니다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># without cut=0</span></span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, fill=<span class="literal">True</span>, ax=ax, ec=<span class="string">&quot;gray&quot;</span>, fc=<span class="string">&quot;w&quot;</span>)</span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, fill=<span class="literal">True</span>, hue=<span class="string">&quot;species&quot;</span>, ax=ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># with cut=0</span></span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, fill=<span class="literal">True</span>, ax=ax, lw=<span class="number">3</span>, ec=<span class="string">&quot;k&quot;</span>, fc=<span class="string">&quot;#FFFFFF00&quot;</span>, cut=<span class="number">0</span>)</span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, fill=<span class="literal">True</span>, hue=<span class="string">&quot;species&quot;</span>, ax=ax, </span><br><span class="line">            cut=<span class="number">0</span>, lw=<span class="number">3</span>, palette=[<span class="string">&quot;b&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;g&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># legend</span></span><br><span class="line">handles = ax.get_children()[:<span class="number">4</span>]</span><br><span class="line">labels = [<span class="string">&quot;all species&quot;</span>, <span class="string">&quot;Adelie&quot;</span>, <span class="string">&quot;Chinstrap&quot;</span>, <span class="string">&quot;Gentoo&quot;</span>]</span><br><span class="line">ax.legend(handles=handles, labels=labels)</span><br></pre></td></tr></table></figure><p><img src="102_kdeplot_05.png"><br></p></li><li><p><code>cut</code>이 적용된 그림은 그저 좌우가 잘릴 뿐임을 알 수 있습니다.</p></li><li><p>그렇다면 넓이도 줄어들 것입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, (p, label, a) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(ax.get_children()[<span class="number">4</span>:<span class="number">8</span>], labels, areas)):</span><br><span class="line">    area = Polygon(p.get_paths()[<span class="number">0</span>].vertices).area</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;# area of KDE plot: <span class="subst">&#123;label&#125;</span> = <span class="subst">&#123;area:<span class="number">.3</span>f&#125;</span> (cf. <span class="subst">&#123;a:<span class="number">.3</span>f&#125;</span>)&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># area of KDE plot: all species = 0.986 (cf. 1.000)</span></span><br><span class="line"><span class="comment"># area of KDE plot: Adelie = 0.353 (cf. 0.360)</span></span><br><span class="line"><span class="comment"># area of KDE plot: Chinstrap = 0.195 (cf. 0.199)</span></span><br><span class="line"><span class="comment"># area of KDE plot: Gentoo = 0.423 (cf. 0.441)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>잘려지는 넓이가 보상되지 않고 있습니다.</p></li><li><p>데이터에 따라, 그리고 수집하는 숫자의 범위에 따라 얼마가 잘려질지는 알 수 없습니다.</p></li><li><p>기사에 나온 그림처럼 분포가 한쪽 끝에 치우쳐 있다면 훨씬 많이 잘려나갈 것입니다.</p></li><li><p>보완 알고리즘을 구현하려 해도 생각보다 복잡합니다. 단순하게 비율을 곱하는 것으로는 부족합니다.</p></li></ul><h1 id="4-결론"><a href="#4-결론" class="headerlink" title="4. 결론"></a>4. 결론</h1><ul><li>KDE plot은 매끈한 곡선으로 이루어져 보기 좋고 겹쳐 그리기 좋아 많이 사용됩니다.</li><li>그러나 확인했듯 단점이 적지 않습니다.</li><li>KDE plot은 참고용으로만 사용하고, 실제 결론은 통계적 분석으로 냅시다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/kdeplot/">kdeplot</category>
      
      
    </item>
    
    <item>
      <title>머신 러닝 파이프라인</title>
      <link>https://jehyunlee.github.io/2022/05/24/Python-DS-101-kierlecture2/</link>
      <guid>https://jehyunlee.github.io/2022/05/24/Python-DS-101-kierlecture2/</guid>
      <pubDate>Tue, 24 May 2022 09:20:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;한국에너지기술연구원 AI 학습조직&lt;/b&gt;에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.&lt;ul&gt;
&lt;li&gt;scikit-learn 기능 중 데이터 전처리와 머신 러닝을 안정적으로 수행할 수 있는 파이프라인을 소개합니다.&lt;/l</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b>한국에너지기술연구원 AI 학습조직</b>에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.<ul><li>scikit-learn 기능 중 데이터 전처리와 머신 러닝을 안정적으로 수행할 수 있는 파이프라인을 소개합니다.</li><li>one-hot encoding과 standard scaling도 그냥 하면 안 됩니다. </li><li>train set으로 학습해서 test set에 적용해야 합니다.</li><li>feature importance는 permutation importance로 확인합시다.</li><li><a href="220524_%EC%9D%B4%EC%A0%9C%ED%98%84_KIERML_2201_pipeline.pdf">강의 자료는 여기에서 다운받으실 수 있습니다</a></li></ul></li></ul><ul><li><p>발표 영상 : (<a href="https://youtu.be/xcSaOtM2PeY">Youtube Link</a>)<br></p></li><li><p>실습 코드 : (<a href="https://bit.ly/3MOtZr6">https://bit.ly/3MOtZr6</a>)<br></p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/xcSaOtM2PeY" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p>* 바쁜 연구원 일정 속에 변동이 있겠지만, 최대한 일정을 지켜보고자 합니다.<p><img src="thumbnail_012.PNG" alt="학습조직 일정"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/pipeline/">pipeline</category>
      
      <category domain="https://jehyunlee.github.io/tags/machine-learning/">machine learning</category>
      
      <category domain="https://jehyunlee.github.io/tags/KIER/">KIER</category>
      
      
    </item>
    
    <item>
      <title>머신 러닝 기본 개념</title>
      <link>https://jehyunlee.github.io/2022/04/26/Python-DS-100-kierlecture1/</link>
      <guid>https://jehyunlee.github.io/2022/04/26/Python-DS-100-kierlecture1/</guid>
      <pubDate>Tue, 26 Apr 2022 12:13:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;한국에너지기술연구원 AI 학습조직&lt;/b&gt;에서는 2022년 한 해동안 머신러닝 진도를 나가기로 했습니다.&lt;ul&gt;
&lt;li&gt;scikit-learn을 중심으로 머신러닝 실습을 할 예정입니다.&lt;/li&gt;
&lt;li&gt;코드를 만지기 전 기본 개념을</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b>한국에너지기술연구원 AI 학습조직</b>에서는 2022년 한 해동안 머신러닝 진도를 나가기로 했습니다.<ul><li>scikit-learn을 중심으로 머신러닝 실습을 할 예정입니다.</li><li>코드를 만지기 전 기본 개념을 전달드리는 강의를 진행했습니다.</li><li><a href="220426_%EC%9D%B4%EC%A0%9C%ED%98%84_%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90_blog.pdf">강의 자료는 여기에서 다운받으실 수 있습니다</a></li></ul></li></ul><ul><li>발표 영상입니다 (<a href="https://youtu.be/Q4ue1G9G4kw">Youtube Link</a>)<br></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/Q4ue1G9G4kw" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <ul><li>바쁜 연구원 일정 속에 변동이 있겠지만, 최대한 일정을 지켜보고자 합니다.</li></ul><p><img src="thumbnail_012.PNG" alt="학습조직 일정"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/machine-learning/">machine learning</category>
      
      <category domain="https://jehyunlee.github.io/tags/KIER/">KIER</category>
      
      
    </item>
    
    <item>
      <title>reliability of Covid-19 self test kit</title>
      <link>https://jehyunlee.github.io/2022/04/23/Python-DS-99-covidprec/</link>
      <guid>https://jehyunlee.github.io/2022/04/23/Python-DS-99-covidprec/</guid>
      <pubDate>Sat, 23 Apr 2022 12:51:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;코로나-19 자가진단키트에서 두 줄이 떴습니다.&lt;/li&gt;
&lt;li&gt;올 게 왔나 싶으면서도, 이거 얼마나 믿을만한지 몹시 궁금했습니다.&lt;/li&gt;
&lt;li&gt;선별진료소 결과를 기다리며 분류 기초를 복습합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>코로나-19 자가진단키트에서 두 줄이 떴습니다.</li><li>올 게 왔나 싶으면서도, 이거 얼마나 믿을만한지 몹시 궁금했습니다.</li><li>선별진료소 결과를 기다리며 분류 기초를 복습합니다.</li></ul><h1 id="1-사건의-발단"><a href="#1-사건의-발단" class="headerlink" title="1. 사건의 발단"></a>1. 사건의 발단</h1><blockquote><p><a href="https://blog.naver.com/kfdazzang/222640236513">식품의약품안전처: 자가진단키트 양성예측도 76%</a><br><a href="https://www.khan.co.kr/national/health-welfare/article/202202080845011">경향신문: 자가검사키트, 민감도 특이도는 뭐고 양성예측도는 또 뭔가요?</a></p></blockquote><p><img src="99_cp_02.jpg"><br></p><ul><li><b>3일 전,</b> 안녕하시냐고 묻는 안녕하지 못한 내용의 문자가 왔다.</li><li>업무 효율화 관련해서 자주 뵙던 분이 걸렸단다. 문자로 안부를 여쭈니 다행히 괜찮다고 하신다.</li><li>바닷가에서 학회 발표를 준비하다 말고 10여분 차를 달려 읍내에 갔다.</li><li>병원에서 신속항원검사 음성확인서를 받았지만 기분 탓인지 목이 아프다.<br></li></ul><p><img src="99_cp_01.PNG" alt="잘 보면 보입니다."><br></p><ul><li>그리고 오늘, <b>자가진단키트에 매우 희미하지만 두 줄이 떴다.</b></li><li>주말 저녁이라 신속항원검사를 할 동네 병원은 모두 닫았고, 시청 선별진료소에서 검사를 했다.</li><li><b>“두 줄 맞습니다. 이쪽에서 검사받으세요. 결과는 내일 아침 9시 전에 나옵니다.”</b></li></ul><ul><li><p>훨씬 정확하다는 PCR 검사가 나오겠지만 <b>자가진단키트의 신뢰도가 궁금해졌다.</b></p></li><li><p><b>민감도<code>sensitivity</code> 90%</b>, <b>특이도<code>specificity</code> 99%</b>. </p></li><li><p>그런데 <b>양성예측도<code>positive predictive value (PPV)</code> 76%</b>.</p></li><li><p>내 밥벌이이고, 비슷한 문제를 몇 번이나 손계산으로 풀었는데도 왜 이런지 헷갈린다.</p></li><li><p>그래서 얼마나 잘 맞는 거냐는 기자의 마음이 이해가 간다.<br><br><img src="99_cp_03.PNG"><br></p></li><li><p>기자는 <b>“공식은 모르겠고”</b>라고 해도 되지만 난 그러면 안 된다.</p></li><li><p>당사자가 된 이상 최선을 다해 정리해보자.</p></li><li><p>지금처럼 이 문제에 진심인 적이 없다.</p></li></ul><h1 id="2-복잡한-분류-예측"><a href="#2-복잡한-분류-예측" class="headerlink" title="2. 복잡한 분류 예측"></a>2. 복잡한 분류 예측</h1><blockquote><p><a href="https://3months.tistory.com/318">쉽게 이해하는 특이도, 민감도, 양성 예측도</a><br><a href="https://en.wikipedia.org/wiki/Sensitivity_and_specificity">wikipedia: sensitivity and specificity</a></p></blockquote><ul><li>분류 예측 문제는 모델링보다 평가가 훨씬 복잡하다.</li><li>단순히 맞다/틀리다로 끝나는게 아니기 때문이다.</li></ul><ul><li>어떤 마을 1000명 중 100명이 폐암에 걸렸고, 이들이 병원에서 진단을 받는다고 하자.</li><li>진단 기기나 의사의 판단이 100% 정확하지 않기 때문에 <b>오진이 발생한다</b>.</li><li><b>병이 없는데 환자 진단을 받기도 하고</b>, <b>환자에게 정상이라고 하기도 한다</b>.<br><br><img src="99_cp_04.PNG"><br></li></ul><h2 id="2-1-전지적-의사-시점"><a href="#2-1-전지적-의사-시점" class="headerlink" title="2.1. 전지적 의사 시점"></a>2.1. 전지적 의사 시점</h2><ul><li>여기서 <b>진단을 잘 했다</b>는 둘로 나뉜다.</li><li><b>(1) 환자를 환자라고 하는 경우 : 민감도</b> = $\dfrac{90}{90+10} = 90$%</li><li><b>(2) 비환자를 비환자라고 하는 경우 : 특이도</b> = $\dfrac{800}{800+100} = 89$%</li><li>둘 다 준수하다.</li></ul><h2 id="2-2-환자의-시점"><a href="#2-2-환자의-시점" class="headerlink" title="2.2. 환자의 시점"></a>2.2. 환자의 시점</h2><ul><li>하지만 환자의 입장은 조금 다르다. <b>본인이 받은 진단의 신뢰도</b>가 중요하다.</li><li><b>(1) 양성(암) 진단을 받은 경우 : 양성 예측도</b> = $\dfrac{90}{90+100} = 47$%</li><li><b>(2) 음성(정상) 진단을 받은 경우 : 음성 예측도</b> = $\dfrac{800}{800+10} = 99$%</li><li>음성 예측도는 매우 높지만 양성 예측도가 크게 낮다. 데이터가 1:9로 불균일하기 때문이다. </li><li><b>귀찮은 의사가 대충 음성이라고 해도 맞출 확률이 90%인 것이다.</b></li></ul><h1 id="3-코로나-19"><a href="#3-코로나-19" class="headerlink" title="3. 코로나-19"></a>3. 코로나-19</h1><blockquote><p><a href="https://coronaboard.kr/">코로나-19 실시간 현황판</a><br><a href="https://jumin.mois.go.kr/">행정안전부: 주민등록 인구 통계</a><br><a href="https://www.hani.co.kr/arti/society/health/1029592.html">한겨레: ‘가짜양성’ 넷 중 하나… 자가키트 양성 뒤 PCR 음성 23.9%</a></p></blockquote><h2 id="3-1-자가진단키트-검사자-시점"><a href="#3-1-자가진단키트-검사자-시점" class="headerlink" title="3.1. 자가진단키트 검사자 시점"></a>3.1. 자가진단키트 검사자 시점</h2><ul><li>자가진단키트의 민감도와 특이도는 각기 90%와 99%.</li><li>그리고 2022.04.23. 현재 우리 나라의 누적 확진자는 <b>16,830,469명</b></li><li>우리 나라의 <b>총 인구는 51,610,695명</b> 고려시 <b>확진자 비율은 32.6%.</b></li><li>신속항원검사와 PCR로 <b>최종 검증이 된다 가정</b>하고 종합하면 다음과 같은 그림이 그려진다.<br></li></ul><p><img src="99_cp_05.PNG"><br></p><ul><li>PCR보다 <b>자가진단키트가 확진자를 3%가량 덜 잡아내고 있으며</b>,</li><li>(1) 양성(확진) 진단을 받은 경우 : 양성 예측도</b> = $\dfrac{29.3}{29.3 + 0.7} = 97.7$%</li><li>(2) 음성(미확진) 진단을 받은 경우 : 음성 예측도</b> = $\dfrac{66.7}{66.7 + 3.3} = 95.3$%</li><li><b>생각보다 자가진단키트가 믿을만 하다</b>는 결론인데,</li><li>한때 <a href="https://www.hani.co.kr/arti/society/health/1029592.html">자가키트의 신뢰성 문제</a>가 언론에 보도된 때는 2월 5일로 <b>오미크론이 본격적으로 유행하기 전</b>이었다. <br></li></ul><p><img src="99_cp_06.PNG"><br></p><ul><li>앞서 양성예측도 76% 계산시 전국민의 3%가 감염되었다는 것을 가정한 것에 비해 10배 가량 많기 때문에 <b>데이터 불균형에 의한 문제가 해소</b>되었다고 볼 수 있다.</li></ul><h2 id="3-2-유병률-영향"><a href="#3-2-유병률-영향" class="headerlink" title="3.2. 유병률 영향"></a>3.2. 유병률 영향</h2><ul><li>양성 예측도와 음성 예측도 모두 전국민 중 얼마나 병에 걸렸냐는 <b>유병률<code>prevalence</code></b>의 영향을 받는다.</li><li>수식으로 표현하면 다음과 같다.<br></li></ul><p>$$양성예측도 PPV = \frac{민감도 \cdot 유병률}{민감도 \cdot 유병률 + (1- 특이도) \cdot (1 - 유병률)}$$</p><br><p>$$음성예측도 NPV = \frac{특이도 \cdot (1-유병률)}{특이도 \cdot (1-유병률) + (1-민감도) \cdot 유병률}$$</p><ul><li>자가진단키트 기준인 <b>민감도 90%</b>와 <b>특이도 99%</b>를 넣고 그림을 그리면 이렇다.</li><li>데이터 불균형 문제가 해결되어 두 예측도가 모두 높은 상황임을 알 수 있다.</li></ul><p><img src="99_cp_07.PNG"><br></p><h2 id="3-3-민감도와-특이도-영향력"><a href="#3-3-민감도와-특이도-영향력" class="headerlink" title="3.3. 민감도와 특이도 영향력"></a>3.3. 민감도와 특이도 영향력</h2><ul><li><p>자가진단키트가 불량이거나 검사 방법이 제대로 이루어지지 않은 경우, </p></li><li><p><b>민감도와 특이도가 기대치에 미치지 못할 수 있다</b>.</p></li><li><p>특이도를 99%로 고정하고 민감도를 50%까지 떨어트리면 <b>양성예측도는 별 차이가 없는 반면 음성예측도가 80%까지 감소한다</b>.<br><br><img src="99_cp_08.PNG"><br></p></li><li><p>거꾸로, 민감도를 90%로 고정하고 특이도만 60%까지 떨어트리면 <b>양성예측도가 50% 수준으로 감소한다</b>. <br><br><img src="99_cp_09.PNG"><br></p></li><li><p>공장에서 제품이 제대로 나온다는 가정 하에, <b>올바른 검사 방법</b>이 가장 중요한 요소일지도 모른다.</p></li></ul><h1 id="4-결론"><a href="#4-결론" class="headerlink" title="4. 결론"></a>4. 결론</h1><ul><li><b>검사를 제대로 했다는 전제 하에,</b></li><li>즉 자가진단키트가 실제로 민감도 90%와 특이도 99%를 발휘한다는 전제 하에 상당히 믿을 만한 수준이다.</li><li>많은 분들이 코로나-19에 걸리지 않고 무사히 이 시기를 지나가기를 바란다.</li></ul><h1 id="5-에필로그"><a href="#5-에필로그" class="headerlink" title="5. 에필로그"></a>5. 에필로그</h1><blockquote><p><a href="https://www.docdocdoc.co.kr/news/articleView.html?idxno=2009532">청년의사: 신속항원진단키트로 입원 전 코로나 검사했더니 민감도 17.5%</a><br><a href="https://www.docdocdoc.co.kr/news/articleView.html?idxno=2022211&utm_source=dable">청년의사: 이비인후과 전문의 60% ‘자가검사키트 정확도 절반 이하’ 우려</a><br><a href="https://www.chosun.com/national/welfare-medical/2022/03/14/CZG6DUQLFJHLVHQ6QRRGUPFQDE/">조선일보: 신속항원검사 11%는 음성을 양성으로 판정</a></p></blockquote><ul><li><b>PCR 검사 결과 음성.</b></li><li>결론적으로 <b>위양성(False Positive)</b>이었다.<br></li></ul><p><img src="99_cp_10.jpg"><br></p><ul><li>자가진단키트의 신뢰성에 대해 지속적으로 의문이 제기되고 있다.</li><li><b>민감도 문제가 특히 심각하다고 하다.</b> <br></li></ul><p><img src="99_cp_12.png" alt="청년의사: 2022.04.22. 기사"><br></p><ul><li>잘 찌른 자가진단키트와 유사할 <b>신속항원검사가 음성을 양성으로 판정하는 비율이 11%라고 한다.</b></li><li>내가 이 11%에 들었던 것 같다.</li><li>결론이 무엇이건, 확률이 어쨌건, 모두 건강하자.<br></li></ul><p><img src="99_cp_13.png" alt="조선일보: 2022.03.14. 기사"><br></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/statistics/">statistics</category>
      
      <category domain="https://jehyunlee.github.io/tags/classification/">classification</category>
      
      
    </item>
    
    <item>
      <title>ridge-map</title>
      <link>https://jehyunlee.github.io/2022/04/17/Python-DS-98-ridgemap/</link>
      <guid>https://jehyunlee.github.io/2022/04/17/Python-DS-98-ridgemap/</guid>
      <pubDate>Sat, 16 Apr 2022 20:12:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;지형을 중첩된 line plot으로 그리는 ridgemap 라이브러리를 소개합니다.&lt;/li&gt;
&lt;li&gt;Matplotlib 생태계의 일원으로 쉽게 사용할 수 있습니다.&lt;/li&gt;
&lt;li&gt;소스 코드를 조금 고쳐줄 필요가 있습니다.&lt;/li&gt;
&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>지형을 중첩된 line plot으로 그리는 ridgemap 라이브러리를 소개합니다.</li><li>Matplotlib 생태계의 일원으로 쉽게 사용할 수 있습니다.</li><li>소스 코드를 조금 고쳐줄 필요가 있습니다.</li></ul><h1 id="1-ridge-map"><a href="#1-ridge-map" class="headerlink" title="1. ridge-map"></a>1. ridge-map</h1><blockquote><p><a href="https://pypi.org/project/ridge-map/">pypi: ridge-map/</a></p></blockquote><ul><li>설명 대신 그림을 한 장 보여드리겠습니다.</li></ul><p><img src="98_ridgemap_01.png"><br></p><ul><li><p>아름다운 산악 지형의 풍경이 고전적인 느낌으로 그려져 있습니다.</p></li><li><p>이 그림은 ridge-map 라이브러리를 사용해서 그린 것으로, 코드는 다음과 같습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rm = RidgeMap((<span class="number">11.098251</span>,<span class="number">47.264786</span>,<span class="number">11.695633</span>,<span class="number">47.453630</span>))</span><br><span class="line">values = rm.get_elevation_data(num_lines=<span class="number">150</span>)</span><br><span class="line">values=rm.preprocess(</span><br><span class="line">    values=values,</span><br><span class="line">    lake_flatness=<span class="number">2</span>,</span><br><span class="line">    water_ntile=<span class="number">10</span>,</span><br><span class="line">    vertical_ratio=<span class="number">240</span>)</span><br><span class="line">rm.plot_map(values=values,</span><br><span class="line">            label=<span class="string">&#x27;Karwendelgebirge&#x27;</span>,</span><br><span class="line">            label_y=<span class="number">0.1</span>,</span><br><span class="line">            label_x=<span class="number">0.55</span>,</span><br><span class="line">            label_size=<span class="number">40</span>,</span><br><span class="line">            linewidth=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>별다른 설명이 없이도 대강 감이 오는 코드입니다.</p></li></ul><h1 id="2-ridge-map-설치"><a href="#2-ridge-map-설치" class="headerlink" title="2. ridge-map 설치"></a>2. ridge-map 설치</h1><blockquote><p><a href="https://github.com/ColCarroll/ridge_map/pull/34">ridge-map issue: Google font</a></p></blockquote><ul><li><p>설치는 어렵지 않습니다. pypi에서 다음 명령을 실행하면 간단히 이루어집니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install ridge_map</span><br></pre></td></tr></table></figure></li><li><p>하지만 약간의 문제가 있습니다.</p></li><li><p>기본적으로 사용하는 google font 경로가 바뀌면서 오류가 발생합니다.</p></li><li><p>이 때문에 <b>소스 코드 일부를 수정해야 합니다.</b></p></li></ul><ul><li>파이썬이 설치된 경로를 찾아 <code>파이썬설치경로/site-packages/ridge_map/ridge_map.py</code>를 수정합니다.</li><li>32번째 줄 <code>github_url</code>부분을 다음과 같이 바꿉니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github_url=<span class="string">&quot;https://github.com/google/fonts/blob/5c3d8ef085f3084db38936d0dcd39a567dbc1e01/ofl/cinzel/static/Cinzel-Regular.ttf?raw=true&quot;</span>, <span class="comment"># pylint: disable=line-too-long</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="3-지도-그리기"><a href="#3-지도-그리기" class="headerlink" title="3. 지도 그리기"></a>3. 지도 그리기</h1><ul><li>rige-map으로 지도를 그릴 수 있습니다.</li><li>지도를 그릴 때 필요한 첫 번째 요소는 <b>경도</b>와 <b>위도</b>입니다.</li><li><b>왼쪽 아래</b>와 <b>오른쪽 위</b>지점의 경도와 위도를 <b><code>Ridgemap()</code></b>에 차례로 입력합니다.</li><li>구글 지도에서 쉽게 위도와 경도를 확인할 수 있습니다.</li></ul><p><img src="98_ridgemap_02.png"><br></p><ul><li>구글 지도에서 한 지점을 클릭하면 빨간 마커가 생깁니다.</li><li>주소창 맨 오른쪽 끝에 숫자 두 개가 숨어 있습니다.</li><li>앞에서부터 해당 지점의 <b>위도</b>와 <b>경도</b>이므로 순서를 바꾸어 입력해야 합니다.</li></ul><h2 id="3-1-서울-지도"><a href="#3-1-서울-지도" class="headerlink" title="3.1. 서울 지도"></a>3.1. 서울 지도</h2><ul><li>서울의 좌표를 입력합니다.</li><li>구글 지도에서 대략 <code>(126.8403339,37.4157432,127.1661446,37.7104195)</code>로 입력했습니다.</li><li><code>rm.plot_map()</code>은 Matplotlib Axes 객체를 반환합니다.</li><li>이를 ax라는 이름으로 받아 <code>fig = ax.figure</code>로 Figure 객체를 추출하고,</li><li><code>fig.tight_layout()</code>로 여백을 줄이고 <code>fig.savefig()</code>로 파일로 저장합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rm = RidgeMap((<span class="number">126.8403339</span>,<span class="number">37.4157432</span>,<span class="number">127.1661446</span>,<span class="number">37.7104195</span>))</span><br><span class="line">values = rm.get_elevation_data(num_lines=<span class="number">150</span>)</span><br><span class="line">values=rm.preprocess(</span><br><span class="line">    values=values,</span><br><span class="line">    lake_flatness=<span class="number">2</span>,</span><br><span class="line">    water_ntile=<span class="number">10</span>,</span><br><span class="line">    vertical_ratio=<span class="number">100</span>)</span><br><span class="line">ax = rm.plot_map(values=values,</span><br><span class="line">            label=<span class="string">&#x27;Seoul, Korea&#x27;</span>,</span><br><span class="line">            label_y=<span class="number">0.1</span>,</span><br><span class="line">            label_x=<span class="number">0.7</span>,</span><br><span class="line">            label_size=<span class="number">40</span>,</span><br><span class="line">            linewidth=<span class="number">1.2</span>)</span><br><span class="line"></span><br><span class="line">fig = ax.figure</span><br><span class="line">fig.tight_layout()</span><br><span class="line">fig.savefig(<span class="string">&quot;98_ridgemap_03.png&quot;</span>)</span><br></pre></td></tr></table></figure><img src="98_ridgemap_03.png"><br></li></ul><h2 id="3-2-서울-지도-고도"><a href="#3-2-서울-지도-고도" class="headerlink" title="3.2. 서울 지도 + 고도"></a>3.2. 서울 지도 + 고도</h2><ul><li><p>선에 색을 입혀 고도를 표현할 수 있습니다.</p></li><li><p>위 코드의 <code>rm.plot_map()</code>에 두 줄을 추가합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kind=<span class="string">&quot;elevation&quot;</span>,</span><br><span class="line">line_color=plt.get_cmap(<span class="string">&#x27;gist_earth&#x27;</span>),</span><br></pre></td></tr></table></figure><p><img src="98_ridgemap_04.png"><br></p></li><li><p>북한산과 관악산이 잘 드러납니다.</p></li></ul><h2 id="3-3-Matplotlib-Axes-삽입"><a href="#3-3-Matplotlib-Axes-삽입" class="headerlink" title="3.3. Matplotlib Axes 삽입"></a>3.3. Matplotlib Axes 삽입</h2><ul><li><code>rm.plot_map()</code>은 Matplotlib Axes를 출력합니다.</li><li>따라서 Matplotlib에서 만들어둔 Figure와 Axes를 사용한 연출이 가능합니다.</li><li><code>rm.plot_map()</code> 안에 <code>ax=</code>매개변수를 삽입해서 출력 지점을 지정합니다.</li><li>서울, 대전, 목포, 제주 4개 지역을 한번에 표현합니다.</li><li>축적이 맞지 않음은 유의해야 합니다.</li></ul><ul><li><code>FontManager</code>로 글꼴을 바꿀 수 있습니다.</li><li>적절한 글꼴을 골라 경로를 지정하고, <code>Ridgemap()</code>에 <code>font=font.prop</code>을 추가합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ridge_map <span class="keyword">import</span> FontManager</span><br><span class="line">font = FontManager(<span class="string">&#x27;https://github.com/google/fonts/blob/main/ofl/arsenal/Arsenal-Bold.ttf?raw=true&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(ncols=<span class="number">2</span>, nrows=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">seoul = (<span class="number">126.8403339</span>, <span class="number">37.4157432</span>, <span class="number">127.1661446</span>, <span class="number">37.7104195</span>)</span><br><span class="line">daejeon = (<span class="number">127.2614837</span>, <span class="number">36.2194529</span>, <span class="number">127.6025534</span>, <span class="number">36.5002879</span>)</span><br><span class="line">mokpo = (<span class="number">126.3071108</span>, <span class="number">34.6873927</span>, <span class="number">126.5647852</span>, <span class="number">34.9315327</span>)</span><br><span class="line">jeju = (<span class="number">126.1623888</span>, <span class="number">33.1179613</span>, <span class="number">126.9962384</span>, <span class="number">33.7520832</span>)</span><br><span class="line"></span><br><span class="line">places = [seoul, daejeon, mokpo, jeju]</span><br><span class="line">names = [<span class="string">&quot;Seoul&quot;</span>, <span class="string">&quot;Daejeon&quot;</span>, <span class="string">&quot;Mokpo&quot;</span>, <span class="string">&quot;Jeju&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> place, name, ax <span class="keyword">in</span> <span class="built_in">zip</span>(places, names, axes.ravel()):</span><br><span class="line">    rm = RidgeMap(place, font=font.prop)</span><br><span class="line">    values = rm.get_elevation_data(num_lines=<span class="number">150</span>)</span><br><span class="line">    values=rm.preprocess(</span><br><span class="line">        values=values,</span><br><span class="line">        lake_flatness=<span class="number">2</span>,</span><br><span class="line">        water_ntile=<span class="number">10</span>,</span><br><span class="line">        vertical_ratio=<span class="number">100</span>)</span><br><span class="line">    rm.plot_map(values=values,</span><br><span class="line">                label=<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>, Korea&#x27;</span>,</span><br><span class="line">                label_y=<span class="number">0.1</span>,</span><br><span class="line">                label_x=<span class="number">0.45</span>,</span><br><span class="line">                label_size=<span class="number">20</span>,</span><br><span class="line">                linewidth=<span class="number">1.2</span>,</span><br><span class="line">                background_color=<span class="string">&quot;w&quot;</span>,</span><br><span class="line">                kind=<span class="string">&quot;elevation&quot;</span>,</span><br><span class="line">                line_color=plt.get_cmap(<span class="string">&#x27;gist_earth&#x27;</span>),</span><br><span class="line">                ax=ax)</span><br><span class="line">    </span><br><span class="line">fig = ax.figure</span><br><span class="line">fig.tight_layout()</span><br><span class="line">fig.savefig(<span class="string">&quot;98_ridgemap_05.png&quot;</span>)</span><br></pre></td></tr></table></figure><img src="98_ridgemap_05.png"><br></li></ul><h1 id="4-데이터"><a href="#4-데이터" class="headerlink" title="4. 데이터"></a>4. 데이터</h1><blockquote><p><a href="https://www2.jpl.nasa.gov/srtm/">NASA: Shuttle Radar Topography Mision (SRTM)</a></p></blockquote><ul><li>해발고도 데이터는 2000년에 수집된 NASA의 SRTM을 사용합니다.</li><li>1 arc-second 단위로, 약 30m 수준의 해상도를 보유하고 있습니다.</li><li>단 북위 60도와 남위 60도를 넘어서는 지역은 데이터가 없습니다.<br><br><img src="98_ridgemap_06.gif"><br></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/gis/">gis</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/ridge-map/">ridge-map</category>
      
      
    </item>
    
    <item>
      <title>AI를 하고 싶은 C-level의 흔한 실수들</title>
      <link>https://jehyunlee.github.io/2022/03/28/Python-DS-97-ceo_mistakes/</link>
      <guid>https://jehyunlee.github.io/2022/03/28/Python-DS-97-ceo_mistakes/</guid>
      <pubDate>Sun, 27 Mar 2022 17:13:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;&lt;a href=&quot;https://www.innopolis.or.kr/mps&quot;&gt;연구개발특구(innopolis)&lt;/a&gt;&lt;/b&gt;에서 CEO 대상 AI 인사이트 교육 발표를 했습니다. (22.03.24.)&lt;ul&gt;
&lt;li&gt;공지된 제목은 &lt;b</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b><a href="https://www.innopolis.or.kr/mps">연구개발특구(innopolis)</a></b>에서 CEO 대상 AI 인사이트 교육 발표를 했습니다. (22.03.24.)<ul><li>공지된 제목은 <b>데이터, 다이아몬드 또는 진흙</b>이었습니다만</li><li>제 앞에서 발표하신 고우영 님의 발표를 보고 연장선상에서 바꿨습니다.</li><li>수정된 제목은 <b>AI를 하고 싶은 C-level의 흔한 실수들</b>입니다.</li></ul></li></ul><ul><li>발표 영상입니다 (<a href="https://youtu.be/mcIU5Fk-pFo">Youtube Link</a>)<br></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/mcIU5Fk-pFo" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <ul><li><b>AI는 회사를 운영하는 방식을 바꾸는 일</b>이기 때문에 굵직한 의사 결정이 많이 필요합니다.<ul><li>“갖다쓰면 되겠지”, “남들도 한다는데”라는 마인드로는 실패할 확률이 매우 큽니다.</li><li>실무자가 필요로 하는 것이 무엇인지, 왜인지, 진짜인지를 알기 위해서라도 공부하셔야 합니다.</li><li>전 직장의 경험담을 위주로 구성했습니다. </li><li>전달력을 위해 여러 사례를 합치기도 했고 나누기도 했습니다. 이 점을 참고해 주시면 좋겠습니다.</li></ul></li></ul><p><img src="poster.jpg" alt="연구개발특구 행사 공지"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/AI-Frenz/">AI Frenz</category>
      
      <category domain="https://jehyunlee.github.io/tags/C-level/">C-level</category>
      
      
    </item>
    
  </channel>
</rss>
