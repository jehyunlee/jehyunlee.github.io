<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Pega Devlog</title>
    <link>https://jehyunlee.github.io/</link>
    
    <atom:link href="https://jehyunlee.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Pega&#39;s Development log for myself and others</description>
    <pubDate>Wed, 01 Feb 2023 20:12:27 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>신천식의 이슈토론 - 과학자 그들은 누구인가? 과학자가 행복한 도시는?</title>
      <link>https://jehyunlee.github.io/2023/02/02/Python-General-15-scs_issue/</link>
      <guid>https://jehyunlee.github.io/2023/02/02/Python-General-15-scs_issue/</guid>
      <pubDate>Wed, 01 Feb 2023 20:11:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;중도TV &lt;b&gt;신천식의 이슈토론&lt;/b&gt;에 패널로 출연했습니다.&lt;ul&gt;
&lt;li&gt;&lt;b&gt;과학자 그들은 누구인가? 과학자가 행복한 도시는?&lt;/b&gt;이라는 주제로 대화를 나눴고,&lt;/li&gt;
&lt;li&gt;채연석 박사님 (前항공우주연구원장, 現국토교통부 항</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>중도TV <b>신천식의 이슈토론</b>에 패널로 출연했습니다.<ul><li><b>과학자 그들은 누구인가? 과학자가 행복한 도시는?</b>이라는 주제로 대화를 나눴고,</li><li>채연석 박사님 (前항공우주연구원장, 現국토교통부 항공,철도사고조사위원회 위원장),<br>유용균 박사 (한국원자력연구원 인공지능응용연구실 실장, AI프렌즈 즈장)<br>두 분과 함께 말씀을 나눴습니다.</li></ul></li></ul><ul><li>영상 : (<a href="https://youtu.be/gDC7agLJFeY">Youtube Link</a>)<br></li><li>기사 : <a href="http://www.joongdo.co.kr/web/view.php?key=20230201010000231">중도일보, “[신천식의 이슈토론]과학자 그들은 누구인가, 과학자들이 행복한 대전”</a></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/gDC7agLJFeY" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><img src="15_scs_issue_01.png" alt="신천식의 이슈토론이 1일 오전 10 중도일보 스튜디오에서 &#39;과학자 그들운 누구인가, 과학자들이 행복한 대전&#39;을 주제로 진행됐다. (왼쪽부터)최연석 전 항공우주연구원장, 신천식 박사, 유용균 원자력 연구원 박사, 이제헌 한국에너지기술 연구원 박사"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/youtube/">youtube</category>
      
      
    </item>
    
    <item>
      <title>연구소의 문헌분석 기술 활용</title>
      <link>https://jehyunlee.github.io/2023/01/09/Python-DS-126-labnlp/</link>
      <guid>https://jehyunlee.github.io/2023/01/09/Python-DS-126-labnlp/</guid>
      <pubDate>Mon, 09 Jan 2023 02:21:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;2022년 12월 13일 &lt;b&gt;모두의 연구소&lt;/b&gt; 초청으로  &lt;b&gt;MODUPOP&lt;/b&gt; 강연을 했습니다.&lt;ul&gt;
&lt;li&gt;몸담고 있는 연구원에서 적용하고 있는 문헌분석 기술을 공유드렸습니다.&lt;/li&gt;
&lt;li&gt;짧은 시간에 압축해서 전달드</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>2022년 12월 13일 <b>모두의 연구소</b> 초청으로  <b>MODUPOP</b> 강연을 했습니다.<ul><li>몸담고 있는 연구원에서 적용하고 있는 문헌분석 기술을 공유드렸습니다.</li><li>짧은 시간에 압축해서 전달드린터라 세부 기술보다는 적용처 중심으로 봐주시면 감사하겠습니다.</li><li>저녁 7시부터 시작된 강의였고, 비와 눈으로 날씨가 많이 나쁜 날이었습니다.</li><li>귀중한 시간을 내서 온라인, 오프라인으로 참석해주신 분들께 다시 한번 감사드립니다.</li><li>초반 2분 가량 소리가 조금 울립니다. 양해 부탁드립니다.</li></ul></li></ul><ul><li>발표 영상 : (<a href="https://youtu.be/fuyOoDBZc1k">Youtube Link</a>)<br></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/fuyOoDBZc1k" frameborder="0" loading="lazy" allowfullscreen></iframe></div> ]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/KIER/">KIER</category>
      
      <category domain="https://jehyunlee.github.io/tags/API/">API</category>
      
      <category domain="https://jehyunlee.github.io/tags/NLP/">NLP</category>
      
      
    </item>
    
    <item>
      <title>Impact of RPA</title>
      <link>https://jehyunlee.github.io/2023/01/01/Python-DS-125-rpa/</link>
      <guid>https://jehyunlee.github.io/2023/01/01/Python-DS-125-rpa/</guid>
      <pubDate>Sun, 01 Jan 2023 07:02:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;RPA(Robotic Process Automation: 업무 자동화) 과제를 하려고 합니다.&lt;/li&gt;
&lt;li&gt;RPA를 적용하면 효용이 얼마나 좋은지를 설득하기 위한 그림을 그립니다.&lt;/li&gt;
&lt;li&gt;RPA 도입 전과 후를 비교하는 그</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>RPA(Robotic Process Automation: 업무 자동화) 과제를 하려고 합니다.</li><li>RPA를 적용하면 효용이 얼마나 좋은지를 설득하기 위한 그림을 그립니다.</li><li>RPA 도입 전과 후를 비교하는 그림을 그려서 보여줍시다.</li></ul><h1 id="1-행정-업무"><a href="#1-행정-업무" class="headerlink" title="1. 행정 업무"></a>1. 행정 업무</h1><p><img src="125_rpa_01.png"></p><ul><li><p>어떤 가상의 데이터 관련 행정 업무가 있다고 합시다.</p></li><li><p>현재는 <b>총 2천만원의 용역비</b>를 포함해 <b>12주</b>가 걸립니다. <b>수작업</b>이기 때문입니다.</p></li><li><p>여기에 RPA를 적용하면, <b>용역비가 없어지고</b> 이어지는 작업도 훨씬 짧게 걸립니다.</p></li><li><p>서류 작업과 취합 작업도 단순 반복 작업에서 <b>검증으로 업무 성격이 바뀝니다.</b><br></p></li><li><p><b>보고서</b>나 <b>기획서</b>등에서 이 훌륭한 업무를 어필하고 싶습니다.</p></li><li><p>일단 <a href="RPA_comparison.xlsx">엑셀로 정리</a>해보니 이렇습니다. 전달은 되는데 아쉽습니다.<br><br><img src="125_rpa_02.png"><br></p></li></ul><h1 id="2-시각화"><a href="#2-시각화" class="headerlink" title="2. 시각화"></a>2. 시각화</h1><h2 id="2-1-용역-비용-amp-인력"><a href="#2-1-용역-비용-amp-인력" class="headerlink" title="2.1. 용역 비용 &amp; 인력"></a>2.1. 용역 비용 &amp; 인력</h2><ul><li>RPA 효과는 크게 두 가지입니다. 하나는 <b>용역 비용</b>, 하나는 <b>인력</b></li><li>인력도 man-week (MW)으로 정리했기 때문에 담당자의 연봉을 적용하면 비용 산정이 됩니다.</li><li>하지만 여기선 용역은 용역, 인력은 인력으로 나누어 그리기로 합니다.</li><li>항목 수에 따라 용역 비용과 인력이 그려질 공간을 1:3의 비율로 분할합니다.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), gridspec_kw=&#123;<span class="string">&quot;width_ratios&quot;</span>:[<span class="number">1</span>, <span class="number">3</span>]&#125;)</span><br></pre></td></tr></table></figure><img src="125_rpa_03.png"><br></li></ul><h2 id="2-2-용역-비용"><a href="#2-2-용역-비용" class="headerlink" title="2.2. 용역 비용"></a>2.2. 용역 비용</h2><ul><li>왼쪽 공간에 RPA 적용 전 2천만원이 들어간 용역 비용과 적용 후 0원이 된 것을 비교하여 그립니다.</li><li>이럴 때는 grouped bar plot이 제격입니다.</li><li>용역 비용 뿐 아니라 다른 모든 항목을 비교할 것이기 때문에 <b>RPA 전</b>과 <b>RPA 후</b> 비교에 일관성이 필요합니다.</li><li>적용 전과 후를 <b>“brown”</b>과 <b>“royalblue”</b>로 표기합니다.</li></ul><ul><li>또한, <b>grouped bar plot</b>은 <b>pandas가 더 편합니다.</b></li><li>pandas DataFrame에서 그림을 그릴 부분만 <code>.loc[]</code>를 사용해 데이터를 한정하고,</li><li><code>.plot.bar()</code>를 사용해 groupled bar plot을 그립니다.</li><li><code>cs = [&quot;brown&quot;, &quot;royalblue&quot;]</code>과 <code>color=cs</code>를 입력하면 적용 전과 후 색이 차례로 입혀집니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data 읽기</span></span><br><span class="line">rpa = pd.read_excel(<span class="string">&quot;RPA_comparison.xlsx&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), gridspec_kw=&#123;<span class="string">&quot;width_ratios&quot;</span>:[<span class="number">1</span>, <span class="number">3</span>]&#125;, constrained_layout=<span class="literal">True</span>)</span><br><span class="line">cs = [<span class="string">&quot;brown&quot;</span>, <span class="string">&quot;royalblue&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 용역 비용</span></span><br><span class="line">rpa.loc[[<span class="number">0</span>]].plot.bar(ax=axs[<span class="number">0</span>], lw=<span class="number">1</span>, ec=<span class="string">&quot;w&quot;</span>, legend=<span class="literal">False</span>, color=cs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 인력</span></span><br><span class="line">rpa.loc[<span class="number">1</span>:].plot.bar(ax=axs[<span class="number">1</span>], lw=<span class="number">1</span>, ec=<span class="string">&quot;w&quot;</span>, legend=<span class="literal">False</span>, color=cs)</span><br></pre></td></tr></table></figure><img src="125_rpa_04.png"><br></li></ul><h2 id="2-3-Annotation"><a href="#2-3-Annotation" class="headerlink" title="2.3. Annotation"></a>2.3. Annotation</h2><ul><li><p>가장 중요한 틀이 갖춰졌습니다.</p></li><li><p>이제 ticks, ticklabels 등을 다듬으면 쓸만한 그래프가 될겁니다.</p></li><li><p>하지만 그 전에, <b>데이터를 직설적으로 알려주는 장치를 하려고 합니다.</b></p></li><li><p>위 코드 아래에 코드를 덧붙여 bar 위에 데이터를 출력합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 용역 비용</span></span><br><span class="line">xs, ws, hs = [], [], []</span><br><span class="line"><span class="keyword">for</span> p, c <span class="keyword">in</span> <span class="built_in">zip</span>(axs[<span class="number">0</span>].patches, cs):</span><br><span class="line">    x, w, h = p.get_x(), p.get_width(), p.get_height()</span><br><span class="line">    xs.append(x)</span><br><span class="line">    ws.append(w)</span><br><span class="line">    hs.append(h)</span><br><span class="line">    cost = <span class="built_in">format</span>(<span class="built_in">int</span>(h), <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> h &gt; <span class="number">0</span>:</span><br><span class="line">        cost = <span class="string">f&quot;<span class="subst">&#123;cost&#125;</span> 천원&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cost = <span class="string">f&quot;<span class="subst">&#123;cost&#125;</span> 원&quot;</span></span><br><span class="line">    axs[<span class="number">0</span>].text(x+w/<span class="number">2</span>, h+<span class="number">1000</span>, cost, ha=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;small&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>, color=c, zorder=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><img src="125_rpa_05.png"><br></p></li><li><p>왼쪽 Axes를 구성하는 두 막대의 위치, 너비, 높이를 뽑아내 글자를 입혔습니다.</p></li><li><p>일반적으로 금액을 <b>천원</b>단위로 표현하기 때문에 일부러 엑셀 파일부터 천원으로 끊었습니다.</p></li></ul><h2 id="2-4-Spines-and-Ticks"><a href="#2-4-Spines-and-Ticks" class="headerlink" title="2.4. Spines and Ticks"></a>2.4. Spines and Ticks</h2><ul><li>이제 y축이 없어도 데이터가 잘 전달됩니다.</li><li>y축과 함께 네모난 테두리(spines)를 없애버립시다.</li><li>x축 눈금은 <code>tick_params()</code>를 사용해 폭을 0으로(<code>width=0</code>) 만듭니다.</li><li>그런데 xticklabel은 여기 말고도 오른쪽 Axes에도 세 개나 더 적용해야 됩니다.</li><li><code>font_label</code>이라는 이름의 dictionary type 매개변수를 만들어 적용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Spines and Ticks</span></span><br><span class="line">axs[<span class="number">0</span>].spines[[<span class="string">&quot;left&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;right&quot;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_yticks([])</span><br><span class="line">font_label = &#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;</span><br><span class="line">axs[<span class="number">0</span>].tick_params(axis=<span class="string">&quot;x&quot;</span>, width=<span class="number">0</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_xticklabels([<span class="string">&quot;용역 비용&quot;</span>], **font_label, rotation=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><img src="125_rpa_06.png"><br></li></ul><h2 id="2-5-Arrow"><a href="#2-5-Arrow" class="headerlink" title="2.5. Arrow"></a>2.5. Arrow</h2><blockquote><p><a href="https://matplotlib.org/stable/gallery/userdemo/connectionstyle_demo.html">matplotlib: Connection styles for annotations</a><br><a href="https://matplotlib.org/stable/gallery/text_labels_and_annotations/fancyarrow_demo.html">matplotlib: Annotation arrow style reference</a></p></blockquote><ul><li>RPA 적용 전후는 나왔는데 그림에서 알아보기 어렵습니다.</li><li><b>RPA를 적용했더니 확 비용이 확 떨어진다</b>는 느낌의 화살표가 있으면 좋을 것 같습니다.</li><li>Matplotlib에서 멋진 화살표를 만들기에는 <code>Axes.annotate()</code>가 가장 좋습니다.</li><li><b>“arrowstyle”:”fancy”</b>와 <b>“connectionstyle”</b>을 이용해 다이나믹한 화살표를 그립니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Arrow</span></span><br><span class="line">axs[<span class="number">0</span>].annotate(<span class="string">&quot;&quot;</span>, xy=(xs[<span class="number">1</span>]+w/<span class="number">2</span>, hs[<span class="number">1</span>]+w/<span class="number">2</span>), xytext=(xs[<span class="number">0</span>]+w/<span class="number">2</span>, hs[<span class="number">0</span>]+w/<span class="number">2</span>),</span><br><span class="line">            arrowprops=&#123;<span class="string">&quot;arrowstyle&quot;</span>:<span class="string">&quot;fancy&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;fc&quot;</span>:<span class="string">&quot;cornflowerblue&quot;</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>,</span><br><span class="line">                        <span class="string">&quot;connectionstyle&quot;</span>:<span class="string">&quot;arc3,rad=-0.3&quot;</span>, <span class="string">&quot;mutation_scale&quot;</span>:<span class="number">100</span>&#125;)</span><br></pre></td></tr></table></figure><img src="125_rpa_07.png"><br></li></ul><h2 id="2-6-인력에도-동일하게"><a href="#2-6-인력에도-동일하게" class="headerlink" title="2.6. 인력에도 동일하게"></a>2.6. 인력에도 동일하게</h2><ul><li>용역 비용에 적용한 사항들을 인력에도 동일하게 적용합니다.</li><li>아까 왼쪽 Axes의 xticklabel에 넣었던 <b>용역 비용</b>은 title이 더 잘 어울리는 것 같습니다.</li><li>내용을 올리고, xticklabel은 새롭게 <b>분석 용역</b>이라고 넣습니다.</li><li>오른쪽에도 여기에 대응되도록 <b>용역 검증</b>, <b>서류 작업</b>, <b>취합 작업</b>을 넣습니다.<br><br><img src="125_rpa_08.png"><br></li></ul><h2 id="2-7-비용과-기간-사이-칸막이"><a href="#2-7-비용과-기간-사이-칸막이" class="headerlink" title="2.7. 비용과 기간 사이 칸막이"></a>2.7. 비용과 기간 사이 칸막이</h2><ul><li>마지막 작업입니다.</li><li>왼쪽과 오른쪽 구간을 나누는 막대를 하나 넣습니다.</li><li><code>matplotlib.lines.Line2D</code>객체를 사용해 선을 그립니다. </li><li>양 끝점의 좌표를 입력해야 하는데 Figure 전체의 상대 좌표를 사용해 <code>[0.255, 0.255], [0.15, 0.85]</code>를 입력합니다.</li><li>양 끝을 둥글게 만들고자 <code>solid_capstyle = &quot;round&quot;</code>를 입력했습니다.</li><li>두 Axes 사이 공간에 그려야 하는 그림이기 때문에 <code>fig.add_artist()</code>로 추가합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.lines <span class="keyword">import</span> Line2D</span><br><span class="line"></span><br><span class="line">line = Line2D([<span class="number">0.255</span>, <span class="number">0.255</span>], [<span class="number">0.15</span>, <span class="number">0.85</span>], linewidth=<span class="number">5</span>, solid_capstyle=<span class="string">&quot;round&quot;</span>, color=<span class="string">&quot;0.6&quot;</span>)</span><br><span class="line">fig.add_artist(line)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">1</span>].legend()</span><br></pre></td></tr></table></figure><img src="125_rpa_09.png"><br></li></ul><h1 id="3-활용"><a href="#3-활용" class="headerlink" title="3. 활용"></a>3. 활용</h1><blockquote><p><a href="https://m.etnews.com/20221228000275">관련기사: 전자신문- NST, 출연연 연구행정혁신 성과확산 공모전 시상식 개최</a></p></blockquote><ul><li>이렇게 정리된 그림은 <b>적절한 표</b>, <b>근거 자료</b>와 함께 <b>보고서</b>와 <b>ppt</b>에 삽입하면 좋습니다.</li><li><b>그냥 파워포인트에서 그리면 더 쉽지 않냐</b>고 하실 수 있습니다.</li><li>경험상 이런 일은 현업 부서에서 수치가 수차례 변경되는 것이 일반적이고, 실제로 열번쯤 바뀐 것 같습니다.</li><li>일일이 새로 그렸다면 너무 힘들었을테지만 코드로 그린 덕택에 그때마다 데이터만 바꿔 끼웠습니다.</li></ul><ul><li><p>위 그림은 실제로 최근 있었던 한 공모전에서 서류 작성과 발표 자료에 사용했습니다.</p></li><li><p>데이터는 제가 접한 실제 사례와 다르게 바꾸었습니다만, 전반적인 틀은 살렸습니다.<br><br><img src="125_rpa_10.png" alt="혹시나 싶은 마음에 내용은 흐리게 가렸습니다."><br></p></li><li><p>전체 코드는 아래와 여기에서 확인할 수 있습니다: <a href="https://colab.research.google.com/drive/1RLo4aTtP_sM9EoxWyfkvR5hetGNmvVZH?usp=share_link">Colab 링크</a></p></li><li><p>여러분께도 좋은 결과가 있기를 바랍니다.</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> matplotlib.lines <span class="keyword">import</span> Line2D</span><br><span class="line"></span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line">plt.rcParams[<span class="string">&quot;font.family&quot;</span>] = <span class="string">&quot;NanumGothic&quot;</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># data 읽기</span></span><br><span class="line">rpa = pd.read_excel(<span class="string">&quot;RPA_comparison.xlsx&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), gridspec_kw=&#123;<span class="string">&quot;width_ratios&quot;</span>:[<span class="number">1</span>, <span class="number">3</span>]&#125;, constrained_layout=<span class="literal">True</span>)</span><br><span class="line">cs = [<span class="string">&quot;brown&quot;</span>, <span class="string">&quot;royalblue&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 용역 비용</span></span><br><span class="line">rpa.loc[[<span class="number">0</span>]].plot.bar(ax=axs[<span class="number">0</span>], lw=<span class="number">1</span>, ec=<span class="string">&quot;w&quot;</span>, legend=<span class="literal">False</span>, color=cs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 인력</span></span><br><span class="line">rpa.loc[<span class="number">1</span>:].plot.bar(ax=axs[<span class="number">1</span>], lw=<span class="number">1</span>, ec=<span class="string">&quot;w&quot;</span>, legend=<span class="literal">False</span>, color=cs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 용역 비용</span></span><br><span class="line">xs, ws, hs = [], [], []</span><br><span class="line"><span class="keyword">for</span> p, c <span class="keyword">in</span> <span class="built_in">zip</span>(axs[<span class="number">0</span>].patches, cs):</span><br><span class="line">    x, w, h = p.get_x(), p.get_width(), p.get_height()</span><br><span class="line">    xs.append(x)</span><br><span class="line">    ws.append(w)</span><br><span class="line">    hs.append(h)</span><br><span class="line">    cost = <span class="built_in">format</span>(<span class="built_in">int</span>(h), <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> h &gt; <span class="number">0</span>:</span><br><span class="line">        cost = <span class="string">f&quot;<span class="subst">&#123;cost&#125;</span> 천원&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cost = <span class="string">f&quot;<span class="subst">&#123;cost&#125;</span> 원&quot;</span></span><br><span class="line">    axs[<span class="number">0</span>].text(x+w/<span class="number">2</span>, h+<span class="number">1000</span>, cost, ha=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;small&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>, color=c, zorder=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Spines and Ticks</span></span><br><span class="line">font_label = &#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [<span class="string">&quot;용역 비용\n&quot;</span>, <span class="string">&quot;업무 기간\n&quot;</span>]):</span><br><span class="line">    ax.spines[[<span class="string">&quot;left&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;right&quot;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.set_yticks([])</span><br><span class="line">    ax.tick_params(axis=<span class="string">&quot;x&quot;</span>, width=<span class="number">0</span>)</span><br><span class="line">    ax.set_title(title, **font_label)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">0</span>].set_xticklabels([<span class="string">&quot;분석 용역&quot;</span>], rotation=<span class="number">0</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_xticklabels([<span class="string">&quot;용역 검증&quot;</span>, <span class="string">&quot;서류 작업&quot;</span>, <span class="string">&quot;취합 작업&quot;</span>], </span><br><span class="line">                       rotation=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Arrow</span></span><br><span class="line">axs[<span class="number">0</span>].annotate(<span class="string">&quot;&quot;</span>, xy=(xs[<span class="number">1</span>]+w/<span class="number">2</span>, hs[<span class="number">1</span>]+w/<span class="number">2</span>), xytext=(xs[<span class="number">0</span>]+w/<span class="number">2</span>, hs[<span class="number">0</span>]+w/<span class="number">2</span>),</span><br><span class="line">            arrowprops=&#123;<span class="string">&quot;arrowstyle&quot;</span>:<span class="string">&quot;fancy&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;fc&quot;</span>:<span class="string">&quot;cornflowerblue&quot;</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>,</span><br><span class="line">                        <span class="string">&quot;connectionstyle&quot;</span>:<span class="string">&quot;arc3,rad=-0.3&quot;</span>, <span class="string">&quot;mutation_scale&quot;</span>:<span class="number">100</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 인력 감축</span></span><br><span class="line">xs, ws, hs = [], [], []</span><br><span class="line"><span class="keyword">for</span> i, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(axs[<span class="number">1</span>].patches):</span><br><span class="line">    x, w, h = p.get_x(), p.get_width(), p.get_height()</span><br><span class="line">    xs.append(x)</span><br><span class="line">    ws.append(w)</span><br><span class="line">    hs.append(h)</span><br><span class="line">    person = <span class="built_in">format</span>(<span class="built_in">int</span>(h), <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> h &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> h%<span class="number">1</span>:</span><br><span class="line">            h = <span class="built_in">int</span>(h)</span><br><span class="line">        day = <span class="string">f&quot;<span class="subst">&#123;h&#125;</span> 주&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">3</span>:</span><br><span class="line">        c = cs[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        c = cs[<span class="number">1</span>]</span><br><span class="line">    p.set_fc(c)</span><br><span class="line">    axs[<span class="number">1</span>].text(x+w/<span class="number">2</span>, h+<span class="number">0.3</span>, day, ha=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;small&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>, color=c, zorder=<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    axs[<span class="number">1</span>].annotate(<span class="string">&quot;&quot;</span>, xy=(xs[i+<span class="number">3</span>]+w/<span class="number">2</span>, hs[i+<span class="number">3</span>]+w/<span class="number">2</span>), xytext=(xs[i]+w/<span class="number">2</span>, hs[i]+w/<span class="number">2</span>),</span><br><span class="line">            arrowprops=&#123;<span class="string">&quot;arrowstyle&quot;</span>:<span class="string">&quot;fancy&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;skyblue&quot;</span>, <span class="string">&quot;fc&quot;</span>:<span class="string">&quot;skyblue&quot;</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.8</span>,</span><br><span class="line">                        <span class="string">&quot;connectionstyle&quot;</span>:<span class="string">&quot;arc3,rad=-0.3&quot;</span>, <span class="string">&quot;mutation_scale&quot;</span>:<span class="number">40</span>&#125;)</span><br><span class="line"></span><br><span class="line">line = Line2D([<span class="number">0.255</span>, <span class="number">0.255</span>], [<span class="number">0.15</span>, <span class="number">0.85</span>], linewidth=<span class="number">5</span>, solid_capstyle=<span class="string">&quot;round&quot;</span>, color=<span class="string">&quot;0.6&quot;</span>)</span><br><span class="line">fig.add_artist(line)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">1</span>].legend()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      
    </item>
    
    <item>
      <title>산타 방문 증빙 feat. DALL.E</title>
      <link>https://jehyunlee.github.io/2022/12/26/Python-General-14_santa/</link>
      <guid>https://jehyunlee.github.io/2022/12/26/Python-General-14_santa/</guid>
      <pubDate>Mon, 26 Dec 2022 07:30:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;2022년 한 해는 그림 생성 모델로 뜨거웠습니다.&lt;/li&gt;
&lt;li&gt;DALL.E를 사용해서 산타가 다녀갔다는 증빙을 만듭니다.&lt;/li&gt;
&lt;li&gt;사진 한 장이 필요합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-산타가-다녀가셨다&quot;&gt;&lt;a h</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>2022년 한 해는 그림 생성 모델로 뜨거웠습니다.</li><li>DALL.E를 사용해서 산타가 다녀갔다는 증빙을 만듭니다.</li><li>사진 한 장이 필요합니다.</li></ul><h1 id="1-산타가-다녀가셨다"><a href="#1-산타가-다녀가셨다" class="headerlink" title="1. 산타가 다녀가셨다!"></a>1. 산타가 다녀가셨다!</h1><ul><li>크리스마스에 다녀가시는 산타는 아이들에게 큰 기쁨입니다.</li><li>선물 자체도 기쁘고, 한 해 잘 살았다는 칭찬을 받는 듯한 느낌도 나지요.</li><li>반면 부모에게는 어떻게 올해를 넘길지가 고민입니다.</li></ul><blockquote><p><b>산타가 다녀가셨나봐! 선물도 있고 아빠 핸드폰에 사진도 찍혔어!</b></p></blockquote><p><img src="14_santa_02.png"></p><ul><li>다행히 아이들은 눈을 동그랗게 뜨고 믿어주었습니다.</li><li><b>산타를 제외한 배경이 우리 집이었기 때문에 의심도 안 했을 것입니다.</b></li></ul><h1 id="2-준비"><a href="#2-준비" class="headerlink" title="2. 준비"></a>2. 준비</h1><blockquote><p><a href="https://labs.openai.com/">DALL.E</a></p></blockquote><ul><li><p>먼저, 그림을 그려주는 AI, <b><a href="https://labs.openai.com/">DALL.E</a> 계정</b>이 필요합니다.</p></li><li><p>아직 계정이 없으시다면 위 링크로 들어가 회원 가입을 합니다.</p></li><li><p>로그인을 마치면 아래와 같은 화면이 나타납니다.<br><br><img src="14_santa_04.png"><br></p></li><li><p>그리고 <b>집 사진 한 장</b>이 필요합니다.</p></li><li><p>크리스마스를 맞아 꾸민 트리 밑에 아이들에게 줄 선물을 놓고 사진을 찍습니다.</p></li><li><p>산타가 등장할 곳은 다소 어두워야 부모에게 유리합니다.<br><br><img src="14_santa_01.jpg"><br></p></li></ul><h1 id="3-DALL-E-활약"><a href="#3-DALL-E-활약" class="headerlink" title="3. DALL.E 활약"></a>3. DALL.E 활약</h1><ul><li><b>Upload an image</b>를 클릭해서 집 사진을 올립니다.</li><li>그러면 정사각형으로 자르라고 하는데, 적절히 위치를 지정하고 <b>Crop</b>을 누릅니다.<br><br><img src="14_santa_05.png"><br></li></ul><ul><li><p>확인이 되었으면 <b>Edit image</b>를 눌러 수정을 들어갑니다.</p></li><li><p>기본으로 설정된 <b>지우개</b> 아이콘으로 산타가 놓일 자리를 지웁니다.<br><br><img src="14_santa_06.png"><br></p></li><li><p>이제 산타를 그릴 차례입니다.</p></li><li><p>구글 검색창을 닮은 하얀 막대 안에 산타가 어떤 모습으로 들어올지를 씁니다.</p></li><li><p>저는 이렇게 적었습니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Realistic photography of Santa Clause from backside, bending his knee towards the tree, standing to distribute Christmas presents.</span><br></pre></td></tr></table></figure></li><li><p>마지막으로 <b>Generate</b> 버튼을 누르면 4장의 이미지가 한번에 생성됩니다.<br><br><img src="14_santa_03.png"><br></p></li><li><p>마음에 드는 이미지가 없다면 <b>Generate</b>를 다시 눌러 다른 그림을 만들어봅니다.</p></li><li><p>마음에 드는 이미지가 나오면 그림을 다운받아 휴대폰에 저장합니다.<br><br><img src="14_santa_02.png"><br></p></li><li><p>언젠가 산타의 정체가 부모라는 것을 알게 되겠지만, 그 날이 오기 전까지는 동심을 간직하기를 바랍니다.</p></li><li><p>훗날 아이들이 이 포스팅을 읽게 된다면, 2022년의 산타와 선물을 떠올려주면 좋겠습니다. :)</p></li></ul><blockquote><p><b>아빠, 산타가 우리가 키우는 나무 만져줬나봐! 하루 사이에 더 자랐어!</b></p></blockquote>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/dall-e/">dall.e</category>
      
      <category domain="https://jehyunlee.github.io/tags/inpaining/">inpaining</category>
      
      
    </item>
    
    <item>
      <title>Deep Learning by Open API</title>
      <link>https://jehyunlee.github.io/2022/11/29/Python-DS-124-kierlecture8/</link>
      <guid>https://jehyunlee.github.io/2022/11/29/Python-DS-124-kierlecture8/</guid>
      <pubDate>Mon, 28 Nov 2022 17:02:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;한국에너지기술연구원 AI 학습조직&lt;/b&gt;에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.&lt;ul&gt;
&lt;li&gt;이번에는 직접 하는 코딩을 벗어나 공개된 딥러닝 모델을 사용하는 방법을 알아봅니다.&lt;/li&gt;
&lt;li&gt;영상과 자연어 처</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b>한국에너지기술연구원 AI 학습조직</b>에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.<ul><li>이번에는 직접 하는 코딩을 벗어나 공개된 딥러닝 모델을 사용하는 방법을 알아봅니다.</li><li>영상과 자연어 처리를 중심으로 OpenAI에서 제공하는 여러 모델이 있습니다.</li><li>강의실 예약 시간 문제로 마무리가 매끄럽지 못했습니다.</li><li>요약본이 번역되다 만 문제는 <code>max_tokens=300</code>을 추가하면 해결됩니다.</li><li><a href="221128_9%EC%B0%A8%EB%AA%A8%EC%9E%84.pdf">강의 자료는 여기에서 다운받으실 수 있습니다</a></li></ul></li></ul><ul><li><p>발표 영상 : (<a href="https://youtu.be/dsnrl0tLkdU">Youtube Link</a>)<br></p></li><li><p>실습 코드 : (<a href="https://bit.ly/3gEMeUS">https://bit.ly/3gEMeUS</a>)<br></p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/dsnrl0tLkdU" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><img src="cats.png" alt="DALL.E Open API로 그린 그림"><br></p><p><ul><li>1년간 총 8개의 강좌로 정리되었습니다.</li></ul><p><img src="schedule.png" alt="학습조직 일정"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/machine-learning/">machine learning</category>
      
      <category domain="https://jehyunlee.github.io/tags/KIER/">KIER</category>
      
      <category domain="https://jehyunlee.github.io/tags/API/">API</category>
      
      <category domain="https://jehyunlee.github.io/tags/Open-AI/">Open AI</category>
      
      <category domain="https://jehyunlee.github.io/tags/DALL-E/">DALL.E</category>
      
      <category domain="https://jehyunlee.github.io/tags/summary/">summary</category>
      
      
    </item>
    
    <item>
      <title>Gaussian Process Practice (3) Beware Boundaries</title>
      <link>https://jehyunlee.github.io/2022/11/19/Python-DS-123-gpr3/</link>
      <guid>https://jehyunlee.github.io/2022/11/19/Python-DS-123-gpr3/</guid>
      <pubDate>Sat, 19 Nov 2022 08:35:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;Gaussian Process 연습입니다.&lt;/li&gt;
&lt;li&gt;scikit-learn을 비롯한 예제를 재구성하여 연습합니다.&lt;/li&gt;
&lt;li&gt;주의사항을 알려드립니다. Gaussian Process는 경계조건에 매우 취약합니다.&lt;/li&gt;
&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>Gaussian Process 연습입니다.</li><li>scikit-learn을 비롯한 예제를 재구성하여 연습합니다.</li><li>주의사항을 알려드립니다. Gaussian Process는 경계조건에 매우 취약합니다.</li></ul><h1 id="1-Gaussian-Process의-한계"><a href="#1-Gaussian-Process의-한계" class="headerlink" title="1. Gaussian Process의 한계"></a>1. Gaussian Process의 한계</h1><blockquote><p><a href="https://scikit-learn.org/stable/auto_examples/gaussian_process/plot_gpr_noisy_targets.html#sphx-glr-auto-examples-gaussian-process-plot-gpr-noisy-targets-py">scikit-learn: Gaussian Process Regression: basic introductory example</a></p></blockquote><ul><li><p>Gaussian Process는 적은 데이터로도 꽤 믿을만한 결과를 출력합니다.</p></li><li><p>심지어 신뢰 구간까지 알 수 있어서 매우 정직해 보입니다.</p></li><li><p>하지만 치명적인 단점이 있습니다.</p></li><li><p><a href="https://jehyunlee.github.io/2022/11/16/Python-DS-121-gpr1/">지난 글</a>과 같은 예제를 사용합니다.<br><img src="123_gpr3_3.png"><br></p></li><li><p>모든 것이 정상으로 보입니다.</p></li><li><p>합리적인 범위의 평균값(<code>GP prediction (mean)</code>)과 신뢰 구간(<code>95% CI</code>)을 보이고 있습니다.</p></li><li><p>하지만 오른쪽 끄트머리를 보면, 조금 미심쩍습니다.</p></li><li><p><b>참값이 신뢰 구간의 바닥에 겨우 걸려있습니다.</b><br><br><img src="123_gpr3_8.png" alt="개그콘서트, &quot;불편한 진실&quot; "><br></p></li><li><p>극단적인 경우를 살펴봅니다.</p></li><li><p><b>X 값의 범위</b>로 참값의 좌우에 50씩을 보태 <b>-50 ~ 60을 입력</b>합니다.</p></li><li><p>평균이 0, 95% 신뢰구간이 무려 10에 가까운 커다란 밴드가 생겼습니다.</p></li><li><p>다항회귀를 해도 이렇지는 않을 것 같습니다.<br><br><img src="123_gpr3_7.png"><br></p></li><li><p><b>Gaussian Process의 원리</b>에 답이 있습니다.</p></li><li><p>Gaussian 분포를 prior로 놓기 때문에 평균이 0입니다.</p></li><li><p>학습 데이터(evidence)가 반영된 구간 안쪽은 그나마 괜찮지만 바깥쪽이 문제입니다.</p></li><li><p><b>안쪽에서 학습을 시켜봐야 바깥쪽의 중심값이 0이라고 가정되어 있기 때문에 저런 일이 벌어집니다.</b></p></li></ul><h1 id="2-비교"><a href="#2-비교" class="headerlink" title="2. 비교"></a>2. 비교</h1><ul><li><p>조금 더 확실하게 확인합니다.</p></li><li><p>위의 예제에 <b>offset = $\pm 5$</b>를 해서 <b>새로운 참값</b>을 만듭니다.</p></li><li><p>그리고, 여기서 같은 X 좌표의 데이터들을 학습용으로 추출합니다.<br><br><img src="123_gpr3_4.png"><br></p></li><li><p>여기에 똑같은 RBF 커널을 적용한 Gaussian Process를 적용하면 아래와 같은 결과가 나옵니다.</p></li><li><p>좌우 그림에서 <b>파란 선</b>으로 표시한 평균값의 양 끝이 향하는 방향이 반대입니다.<br></p></li><li><p><b>offset=+5</b>인 왼쪽 그림은 양 끝이 아래를 향하고 있고,</p></li><li><p><b>offset=-5</b>인 오른쪽 그림은 양 끝이 기를 쓰고 고개를 들려고 하고 있습니다.</p></li><li><p>모두 <b>0을 향하고 있습니다.</b><br><br><img src="123_gpr3_5.png"><br></p></li><li><p>양 끝만 영향을 받는 것이 아닙니다.</p></li><li><p>X = 6~8 사이 구간도 offset에 따라 달라집니다.</p></li><li><p>0에서 먼 왼쪽 그림은 신뢰 구간이 비교적 얇은 반면 오른쪽은 두텁고 mean 값도 참값과 더 벌어져 있습니다.</p></li></ul><h1 id="3-Solution"><a href="#3-Solution" class="headerlink" title="3. Solution"></a>3. Solution</h1><ul><li><p>해결 방법은 생각보다 간단합니다.</p></li><li><p>외삽(extrapolation)이 문제라면 외삽을 하지 않으면 됩니다.</p></li><li><p>학습 데이터에 데이터 범위의 양 끝을 추가하면 모든 범위가 내삽이 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sample including ends</span></span><br><span class="line">training_indices += [<span class="number">0</span>, <span class="number">999</span>]</span><br><span class="line">Xp_train1, Xm_train1 = Xp[training_indices], Xm[training_indices]</span><br><span class="line">yp_train1, ym_train1 = yp[training_indices], ym[training_indices]</span><br></pre></td></tr></table></figure></li><li><p>그리고 같은 학습을 시키면 offset에 관계 없이 동일한 결과를 얻을 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">6</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>, sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, X, y, X_train, y_train, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [Xp, Xm], [yp, ym], </span><br><span class="line">                                             [Xp_train1, Xm_train1], [yp_train1, ym_train1], </span><br><span class="line">                                             [<span class="string">&quot;offset = +5&quot;</span>, <span class="string">&quot;offset = -5&quot;</span>]):</span><br><span class="line">    <span class="comment"># Gaussian Process</span></span><br><span class="line">    gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, random_state=<span class="number">0</span>)</span><br><span class="line">    gpr.fit(X_train, y_train)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># prediction</span></span><br><span class="line">    y_pred_mean, y_pred_std = gpr.predict(X, return_std=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    ax.plot(X, y, c=<span class="string">&quot;0.5&quot;</span>, label=<span class="string">&quot;true&quot;</span>)</span><br><span class="line">    ax.scatter(X_train, y_train, label=<span class="string">&quot;sample&quot;</span>)</span><br><span class="line">    ax.plot(X.ravel(), y_pred_mean, c=<span class="string">&quot;b&quot;</span>, label=<span class="string">&quot;GP prediction (mean)&quot;</span>)</span><br><span class="line">    ax.fill_between(X.ravel(), y_pred_mean-<span class="number">1.96</span>*y_pred_std, y_pred_mean+<span class="number">1.96</span>*y_pred_std, alpha=<span class="number">0.5</span>, fc=<span class="string">&quot;cornflowerblue&quot;</span>, label=<span class="string">&quot;95% CI&quot;</span>)</span><br><span class="line">    ax.axhline(<span class="number">0</span>, c=<span class="string">&quot;g&quot;</span>, lw=<span class="number">1</span>)</span><br><span class="line">    ax.set_title(title, pad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">axs[<span class="number">0</span>].legend(loc=<span class="string">&quot;lower right&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="123_gpr3_6.png"><br></p></li></ul><h1 id="4-결론"><a href="#4-결론" class="headerlink" title="4. 결론"></a>4. 결론</h1><ul><li>머신 러닝 기법들이 모두 그렇지만 외삽은 주의해야 합니다.</li><li>Gaussian Process는 prior의 존재로 인해 외삽에 더 취약할 수 있으니 각별히 주의해야 합니다.</li><li>본 글에 사용된 코드는 <b><a href="gpr3.ipynb">여기에서 다운받으실 수 있습니다.</a></b></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/gaussian-process/">gaussian process</category>
      
      <category domain="https://jehyunlee.github.io/tags/bayesian/">bayesian</category>
      
      <category domain="https://jehyunlee.github.io/tags/scikit-learn/">scikit-learn</category>
      
      
    </item>
    
    <item>
      <title>Gaussian Process Practice (2) Kernels</title>
      <link>https://jehyunlee.github.io/2022/11/17/Python-DS-122-gpr2/</link>
      <guid>https://jehyunlee.github.io/2022/11/17/Python-DS-122-gpr2/</guid>
      <pubDate>Thu, 17 Nov 2022 10:22:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;Gaussian Process 연습입니다.&lt;/li&gt;
&lt;li&gt;scikit-learn을 비롯한 예제를 재구성하여 연습합니다.&lt;/li&gt;
&lt;li&gt;여러 커널의 특징을 알아보고 사용처를 알아봅니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-Data-</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>Gaussian Process 연습입니다.</li><li>scikit-learn을 비롯한 예제를 재구성하여 연습합니다.</li><li>여러 커널의 특징을 알아보고 사용처를 알아봅니다.</li></ul><h1 id="1-Data-Preparation"><a href="#1-Data-Preparation" class="headerlink" title="1. Data Preparation"></a>1. Data Preparation</h1><blockquote><p><a href="https://scikit-learn.org/stable/auto_examples/gaussian_process/plot_gpr_noisy_targets.html#sphx-glr-auto-examples-gaussian-process-plot-gpr-noisy-targets-py">scikit-learn: Gaussian Process Regression: basic introductory example</a></p></blockquote><h2 id="1-1-example-data"><a href="#1-1-example-data" class="headerlink" title="1.1. example data"></a>1.1. example data</h2><ul><li><a href="https://jehyunlee.github.io/2022/11/16/Python-DS-121-gpr1/">지난 글</a>과 같은 예제를 사용합니다.</li><li>오늘은 어제보다는 색을 많이 사용할 겁니다. 참값과 Gaussian Process 결과를 무채색으로 표현합니다.</li><li>관측값은 참값이라고 합시다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.gaussian_process <span class="keyword">import</span> GaussianProcessRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> RBF</span><br><span class="line"></span><br><span class="line"><span class="comment"># Random Number Generation</span></span><br><span class="line">rng = np.random.RandomState(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Gaussian Process Regression</span></span><br><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, random_state=<span class="number">0</span>)</span><br><span class="line">gpr.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prediction</span></span><br><span class="line">y_pred_mean, y_pred_std = gpr.predict(X, return_std=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br><span class="line">ax.plot(X, y, c=<span class="string">&quot;k&quot;</span>, label=<span class="string">&quot;true&quot;</span>)</span><br><span class="line">ax.scatter(X_train, y_train, fc=<span class="string">&quot;k&quot;</span>, label=<span class="string">&quot;sample without noise&quot;</span>)</span><br><span class="line"></span><br><span class="line">ax.plot(X.ravel(), y_pred_mean, c=<span class="string">&quot;0.5&quot;</span>, label=<span class="string">&quot;GP prediction (mean)&quot;</span>)</span><br><span class="line">ax.fill_between(X.ravel(), y_pred_mean-<span class="number">1.96</span>*y_pred_std, y_pred_mean+<span class="number">1.96</span>*y_pred_std, alpha=<span class="number">0.5</span>, fc=<span class="string">&quot;lightgray&quot;</span>, label=<span class="string">&quot;95% CI&quot;</span>)</span><br><span class="line">ax.legend(loc=<span class="string">&quot;upper left&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_3.png"><br></li></ul><h2 id="1-2-sample-추출"><a href="#1-2-sample-추출" class="headerlink" title="1.2. sample 추출"></a>1.2. sample 추출</h2><blockquote><p><a href="https://scikit-learn.org/stable/auto_examples/gaussian_process/plot_gpr_prior_posterior.html#sphx-glr-auto-examples-gaussian-process-plot-gpr-prior-posterior-py">scikit-learn: Illustration of prior and posterior Gaussian process for different kernels</a></p></blockquote><p><img src="ds.gif" alt="14,000,605개의 미래를 보는 닥터 스트레인지, 대혼돈의 멀티버스 中"></p><ul><li><p>신뢰구간에는 다양한 가능성이 내포되어 있습니다.</p></li><li><p>이들 중 일부를 골라 추출할 수 있습니다.</p></li><li><p>5개를 골라 Gaussian Process Regression 위에 얹어봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sampling</span></span><br><span class="line">n_samples=<span class="number">5</span></span><br><span class="line">y_samples = gpr.sample_y(X, n_samples)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prediction</span></span><br><span class="line">y_pred_mean, y_pred_std = gpr.predict(X, return_std=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br><span class="line">ax.plot(X, y, c=<span class="string">&quot;k&quot;</span>, label=<span class="string">&quot;true&quot;</span>)</span><br><span class="line">ax.scatter(X_train, y_train, fc=<span class="string">&quot;k&quot;</span>, label=<span class="string">&quot;sample without noise&quot;</span>)</span><br><span class="line"></span><br><span class="line">ax.plot(X.ravel(), y_pred_mean, c=<span class="string">&quot;0.5&quot;</span>, label=<span class="string">&quot;GP prediction (mean)&quot;</span>)</span><br><span class="line">ax.fill_between(X.ravel(), y_pred_mean-<span class="number">1.96</span>*y_pred_std, y_pred_mean+<span class="number">1.96</span>*y_pred_std, alpha=<span class="number">0.5</span>, fc=<span class="string">&quot;lightgray&quot;</span>, label=<span class="string">&quot;95% CI&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> y_sample <span class="keyword">in</span> y_samples.T:</span><br><span class="line">    ax.plot(X.ravel(), y_sample, lw=<span class="number">1</span>, ls=<span class="string">&quot;:&quot;</span>, label=<span class="string">&quot;GP prediction (mean)&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="122_gpr2_4.png"><br></p></li><li><p>대부분 신뢰구간 안에 들어와 있지만 일부는 신뢰구간 밖으로도 나가 있습니다.</p></li><li><p>정상입니다.</p></li></ul><h2 id="1-3-posterior-vs-prior"><a href="#1-3-posterior-vs-prior" class="headerlink" title="1.3. posterior vs prior"></a>1.3. posterior vs prior</h2><ul><li><p>지금 그린 그림은 evidence가 반영된 결과, 즉 <b>posterior(사후확률)</b>입니다.</p></li><li><p>학습을 시키지 않은 채 예측을 하고 sample curve를 뽑을 수도 있습니다.</p></li><li><p>evidence가 반영되기 전의 <b>prior(사전확률)</b>입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prior</span></span><br><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sampling</span></span><br><span class="line">y_samples = gpr.sample_y(X, n_samples)</span><br></pre></td></tr></table></figure><p><img src="122_gpr2_5.png"><br></p></li><li><p>관측값이 반영되어 있지 않기 때문에 데이터와는 무관한 모습입니다.</p></li><li><p>그러나 곡선의 모양에는 우리가 선택한 RBF 커널이 드러나 있습니다.</p></li><li><p>학습에 커널이 반영되는만큼 <b>데이터의 모습을 반영</b>해 <b>커널을 선정</b>해야 합니다.</p></li><li><p>scikit-learn이 지원하는 커널들의 prior와 posterior를 살펴보겠습니다.</p></li></ul><h1 id="2-Kernels"><a href="#2-Kernels" class="headerlink" title="2. Kernels"></a>2. Kernels</h1><blockquote><p><a href="https://pasus.tistory.com/209">Deep Campus: 가우시안 프로세스의 개념</a><br><a href="https://towardsdatascience.com/understanding-gaussian-process-the-socratic-way-ba02369d804">towardsdatascience: Understanding Gaussian Process, the Socratic Way</a><br><a href="https://thegradient.pub/gaussian-process-not-quite-for-dummies/">The Gradient, Gaussian process not quite for dummies</a></p></blockquote><h2 id="2-1-커널의-정체"><a href="#2-1-커널의-정체" class="headerlink" title="2.1. 커널의 정체"></a>2.1. 커널의 정체</h2><ul><li><p>Gaussian Process의 커널은 covariance function입니다. </p></li><li><p>서로 다른 두 점 $x_i$와 $x_j$와의 상호 연관성을 나타냅니다.</p></li><li><p>이 함수를 커널 함수라고 하며, <b>Radial basis function</b>은 다음과 같이 정의됩니다.<br>$$k(x_i, x_j) = \exp\left(- \frac{d(x_i, x_j)^2}{2l^2} \right)$$</p></li><li><p>$x_i$와 $x_j$의 거리가 같아도 $l$이 크면 $k$가 큽니다: 먼 거리의 데이터까지 연관성을 가진다는 뜻입니다.</p></li><li><p>$x_i = x_j$ 일때 공분산은 최대값으로 1을 가집니다.</p></li><li><p>그렇다면 $x_i$과 $x_j$ 사이의 한 점은 두 점 모두와의 공분산을 최대한 높이는 방향으로 결정될텐데</p></li><li><p>Gaussian Process는 결정변수가 아니라 확률변수이므로 <b>확률</b>이 높을 뿐 조금씩 변합니다.</p></li><li><p>이로 인해 아무런 관찰값이 입력되지 않아도(prior) <b>RBF</b>의 sample 함수는 <b>랜덤하게 매끈한 곡선</b>을 이룹니다.</p></li></ul><ul><li>같은 이유로 참값으로 관측값이 지정되면(posterior) <b>관측값과 관측값 사이를 최대한 매끈하게 잇는 곡선의 존재 범위</b>가 도출됩니다.</li><li>그렇다면, <b>커널 함수가 바뀌면 예측값이 바뀔 것</b>이라는 것을 상상할 수 있으며</li><li><b>데이터의 성격에 맞는 커널 함수가 있음</b>을 예상할 수도 있습니다.</li><li>최적값을 얻는 방법으로 <b>MLE(Maximum Likelihood Estimation)</b>이 사용됩니다.</li><li><code>log_marginal_likelihood()</code> 메소드를 사용해 결과값을 추출할 수 있습니다.</li></ul><ul><li>커널 종류를 바꾸며 prior와 posterior를 관찰합니다.</li><li><b>커널을 입력받는 시각화 함수</b>를 아래와 같이 준비합니다.</li><li>코드가 길어 접어두었습니다.<details>  <summary><b>코드 보기/접기</b></summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">plt.rcParams[<span class="string">&#x27;mathtext.fontset&#x27;</span>] = <span class="string">&quot;cm&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_pp</span>(<span class="params">kernel, kernel_name=<span class="string">&quot;&quot;</span>, X_train=X_train, y_train=y_train, X_true=X, y_true=y, n_samples=<span class="number">5</span></span>):</span></span><br><span class="line">    gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, random_state=<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># prior</span></span><br><span class="line">    y_prior_mean, y_prior_std = gpr.predict(X_true, return_std=<span class="literal">True</span>)</span><br><span class="line">    y_prior_samples = gpr.sample_y(X_true, n_samples)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># posterior</span></span><br><span class="line">    gpr.fit(X_train, y_train)</span><br><span class="line">    y_posterior_mean, y_posterior_std = gpr.predict(X_true, return_std=<span class="literal">True</span>)</span><br><span class="line">    y_posterior_samples = gpr.sample_y(X_true, n_samples)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># kernel after fitting</span></span><br><span class="line">    kernel_ = gpr.kernel_</span><br><span class="line">    theta = gpr.kernel_.theta</span><br><span class="line">    ll = gpr.log_marginal_likelihood(theta)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># visualize</span></span><br><span class="line">    fig, axs = plt.subplots(nrows=<span class="number">2</span>, figsize=(<span class="number">6</span>, <span class="number">4</span>), sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>, constrained_layout=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> ax, y_mean, y_std, y_samples, title, k <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [y_prior_mean, y_posterior_mean], </span><br><span class="line">                                                           [y_prior_std, y_posterior_std], [y_prior_samples, y_posterior_samples],</span><br><span class="line">                                                           [<span class="string">&quot;prior&quot;</span>, <span class="string">&quot;posterior&quot;</span>], [kernel, kernel_]):</span><br><span class="line">        <span class="comment"># true</span></span><br><span class="line">        ax.plot(X_true, y_true, c=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">        ax.scatter(X_train, y_train, fc=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># pred</span></span><br><span class="line">        ax.plot(X_true.ravel(), y_mean, c=<span class="string">&quot;0.5&quot;</span>)</span><br><span class="line">        ax.fill_between(X_true.ravel(), y_mean-<span class="number">1.96</span>*y_std, y_mean+<span class="number">1.96</span>*y_std, alpha=<span class="number">0.5</span>, fc=<span class="string">&quot;lightgray&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># samples</span></span><br><span class="line">        <span class="keyword">for</span> y_sample <span class="keyword">in</span> y_samples.T:</span><br><span class="line">            ax.plot(X_true.ravel(), y_sample, lw=<span class="number">1</span>, ls=<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># title</span></span><br><span class="line">        ax.text(<span class="number">0.18</span>, <span class="number">0.97</span>, title, fontsize=<span class="string">&quot;large&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>, color=<span class="string">&quot;b&quot;</span>, ha=<span class="string">&quot;right&quot;</span>, va=<span class="string">&quot;top&quot;</span>, transform=ax.transAxes)</span><br><span class="line">        str_k = <span class="built_in">str</span>(k).replace(<span class="string">&#x27; ** &#x27;</span>,<span class="string">&#x27;^&#x27;</span>).replace(<span class="string">&#x27;**&#x27;</span>,<span class="string">&#x27;^&#x27;</span>).replace(<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;\cdot&#x27;</span>).replace(<span class="string">&#x27;length_scale&#x27;</span>,<span class="string">&#x27;l&#x27;</span>).replace(<span class="string">&#x27;alpha&#x27;</span>,<span class="string">&#x27;\\alpha&#x27;</span>).replace(<span class="string">&#x27;periodicity&#x27;</span>, <span class="string">&#x27;p&#x27;</span>).replace(<span class="string">&#x27;sigma&#x27;</span>,<span class="string">&#x27;\\sigma&#x27;</span>).replace(<span class="string">&#x27;nu&#x27;</span>,<span class="string">&#x27;\\nu&#x27;</span>)</span><br><span class="line">        ax.text(<span class="number">0.2</span>, <span class="number">0.97</span>, <span class="string">&quot;kernel: &quot;</span> + <span class="string">f&quot;$<span class="subst">&#123;str_k&#125;</span>$&quot;</span>, ha=<span class="string">&quot;left&quot;</span>, va=<span class="string">&quot;top&quot;</span>, color=<span class="string">&quot;darkblue&quot;</span>, transform=ax.transAxes)</span><br><span class="line">        </span><br><span class="line">    axs[<span class="number">1</span>].text(<span class="number">0.105</span>, <span class="number">0.84</span>, <span class="string">&quot;Log-likelihood: &quot;</span> + <span class="string">f&quot;$&#123;&#123;<span class="subst">&#123;ll:<span class="number">.3</span>f&#125;</span>&#125;&#125;$&quot;</span>, ha=<span class="string">&quot;left&quot;</span>, va=<span class="string">&quot;top&quot;</span>, color=<span class="string">&quot;darkblue&quot;</span>, transform=axs[<span class="number">1</span>].transAxes)</span><br><span class="line">    str_theta = <span class="string">&quot;, &quot;</span>.join([<span class="string">f&quot;<span class="subst">&#123;t:<span class="number">.3</span>f&#125;</span>&quot;</span> <span class="keyword">for</span> t <span class="keyword">in</span> theta])</span><br><span class="line">    axs[<span class="number">1</span>].text(<span class="number">0.265</span>, <span class="number">0.71</span>, <span class="string">f&quot;$\\theta: (&#123;&#123;<span class="subst">&#123;str_theta&#125;</span>&#125;&#125;)$&quot;</span>, ha=<span class="string">&quot;left&quot;</span>, va=<span class="string">&quot;top&quot;</span>, color=<span class="string">&quot;darkblue&quot;</span>, transform=axs[<span class="number">1</span>].transAxes)</span><br><span class="line">    fig.suptitle(kernel_name, fontsize=<span class="string">&quot;x-large&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fig</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2-Radial-Basis-Function"><a href="#2-2-Radial-Basis-Function" class="headerlink" title="2.2. Radial Basis Function"></a>2.2. Radial Basis Function</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.RBF.html">scikit-learn: RBF Kernel</a></p></blockquote><ul><li>Gaussian Process의 가장 기본이 되는 커널입니다.</li><li>매끈한 곡선이 우리가 알고 있는 가장 기본적인 모양입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;Radial Basis Function&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_6.png"><br></li></ul><h2 id="2-2-White-Kernel"><a href="#2-2-White-Kernel" class="headerlink" title="2.2. White Kernel"></a>2.2. White Kernel</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.WhiteKernel.html">scikit-learn: White Kernel</a></p></blockquote><p>$$k(x_i, x_j) = noise \_ level \text{ if } x_i == x_j \text{ else } 0$$</p><ul><li>단독으로 사용되기보다 다른 커널에 더해져 노이즈 레벨을 측정하는데 활용됩니다.</li><li>아래 예제에서는 RBF와의 합으로 사용되었으며, posterior에서 noise level = $1.13 \times 10^{-8}$에 불과합니다.</li><li>prior의 noise level이 데이터를 만나 0에 가깝게 수렴한 것입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> WhiteKernel</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>)) + WhiteKernel(noise_level=<span class="number">1</span>, noise_level_bounds=(<span class="number">1e-8</span>, <span class="number">1e1</span>))</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;Radial Basis Function + White Noise&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_11.png"><br></li></ul><h2 id="2-3-Radial-Quadratic-Kernel"><a href="#2-3-Radial-Quadratic-Kernel" class="headerlink" title="2.3. Radial Quadratic Kernel"></a>2.3. Radial Quadratic Kernel</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.RationalQuadratic.html">scikit-learn: Rational Quadratic Kernel</a></p></blockquote><p>$$k(x_i, x_j) = \left(1 + \frac{d(x_i, x_j)^2 }{ 2\alpha  l^2}\right)^{-\alpha}$$</p><ul><li>RBF Kernel과 다른 거리 스케일링의 혼합 척도(scale mixture)로 볼 수 있습니다.</li><li>prior에서는 RBF 커널에 비해 곧게 펴진 듯한 모습이지만 posterior는 RBF와 잘 구분되지 않습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> RationalQuadratic</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1.0</span> * RationalQuadratic(length_scale=<span class="number">1.0</span>, alpha=<span class="number">0.1</span>, alpha_bounds=(<span class="number">1e-5</span>, <span class="number">1e15</span>))</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;Radial Quadratic Function&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_7.png"><br></li></ul><h2 id="2-4-Constant-Kernel"><a href="#2-4-Constant-Kernel" class="headerlink" title="2.4. Constant Kernel"></a>2.4. Constant Kernel</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.ConstantKernel.html">scikit-learn: Constant Kernel</a></p></blockquote><p>$$k(x_1, x_2) = constant\_value ;\forall; x_1, x_2$$</p><ul><li>글자 그대로 상수 커널입니다.</li><li>White Kernel과 유사하게 다른 커널과 함께 사용됩니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> ConstantKernel</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1.0</span> * ConstantKernel(constant_value=<span class="number">1.0</span>, constant_value_bounds=(<span class="number">1e-5</span>, <span class="number">1e15</span>))</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;Constant Kernel&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_15.png"><br></li></ul><h2 id="2-5-Exp-Sine-Squared-Kernel-periodic-kernel"><a href="#2-5-Exp-Sine-Squared-Kernel-periodic-kernel" class="headerlink" title="2.5. Exp-Sine-Squared Kernel (periodic kernel)"></a>2.5. Exp-Sine-Squared Kernel (periodic kernel)</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.ExpSineSquared.html">scikit-learn: ExpSineSquared</a></p></blockquote><p>$$k(x_i, x_j) = \text{exp}\left(-\frac{ 2\sin^2(\pi d(x_i, x_j)/p) }{ l^ 2} \right)$$</p><ul><li>지수함수에 sine함수의 제곱이 포함된 형태입니다.</li><li>주기성을 갖는 데이터를 묘사하기 좋으며 length scale $l &gt; 0$과 함께 periodicity $p &gt; 0$를 매개변수로 가집니다.</li><li>$p$는 Euclidean distance입니다.</li><li>prior와 posterior 모두 자세히 보면 주기성을 띄고 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> ExpSineSquared</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1.0</span> * ExpSineSquared(</span><br><span class="line">    length_scale=<span class="number">1.0</span>,</span><br><span class="line">    periodicity=<span class="number">3.0</span>,</span><br><span class="line">    length_scale_bounds=(<span class="number">0.1</span>, <span class="number">10.0</span>),</span><br><span class="line">    periodicity_bounds=(<span class="number">1.0</span>, <span class="number">10.0</span>),</span><br><span class="line">)</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;ExpSineSquared&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_8.png"><br></li></ul><h2 id="2-6-Dot-Product"><a href="#2-6-Dot-Product" class="headerlink" title="2.6. Dot Product"></a>2.6. Dot Product</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.DotProduct.html?highlight=dotproduct#sklearn.gaussian_process.kernels.DotProduct">scikit-learn: Dot Product</a></p></blockquote><p>$$k(x_i, x_j) = \sigma_0 ^ 2 + x_i \cdot x_j$$</p><ul><li><p>앞에서 본 커널들은 형태는 달라도 두 점 사이의 거리 $d(x_i, x_j)$를 주요 인자로 가집니다.</p></li><li><p>이런 커널을 <b>stationary kernel</b>이라고 합니다.</p></li><li><p>반면 $x_i$, $x_j$ 값 자체에 의해 좌우되는 커널을 <b>non-stationary kernel</b>이라고 합니다.</p></li><li><p>dot product로 정의되기 때문에 원점으로부터의 회전에는 무관하지만 transition에는 민감하게 반응합니다.</p></li><li><p>$\sigma_0 = 0$이라면 homogeneous linear kernel, $\sigma_0 \neq 0$이라면 inhomogeneous가 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1st degree</span></span><br><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> DotProduct</span><br><span class="line"></span><br><span class="line">kernel = DotProduct(sigma_0=<span class="number">1.0</span>, sigma_0_bounds=(<span class="number">0.1</span>, <span class="number">100.0</span>))</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;DotProduct&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="122_gpr2_9.png"><br></p></li><li><p>제곱식을 통해 다항식을 만들 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3rd degree</span></span><br><span class="line">kernel = DotProduct(sigma_0=<span class="number">1.0</span>, sigma_0_bounds=(<span class="number">0.1</span>, <span class="number">100.0</span>))**<span class="number">3</span></span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;DotProduct&quot;</span>)</span><br><span class="line">fig.axes[<span class="number">1</span>].set_ylim(-<span class="number">25</span>, <span class="number">25</span>)</span><br></pre></td></tr></table></figure><p><img src="122_gpr2_16.png"><br></p></li></ul><h2 id="2-7-Matern-Kernel"><a href="#2-7-Matern-Kernel" class="headerlink" title="2.7. Matérn Kernel"></a>2.7. Matérn Kernel</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.Matern.html#sklearn.gaussian_process.kernels.Matern">scikit-learn: Matern</a></p></blockquote><p>$$k(x_i, x_j) =  \frac{1}{\Gamma(\nu)2^{\nu-1}}\Bigg(\frac{\sqrt{2\nu}}{l} d(x_i , x_j )\Bigg)^\nu K_\nu\Bigg(\frac{\sqrt{2\nu}}{l} d(x_i , x_j )\Bigg)$$</p><ul><li>RBF의 일반화된 버전입니다.</li><li>$\nu$로 결과 함수의 smoothness를 조절하는데 $\nu$가 $\infty$에 접근할수록 RBF에 가까워집니다.</li><li>위 식의 $K_{\nu}(\cdot)$는 modified Bessel function, $\Gamma(\cdot)$는 gamma function입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> Matern</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1.0</span> * Matern(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-1</span>, <span class="number">10.0</span>), nu=<span class="number">1.5</span>)</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;Matérn&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_10.png"><br></li></ul><h2 id="3-결론"><a href="#3-결론" class="headerlink" title="3. 결론"></a>3. 결론</h2><ul><li>Gaussian Process는 임의의 적은 데이터로 멋진 결과물을 만들어내지만 Kernel function에 크게 좌우됩니다.</li><li>문제의 성격과 데이터의 특성에 맞는 적절한 Kernel 선택이 매우 중요합니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/gaussian-process/">gaussian process</category>
      
      <category domain="https://jehyunlee.github.io/tags/bayesian/">bayesian</category>
      
      <category domain="https://jehyunlee.github.io/tags/scikit-learn/">scikit-learn</category>
      
      
    </item>
    
    <item>
      <title>Gaussian Process Practice (1) 1D</title>
      <link>https://jehyunlee.github.io/2022/11/16/Python-DS-121-gpr1/</link>
      <guid>https://jehyunlee.github.io/2022/11/16/Python-DS-121-gpr1/</guid>
      <pubDate>Wed, 16 Nov 2022 12:38:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;Gaussian Process 연습입니다.&lt;/li&gt;
&lt;li&gt;scikit-learn을 비롯한 예제를 재구성하여 연습합니다.&lt;/li&gt;
&lt;li&gt;오차가 없을 때와 있을 때를 비교합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-Data-Prepa</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>Gaussian Process 연습입니다.</li><li>scikit-learn을 비롯한 예제를 재구성하여 연습합니다.</li><li>오차가 없을 때와 있을 때를 비교합니다.</li></ul><h1 id="1-Data-Preparation"><a href="#1-Data-Preparation" class="headerlink" title="1. Data Preparation"></a>1. Data Preparation</h1><blockquote><p><a href="https://scikit-learn.org/stable/auto_examples/gaussian_process/plot_gpr_noisy_targets.html#sphx-glr-auto-examples-gaussian-process-plot-gpr-noisy-targets-py">scikit-learn: Gaussian Process Regression: basic introductory example</a></p></blockquote><h2 id="1-1-example-data"><a href="#1-1-example-data" class="headerlink" title="1.1. example data"></a>1.1. example data</h2><ul><li><p>Gaussian Process 연습을 위한 데이터를 준비합니다.</p></li><li><p><a href="https://scikit-learn.org/stable/auto_examples/gaussian_process/plot_gpr_noisy_targets.html#sphx-glr-auto-examples-gaussian-process-plot-gpr-noisy-targets-py">scikit-learn의 예제</a>를 일부 변형합니다.</p></li><li><p>1000개로 이루어진 매끈한 곡선을 만듭니다. </p></li><li><p>이번 글에서는 랜덤 함수를 많이 사용합니다. <b>random number generator</b>를 정의해 재현성을 확보합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 라이브러리 및 random number generator</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">rng = np.random.RandomState(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># example data visualization</span></span><br><span class="line">X = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">1000</span>).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">y = np.squeeze(X*np.sin(X))</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">ax.plot(X, y)</span><br></pre></td></tr></table></figure><p><img src="121_gpr1_1.png"><br></p></li><li><p>지금 그린 그래프는 우리가 Gaussian Process로 찾아야 할 참값입니다.</p></li></ul><h2 id="1-2-6-training-points"><a href="#1-2-6-training-points" class="headerlink" title="1.2. 6 training points"></a>1.2. 6 training points</h2><ul><li>임의의 x 좌표 6개를 골라 예제 데이터를 뽑습니다. <b>측정값(evidence)</b>이라 볼 수 있습니다.</li><li>두 가지 상황을 가정해 이 지점들로 참값 곡선을 찾아갈 것입니다.</li><li><b>① 측정을 하면 정확한 값을 찾아내는 경우:</b> 딱 6개만 뽑으면 됩니다.</li><li><b>② 측정이 불확실성을 안고 있는 경우: </b> x 하나당 10번씩 측정했다고 하겠습니다. 표준 편차 = 1입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">training_indices = rng.choice(np.arange(y.size), size=<span class="number">6</span>, replace=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ① exact observation</span></span><br><span class="line">X_train = X[training_indices]</span><br><span class="line">y_train = y[training_indices]</span><br><span class="line"></span><br><span class="line"><span class="comment"># ② noisy situation</span></span><br><span class="line">noise_std = <span class="number">1</span></span><br><span class="line">X_train_noisy = np.array(X[training_indices].tolist()*<span class="number">10</span>)</span><br><span class="line">y_train_noisy = np.array(<span class="built_in">list</span>(y[training_indices])*<span class="number">10</span>) + rng.normal(<span class="number">0</span>, noise_std, size=y_train.shape[<span class="number">0</span>]*<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">ax.plot(X, y, c=<span class="string">&quot;lightgray&quot;</span>, label=<span class="string">&quot;true&quot;</span>)</span><br><span class="line">ax.scatter(X_train, y_train, label=<span class="string">&quot;sample without noise&quot;</span>)</span><br><span class="line">ax.scatter(X_train_noisy, y_train_noisy, label=<span class="string">&quot;sample with noise&quot;</span>, s=<span class="number">5</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">ax.legend()</span><br></pre></td></tr></table></figure><img src="121_gpr1_2.png"><br></li></ul><h1 id="2-Gaussian-Process"><a href="#2-Gaussian-Process" class="headerlink" title="2. Gaussian Process"></a>2. Gaussian Process</h1><h2 id="2-1-Without-Noise"><a href="#2-1-Without-Noise" class="headerlink" title="2.1. Without Noise"></a>2.1. Without Noise</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.RBF.html">scikit-learn: Radial basis function kernel</a><br><a href="https://thegradient.pub/gaussian-process-not-quite-for-dummies/">The Gradient: Gaussian Process, not quite for dummies</a></p></blockquote><ul><li><p>evidence가 참값인 경우의 Gaussian Process를 실행합니다.</p></li><li><p>커널에는 Radial Bassis Function 커널을 사용합니다.</p></li><li><p>length_scale 초기값은 1, 범위는 0.01부터 100 안에서 fitting합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process <span class="keyword">import</span> GaussianProcessRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> RBF</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>)</span><br><span class="line">gpr.fit(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(gpr.kernel_)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5.02**2 * RBF(length_scale=1.43)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>fitting 결과 1로 지정했던 계수와 <code>length_scale</code>이 변경되었습니다.</p></li><li><p>계수는 신뢰구간의 폭, <code>length_scale</code>은 곡선의 매끈함(smoothness)에 해당합니다.<br><br><img src="121_gpr1_10.png" alt="The Gradient"><br><br><img src="121_gpr1_11.png" alt="The Gradient"><br></p></li><li><p>다음 명령으로 추가 정보를 얻을 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpr.kernel_.theta</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([3.22768806, 0.36021977])</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>gpr.kernel_theta</code>는 <code>(flattened, log-transformed) non-fixed hyperparameters</code>입니다.</p></li><li><p>전체 X를 넣고 Gaussian Process 결과를 그림으로 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prediction</span></span><br><span class="line">y_pred_mean, y_pred_std = gpr.predict(X, return_std=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="121_gpr1_3.png"><br></p></li><li><p>확대를 해도 측정값은 신뢰구간의 폭이 0임을 확인할 수 있습니다.</p></li><li><p>측정된 데이터를 참값으로 가정했으므로 측정값의 분산은 0입니다.</p></li></ul><h2 id="2-2-With-Noise"><a href="#2-2-With-Noise" class="headerlink" title="2.2. With Noise"></a>2.2. With Noise</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.GaussianProcessRegressor.html#sklearn.gaussian_process.GaussianProcessRegressor">scikit-learn: GaussianProcessRegressor</a></p></blockquote><ul><li>이번에는 측정 데이터에 오차가 포함된 경우를 살펴봅니다.</li><li>오차가 있는 데이터는 <code>GaussianProcessRegressor()</code>에 측정 오차를 의미하는 매개변수 <code>alpha</code>를 추가해야 합니다.</li><li>수식에서는 커널 행렬의 대각 요소에 추가되는 값으로 fitting시 발생하는 numerical issue를 예방합니다. </li></ul><h3 id="2-2-1-오차-데이터-직접-입력"><a href="#2-2-1-오차-데이터-직접-입력" class="headerlink" title="2.2.1. 오차 데이터 직접 입력"></a>2.2.1. 오차 데이터 직접 입력</h3><ul><li><p>아까와 동일하게 Gaussian Process fitting을 수행합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">gpr.fit(X_train_noisy, y_train_noisy)</span><br><span class="line"><span class="built_in">print</span>(gpr.kernel_)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.92**2 * RBF(length_scale=1.37)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>아까와는 다른 값으로 수렴했습니다.</p></li><li><p>다시 전체 X를 넣고 예측 결과를 확인합니다.</p></li><li><p>참값은 입력하지 않았지만 대조를 위해 함께 도시합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prediction</span></span><br><span class="line">y_pred_mean, y_pred_std = gpr.predict(X, return_std=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="121_gpr1_4.png"><br></p></li><li><p>데이터를 확보한 곳에서도 불확실성에 의해 신뢰구간이 한 점으로 수렴하지 않습니다.</p></li><li><p>아울러 전체의 평균값도 참값에서 조금씩 어긋나 있음을 확인할 수 있습니다.</p></li></ul><h3 id="2-2-2-오차-분산-입력"><a href="#2-2-2-오차-분산-입력" class="headerlink" title="2.2.2. 오차 분산 입력"></a>2.2.2. 오차 분산 입력</h3><ul><li>이번에는 모든 데이터를 입력하는 대신 <b>참값</b>데이터와 함께 <b>분산</b>을 입력합니다.</li><li>앞서 noise를 만들 때 표준 편차 = 1을 입력했는데 정말 그런지 확인합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df_noisy = pd.DataFrame(&#123;<span class="string">&quot;X_noisy&quot;</span>:X_train_noisy.ravel(), <span class="string">&quot;y_noisy&quot;</span>:y_train_noisy&#125;)</span><br><span class="line">dfg_noisy = df_noisy.groupby(<span class="string">&quot;X_noisy&quot;</span>).std()</span><br><span class="line">std = dfg_noisy.mean().values[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(std)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.0616168585081918</span><br></pre></td></tr></table></figure></li></ul></li><li>의도한 바와 같이 데이터의 평균 분산은 1과 유사한 값으로 나왔습니다.</li><li>애초에 의도한 값 1을 제곱하여 <code>alpha</code>에 입력하고 Gaussian Process를 진행합니다.</li><li>계수가 아까보다 작게 나왔습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, alpha=<span class="number">1</span>**<span class="number">2</span>)</span><br><span class="line">gpr.fit(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(gpr.kernel_)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.39**2 * RBF(length_scale=1.16)</span><br></pre></td></tr></table></figure></li></ul></li><li>같은 코드로 그림을 그려 확인합니다.</li><li>줄어든 계수가 무색하게 전체적으로 신뢰구간이 더 넓은 듯한 느낌입니다.<br><img src="121_gpr1_5.png"><br></li></ul><h3 id="2-2-3-alpha가-같을-때-데이터-수에-따른-비교"><a href="#2-2-3-alpha가-같을-때-데이터-수에-따른-비교" class="headerlink" title="2.2.3. alpha가 같을 때 데이터 수에 따른 비교"></a>2.2.3. alpha가 같을 때 데이터 수에 따른 비교</h3><ul><li><p>noisy data를 직접 입력했을 때와 모양이 달라진 것이 데이터에 무관한, alpha에 따른 차이가 아닐까 의구심이 듭니다.</p></li><li><p><code>alpha=1</code>로 설정하고 noisy data로 학습시킨 후 양상을 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, alpha=<span class="number">1</span>)</span><br><span class="line">gpr.fit(X_train_noisy, y_train_noisy)</span><br><span class="line"><span class="built_in">print</span>(gpr.kernel_)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.84**2 * RBF(length_scale=1.34)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>값이 조금 다르기는 하지만 noisy data를 입력했을 때에 가깝습니다.</p></li><li><p>그래프 모양을 보면 더 확연하게 드러납니다.<br><img src="121_gpr1_8.png"><br></p></li></ul><h3 id="2-2-4-커널-parameter-범위에-따른-결과"><a href="#2-2-4-커널-parameter-범위에-따른-결과" class="headerlink" title="2.2.4. 커널 parameter 범위에 따른 결과"></a>2.2.4. 커널 parameter 범위에 따른 결과</h3><ul><li><p>앞서 kernel을 다음과 같이 정의했습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br></pre></td></tr></table></figure></li><li><p>RBF kernel의 length scale이 가질 수 있는 범위를 0.01 ~ 100으로 지정한 것입니다.</p></li><li><p>그리고 결과적으로 입력된 데이터에 의해 <code>length scale = 1.16</code>로 결정되었습니다.</p></li><li><p>그런데 초기값의 범위가 이 밖에 있으면 전혀 다른 결과가 얻어집니다.</p></li><li><p>먼저, length scale이 너무 클 때입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">100</span>, length_scale_bounds=(<span class="number">10</span>, <span class="number">1e3</span>))</span><br></pre></td></tr></table></figure></li><li><p>초기값을 100, 범위를 10~1000으로 잡으면 결과적으로 <code>316**2 * RBF(length_scale=10)</code>에 수렴합니다.</p></li><li><p>이 때 결과는 다음과 같습니다.</p></li><li><p>지나친 과소적합(underfitting)으로 인해 x=0 부근에서 참값을 따라가지 못하고 평균값이 40 가까이 발산해 버렸습니다.<br><img src="121_gpr1_6.png"><br></p></li></ul><ul><li><p>이번에는 거꾸로 kernel의 length_scale이 너무 작은 경우입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">0.01</span>, length_scale_bounds=(<span class="number">1e-4</span>, <span class="number">1e-1</span>))</span><br></pre></td></tr></table></figure></li><li><p>학습 결과 kernel이 <code>4.16**2 * RBF(length_scale=0.01)</code>로, length scale이 입력된 범위의 최대값에 닿았습니다.</p></li><li><p>결과적으로 과대적합(overfitting)이라고 불러야 할지 애매하지만 측정값 외에는 미동도 하지 않았습니다.<br><img src="121_gpr1_7.png"><br></p></li></ul><h1 id="3-결론"><a href="#3-결론" class="headerlink" title="3. 결론"></a>3. 결론</h1><ul><li>Gaussian Process는 적은 데이터로 오차를 포함한 결과를 효과적으로 추론합니다.</li><li>그러나 커널의 제약에 민감하기 때문에 주의깊게 살펴볼 필요가 있습니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/gaussian-process/">gaussian process</category>
      
      <category domain="https://jehyunlee.github.io/tags/bayesian/">bayesian</category>
      
      <category domain="https://jehyunlee.github.io/tags/scikit-learn/">scikit-learn</category>
      
      
    </item>
    
    <item>
      <title>딥러닝 공개 모델 활용 정보 수집 효율화</title>
      <link>https://jehyunlee.github.io/2022/11/11/Python-DS-120-eost2022/</link>
      <guid>https://jehyunlee.github.io/2022/11/11/Python-DS-120-eost2022/</guid>
      <pubDate>Fri, 11 Nov 2022 13:13:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;&lt;a href=&quot;https://www.etri.re.kr/&quot;&gt;한국전자통신연구원&lt;/a&gt;&lt;/b&gt; 오픈소스센터가 주축이 되어 &lt;b&gt;ETRI Open Source Tech Day&lt;/b&gt;가 열렸습니다.&lt;ul&gt;
&lt;li&gt;과학기술정보통신부가 주</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b><a href="https://www.etri.re.kr/">한국전자통신연구원</a></b> 오픈소스센터가 주축이 되어 <b>ETRI Open Source Tech Day</b>가 열렸습니다.<ul><li>과학기술정보통신부가 주최하고</li><li>한국전자통신연구원, 한국과학기술정보연구원, 한국식품연구원, 한국에너지기술연구원, 한국원자력연구원, 한국화학연구원, 한국항공우주연구원이 공동 주관했습니다.<br></li></ul></li></ul><ul><li>2021년 <b><a href="https://www.youtube.com/watch?v=X3FjEzfHsyc">내가 해온 연구에 데이터 분석 끼얹기</a></b>라는 제목으로 온라인 발표를 했고,</li><li>올해는 오프라인으로 <b>딥러닝 공개 모델 활용 정보 수집 효율화</b> 발표를 진행했습니다.<ul><li>저희 연구원 글로벌전략실과 협업을 진행하는 내용을 공개했습니다.</li><li>해외 연구원과 효과적인 협업을 위해 현황과 양측의 상대적 장단점을 파악했습니다.<br></li></ul></li></ul><ul><li>발표 영상 : <a href="https://youtu.be/epOab26Zsas">Youtube Link</a><br><p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/epOab26Zsas" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><img src="kier.PNG"><br><br></p><ul><li>행사 홈페이지: <a href="https://eostday.kr/">https://eostday.kr/</a><br><br><img src="EOST2022-EDM-v1.3.jpg" alt="EOST2022 일정표"></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/EOST/">EOST</category>
      
      <category domain="https://jehyunlee.github.io/tags/natural-language-processing/">natural language processing</category>
      
      <category domain="https://jehyunlee.github.io/tags/ETRI/">ETRI</category>
      
      
    </item>
    
    <item>
      <title>gaussian process</title>
      <link>https://jehyunlee.github.io/2022/11/04/Python-DS-119-kierlecture7/</link>
      <guid>https://jehyunlee.github.io/2022/11/04/Python-DS-119-kierlecture7/</guid>
      <pubDate>Fri, 04 Nov 2022 07:18:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;한국에너지기술연구원 AI 학습조직&lt;/b&gt;에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.&lt;ul&gt;
&lt;li&gt;실험을 계획하고 최적 실험 조건을 탐색하는 방법들을 살펴봅니다.&lt;/li&gt;
&lt;li&gt;전통적인 실험계획법(design of</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b>한국에너지기술연구원 AI 학습조직</b>에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.<ul><li>실험을 계획하고 최적 실험 조건을 탐색하는 방법들을 살펴봅니다.</li><li>전통적인 실험계획법(design of experiment), 반응표면법(response surface method)을 살펴보고,</li><li>효과적인 실험 설계를 도와주는 Gaussian Process와 이 바탕에 깔린 베이즈 법칙(Bayes’ Rule)을 살펴봅니다.</li><li><a href="221104_%EC%9D%B4%EC%A0%9C%ED%98%84_8%EC%B0%A8%EB%AA%A8%EC%9E%84_GaussianProcess.pdf">강의 자료는 여기에서 다운받으실 수 있습니다</a></li></ul></li></ul><ul><li><p>발표 영상 : (<a href="https://youtu.be/9vIPzpzfw-o">Youtube Link</a>)<br></p></li><li><p>실습 코드 : (<a href="https://bit.ly/3NvEwIO">https://bit.ly/3NvEwIO</a>)<br></p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/9vIPzpzfw-o" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><img src="gp.gif"><br></p><p><ul><li>바쁜 연구원 일정 속에 변동이 있겠지만, 최대한 일정을 지켜보고자 합니다.</li></ul><p><img src="schedule.png" alt="학습조직 일정"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/machine-learning/">machine learning</category>
      
      <category domain="https://jehyunlee.github.io/tags/KIER/">KIER</category>
      
      <category domain="https://jehyunlee.github.io/tags/gaussian-process/">gaussian process</category>
      
      <category domain="https://jehyunlee.github.io/tags/bayesian/">bayesian</category>
      
      <category domain="https://jehyunlee.github.io/tags/design-of-experiment/">design of experiment</category>
      
      <category domain="https://jehyunlee.github.io/tags/response-surface-method/">response surface method</category>
      
      
    </item>
    
    <item>
      <title>Auto Contrast on SEM image</title>
      <link>https://jehyunlee.github.io/2022/10/29/Python-DS-118-autocontrast/</link>
      <guid>https://jehyunlee.github.io/2022/10/29/Python-DS-118-autocontrast/</guid>
      <pubDate>Fri, 28 Oct 2022 19:58:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;영상 촬영을 하다 보면 결과물이 마음에 들지 않는 여러 이유가 있습니다.&lt;/li&gt;
&lt;li&gt;애초에 잘 찍으면 되겠지만 장비나 숙련도 등의 문제로 한계가 있습니다.&lt;/li&gt;
&lt;li&gt;전자현미경 사진은 여기에 시료의 상태까지 한 몫 합니다.&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>영상 촬영을 하다 보면 결과물이 마음에 들지 않는 여러 이유가 있습니다.</li><li>애초에 잘 찍으면 되겠지만 장비나 숙련도 등의 문제로 한계가 있습니다.</li><li>전자현미경 사진은 여기에 시료의 상태까지 한 몫 합니다.</li><li>방해 요소를 제외하고 자동 명도 및 대비 보정을 하는 방법을 알아봅니다.</li></ul><h1 id="1-예제-이미지"><a href="#1-예제-이미지" class="headerlink" title="1. 예제 이미지"></a>1. 예제 이미지</h1><p><img src="118_autocontrast_0.png"><br></p><ul><li>위와 같은 전자현미경 사진을 얻었다고 합시다.</li><li>전자현미경은 빛 대신 전자빔을 쏘아 매우 작은 시료를 찍는 도구입니다.</li><li>전자빔을 충분히 강하게 쬐면 밝고 좋은 영상을 얻을 수 있지만 시료에 따라 망가지기도 합니다.</li></ul><h1 id="2-ImageJ-사용-보정"><a href="#2-ImageJ-사용-보정" class="headerlink" title="2. ImageJ 사용 보정"></a>2. ImageJ 사용 보정</h1><blockquote><p><a href="https://imagej.net/">ImageJ</a></p></blockquote><ul><li><p>이미지 보정 프로그램에서 대비를 높일 수 있습니다.</p></li><li><p><a href="https://imagej.net/software/fiji/">ImageJ Fiji</a>를 사용해 개선을 시도합니다.</p></li><li><p><b>File &gt; Open</b>으로 파일을 불러온 후 <b>Image &gt; Adjust &gt; Bright &amp; Contrast</b>를 실행합니다.<br><br><img src="118_autocontrast_1.png"><br></p></li><li><p><b>B&amp;C</b>라는 이름의 작은 창에 이미지를 구성하는 픽셀들의 히스토그램이 보입니다.</p></li><li><p><b>Auto</b>를 두 번 누르면 아래와 같이 밝아지지만 대비가 개선되지 않습니다.<br><br><img src="118_autocontrast_2.png"><br></p></li><li><p>이미지 하단에 촬영 조건과 스케일바가 검정과 흰색 부분으로 붙어 있어 이 부분이 걸림돌이 됩니다.</p></li><li><p>이미지를 구성하는 음영 중 최대값(white)와 최소값(black)이 정해져 있는 바람에 가운데 몰린 분포가 개선되지 않는 것입니다.</p></li><li><p>하단을 잘라내고 재시도합니다. 메뉴 바 왼쪽의 사각형을 골라 이미지 부분만 선택합니다.<br><br><img src="118_autocontrast_3.png"><br></p></li><li><p><b>Image &gt; Crop</b>을 실행하면 아래처럼 하단이 사라집니다.<br><br><img src="118_autocontrast_4.png"><br></p></li><li><p>다시 <b>Image &gt; Adjust &gt; Bright &amp; Contrast</b>에서 Auto를 실행하면 비로소 선명해집니다.<br><br><img src="118_autocontrast_5.png"><br></p></li><li><p>하지만 스케일 바를 비롯한 중요 정보를 잃어버린 상태입니다.</p></li><li><p>논문에 싣거나 내부 발표라도 하려면 스케일 바를 다시 붙여야 합니다.</p></li><li><p>몹시 귀찮아지고, 잘 하더라도 실수가 생길 수 있습니다.</p></li><li><p>무엇보다 대개 이런 이미지는 한 두 장으로 끝나지 않습니다. 자동화가 필요합니다.</p></li></ul><h1 id="3-scikit-image-사용-보정"><a href="#3-scikit-image-사용-보정" class="headerlink" title="3. scikit-image 사용 보정"></a>3. <code>scikit-image</code> 사용 보정</h1><blockquote><p><a href="https://scikit-image.org/">scikit-image</a></p></blockquote><h2 id="3-1-scikit-image-설치"><a href="#3-1-scikit-image-설치" class="headerlink" title="3.1. scikit-image 설치"></a>3.1. <code>scikit-image</code> 설치</h2><ul><li>파이썬에는 이미지 처리 라이브러리가 여럿 있습니다.</li><li>오늘은 <a href="https://scikit-image.org/">scikit-image</a>를 사용해 작업합니다.</li><li><code>pip</code>를 사용해 설치할 수 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!pip install scikit-image -U</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-2-이미지-불러오기"><a href="#3-2-이미지-불러오기" class="headerlink" title="3.2. 이미지 불러오기"></a>3.2. 이미지 불러오기</h2><ul><li><p><code>skimage.io</code>의 <code>imread</code> 모듈을 사용해 이미지를 읽고 <code>imshow</code>로 출력합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage.io <span class="keyword">import</span> imread, imshow</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">infilename = <span class="string">&quot;sample.jpg&quot;</span></span><br><span class="line"></span><br><span class="line">img_ = imread(infilename)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(img_))</span><br><span class="line">imshow(img_)</span><br></pre></td></tr></table></figure><p><img src="118_autocontrast_6.png"><br></p></li><li><p><code>imread</code>로 읽은 이미지의 정체는 <code>numpy.ndarray</code>입니다.</p></li><li><p>출력된 이미지의 정체는 사실 <code>matplotlib.image.AxesImage</code>입니다.</p></li><li><p><code>scikit-image</code> 내부에서 <code>matplotlib</code>을 호출하는 것입니다.</p></li><li><p><code>imshow(img_)</code> 대신 <code>plt.imshow(img_, cmap=&quot;Greys_r&quot;)</code>를 실행해도 같은 결과를 얻을 수 있습니다.</p></li></ul><h2 id="3-3-이미지-및-하단-영역-크기-분리"><a href="#3-3-이미지-및-하단-영역-크기-분리" class="headerlink" title="3.3. 이미지 및 하단 영역 크기 분리"></a>3.3. 이미지 및 하단 영역 크기 분리</h2><ul><li><p>이미지 크기는 <code>.shape</code>을 출력해 확인할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_.shape</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(480, 640)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>이제 하단 영역의 높이를 알아볼 차례입니다.</p></li><li><p>x = 300 지점에서 세로로 나열된 픽셀들의 line profile을 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">0</span>].imshow(img_, cmap=<span class="string">&quot;Greys_r&quot;</span>)   <span class="comment"># 왼쪽 Axes에 Image 출력</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># x = 300을 추출해서 오른쪽 Axes에 line profile 출력, 왼쪽에 선 표시</span></span><br><span class="line">x = <span class="number">300</span></span><br><span class="line">axs[<span class="number">1</span>].plot(img_[:, x], c=<span class="string">&quot;orange&quot;</span>)   <span class="comment"># 오른쪽 Axes에 line profile 출력</span></span><br><span class="line">axs[<span class="number">0</span>].axvline(x, c=<span class="string">&quot;orange&quot;</span>)         <span class="comment"># 왼쪽 image 위에 해당 line 출력   </span></span><br></pre></td></tr></table></figure><p><img src="118_autocontrast_7.png"><br></p></li><li><p>450 부근부터의 데이터 값이 모두 0입니다. </p></li><li><p>여기가 하단 메타데이터 영역입니다.</p></li><li><p>말단 50개 데이터를 출력해 0을 세어 보면 0이 31개 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_[-<span class="number">50</span>:, x]</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array([118, 112, 115, 113, 111, 122, 122, 118, 111, 114, 111, 116, 122,</span><br><span class="line">      120, 120, 123, 124, 101,  25,   0,   0,   0,   0,   0,   0,   0,</span><br><span class="line">      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,</span><br><span class="line">      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0], dtype=uint8)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>480행 중 31행이면 16분의 1을 조금 넘습니다.</p></li><li><p>여유 있게 하단 15분의 1을 잘라내고 위쪽을 <code>img</code>, 아래쪽을 <code>desc</code>(description)라고 부릅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">h, w = img_.shape</span><br><span class="line"></span><br><span class="line">imgfrac = <span class="number">14</span>/<span class="number">15</span></span><br><span class="line">img = img_[:<span class="built_in">int</span>(h*imgfrac), :]</span><br><span class="line">desc = img_[<span class="built_in">int</span>(h*imgfrac):, :]</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">axs[<span class="number">0</span>].imshow(img, cmap=<span class="string">&quot;Greys_r&quot;</span>)</span><br><span class="line">axs[<span class="number">1</span>].imshow(desc, cmap=<span class="string">&quot;Greys_r&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig.savefig(<span class="string">&quot;118_autocontrast_8.png&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="118_autocontrast_8.png"><br></p></li><li><p>잘라낸 것만으로 왼쪽 그림이 선명해졌습니다.</p></li><li><p>Matplotlib이 그림을 보여주면서 데이터의 최소값과 최대값을 자동으로 적용했기 때문입니다.</p></li><li><p>원본 <code>img_</code>와 하단을 잘라낸 <code>img</code>의 데이터 분포를 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>,</span><br><span class="line">                       sharex=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, im, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [img_, img], [<span class="string">&quot;original&quot;</span>, <span class="string">&quot;image only&quot;</span>]):</span><br><span class="line">    ax.hist(im.flatten(), bins=np.linspace(<span class="number">0</span>, <span class="number">255</span>, <span class="number">30</span>))</span><br><span class="line">    ax.text(<span class="number">0.7</span>, <span class="number">0.95</span>, <span class="string">f&quot;min = <span class="subst">&#123;im.<span class="built_in">min</span>()&#125;</span>\nmax = <span class="subst">&#123;im.<span class="built_in">max</span>()&#125;</span>&quot;</span>, va=<span class="string">&quot;top&quot;</span>,</span><br><span class="line">           fontsize=<span class="string">&quot;x-large&quot;</span>, transform=ax.transAxes)</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;x-large&quot;</span>, pad=<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p><img src="118_autocontrast_9.png"><br></p></li><li><p>원본이 0<del>252까지 범위를 가지는 데 비해 이미지 영역만 따지면 75</del>187에 분포하고 있습니다.</p></li></ul><h2 id="3-4-이미지-영역에-auto-contrast-적용"><a href="#3-4-이미지-영역에-auto-contrast-적용" class="headerlink" title="3.4. 이미지 영역에 auto contrast 적용"></a>3.4. 이미지 영역에 auto contrast 적용</h2><blockquote><p><a href="https://en.wikipedia.org/wiki/Salt-and-pepper_noise">wikipedia: salt and pepper noise</a></p></blockquote><ul><li><p>이미지의 최대값과 최소값을 0~255로 폅니다.</p></li><li><p>그 전에, 전자현미경 같은 디지털 영상에 흔한 <b>salt and pepper noise</b> 대응책을 마련합니다.</p></li><li><p><a href="https://en.wikipedia.org/wiki/Salt-and-pepper_noise">salt and pepper noise</a>는 영상 위에 희고 검은 점이 흩뿌려지는 현상입니다.</p></li><li><p>전기 신호가 불안정하거나 원본의 대비가 잡음보다 약할 때 주로 생깁니다.<br><br><img src="118_autocontrast_10.png" alt="wikipedia: salt and pepper noise"><br></p></li><li><p><code>numpy.percentile()</code>로 전체 데이터의 상하위 0.2%씩을 제거한 뒤,</p></li><li><p><code>skimage.exposure.rescale_intensity()</code>를 사용해 0부터 255까지 데이터의 범위를 늘려줍니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> exposure</span><br><span class="line"></span><br><span class="line"><span class="comment"># salt and pepper noise 제거</span></span><br><span class="line">v_min, v_max = np.percentile(img, (<span class="number">0.2</span>, <span class="number">99.8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># auto contrast 적용</span></span><br><span class="line">img_ac = exposure.rescale_intensity(img, in_range=(v_min, v_max), out_range=(<span class="number">0</span>, <span class="number">255</span>)).astype(np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 전후 비교</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, im, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [img, img_ac], [<span class="string">&quot;original&quot;</span>, <span class="string">&quot;auto contrast&quot;</span>]):</span><br><span class="line">    ax.imshow(im, cmap=<span class="string">&quot;Greys_r&quot;</span>, vmin=<span class="number">0</span>, vmax=<span class="number">255</span>)</span><br><span class="line">    x_pos = <span class="number">0.045</span></span><br><span class="line">    <span class="keyword">if</span> ax == axs[<span class="number">1</span>]:</span><br><span class="line">        x_pos += <span class="number">0.5</span></span><br><span class="line">    ax_inset = fig.add_axes([x_pos, <span class="number">0.69</span>, <span class="number">0.15</span>, <span class="number">0.2</span>])</span><br><span class="line">    ax_inset.hist(im.flatten(), fc=<span class="string">&quot;orange&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, bins=np.linspace(<span class="number">0</span>, <span class="number">255</span>, <span class="number">30</span>))</span><br><span class="line">    ax_inset.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">255</span>), yticks=[], xticks=[])</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;x-large&quot;</span>, pad=<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p><img src="118_autocontrast_11.png"><br></p></li></ul><h2 id="3-4-하단-영역-결합"><a href="#3-4-하단-영역-결합" class="headerlink" title="3.4. 하단 영역 결합"></a>3.4. 하단 영역 결합</h2><ul><li>이제 처음에 분리해 둔 하단 영역을 결합할 차례입니다.</li><li><code>numpy.vstack()</code>을 사용합니다.</li><li>파일 저장은 <code>skimage.io</code>의 <code>imsave</code>로 실행합니다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage.io <span class="keyword">import</span> imsave</span><br><span class="line"></span><br><span class="line">img_merge = np.vstack((img_ac, desc))</span><br><span class="line">imsave(<span class="string">&quot;img_autocontrast.png&quot;</span>, img_merge)</span><br></pre></td></tr></table></figure><p><img src="img_autocontrast.png"><br></p><ul><li>스케일바를 비롯한 정보가 돌아왔습니다.</li></ul><h1 id="4-주의-사항"><a href="#4-주의-사항" class="headerlink" title="4. 주의 사항"></a>4. 주의 사항</h1><ul><li><p>분석을 열심히 하다 보면 크기를 재거나 중요 지점을 표시할 때가 있습니다.<br><br><img src="sample_annot.png"><br></p></li><li><p>여기에 위 코드를 동일하게 적용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">infilename = <span class="string">&quot;sample_annot.png&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># read image</span></span><br><span class="line">img_ = imread(infilename)</span><br><span class="line"></span><br><span class="line"><span class="comment"># image split: img + desc</span></span><br><span class="line">imgfrac = <span class="number">14</span>/<span class="number">15</span></span><br><span class="line">img = img_[:<span class="built_in">int</span>(h*imgfrac), :]</span><br><span class="line">desc = img_[<span class="built_in">int</span>(h*imgfrac):, :]</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove salt and pepper noise</span></span><br><span class="line">v_min, v_max = np.percentile(img, (<span class="number">0.2</span>, <span class="number">99.8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># apply auto contrast</span></span><br><span class="line">img_ac = exposure.rescale_intensity(img, in_range=(v_min, v_max), out_range=(<span class="number">0</span>, <span class="number">255</span>)).astype(np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># merge images</span></span><br><span class="line">img_merge = np.vstack((img_ac, desc))</span><br><span class="line"></span><br><span class="line"><span class="comment"># save file</span></span><br><span class="line">imsave(<span class="string">&quot;annot_autocontrast.png&quot;</span>, img_merge)</span><br></pre></td></tr></table></figure></li><li><p>그리고 결과를 확인해 보면 대비 보정이 적용되지 않았습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, im, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [img_, img_merge], [<span class="string">&quot;original&quot;</span>, <span class="string">&quot;auto contrast&quot;</span>]):</span><br><span class="line">    ax.imshow(im, cmap=<span class="string">&quot;Greys_r&quot;</span>, vmin=<span class="number">0</span>, vmax=<span class="number">255</span>)</span><br><span class="line">    x_pos = <span class="number">0.045</span></span><br><span class="line">    <span class="keyword">if</span> ax == axs[<span class="number">1</span>]:</span><br><span class="line">        x_pos += <span class="number">0.5</span></span><br><span class="line">    ax_inset = fig.add_axes([x_pos, <span class="number">0.69</span>, <span class="number">0.15</span>, <span class="number">0.2</span>])</span><br><span class="line">    ax_inset.hist(im.flatten(), fc=<span class="string">&quot;orange&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, bins=np.linspace(<span class="number">0</span>, <span class="number">255</span>, <span class="number">30</span>))</span><br><span class="line">    ax_inset.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">255</span>), yticks=[], xticks=[])</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;x-large&quot;</span>, pad=<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p><img src="118_autocontrast_12.png"><br></p></li><li><p><b>이미지 영역에 추가한 표지가 문제</b>가 되는 경우입니다.</p></li><li><p>salt and pepper noise를 제거하기 위해 상하위 0.2%만 제거했는데, 이 그림에는 <b>하양과 검정으로 표현된 화살표와 글자들이 0.2%를 넘어섰기 때문에 제거되지 않고 명도의 최대값고 최소값으로 인지된 것</b>입니다. </p></li><li><p>이러한 보정은 추가 정보를 기입하지 않은 상태에서 적용해야 올바르게 적용되니 주의해야 합니다.</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/imagej/">imagej</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/image/">image</category>
      
      <category domain="https://jehyunlee.github.io/tags/scikit-image/">scikit-image</category>
      
      
    </item>
    
    <item>
      <title>혼란한 Matplotlib에서 질서 찾기</title>
      <link>https://jehyunlee.github.io/2022/10/16/Python-DS-117-pycon2022/</link>
      <guid>https://jehyunlee.github.io/2022/10/16/Python-DS-117-pycon2022/</guid>
      <pubDate>Sun, 16 Oct 2022 12:49:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://2022.pycon.kr/&quot;&gt;&lt;b&gt;PyCon Korea 2022&lt;/b&gt;&lt;/a&gt;에서 한 발표 영상입니다.&lt;ul&gt;
&lt;li&gt;Matplotlib을 데이터를 그리는 도구로 많이 알고 계십니다.&lt;/li&gt;
&lt;li&gt;하지</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><a href="https://2022.pycon.kr/"><b>PyCon Korea 2022</b></a>에서 한 발표 영상입니다.<ul><li>Matplotlib을 데이터를 그리는 도구로 많이 알고 계십니다.</li><li>하지만 Matplotlib은 시각화 라이브러리 이상의 생태계입니다. </li><li>seaborn을 사용해 데이터 시각화 결과물의 퀄리티를 높일 수 있고,</li><li>생태계의 다른 라이브러리를 사용해 그린 그림을 Matplotlib으로 편집할 수 있습니다.</li></ul></li></ul><ul><li>발표 영상 : (<a href="https://youtu.be/ZTRKojTLE8M">Youtube Link</a>)<br></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/ZTRKojTLE8M" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><img src="117_pycon2022_1.png"><br></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/pycon/">pycon</category>
      
      
    </item>
    
    <item>
      <title>Python Script in Power BI Desktop</title>
      <link>https://jehyunlee.github.io/2022/10/14/Python-DS-116-powerbi/</link>
      <guid>https://jehyunlee.github.io/2022/10/14/Python-DS-116-powerbi/</guid>
      <pubDate>Fri, 14 Oct 2022 00:47:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;Microsoft가 출시한 Power BI는 강력합니다.&lt;ul&gt;
&lt;li&gt;윈도 환경에서 데이터를 쉽게 시각화할 수 있을 뿐 아니라&lt;/li&gt;
&lt;li&gt;온라인 배포를 통해 동료와 공유하기도 쉽습니다.&lt;/li&gt;
&lt;li&gt;한편으로 데이터 불러오기,</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>Microsoft가 출시한 Power BI는 강력합니다.<ul><li>윈도 환경에서 데이터를 쉽게 시각화할 수 있을 뿐 아니라</li><li>온라인 배포를 통해 동료와 공유하기도 쉽습니다.</li><li>한편으로 데이터 불러오기, 전처리, 시각화를 python script로 할 수도 있습니다.</li><li>공식 문서도 풍부하여 익히기 좋습니다.</li></ul></li></ul><h1 id="1-Power-BI-설치"><a href="#1-Power-BI-설치" class="headerlink" title="1. Power BI 설치"></a>1. Power BI 설치</h1><blockquote><p><a href="https://learn.microsoft.com/ko-kr/power-bi/fundamentals/desktop-get-the-desktop">Microsoft Learn: Power BI Desktop 다운로드</a></p></blockquote><ul><li><p>Power BI Desktop은 <b>무료</b>로 <b>Microsoft Store</b>에서 설치합니다.<br><br><img src="116_powerbi_04.png" alt="Microsoft Store Power BI 설치 화면"></p></li><li><p>파일을 다운받아 설치할 수도 있지만 직접 다운받으면 다음과 같은 이점이 있다고 합니다.</p></li></ul><ol><li><b>자동 업데이트:</b> 최신 버전이 제공되는 즉시, Windows가 백그라운드에서 자동으로 다운로드하므로 항상 최신 버전이 유지됩니다.</li><li><b>필요한 파일만 다운로드:</b> Microsoft Store는 각 업데이트에서 변경된 구성 요소만 사용자 머신에 다운로드하므로 각 업데이트에 필요한 파일만 다운로드됩니다.</li><li><b>관리자 권한이 필요하지 않음:</b> 패키지를 직접 다운로드하고 설치하는 경우 설치가 성공적으로 완료되려면 관리자여야 합니다. Microsoft Store에서 Power BI Desktop을 가져오는 경우에는 관리자 권한이 필요하지 ‘않습니다’.</li><li><b>IT 롤아웃 사용:</b> 비즈니스용 Microsoft Store를 통해 조직의 모든 사용자에게 Power BI Desktop을 보다 쉽게 배포하거나 ‘롤아웃’할 수 있습니다.</li><li><b>언어 감지:</b> Microsoft Store 버전은 지원되는 언어를 모두 포함하며, 시작할 때마다 컴퓨터에서 사용되는 언어를 확인합니다. 이 언어 지원은 Power BI Desktop에서 만든 모델의 지역화에도 영향을 줍니다. 예를 들어 기본 제공 날짜 계층 구조는 .pbix 파일을 만들 때 Power BI Desktop에서 사용 중인 언어와 일치합니다.</li></ol><h1 id="2-데이터-불러오기"><a href="#2-데이터-불러오기" class="headerlink" title="2. 데이터 불러오기"></a>2. 데이터 불러오기</h1><ul><li><p>그림으로 표현할 데이터를 불러옵니다. </p></li><li><p><b>엑셀 파일</b>, <b>SQL 서버</b>, <b>붙여넣기</b>를 제공하고 <b>샘플 데이터</b>를 사용할 수 있습니다.<br><br><img src="116_powerbi_05.png"><br></p></li><li><p>또한 <b>파이썬 스크립트</b>를 사용해 데이터를 불러올 수 있습니다.</p></li><li><p>엑셀 파일과 파이썬 스크립트를 사용해 데이터를 불러 scatter plot을 그리겠습니다.</p></li></ul><h2 id="2-1-엑셀-파일-불러오기"><a href="#2-1-엑셀-파일-불러오기" class="headerlink" title="2.1. 엑셀 파일 불러오기"></a>2.1. 엑셀 파일 불러오기</h2><ul><li><p><b>Excel 파일에서 데이터 가져오기</b>를 클릭하고 파일을 선택합니다.</p></li><li><p>seaborn의 <a href="penguins.xlsx"><b>펭귄 데이터셋</b>을 추출한 파일</a>을 선택합니다.<br><br><img src="116_powerbi_06.png"><br></p></li><li><p>Sheet를 선택하면 데이터 일부가 화면에 출력됩니다.</p></li><li><p>결측치는 <em>null</em> 이라고 표현됩니다.</p></li><li><p><b>[로드]</b>를 누르면 <b>PowerQuery</b>로 넘어갑니다.<br></p></li></ul><p><img src="116_powerbi_07.png"><br></p><ul><li>Power Query에서 전처리를 적용할 수 있습니다.</li><li>여기서는 매뉴의 맨 왼쪽, <b>[닫기 및 적용]</b>을 눌러 그대로 가져옵니다.</li><li>창을 닫아도 마찬가지로 동작하며, 이제 그림을 그릴 준비가 되었습니다.<br></li></ul><p><img src="116_powerbi_08.png"><br></p><ul><li>그림이 그려질 공간과 함께 <b>[시각화]</b> 메뉴에 다양한 선택지가 보입니다.</li><li>왼쪽 위부터 3행 3열에 있는 버튼을 클릭해 산점도를 그립시다.</li><li>산점도를 클릭하면 왼쪽에 네모난 공간이 생깁니다. 마우스로 크기와 위치를 정합니다.<br></li></ul><p><img src="116_powerbi_10.png"><br></p><ul><li>데이터를 지정할 차례입니다.</li><li><b>[시각화]</b> 메뉴 아래 있는<b>[X축]</b>, <b>[Y축]</b>에 인자를 끌어다 놓습니다.</li><li>여기서는 <b><code>bill_length_mm</code></b>와 <b><code>bill_depth_mm</code></b>를 선택했습니다.</li><li>기본값으로 <b>합계</b>가 선택되어 점이 하나밖에 나오지 않습니다. </li><li>우클릭을 하거나 <b>v</b> 버튼을 눌러 <b>[요약 안함]</b>을 누릅니다.<br></li></ul><p><img src="116_powerbi_11.png"><br></p><ul><li><b>범례</b>에 <b><code>species</code></b>를 추가하면 종에 따라 다른 색이 입혀집니다.</li></ul><p><img src="116_powerbi_12.png"><br></p><ul><li>일단 여기에서 정리하고 파이썬으로 불러보겠습니다.</li><li>화면 왼쪽 하단 <b>1 페이지</b> 옆에 있는 <b>+</b>를 눌러 새 페이지를 엽니다.</li></ul><h2 id="2-2-파이썬으로-불러오기"><a href="#2-2-파이썬으로-불러오기" class="headerlink" title="2.2. 파이썬으로 불러오기"></a>2.2. 파이썬으로 불러오기</h2><blockquote><p><a href="https://learn.microsoft.com/ko-kr/power-bi/connect-data/desktop-python-scripts">Microsoft Learn: Power BI, Power BI Desktop에서 Python 스크립트 실행</a></p></blockquote><ul><li>먼저 파이썬이 설치되어 있어야 합니다.</li><li><b>[파일] &gt; [옵션 및 설정] &gt; [옵션] &gt; [Python 스크립팅]</b>을 선택합니다.<br></li></ul><p><img src="116_powerbi_14.png"><br></p><ul><li>설정이 되어 있다면 자동으로 검색된 경로를 가져옵니다. 필요하다면 다른 경로를 지정할 수 있습니다.</li><li>상단 메뉴의 <b>[데이터 가져오기] &gt; [기타] &gt; [Python 스크립트]</b>를 선택합니다.<br></li></ul><p><img src="116_powerbi_15.png"><br></p><ul><li>데이터를 로딩하는 파이썬 스크립트를 작성합니다.</li><li><code>seaborn</code>을 읽어들여 내장된 펭귄 데이터셋을 부릅니다.<br></li></ul><p><img src="116_powerbi_16.png"><br></p><ul><li>엑셀로 불렀을 때와 동일한 화면이 나옵니다.<br></li></ul><p><img src="116_powerbi_17.png"><br></p><ul><li>앞에서 진행한 것과 같은 단계를 거치면 동일한 결과를 얻을 수 있습니다.<br></li></ul><p><img src="116_powerbi_19.png"><br></p><h1 id="3-파이썬-데이터-처리"><a href="#3-파이썬-데이터-처리" class="headerlink" title="3. 파이썬 데이터 처리"></a>3. 파이썬 데이터 처리</h1><blockquote><p><a href="https://learn.microsoft.com/ko-kr/power-bi/connect-data/desktop-python-in-query-editor?source=recommendations">Microsoft Learn: Power BI, 쿼리 편집기에서 Python 사용</a></p></blockquote><ul><li>내장 파이썬 스크립트를 사용해 데이터를 처리하겠습니다.</li><li><code>bill_length_mm</code>와 <code>bill_depth_mm</code>의 비율을 구해 <b><code>bill_ratio</code></b>라는 새 인자를 만듭니다.<br></li><li>데이터 이름인 <code>df_peng</code>에서 오른쪽 클릭을 한 후 <b>쿼리 편집</b>을 선택합니다.<br></li></ul><p><img src="116_powerbi_20.png"><br></p><ul><li>데이터를 처음 불렀을 때와 마찬가지로 Power Query가 실행됩니다.<br></li></ul><p><img src="116_powerbi_21.png"><br></p><ul><li>상단 메뉴에서 <b>[변환] &gt; [스크립트] 중 [Python 스크립트 실행]</b>을 선택합니다.</li><li>파이썬 스크립트를 입력합니다.</li><li>Power BI 내부의 데이터 이름은 <b>dataset</b>입니다.</li><li><code>bill_ratio</code>를 구하는 코드를 다음과 같이 입력합니다.<br></li></ul><p><img src="116_powerbi_28.png"><br></p><ul><li><b>[확인]</b>을 누르면 스크립트가 실행됩니다.<br></li></ul><p><img src="116_powerbi_29.png"><br></p><ul><li><b>[Table]</b>을 클릭하면 하단에 데이터가 펼쳐집니다.</li><li><b>[Table]</b>을 우클릭 후 <b>[새 쿼리로 추가]</b>를 선택합니다.</li></ul><p><img src="116_powerbi_30.png"><br></p><ul><li>새로 추가된 쿼리에서 <b>데이터 형식을 지정</b>할 차례입니다.</li><li>수치 데이터를 선택한 후 <b>[형식 변경]</b>에서 적절한 형식을 선택합니다. </li><li>여기서는 <b>10진수</b>를 선택해 수치형으로 변경했습니다.</li><li>상단의 수식에서 <code>type number</code>를 추가해도 좋습니다. 변수가 많을 경우 이게 더 편합니다.</li></ul><p><img src="116_powerbi_31.png"><br></p><ul><li>처리한 데이터를 그림으로 표현할 차례입니다.</li><li>Power Query를 닫고 돌아온 창에서 x축에 <code>bill_ratio</code>, y축에 <code>body_mass_g</code>, 그리고 범례에 <code>species</code>를 입력하면 아래와 같은 그림이 그려집니다.</li></ul><p><img src="116_powerbi_32.png"><br></p><h1 id="4-결론"><a href="#4-결론" class="headerlink" title="4. 결론"></a>4. 결론</h1><ul><li>Power BI는 상당히 많은 기능을 가지고 있습니다.</li><li>저도 이제 막 시작했지만 차분히 알아가려고 합니다.</li><li>파이썬도 함께 활용할 수 있으니 많은 분들이 잘 사용하시면 좋겠습니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/data-visualization/">data visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/power-platform/">power platform</category>
      
      <category domain="https://jehyunlee.github.io/tags/power-bi/">power bi</category>
      
      
    </item>
    
    <item>
      <title>모듈(.py) 안에서 library 설치</title>
      <link>https://jehyunlee.github.io/2022/10/12/Python-General-13-install/</link>
      <guid>https://jehyunlee.github.io/2022/10/12/Python-General-13-install/</guid>
      <pubDate>Tue, 11 Oct 2022 21:34:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;Colab 같은 클라우드 환경 사용 비중이 늘어나고 있습니다.&lt;/li&gt;
&lt;li&gt;클라우드에 기본으로 설치되지 않은 라이브러리를 설치하는 방법을 알아봅니다.&lt;/li&gt;
&lt;li&gt;pip도 import 해서 사용할 수 있습니다.&lt;/li&gt;
&lt;/ul</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>Colab 같은 클라우드 환경 사용 비중이 늘어나고 있습니다.</li><li>클라우드에 기본으로 설치되지 않은 라이브러리를 설치하는 방법을 알아봅니다.</li><li>pip도 import 해서 사용할 수 있습니다.</li></ul><h1 id="1-클라우드-환경"><a href="#1-클라우드-환경" class="headerlink" title="1. 클라우드 환경"></a>1. 클라우드 환경</h1><ul><li>Google Colab이나 Streamlit cloud 처럼 클라우드 기반 서비스 활용 비율이 늘어납니다.</li><li>장점이 많지만 서버가 물리적으로 고정되어 있지 않다 보니 필요한 라이브러리가 없을 때가 많습니다.</li><li>일일이 확인하면서 <code>!pip install &#123;library&#125;</code>를 실행하기가 번거롭습니다.</li><li>그렇다고 <code>requirements.txt</code>를 쓸 만큼 큰 일도 아닐 때 간단하게 처리하고 싶습니다.</li></ul><h1 id="2-import-pip"><a href="#2-import-pip" class="headerlink" title="2. import pip"></a>2. <code>import pip</code></h1><ul><li>라이브러리 설치에 사용하는 <code>pip</code>는 import도 가능합니다.</li><li>노트북 환경이건 모듈로 사용되는 .py 파일이건 무관합니다.</li><li>프로그램 시작 부분에 아래 코드를 삽입해 import가 안 되어 있는 라이브러리를 설치할 수 있습니다.</li><li>아래는 geopandas를 사용하고자 설치하는 코드입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pip</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">install</span>(<span class="params">package, upgrade=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="comment"># package install with upgrade or not</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(pip, <span class="string">&#x27;main&#x27;</span>):</span><br><span class="line">        <span class="keyword">if</span> upgrade:</span><br><span class="line">            pip.main([<span class="string">&#x27;install&#x27;</span>, <span class="string">&#x27;--upgrade&#x27;</span>, package])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pip.main([<span class="string">&#x27;install&#x27;</span>, package])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> upgrade:</span><br><span class="line">            pip._internal.main([<span class="string">&#x27;install&#x27;</span>, <span class="string">&#x27;--upgrade&#x27;</span>, package])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pip._internal.main([<span class="string">&#x27;install&#x27;</span>, package])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># import package</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">eval</span>(<span class="string">f&quot;import <span class="subst">&#123;package&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> ModuleNotFoundError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;# Package name might be differnt. please check it again.&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure></li></ul><h1 id="3-GeoPandas-예제-Choro-legends"><a href="#3-GeoPandas-예제-Choro-legends" class="headerlink" title="3. GeoPandas 예제: Choro legends"></a>3. GeoPandas 예제: Choro legends</h1><blockquote><p><a href="https://geopandas.org/en/stable/gallery/choro_legends.html">GeoPandas Example Gallery: Choro legends</a></p></blockquote><ul><li>같은 요령으로 Colab 기본 설치 라이브러리가 아닌 <code>mapclassify</code>와 <code>libpysal</code>을 설치합니다.</li><li>이후 아래 코드를 실행하면 깔끔하게 실행됩니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> geopandas <span class="keyword">import</span> read_file</span><br><span class="line"></span><br><span class="line">_ = libpysal.examples.load_example(<span class="string">&#x27;South&#x27;</span>)</span><br><span class="line">pth = libpysal.examples.get_path(<span class="string">&#x27;south.shp&#x27;</span>)</span><br><span class="line">df = read_file(pth)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">df.plot(column=<span class="string">&#x27;HR60&#x27;</span>, scheme=<span class="string">&#x27;QUANTILES&#x27;</span>, k=<span class="number">4</span>, \</span><br><span class="line">             cmap=<span class="string">&#x27;BuPu&#x27;</span>, legend=<span class="literal">True</span>,</span><br><span class="line">             legend_kwds=&#123;<span class="string">&#x27;loc&#x27;</span>: <span class="string">&#x27;center left&#x27;</span>, <span class="string">&#x27;bbox_to_anchor&#x27;</span>:(<span class="number">1</span>,<span class="number">0.5</span>)&#125;,</span><br><span class="line">             ax=ax)</span><br><span class="line"></span><br><span class="line">fig.savefig(<span class="string">&quot;13_install_01.png&quot;</span>)</span><br></pre></td></tr></table></figure><img src="13_install_01.png"><br></li></ul><ul><li><a href="https://colab.research.google.com/drive/1_oF9RkHi_XADp9m9UJMD4383YnDSosCF?usp=sharing">위 코드는 여기에서 확인 가능합니다 (링크)</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/pip/">pip</category>
      
      
    </item>
    
    <item>
      <title>Nature Methods- Points of significance</title>
      <link>https://jehyunlee.github.io/2022/10/02/Python-DS-115-pointsofsignificance/</link>
      <guid>https://jehyunlee.github.io/2022/10/02/Python-DS-115-pointsofsignificance/</guid>
      <pubDate>Sun, 02 Oct 2022 12:33:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.nature.com/&quot;&gt;&lt;b&gt;Nature지&lt;/b&gt;&lt;/a&gt;에서는 연구자들의 올바른 통계 분석 역량을 배양하고자 컬럼을 연재했습니다.&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.nature.c</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><a href="https://www.nature.com/"><b>Nature지</b></a>에서는 연구자들의 올바른 통계 분석 역량을 배양하고자 컬럼을 연재했습니다.<ul><li><a href="https://www.nature.com/collections/qghhqm/pointsofsignificance"><b>Points of Significance</b></a>라는 이름으로 연재했으며, </li><li>데이터의 올바른 해석과 실험 계획에 대한 가이드를 주고 있습니다.</li><li>주로 정해진 필진이 길지 않은 기사를 쓰는데 <a href="https://www.nature.com/nmeth/">Nature Methods</a>에 실립니다.</li><li>간간이 Nature 자매지에 투고되는 분석이 얼마나 틀렸는지를 지적합니다.<br></li><li><a href="https://www.nature.com/collections/qghhqm">Statistics in biology</a>라는 제목으로 더 많은 기사가 모여 있습니다.</li></ul></li></ul><p><img src="115_pos_01.png"><br></p><blockquote><p><a href="https://www.nature.com/">Nature</a><br><a href="https://www.nature.com/collections/qghhqm/pointsofsignificance">Points of Significance</a><br><a href="https://www.nature.com/collections/qghhqm">Statistics in biology</a></p></blockquote><ul><li>오차 막대같은 <b>기본기</b>부터 다룹니다.<ul><li>학부에서 배웠어야 했을, </li><li>적어도 대학원에서는 배웠어야 했을 지식이지만 제대로 배운 적이 없는 것들입니다.</li><li><b>데이터 시각화</b> 이야기도 많습니다. </li><li>잘못된 그림은 오해를 불러 일으키기 때문입니다.<br></li></ul></li></ul><p><img src="115_pos_02.png"><br></p><ul><li>라이센스가 풀려 있습니다.<ul><li>자택처럼 네이처 구독 라이센스가 없어도 읽을 수 있습니다.</li><li><b>총 42편</b>의 기사를 <a href="Points_of_Significance.enlx"><b>EndNote Library로 정리</b>했습니다.(다운로드 링크)</a></li><li>EndNote 사용자들은 다운받아 본인 연구에 마음껏 인용하시기 바랍니다.<br></li></ul></li></ul><p><img src="115_pos_03.png"><br></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/statistics/">statistics</category>
      
      <category domain="https://jehyunlee.github.io/tags/data-visualization/">data visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/experiment-design/">experiment design</category>
      
      
    </item>
    
    <item>
      <title>nonlinear models</title>
      <link>https://jehyunlee.github.io/2022/09/16/Python-DS-114-kierlecture6/</link>
      <guid>https://jehyunlee.github.io/2022/09/16/Python-DS-114-kierlecture6/</guid>
      <pubDate>Fri, 16 Sep 2022 10:49:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;한국에너지기술연구원 AI 학습조직&lt;/b&gt;에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.&lt;ul&gt;
&lt;li&gt;이번 시간에는 가장 기초가 되는 선형 모델과 함께 위한 비선형 모델을 소개했습니다.&lt;/li&gt;
&lt;li&gt;대부분의 데이터가</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b>한국에너지기술연구원 AI 학습조직</b>에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.<ul><li>이번 시간에는 가장 기초가 되는 선형 모델과 함께 위한 비선형 모델을 소개했습니다.</li><li>대부분의 데이터가 비선형이기 때문에 선형의 한계를 벗어나기 위해 다항변환과 커널을 이용합니다.</li><li>강의에서 하나를 빼먹었는데요, PCA는 데이터 값의 영향을 크게 받기 때문에 Standard Scaling 등이 필수입니다.</li><li><a href="220916_%EC%9D%B4%EC%A0%9C%ED%98%84_KIERML_2206_nonlinear.pdf">강의 자료는 여기에서 다운받으실 수 있습니다</a></li></ul></li></ul><ul><li><p>발표 영상 : (<a href="https://youtu.be/NQ5vcDV3-RU">Youtube Link</a>)<br></p></li><li><p>실습 코드 : (<a href="https://bit.ly/3DC80BA">https://bit.ly/3DC80BA</a>)<br></p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/NQ5vcDV3-RU" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><img src="thumbnail2.PNG"><br></p><p><ul><li>바쁜 연구원 일정 속에 변동이 있겠지만, 최대한 일정을 지켜보고자 합니다.</li></ul><p><img src="schedule.png" alt="학습조직 일정"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/machine-learning/">machine learning</category>
      
      <category domain="https://jehyunlee.github.io/tags/KIER/">KIER</category>
      
      <category domain="https://jehyunlee.github.io/tags/PCA/">PCA</category>
      
      
    </item>
    
    <item>
      <title>glowing full moon</title>
      <link>https://jehyunlee.github.io/2022/09/09/Python-DS-113-moon/</link>
      <guid>https://jehyunlee.github.io/2022/09/09/Python-DS-113-moon/</guid>
      <pubDate>Thu, 08 Sep 2022 21:34:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;추석입니다.&lt;/li&gt;
&lt;li&gt;빛나는 보름달을 그립니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-추석-달&quot;&gt;&lt;a href=&quot;#1-추석-달&quot; class=&quot;headerlink&quot; title=&quot;1. 추석 달&quot;&gt;&lt;/a&gt;1. 추석 달&lt;/h1&gt;&lt;blo</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>추석입니다.</li><li>빛나는 보름달을 그립니다.</li></ul><h1 id="1-추석-달"><a href="#1-추석-달" class="headerlink" title="1. 추석 달"></a>1. 추석 달</h1><blockquote><p><a href="http://www.ohmynews.com/NWS_Web/View/at_pg.aspx?CNTN_CD=A0002145580">오마이뉴스: 이번 추석, ‘초 슈퍼문’ 볼 수 있다 (2015.09.22.)</a></p></blockquote><ul><li>보름달 주위로 빛이 살짝 스며나올 때가 있습니다.</li><li>구름이 옅게 끼거나 공기가 습할 때 일부가 굴절되는 것입니다.<br><br><img src="113_moon_11.jpg"><br></li></ul><h1 id="2-빛이-스미는-보름달"><a href="#2-빛이-스미는-보름달" class="headerlink" title="2. 빛이 스미는 보름달"></a>2. 빛이 스미는 보름달</h1><h2 id="2-1-보름달"><a href="#2-1-보름달" class="headerlink" title="2.1. 보름달"></a>2.1. 보름달</h2><ul><li>빛이 하늘에 번지는 보름달을 그립니다.</li><li>먼저, 2022 x 2022 크기의 공간을 만들고 한 가운데 반지름이 800인 원을 그립니다.</li><li>2022 x 2022 numpy array를 만든 후 가운데만 255, 나머지는 0으로 지정합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">moon = np.zeros((<span class="number">2022</span>, <span class="number">2022</span>), dtype=<span class="built_in">int</span>)</span><br><span class="line">r = <span class="number">800</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2022</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2022</span>):</span><br><span class="line">        d = np.sqrt(np.power(i-<span class="number">1011</span>, <span class="number">2</span>) + np.power(j-<span class="number">1011</span>, <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">if</span> d &lt; r:</span><br><span class="line">            moon[i, j] = <span class="number">255</span></span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.imshow(moon)</span><br></pre></td></tr></table></figure><img src="113_moon_01.png"><br></li></ul><h2 id="2-2-빛-번짐"><a href="#2-2-빛-번짐" class="headerlink" title="2.2. 빛 번짐"></a>2.2. 빛 번짐</h2><blockquote><p><a href="https://github.com/rougier/scientific-visualization-book/blob/master/code/showcases/contour-dropshadow.py">Nicolas P. Rougier, Contour-Dropshadow</a><br><a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.gaussian_filter.html">scipy: gaussian_filter</a></p></blockquote><ul><li><p>빛이 번지는 효과를 구현합니다.</p></li><li><p><code>scipy</code>의 <code>gaussian_filter</code>를 사용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> gaussian_filter</span><br><span class="line">glow = gaussian_filter(moon, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.imshow(glow)</span><br></pre></td></tr></table></figure><p><img src="113_moon_02.png"><br></p></li><li><p>붉은 달이 떴습니다.</p></li><li><p>색은 <code>cmap</code>에 적절한 컬러맵을 입력해 조정합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">ax.imshow(glow, origin=<span class="string">&quot;upper&quot;</span>, zorder=<span class="number">0</span>, cmap=<span class="string">&quot;viridis&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="113_moon_03.png"><br></p></li></ul><h2 id="2-3-컬러맵-제작"><a href="#2-3-컬러맵-제작" class="headerlink" title="2.3. 컬러맵 제작"></a>2.3. 컬러맵 제작</h2><blockquote><p><a href="https://seaborn.pydata.org/generated/seaborn.color_palette.html">seaborn.color_palette</a><br><a href="https://matplotlib.org/stable/tutorials/colors/colormap-manipulation.html#sphx-glr-tutorials-colors-colormap-manipulation-py">matplotlib: Creating Colormaps in Matplotlib</a></p></blockquote><ul><li><p>검정에 가까운 어두운 색부터 밝은 노랑을 거쳐 흰색으로 이어지는 컬러맵이 필요합니다.</p></li><li><p>이런 컬러맵이 없으니 새로 만듭니다.</p></li><li><p>매우 어두운 노랑 ~ 조금 어두운 노랑(<code>y</code>)까지 이어지는 팔레트를 먼저 만들고,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmap0 = sns.color_palette(<span class="string">&quot;dark:y&quot;</span>, <span class="number">20</span>)</span><br><span class="line">cmap0</span><br></pre></td></tr></table></figure><p><img src="113_moon_04.png"><br></p></li><li><p>조금 어두운 노랑(<code>y</code>)에서 흰색으로 이어지는 팔레트를 새로 만듭니다.</p></li><li><p>seaborn의 <code>color_palette()</code>를 사용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmap1 = sns.color_palette(<span class="string">&quot;blend:y,w&quot;</span>, <span class="number">20</span>)</span><br><span class="line">cmap1</span><br></pre></td></tr></table></figure><p><img src="113_moon_05.png"><br></p></li><li><p>이 두 팔레트를 합쳐 Matplotlib colormap으로 출력합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"></span><br><span class="line">cmap = ListedColormap(cmap0 + cmap1)</span><br><span class="line">cmap</span><br></pre></td></tr></table></figure><p><img src="113_moon_06.png"><br></p></li><li><p>이렇게 만든 컬러맵을 번진 달빛에 적용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">ax.imshow(glow, origin=<span class="string">&quot;upper&quot;</span>, zorder=<span class="number">0</span>, cmap=cmap)</span><br></pre></td></tr></table></figure><p><img src="113_moon_08.png"><br></p></li></ul><h2 id="2-4-보름달-빛-번짐"><a href="#2-4-보름달-빛-번짐" class="headerlink" title="2.4. 보름달 + 빛 번짐"></a>2.4. 보름달 + 빛 번짐</h2><blockquote><p><a href="https://numpy.org/doc/stable/reference/maskedarray.generic.html">Numpy: ma module</a></p></blockquote><ul><li><p>보름달 사진을 보면, 웬만큼 구름이 끼지 않고서야 달의 동그란 경계가 선명합니다.</p></li><li><p>빛 번짐 그림은 경계가 흐릿합니다.</p></li><li><p>여기 달 그림을 반투명하게 씌워 선명한 경계를 구현합니다.</p></li><li><p>달 그림 중에서 배경에 해당하는 부분은 <code>numpy masked_array</code>를 사용해 그리지 않습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">ax.imshow(glow, origin=<span class="string">&quot;upper&quot;</span>, zorder=<span class="number">0</span>, cmap=cmap)</span><br><span class="line">ax.imshow(np.ma.masked_array(moon, moon &lt;<span class="number">1</span>), origin=<span class="string">&quot;upper&quot;</span>, zorder=<span class="number">0</span>, </span><br><span class="line">          vmin=<span class="number">0</span>, vmax=<span class="number">255</span>, cmap=cmap, alpha=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p><img src="113_moon_10.png"><br></p></li><li><p>달의 경계가 살아났습니다</p></li><li><p>마지막으로, x 축과 y 축을 없애고 그림만 남깁니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig.set_size_inches((<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">ax.axis(<span class="literal">False</span>)</span><br><span class="line">fig.set_facecolor(cmap0[<span class="number">0</span>])</span><br><span class="line">fig.tight_layout()</span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure><p><img src="113_moon_09.png"><br></p></li><li><p>모두 즐거운 한가위 되시기 바랍니다.</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualziation/">visualziation</category>
      
      
    </item>
    
    <item>
      <title>Emphasis on main data</title>
      <link>https://jehyunlee.github.io/2022/09/05/Python-DS-112-sethls/</link>
      <guid>https://jehyunlee.github.io/2022/09/05/Python-DS-112-sethls/</guid>
      <pubDate>Mon, 05 Sep 2022 05:04:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;시각화에서 색은 매우 중요한 요소입니다.&lt;/li&gt;
&lt;li&gt;중요 데이터를 강조하기 위해 특정 영역의 색을 다르게 지정하기도 합니다.&lt;/li&gt;
&lt;li&gt;HLS 색공간을 사용해 특정 데이터만 강조합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>시각화에서 색은 매우 중요한 요소입니다.</li><li>중요 데이터를 강조하기 위해 특정 영역의 색을 다르게 지정하기도 합니다.</li><li>HLS 색공간을 사용해 특정 데이터만 강조합니다.</li></ul><h1 id="1-중요-데이터-강조"><a href="#1-중요-데이터-강조" class="headerlink" title="1. 중요 데이터 강조"></a>1. 중요 데이터 강조</h1><blockquote><p><a href="http://m.yes24.com/goods/detail/87631760">Claus Wikle, “데이터 시각화 교과서”</a></p></blockquote><ul><li><p>아래 그림은 <b><a href="http://m.yes24.com/goods/detail/87631760">데이터 시각화 교과서</a></b>에 수록된 데이터 강조 사례입니다.</p></li><li><p>여러 항공사 중 <b>Delta</b>와 <b>American</b>만 강조되어 있습니다.</p></li><li><p>중요한 데이터만 <b>유채색</b>으로, 그렇지 않으면 <b>무채색</b>으로 처리하면 우리 눈에 잘 들어옵니다.<br><br><img src="112_sethls_01.png"><br></p></li><li><p>데이터를 강조하는 가장 간단하면서도 정석적인 방법입니다.</p></li><li><p>하지만 막상 코드로 구현하려면 다소 성가십니다. bar마다 다른 색을 지정해야 하기 때문입니다.</p></li></ul><h1 id="2-HLS-color-space"><a href="#2-HLS-color-space" class="headerlink" title="2. HLS color space"></a>2. HLS color space</h1><h2 id="2-1-유채색과-무채색"><a href="#2-1-유채색과-무채색" class="headerlink" title="2.1. 유채색과 무채색"></a>2.1. 유채색과 무채색</h2><blockquote><p><a href="https://jehyunlee.github.io/2022/01/04/Python-DS-95-tiger/">Pega Devlog: colorsys-Conversion between Color systems</a></p></blockquote><ul><li>유채색과 무채색의 차이는 간단합니다.</li><li>색을 이루는 구성 요소, <b>명도(Lightness)</b>, <b>색상(Hue)</b>, <b>채도(Saturation)</b> 중 명도만 있으면 무채색입니다.</li><li>조금 더 정확히 말하면, 채도가 0이 되어 색상이 드러나지 않으면 무채색이 됩니다.</li><li>채도를 아주 살짝 남기면 색상만 약하게 전달할 수 있습니다.<br><br><img src="112_sethls_02.png"><br></li></ul><h2 id="2-2-set-hls"><a href="#2-2-set-hls" class="headerlink" title="2.2. set_hls()"></a>2.2. <code>set_hls()</code></h2><p><img src="112_sethls_11.png"><br></p><ul><li><p>색 데이터와 함께 HLS 공간에서의 수정 내역을 입력받아 바뀐 색을 출력하는 함수를 만듭니다.</p></li><li><p>색을 제어하는 <code>matplotlib.colors</code>모듈과 함께 python 기본 라이브러리 <code>colorsys</code>를 사용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.colors <span class="keyword">as</span> mcolors</span><br><span class="line"><span class="keyword">import</span> colorsys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_hls</span>(<span class="params">c, dh=<span class="number">0</span>, dl=<span class="number">0</span>, ds=<span class="number">0</span>, dalpha=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    c : (array -like, str) color in RGB space</span></span><br><span class="line"><span class="string">    dh : (float) change in Hue</span></span><br><span class="line"><span class="string">        default = 0</span></span><br><span class="line"><span class="string">    dl : (float) change in Lightness</span></span><br><span class="line"><span class="string">        default = 0</span></span><br><span class="line"><span class="string">    ds : (float) change in Saturation</span></span><br><span class="line"><span class="string">        default = 0</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 입력된 color를 RGBA numpy array로 변환</span></span><br><span class="line">    c_rgba = mcolors.to_rgba(c)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># RGB와 alpha 분리</span></span><br><span class="line">    c_rgb = c_rgba[:<span class="number">3</span>]</span><br><span class="line">    alpha = c_rgba[<span class="number">3</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># RGB 색공간을 HLS 색공간으로 변환 후 입력된 변화 적용</span></span><br><span class="line">    c_hls = colorsys.rgb_to_hls(*c_rgb)</span><br><span class="line">    h = c_hls[<span class="number">0</span>] + dh</span><br><span class="line">    l = <span class="built_in">max</span>(<span class="built_in">min</span>(c_hls[<span class="number">1</span>] + dl, <span class="number">1</span>), <span class="number">0</span>)     <span class="comment"># 0~1 범위를 넘지 않도록 제어</span></span><br><span class="line">    s = <span class="built_in">max</span>(<span class="built_in">min</span>(c_hls[<span class="number">2</span>] + ds, <span class="number">1</span>), <span class="number">0</span>)     <span class="comment"># 0~1 범위를 넘지 않도록 제어</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># HLS 색공간에서 변경된 색을 RGB 색공간으로 변환</span></span><br><span class="line">    c_rgb_new = colorsys.hls_to_rgb(h, l, s)</span><br><span class="line">    alpha = <span class="built_in">max</span>(<span class="built_in">min</span>(alpha+dalpha, <span class="number">1</span>), <span class="number">0</span>)  <span class="comment"># 0~1 범위를 넘지 않도록 제어</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> np.append(c_rgb_new, alpha) <span class="comment"># alpha 추가하여 return</span></span><br></pre></td></tr></table></figure></li><li><p>구성은 간단합니다. </p></li><li><p>RGB 색공간에서 정의된 색을 색상, 명도, 채도 변화량과 함께 입력받고,</p></li><li><p>HLS 공간으로 변환해서 원하는 변화를 적용하고, 다시 RGB 색공간으로 변환시켜 <code>return</code>합니다.</p></li><li><p><b><code>mcolors.to_rgba()</code></b>명령으로 색 이름을 처리했기 때문에 <b>array-like</b>, <b>string</b>, <b>hex code</b>를 모두 인식합니다.</p></li><li><p>Hue는 무한 순환하지만 Lightness와 Saturation은 그렇지 않습니다. 범위를 넘지 않도록 제어합니다.</p></li><li><p>만약 입력 색에 alpha 채널이 있어 불투명도가 지정되어 있다면, 이를 따로 떼었다가 마지막에 다시 붙입니다.<br><br><img src="bobross.jpg" alt="어때요, 참 쉽죠?"><br></p></li></ul><h2 id="2-3-bar-plot-적용"><a href="#2-3-bar-plot-적용" class="headerlink" title="2.3. bar plot 적용"></a>2.3. bar plot 적용</h2><ul><li><p>펭귄 데이터셋을 예제로 bar plot을 이렇게 강조해 봅니다.</p></li><li><p>Adelie, Chinstrap, Gentoo 세 펭귄의 데이터 수를 seaborn의 <code>countplot</code> 함수로 표현합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df_peng = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">sns.countplot(y=<span class="string">&quot;species&quot;</span>, data=df_peng, ax=ax)</span><br></pre></td></tr></table></figure><p><img src="112_sethls_04.png"><br></p></li><li><p><b>Gentoo</b> 데이터만 강조합시다.</p></li><li><p>우리의 <code>set_hls()</code>를 사용할 차례입니다.</p></li><li><p><b>세 개의 bar 중 처음 두 개는 명도+0.5, 채도-0.3를 적용</b>하고, <b>Gentoo는 채도+0.2</b>를 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(ax.patches):</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">2</span>:</span><br><span class="line">        fc = set_hls(p.get_fc(), dl=<span class="number">0.4</span>, ds=-<span class="number">0.3</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        fc = set_hls(p.get_fc(), ds=<span class="number">0.2</span>)</span><br><span class="line">    p.set_fc(fc)</span><br><span class="line">    </span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure><p><img src="112_sethls_05.png"><br></p></li><li><p><code>sns.countplot()</code>에 <code>palette</code>매개변수로 각 bar별 색을 따로 지정할 수도 있습니다.</p></li><li><p>그러나 이 경우 <b>bar가 많으면 일일이 입력하기 어렵고</b>,</p></li><li><p><b>sorting 등으로 순서가 바뀌면 일일이 순서를 바꿔줘야 하고</b></p></li><li><p>회색을 쓰지 않고 <b>색상을 살짝 남기려면 RGB 공간에서 적당한 색을 찾기가 어렵습니다.</b></p></li></ul><ul><li><p>하는 김에 한 단계 더 들어갑니다.</p></li><li><p>불필요한 spines와 ticks를 제거하고 데이터 값을 bar에 직접 박아 넣습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ax.spines[[<span class="string">&quot;top&quot;</span>, <span class="string">&quot;right&quot;</span>, <span class="string">&quot;bottom&quot;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line">ax.<span class="built_in">set</span>(xticks=[], xlabel=<span class="string">&quot;&quot;</span>, ylabel=<span class="string">&quot;&quot;</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;count (species)&quot;</span>, color=<span class="string">&quot;gray&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(ax.patches):</span><br><span class="line">    x, width = p.get_x(), p.get_width()</span><br><span class="line">    c = <span class="string">&quot;gray&quot;</span> <span class="keyword">if</span> i &lt; <span class="number">2</span> <span class="keyword">else</span> <span class="string">&quot;w&quot;</span></span><br><span class="line">    ax.text(width-<span class="number">3</span>, i, <span class="string">f&quot;<span class="subst">&#123;width&#125;</span>&quot;</span>, c=c,</span><br><span class="line">            ha=<span class="string">&quot;right&quot;</span>, va=<span class="string">&quot;center&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line"></span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure><p><img src="112_sethls_06.png"><br></p></li><li><p>시각화 지침서에 나오는 모범 사례에 조금은 더 가까워진 듯 합니다.</p></li></ul><h2 id="2-4-KDE-plot-적용"><a href="#2-4-KDE-plot-적용" class="headerlink" title="2.4. KDE plot 적용"></a>2.4. KDE plot 적용</h2><blockquote><p><a href="http://m.yes24.com/goods/detail/87631760">Claus Wikle, “데이터 시각화 교과서”</a></p></blockquote><ul><li><p>같은 책에는 이런 그림도 있습니다.</p></li><li><p>승객의 연령과 성별을 누적 분포로 그린 그림입니다.</p></li><li><p>bar plot보다 난이도가 조금 더 높게 느껴집니다.<br><br><img src="112_sethls_03.png"><br></p></li><li><p>이번에는 이런 그림에 도전합니다.</p></li><li><p><code>seaborn</code>의 <code>kdeplot()</code>을 사용해 Male과 Female이 아래에 위치한 누적 분포를 그립니다.</p></li><li><p>윤곽선을 없애기 위해 <code>linewidth=0</code>을 입력하고, </p></li><li><p>배색과 hue_order를 데이터가 위에서 아래로 쌓이는 순서대로 입력합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>,</span><br><span class="line">                       sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, multiple=<span class="string">&quot;stack&quot;</span>,</span><br><span class="line">            palette=[<span class="string">&quot;lightgray&quot;</span>, <span class="string">&quot;C0&quot;</span>], alpha=<span class="number">1</span>, linewidths=<span class="number">0</span>,</span><br><span class="line">            hue=<span class="string">&quot;sex&quot;</span>, hue_order=[<span class="string">&quot;Female&quot;</span>, <span class="string">&quot;Male&quot;</span>], ax=axs[<span class="number">0</span>])</span><br><span class="line">sns.kdeplot(x=<span class="string">&quot;body_mass_g&quot;</span>, data=df_peng, multiple=<span class="string">&quot;stack&quot;</span>,</span><br><span class="line">            palette=[<span class="string">&quot;lightgray&quot;</span>, <span class="string">&quot;C1&quot;</span>], alpha=<span class="number">1</span>, linewidths=<span class="number">0</span>,</span><br><span class="line">            hue=<span class="string">&quot;sex&quot;</span>, ax=axs[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><img src="112_sethls_07.png"><br></p></li><li><p>ticklabels, label, title, spines, grid 등을 차례로 수정합니다.</p></li><li><p>불필요한 요소는 제거하고 필요한 요소는 추가합니다.</p></li><li><p>애초에 <code>sns.kdeplot()</code> 안에 <code>legend=False</code>를 입력하면 legend가 생기지 않습니다.</p></li><li><p>그러나 일단 생성된 legend를 제거하려면 <code>Axes.get_legend()</code>로 접근해서 <code>.remove()</code>를 실행해야 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">titles = [<span class="string">&quot;male penguins&quot;</span>, <span class="string">&quot;female penguins&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, titles):</span><br><span class="line">    <span class="comment"># ticklabels, x/y label, title, facecolor</span></span><br><span class="line">    ax.<span class="built_in">set</span>(xlim=(<span class="number">2001</span>, <span class="number">6999</span>), yticklabels=[], xlabel=<span class="string">&quot;&quot;</span>, ylabel=<span class="string">&quot;&quot;</span>, title=title, facecolor=<span class="string">&quot;none&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ytick length = 0</span></span><br><span class="line">    ax.tick_params(axis=<span class="string">&quot;y&quot;</span>, length=<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># spines 제거</span></span><br><span class="line">    ax.spines[[<span class="string">&quot;left&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;right&quot;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># grid</span></span><br><span class="line">    ax.yaxis.set_zorder(-<span class="number">1</span>)</span><br><span class="line">    ax.grid(axis=<span class="string">&quot;y&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># legend 제거</span></span><br><span class="line">    legend = ax.get_legend()</span><br><span class="line">    legend.remove()</span><br></pre></td></tr></table></figure><p><img src="112_sethls_08.png"><br></p></li><li><p>xlabel을 두 Axes에 공통으로 추가합니다.</p></li><li><p>Figure 레벨에 붙이는 공통 Axes는 <code>fig.supxlabel()</code>을 사용합니다.</p></li><li><p>예제 그림처럼 뒤쪽에 있는 회색 밀도함수에만 투명도를 0.7로 지정합니다.</p></li><li><p>seaborn에서 생성한 색칠된 KDE plot은 collection 객체로 지정됩니다.</p></li></ul><ul><li><p>Legend를 새로 만들 차례입니다.</p></li><li><p>Legend를 지정할 요소를 list로 모아 <code>handles</code>로 지정하고,</p></li><li><p>이를 가리킬 이름들을 <code>labels</code>로 지정해 오른쪽 Axes 우측 상단에 추가합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># common xlabel</span></span><br><span class="line">fig.supxlabel(<span class="string">&quot;body mass (g)&quot;</span>, fontsize=<span class="string">&quot;large&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 투명도 설정</span></span><br><span class="line">all_sexs = [axs[<span class="number">0</span>].collections[<span class="number">1</span>], axs[<span class="number">1</span>].collections[<span class="number">1</span>]]</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> all_sexs:</span><br><span class="line">    a.set_alpha(<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 새 legend 추가</span></span><br><span class="line">handles = [axs[<span class="number">0</span>].collections[<span class="number">1</span>], axs[<span class="number">0</span>].collections[<span class="number">0</span>], axs[<span class="number">1</span>].collections[<span class="number">0</span>]]</span><br><span class="line">labels = [<span class="string">&quot;all sexs&quot;</span>, <span class="string">&quot;males&quot;</span>, <span class="string">&quot;females&quot;</span>]</span><br><span class="line">axs[<span class="number">1</span>].legend(handles=handles, labels=labels, loc=<span class="string">&quot;upper right&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="112_sethls_09.png"><br></p></li><li><p>여기까지 했으면 모두 완료입니다.</p></li><li><p>그런데 수컷과 암컷에 지정된 색을 바꿔보고 싶다면 <code>set_hls()</code>를 적용할 수 있습니다.</p></li><li><p><code>dh</code>로 색상을 바꾸고 <code>ds</code>로 채도를 낮춥니다.</p></li><li><p>handles 변경 후에는 legend도 새로 만듭니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 성별 밀도 함수 객체 색상 변경</span></span><br><span class="line">sexs = [axs[<span class="number">0</span>].collections[<span class="number">0</span>], axs[<span class="number">1</span>].collections[<span class="number">0</span>]]</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> sexs:</span><br><span class="line">    fc = p.get_facecolor()</span><br><span class="line">    p.set_facecolor(set_hls(fc, dh=<span class="number">0.8</span>, ds=-<span class="number">0.3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># handles 변경을 legend에 반영    </span></span><br><span class="line">handles = [axs[<span class="number">0</span>].collections[<span class="number">1</span>], axs[<span class="number">0</span>].collections[<span class="number">0</span>], axs[<span class="number">1</span>].collections[<span class="number">0</span>]]</span><br><span class="line">labels = [<span class="string">&quot;all sexs&quot;</span>, <span class="string">&quot;males&quot;</span>, <span class="string">&quot;females&quot;</span>]</span><br><span class="line">axs[<span class="number">1</span>].legend(handles=handles, labels=labels, loc=<span class="string">&quot;upper right&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="112_sethls_10.png"><br></p></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualziation/">visualziation</category>
      
      <category domain="https://jehyunlee.github.io/tags/color/">color</category>
      
      
    </item>
    
    <item>
      <title>Text Processing Functions</title>
      <link>https://jehyunlee.github.io/2022/08/27/Python-DS-111-textprocfn/</link>
      <guid>https://jehyunlee.github.io/2022/08/27/Python-DS-111-textprocfn/</guid>
      <pubDate>Sat, 27 Aug 2022 06:59:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;자연어 처리는 품이 많이 듭니다.&lt;/li&gt;
&lt;li&gt;단어부터 문장, 맥락까지 처리할 것이 한 두 가지가 아닙니다.&lt;/li&gt;
&lt;li&gt;그러면서도 반복이 많습니다. 함수로 만듭니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;초록-요약-및-키워드-추출</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>자연어 처리는 품이 많이 듭니다.</li><li>단어부터 문장, 맥락까지 처리할 것이 한 두 가지가 아닙니다.</li><li>그러면서도 반복이 많습니다. 함수로 만듭니다.</li></ul><h1 id="초록-요약-및-키워드-추출"><a href="#초록-요약-및-키워드-추출" class="headerlink" title="초록 요약 및 키워드 추출"></a>초록 요약 및 키워드 추출</h1><blockquote><p><a href="https://jehyunlee.github.io/2022/07/02/Python-DS-106-aaicon/">Pega Devlog: Open API를 이용한 고속 논문 분석</a></p></blockquote><ul><li>우연히 시작한 문헌 분석 일이 형태를 갖춰 갑니다. </li><li>주먹구구로 시작했던 일을 체계적으로 정리하고자 합니다.</li><li>무엇보다, 결과물의 수준을 높이고자 합니다.</li></ul><ul><li><b>본 글의 내용은 <a href="https://jehyunlee.github.io/2022/07/02/Python-DS-106-aaicon/">지난 학회 발표</a>를 자세히 설명한 것입니다.</b></li><li>이 코드를 활용하시고자 하는 분들은 다음과 같이 인용해 주시기 바랍니다.</li></ul><blockquote><p><b>이제현, 유시현, 김창기, 김현구, “Open API를 활용한 고속 논문 분석”, 실용인공지능학회지 vol.1 p.9, 2022</b></p></blockquote><ul><li>여러 라이브러리를 호출할 것입니다. 노트북에 구축한 개인 환경에서 다음과 같은 라이브러리를 사용했습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%load_ext watermark</span><br><span class="line">%watermark -v -p numpy,pandas,matplotlib,seaborn,spacy,pytextrank,keybert</span><br></pre></td></tr></table></figure></li><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Python implementation: CPython</span><br><span class="line">Python version       : 3.7.4</span><br><span class="line">IPython version      : 7.23.1</span><br><span class="line"></span><br><span class="line">numpy     : 1.19.5</span><br><span class="line">pandas    : 1.3.5</span><br><span class="line">matplotlib: 3.5.2</span><br><span class="line">seaborn   : 0.11.0</span><br><span class="line">spacy     : 3.0.8</span><br><span class="line">pytextrank: 3.2.4</span><br><span class="line">keybert   : 0.6.0</span><br></pre></td></tr></table></figure><br></li></ul><blockquote><p><a href="https://rapidapi.com/developer/dashboard">RapidAPI dashboard</a><br><a href="https://rapidapi.com/tldrthishq-tldrthishq-default/api/tldrthis/">RapidAPI: TLDRThis</a><br><a href="https://rapidapi.com/datascraper/api/google-translate20/">RapidAPI: Google Translate</a><br><a href="https://www.ncloud.com/product/aiService/papagoTranslation">Naver Cloud Platform: Papago Translation</a></p></blockquote><ul><li>RapidAPI를 사용해 논문을 요약하고 번역했습니다.</li><li><b><a href="https://rapidapi.com/tldrthishq-tldrthishq-default/api/tldrthis/">TLDRThis</a></b>로 요약하고 <b><a href="https://rapidapi.com/datascraper/api/google-translate20/">Google Translate</a></b>로 번역했습니다.</li><li>지난번처럼 <b><a href="https://www.ncloud.com/product/aiService/papagoTranslation">네이버 파파고</a></b>를 쓰려고 했지만 연구원에서 <b>ncloud.com이 차단 대상</b>이라 합니다.</li><li><b><a href="https://rapidapi.com/developer/dashboard">RapidAPI dashboard</a></b>에서 활용 현황을 볼 수 있습니다. 업무의 일환이라 연구비로 결제했습니다.<br><br><img src="111_textprocfn_01.png"></li></ul><h2 id="1-문헌-데이터-추출"><a href="#1-문헌-데이터-추출" class="headerlink" title="1.문헌 데이터 추출"></a>1.문헌 데이터 추출</h2><blockquote><p><a href="https://jehyunlee.github.io/2020/06/15/Python-DS-16-VOSviewer/">Pega Devlog: Citation Network on Scopus Data</a><br><a href="https://jehyunlee.github.io/2020/06/30/Python-DS-17-papermining/">Pega Devlog: Words Co-occurence in Academic Literatures</a><br><a href="https://jehyunlee.github.io/2021/08/13/Python-DS-82-scopusapi/">Pega Devlog: Paper Search usig ScopusAPI</a><br><a href="https://www.sciencedirect.com/science/article/abs/pii/S0360544219303731?via=ihub">Rezk et al, “Fuel cell as an effective energy storage in reverse osmosis desalination plant powered by photovoltaic system”, Energy (2019), doi: 10.1016/j.energy.2019.02.167</a></p></blockquote><ul><li><p><b>scopus API</b>를 활용해 문헌 데이터를 추출하는 방법은 여러 글에서 언급했으니 넘어갑니다.</p></li><li><p><code>df</code>라는 이름의 데이터 프레임으로 받아왔다고 치고 여기부터 시작합니다.</p></li><li><p>테스트에 사용한 논문은 Rezk et al, “Fuel cell as an effective energy storage in reverse osmosis desalination plant powered by photovoltaic system”, Energy (2019), doi: 10.1016/j.energy.2019.02.167 입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abstract = df[<span class="string">&quot;description&quot;</span>].iloc[i]</span><br><span class="line">abstract</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;A hybrid renewable energy systems (HRESs) comprises of photovoltaic (PV), and self-charging fuel cells (SCFC) is designed for securing electrical energy required to operate brackish water pumping (BWP) and reverse osmosis desalination (RO) plant of 150 m3 d-1 for irrigation purposes in remote areas. An optimal configuration of the proposed design is determined based on minimum cost of energy (COE) and the minimum total net present cost (NPC). Moreover, a comparison with a stand-alone diesel generation (DG) or grid extension is carried out against the optimal configuration of PV/SCFC HRES. The modeling, simulation, and techno-economic evaluation of the different proposed systems, including the PV/SCFC system are done using HOMER software. Results show that PV array (66 kW), FC (9 kW), converter (25 KW) –Electrolyzer (15 kW), Hydrogen cylinder (70 kg) are the viable economic option with a total NPC of $115,649 and $0.062 unit cost of electricity. The COE for the stand-alone DG system is 0.206 $/kWh, which is 69.90% higher than that of the PV/SCFC system. The PV/SCFC system is cheaper than grid extension. This study opens the way for using a fuel cell as an effective method for solving the energy intermittence/storage problems of renewable energy sources.&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>다른 데이터도 서지 정보에서 가져옵니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title = df[<span class="string">&quot;title&quot;</span>].iloc[i]</span><br><span class="line">journal = df[<span class="string">&quot;publicationName&quot;</span>].iloc[i]</span><br><span class="line">authors = df[<span class="string">&quot;author_names&quot;</span>].iloc[i]</span><br><span class="line">affiliations = df[<span class="string">&quot;affilname&quot;</span>].iloc[i]</span><br><span class="line">date = df[<span class="string">&quot;coverDate&quot;</span>].iloc[i]</span><br><span class="line">doi = df[<span class="string">&quot;doi&quot;</span>].iloc[i]</span><br></pre></td></tr></table></figure><br></li></ul><h2 id="2-초록-요약"><a href="#2-초록-요약" class="headerlink" title="2. 초록 요약"></a>2. 초록 요약</h2><h3 id="2-1-딥러닝-엔진-활용-요약"><a href="#2-1-딥러닝-엔진-활용-요약" class="headerlink" title="2.1. 딥러닝 엔진 활용 요약"></a>2.1. 딥러닝 엔진 활용 요약</h3><blockquote><p><a href="https://aclanthology.org/2020.findings-emnlp.428.pdf">Cachola et al., “TLDR: Extreme Summarization of Scientific Documents”</a><br><a href="https://www.nature.com/articles/d41586-020-03277-2">Nature: tl;dr: this AI sums up research papers in a sentence</a></p></blockquote><ul><li><p>2020년에 출간된 <b>TL;DR</b>논문은 <b><a href="https://rapidapi.com/tldrthishq-tldrthishq-default/api/tldrthis/">RapidAPI</a></b>에 구현되어 있습니다.<br><br><img src="111_textprocfn_03.png" alt="과학 문헌을 요약하는 기술입니다."><br><img src="111_textprocfn_02.png" alt="네이처에 기사로도 실렸습니다."><br></p></li><li><p>이 기능을 사용하는 함수를 간단하게 구현합니다. RapidAPI의 API Key를 <code>X_RapidAPI_Key</code>로 저장하고 사용합니다.</p></li><li><p>활용성을 높이기 위해 response 전체를 <code>return</code>합니다.</p></li><li><p>구현된 함수에 <code>abstract</code>를 집어넣고 이 중 요약 부분을 처리하면 다음과 같습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TLDR 활용 요약 함수 구현</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tldrthis</span>(<span class="params">webpath, min_length=<span class="number">100</span>, max_length=<span class="number">300</span>, is_detailed=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                               X_RapidAPI_Key=X_RapidAPI_Key</span>):</span></span><br><span class="line">                               </span><br><span class="line">    url = <span class="string">&quot;https://tldrthis.p.rapidapi.com/v1/model/abstractive/summarize-text/&quot;</span></span><br><span class="line">    </span><br><span class="line">    payload = &#123;</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: webpath,</span><br><span class="line">        <span class="string">&quot;min_length&quot;</span>: min_length,</span><br><span class="line">        <span class="string">&quot;max_length&quot;</span>: max_length</span><br><span class="line">    &#125;</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;X-RapidAPI-Key&quot;</span>: X_RapidAPI_Key,</span><br><span class="line">        <span class="string">&quot;X-RapidAPI-Host&quot;</span>: <span class="string">&quot;tldrthis.p.rapidapi.com&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response = requests.request(<span class="string">&quot;POST&quot;</span>, url, json=payload, headers=headers)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="comment"># 함수 실행</span></span><br><span class="line">res = get_tldrthis(abstract)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 요약 부분 추출, 출력</span></span><br><span class="line">summary = res.json()[<span class="string">&quot;summary&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# SUMMARY: <span class="subst">&#123;summary&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SUMMARY:  A hybrid renewable energy systems (HRESs) comprises of photovoltaic (PV), and self-charging fuel cells (SCFC) is designed for securing electrical energy required to operate brackish water pumping (BWP) and reverse osmosis desalination (RO) plant of 150 m3 d-1 for irrigation purposes in remote areas. The study opens the way for using a fuel cell as an effective method for solving the energy intermittence/storage problems of renewable energy sources.</span></span><br></pre></td></tr></table></figure></li><li><p>199 단어(1272 글자)가 68 단어(453 글자)로 줄었습니다. <b>65%</b>의 압축률입니다.</p></li><li><p><code>min_length</code>와 <code>max_length</code>, <code>is_detailed</code>등 매개변수를 사용해 길이를 조정할 수 있습니다.</p></li></ul><h3 id="2-2-독창성-관련-문장-추출"><a href="#2-2-독창성-관련-문장-추출" class="headerlink" title="2.2. 독창성 관련 문장 추출"></a>2.2. 독창성 관련 문장 추출</h3><ul><li>논문의 초록에는 크게 두 가지 내용이 담깁니다.</li><li>첫 번째는 <b>이 연구를 한 이유</b>, 두 번째는 본인들의 <b>독창성</b>입니다.</li><li>연구를 한 이유는 논문마다 비슷비슷할 수 있습니다. TLDR에서 이 부분만 남긴다면 독창성을 잃어버립니다.</li><li>독창성에 연관된 문장은 꼼꼼히 볼 필요가 있습니다. 다소 길더라도 그대로 가져오기로 합니다.</li></ul><ul><li>독창성 관련 문장은 <code>we</code>, <code>in this study</code>등이 사용된 문장으로 판별합니다.</li><li>이 문구가 포함된 문장을 추출해 <code>wesentences</code>라는 이름이 변수에 list 형식으로 저장합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_uniqueness</span>(<span class="params">abstract, </span></span></span><br><span class="line"><span class="params"><span class="function">                                      wewords=[<span class="string">&quot;we &quot;</span>, <span class="string">&quot; our &quot;</span>, <span class="string">&quot;in this &quot;</span>, <span class="string">&quot;carried out&quot;</span>, <span class="string">&quot; determined &quot;</span>, <span class="string">&quot; show &quot;</span>, <span class="string">&quot;this study&quot;</span>]</span>):</span></span><br><span class="line">    sentences = [s <span class="keyword">for</span> s <span class="keyword">in</span> abstract.split(<span class="string">&quot;. &quot;</span>)]</span><br><span class="line">    wesentences = []</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> sentences:</span><br><span class="line">        <span class="keyword">for</span> weword <span class="keyword">in</span> wewords:</span><br><span class="line">            <span class="keyword">if</span> weword <span class="keyword">in</span> s.lower():</span><br><span class="line">                wesentences.append(s)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> wesentences</span><br><span class="line"></span><br><span class="line">wesentences = get_uniqueness(abstract)</span><br><span class="line">wesentences</span><br></pre></td></tr></table></figure></li><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;An optimal configuration of the proposed design is determined based on minimum cost of energy (COE) and the minimum total net present cost (NPC)&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Moreover, a comparison with a stand-alone diesel generation (DG) or grid extension is carried out against the optimal configuration of PV/SCFC HRES&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Results show that PV array (66 kW), FC (9 kW), converter (25 KW) –Electrolyzer (15 kW), Hydrogen cylinder (70 kg) are the viable economic option with a total NPC of $115,649 and $0.062 unit cost of electricity&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;This study opens the way for using a fuel cell as an effective method for solving the energy intermittence/storage problems of renewable energy sources.&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ul><ul><li>4개의 문장이 추출되었습니다.</li></ul><h2 id="3-keyword-추출"><a href="#3-keyword-추출" class="headerlink" title="3. keyword 추출"></a>3. keyword 추출</h2><h3 id="3-1-Author-Keywords"><a href="#3-1-Author-Keywords" class="headerlink" title="3.1. Author Keywords"></a>3.1. Author Keywords</h3><ul><li>저자가 논문을 제출할 때 입력한 키워드를 추출합니다.</li><li>저자가 직접 입력한 만큼 연관성이 매우 높을 것입니다.</li><li>scopus 서지정보에서 곧장 추출합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">authkeywords = df.iloc[<span class="number">0</span>][<span class="string">&quot;authkeywords&quot;</span>]</span><br><span class="line">keywords_author = authkeywords.split(<span class="string">&quot; | &quot;</span>)</span><br><span class="line">keywords_author</span><br></pre></td></tr></table></figure></li><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;Desalination deployment&#x27;</span>, <span class="string">&#x27;Energy&#x27;</span>, <span class="string">&#x27;Trends&#x27;</span>, <span class="string">&#x27;Upscaling&#x27;</span>]</span><br></pre></td></tr></table></figure><br></li></ul><h3 id="3-2-spaCy-PyTextRank-활용-추출"><a href="#3-2-spaCy-PyTextRank-활용-추출" class="headerlink" title="3.2. spaCy + PyTextRank 활용 추출"></a>3.2. spaCy + PyTextRank 활용 추출</h3><blockquote><p><a href="https://spacy.io/">spaCy</a><br><a href="https://spacy.io/universe/project/spacy-pytextrank">PyTextRank</a><br><a href="https://www.analyticsvidhya.com/blog/2022/03/keyword-extraction-methods-from-documents-in-nlp/">AnalyticsVisdhya: Keywords Extraction Methods from Documents in NLP</a></p></blockquote><ul><li><p><b><a href="https://spacy.io/">spaCy</a></b>에 <b><a href="https://spacy.io/universe/project/spacy-pytextrank">PyTextRank</a></b>를 얹어서 키워드를 추출합니다.</p></li><li><p>Textrank 알고리즘이 word graph를 구축합니다. 자주 함께 등장하는 단어들이 있다면 이들 사이의 연결이 강화됩니다.</p></li><li><p>word graph에 Pagerank 알고리즘이 적용되어 상위 3분의 1이 중요 단어로 분류됩니다. 묶인 단어가 중요하다고 판별되면 통으로 추출합니다. </p></li><li><p>2단어 이상의 복합어를 추출할 수 있어 매우 유용한 기능입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line"><span class="keyword">import</span> pytextrank</span><br><span class="line"></span><br><span class="line">nlp = spacy.load(<span class="string">&quot;en_core_web_sm&quot;</span>)</span><br><span class="line">nlp.add_pipe(<span class="string">&quot;textrank&quot;</span>)</span><br><span class="line">doc=nlp(abstract)</span><br></pre></td></tr></table></figure></li><li><p><code>spacy</code>의 <code>&quot;en_core_web_sm&quot;</code>로딩이 되지 않는다면 다음 명령어를 사용해 수동으로 다운받습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install https://github.com/explosion/spacy-models/releases/download/en_core_web_sm-<span class="number">3.0</span><span class="number">.0</span>/en_core_web_sm-<span class="number">3.0</span><span class="number">.0</span>.tar.gz</span><br></pre></td></tr></table></figure></li><li><p><code>keyword_ngram</code>이라고 이름을 붙인 ngram keyword를 rank와 함께 추출합니다. </p></li><li><p>rank 기준으로 상위 10개만 가져오도록 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">keywords_textrank = []</span><br><span class="line">keywords_textrank_rank = []</span><br><span class="line"><span class="keyword">for</span> phrase <span class="keyword">in</span> doc._.phrases[:<span class="number">10</span>]:</span><br><span class="line">    keywords_textrank.append(phrase.text)</span><br><span class="line">    keywords_textrank_rank.append(phrase.rank)</span><br><span class="line">    </span><br><span class="line">keywords_textrank</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;minimum cost&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;renewable energy sources&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;electrical energy&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;energy&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;remote areas&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;PV&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;SCFC&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;brackish water pumping&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;irrigation purposes&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;grid extension&#x27;</span>]</span><br></pre></td></tr></table></figure><br></li></ul><h4 id="3-2-1-약어-full-name-변환"><a href="#3-2-1-약어-full-name-변환" class="headerlink" title="3.2.1. 약어 full name 변환"></a>3.2.1. 약어 full name 변환</h4><ul><li><p><code>PV</code>, <code>SCFC</code>라는 약어가 등장했습니다.</p></li><li><p>이들보다는 full name을 사용하는 편이 좋습니다.</p></li><li><p>abstract에서 이들 단어가 등장한 시점을 찾아 앞에서 문구를 가져옵니다.</p></li><li><p><code>and</code>, <code>for</code> 등 불용어가 함께 등장할 수 있으므로 이들을 제거합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_fullname</span>(<span class="params">keywords, abstract,</span></span></span><br><span class="line"><span class="params"><span class="function">                 stopwords_abb = [<span class="string">&quot;and&quot;</span>, <span class="string">&quot;of&quot;</span>, <span class="string">&quot;for&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>]</span>):</span></span><br><span class="line">    abstract_split = np.array(abstract.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    keywords_fullname = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> keyword <span class="keyword">in</span> keywords:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(keyword, <span class="built_in">tuple</span>):</span><br><span class="line">            keyword = keyword[<span class="number">0</span>]</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 모두 대문자, 또는 대문자 뒤에 s가 붙은 경우. </span></span><br><span class="line">        <span class="comment"># ex) hybrid renewable energy systems (HRESs)</span></span><br><span class="line">        <span class="keyword">if</span> keyword.upper() <span class="keyword">in</span> abstract <span class="keyword">or</span> (keyword[-<span class="number">1</span>]==<span class="string">&quot;s&quot;</span> <span class="keyword">and</span> keyword[:-<span class="number">1</span>] == keyword[:-<span class="number">1</span>].upper()):</span><br><span class="line">            abbword = <span class="string">f&quot;(<span class="subst">&#123;keyword&#125;</span>)&quot;</span></span><br><span class="line">            abbword_len = <span class="built_in">len</span>(keyword)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 구두점이 함께 포함된 경우 대응</span></span><br><span class="line">            <span class="keyword">for</span> abstractword <span class="keyword">in</span> abstract_split:</span><br><span class="line">                <span class="keyword">if</span> abbword <span class="keyword">in</span> abstractword:</span><br><span class="line">                    <span class="comment"># 약어 index</span></span><br><span class="line">                    abbword_idx = np.where(abstract_split == abstractword)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 전체 용어 후보: 약어 글자 수만큼 앞 단어 추출</span></span><br><span class="line">                    fullword_cand = abstract_split[abbword_idx - abbword_len : abbword_idx]</span><br><span class="line">                    <span class="keyword">for</span> w <span class="keyword">in</span> stopwords_abb:</span><br><span class="line">                        index = np.argwhere(fullword_cand==w)</span><br><span class="line">                        fullword_cand = np.delete(fullword_cand, index)</span><br><span class="line"></span><br><span class="line">                    fullword = <span class="string">&quot; &quot;</span>.join(fullword_cand)</span><br><span class="line">                    keywords_fullname.append(fullword)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            keywords_fullname.append(keyword)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> keywords_fullname</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 함수 실행</span></span><br><span class="line">keywords_textrank = get_fullname(keywords_textrank, abstract)</span><br><span class="line">keywords_textrank</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;minimum cost&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;renewable energy sources&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;electrical energy&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;energy&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;remote areas&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;photovoltaic&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;self-charging fuel cells&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;brackish water pumping&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;irrigation purposes&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;grid extension&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li><p>“PV”는 “photovoltaic”으로, “SCFC”는 “self-charging fuel cells”로 변환되었습니다.</p></li><li><p><b>초록을 다시 읽으면서 약어에 해당하는 이름을 찾은 것</b>입니다.</p><br></li></ul><h4 id="3-2-2-단어-기본형-변환"><a href="#3-2-2-단어-기본형-변환" class="headerlink" title="3.2.2. 단어 기본형 변환"></a>3.2.2. 단어 기본형 변환</h4><blockquote><p><a href="https://machinelearningknowledge.ai/tutorial-on-spacy-part-of-speech-pos-tagging/">Machine Learning Knowledge AI Tutorial on SpaCy, Part of Speech POS tagging</a></p></blockquote><ul><li><p>약어를 해결하니 새로운 불편이 눈에 띕니다.</p></li><li><p>“brackish water pump<b>ing</b>“이 적절치 않은 것 같습니다.</p></li><li><p>“irrigation purpose<b>s</b>“도 불편합니다.</p></li><li><p>명사의 복수형을 단수형으로, 동사를 원형으로 변형하는 것을 <b>lemmatization</b>이라고 합니다.</p></li><li><p><code>spaCy</code>를 사용해 lemmatization을 실행합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_lemma</span>(<span class="params">keywords, lemma_tags = &#123;<span class="string">&quot;NNS&quot;</span>, <span class="string">&quot;NNPS&quot;</span>&#125;</span>):</span></span><br><span class="line">    keywords_lemma = []</span><br><span class="line">    lemma_tags = lemma_tags</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> keyword <span class="keyword">in</span> keywords:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(keyword, <span class="built_in">tuple</span>):</span><br><span class="line">            keyword = keyword[<span class="number">0</span>]</span><br><span class="line">            </span><br><span class="line">        keyword_lemma = []</span><br><span class="line">        <span class="keyword">for</span> token <span class="keyword">in</span> nlp(keyword):</span><br><span class="line">            lemma = token.text</span><br><span class="line">            <span class="keyword">if</span> token.tag_ <span class="keyword">in</span> lemma_tags:</span><br><span class="line">                lemma = token.lemma_</span><br><span class="line">                keyword_lemma.append(lemma)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                keyword_lemma.append(lemma)</span><br><span class="line"></span><br><span class="line">        keywords_lemma.append(<span class="string">&quot; &quot;</span>.join(keyword_lemma))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">dict</span>.fromkeys(keywords_lemma))    <span class="comment"># 중복 제거</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 함수 실행</span></span><br><span class="line">keywords_textrank = get_lemma(keywords_textrank)</span><br><span class="line">keywords_textrank</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;minimum cost&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;renewable energy source&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;electrical energy&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;energy&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;remote area&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;photovoltaic&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;self - charging fuel cell&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;brackish water pumping&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;irrigation purpose&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;grid extension&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li><p><code>lemma_tags</code>에 입력한 <code>NNP</code>(noun plural), <code>NNPS</code>(proper noun plural)에 의해 단수와 복수가 정리되었습니다.</p></li><li><p>“blackish water pumping”을 “blackish water pump”로 바꾸려면 <code>VBG</code>(gerund/present participle)도 추가하면 됩니다만 일단은 두기로 합니다.</p></li><li><p>변환 결과를 모니터링하며 <a href="https://machinelearningknowledge.ai/tutorial-on-spacy-part-of-speech-pos-tagging/">POS tagging</a>을 적절하게 조정해야 합니다.</p><br></li></ul><h4 id="3-2-3-유의어-표준화-wikipedia-활용"><a href="#3-2-3-유의어-표준화-wikipedia-활용" class="headerlink" title="3.2.3. 유의어 표준화: wikipedia 활용"></a>3.2.3. 유의어 표준화: wikipedia 활용</h4><blockquote><p><a href="https://en.wikipedia.org/wiki/Main_Page">wikipedia</a></p></blockquote><ul><li>결과 중 “photovoltaic”이라는 단어가 있습니다.</li><li>태양광 발전을 뜻하는 단어인데, 명사로 쓰면 “Photovoltaics”가 맞습니다.</li><li>lemmatization 단계에서 처리할 수도 있겠지만 용어는 문법보다 정확한 단어를 찾아야 합니다.</li><li><b>wikipedia</b>가 좋은 솔루션이 될 수 있습니다. 유의어를 입력하면 표준에 가까운 단어를 찾아주기 때문입니다.</li></ul><p><img src="111_textprocfn_04.png" alt="wikipedia 활용 단어 표준화"></p><ul><li><p>wikipedia에 단어를 던져서 답을 받는 것도 일입니다.</p></li><li><p>같은 단어를 여러 번 찾지 않도록 <b>사전(corpus)</b>을 만들어 활용합시다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">URL_EN_WIKI = <span class="string">&quot;https://en.wikipedia.org/wiki/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 단어 한 개 표준화</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_redirect</span>(<span class="params">keyword</span>):</span></span><br><span class="line">    <span class="comment"># wikipedia 검색시 빈칸 대신 _ 사용</span></span><br><span class="line">    keyword_ = keyword.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;_&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># corpus: 검색어 사전</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;./data/corpus.pkl&quot;</span>):    <span class="comment"># 사전 파일이 없으면 생성</span></span><br><span class="line">        corpus = pd.DataFrame(columns=[<span class="string">&quot;original&quot;</span>, <span class="string">&quot;redirection&quot;</span>])</span><br><span class="line">        corpus.to_pickle(<span class="string">&quot;./data/corpus.pkl&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    corpus = pd.read_pickle(<span class="string">&quot;./data/corpus.pkl&quot;</span>)   <span class="comment"># 사전 읽어오기</span></span><br><span class="line">    corpus = corpus.set_index(<span class="string">&quot;original&quot;</span>)</span><br><span class="line">    dict_corpus = corpus.to_dict()[<span class="string">&quot;redirection&quot;</span>]  <span class="comment"># DataFrame을 dictionary로 변환</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># wikipedia에서 표준어를 찾기 전, 검색어 사전에서 검색</span></span><br><span class="line">    redirect = dict_corpus.get(keyword)</span><br><span class="line">    <span class="keyword">if</span> redirect != <span class="literal">None</span>:    <span class="comment"># 검색 내역이 있다면 대응 단어 return</span></span><br><span class="line">        <span class="keyword">return</span> redirect</span><br><span class="line">    <span class="keyword">else</span>:                   </span><br><span class="line">        <span class="keyword">try</span>:                <span class="comment"># 없다면 wikipedia에 검색, 표준어 가져오기</span></span><br><span class="line">            response = requests.get(URL_EN_WIKI + keyword_)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;Wikipedia does not have an article with this exact name.&quot;</span> <span class="keyword">in</span> response.text:</span><br><span class="line">                redirect = keyword</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                redirect = bs4.BeautifulSoup(response.text, features=<span class="string">&quot;html.parser&quot;</span>).title.text.split(<span class="string">&#x27; - &#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">                </span><br><span class="line">            <span class="comment"># corpus 업데이트</span></span><br><span class="line">            dict_corpus[keyword] = redirect</span><br><span class="line">            corpus = pd.DataFrame.from_dict(&#123;<span class="string">&quot;redirection&quot;</span>: dict_corpus&#125;).reset_index().rename(columns=&#123;<span class="string">&quot;index&quot;</span>:<span class="string">&quot;original&quot;</span>&#125;)</span><br><span class="line">            corpus.to_pickle(<span class="string">&quot;./data/corpus.pkl&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> redirect</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">except</span>:             <span class="comment"># 검색이 되지 않는다면, response return</span></span><br><span class="line">            <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="comment"># 단어 여러개 표준화</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_redirects</span>(<span class="params">keywords</span>):</span></span><br><span class="line">    keywords_redirect = []</span><br><span class="line">    <span class="keyword">for</span> keyword <span class="keyword">in</span> keywords:</span><br><span class="line">        keywords_redirect.append(get_redirect(keyword))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> keywords_redirect</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 함수 실행</span></span><br><span class="line">keywords_textrank = get_redirects(keywords_textrank)</span><br><span class="line">keywords_textrank</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;minimum cost&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Renewable energy&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Electrical energy&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Energy&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;remote area&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Photovoltaics&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;self-charging fuel cell&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;brackish water pumping&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;irrigation purpose&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;grid extension&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li><p>wikipedia를 거치며 단어가 많이 교체되었습니다.</p></li><li><p>“renewable energy sources”가 “Renewable energy”로,</p></li><li><p>“photovoltaic”은 “Photovoltaics”로 바뀌었습니다.</p></li><li><p>사전에는 어떻게 기록되어 있는지 확인하겠습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">corpus = pd.read_pickle(<span class="string">&quot;./data/corpus.pkl&quot;</span>)</span><br><span class="line">corpus</span><br></pre></td></tr></table></figure></li><li><p>실행 결과<br><img src="111_textprocfn_05.png"><br></p></li><li><p>wikipedia에 단어가 있으면 있는 대로, 없으면 없는 대로 사전이 생겼습니다.</p></li><li><p>다른 논문을 분석하다 같은 단어가 나오면 추가 시간이 들지 않을 것입니다.</p></li><li><p>이처럼 단어를 거듭해서 쌓으면 사전 자체가 큰 자산이 될 것임은 자명합니다.</p><br></li></ul><h3 id="3-3-KeyBERT-활용-추출"><a href="#3-3-KeyBERT-활용-추출" class="headerlink" title="3.3. KeyBERT 활용 추출"></a>3.3. KeyBERT 활용 추출</h3><blockquote><p><a href="https://maartengr.github.io/KeyBERT/">KeyBERT</a></p></blockquote><ul><li><p><a href="https://maartengr.github.io/KeyBERT/">KeyBERT</a>는 BERT를 사용해 키워드를 뽑아내는 라이브러리입니다.</p></li><li><p>KeyBERT로도 키워드를 추출해 합산합니다. 단일 단어가 나오는만큼 동명사형을 추가로 처리하기 위해 <code>VBG</code>를 추가합니다.</p></li><li><p>KeyBERT 외에 앞에서 만든 <code>get_fullname()</code>, <code>get_lemma()</code>, <code>get_redirects()</code>를 연달아 사용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keybert <span class="keyword">import</span> KeyBERT</span><br><span class="line"></span><br><span class="line">kw_model = KeyBERT()</span><br><span class="line">keywords_keybert = kw_model.extract_keywords(abstract)</span><br><span class="line">keywords_keybert = get_fullname(keywords_keybert, abstract)</span><br><span class="line">keywords_keybert = get_lemma(keywords_keybert, lemma_tags = &#123;<span class="string">&quot;NNS&quot;</span>, <span class="string">&quot;NNPS&quot;</span>, <span class="string">&quot;VBG&quot;</span>&#125;)</span><br><span class="line">keywords_keybert = get_redirects(keywords_keybert)</span><br><span class="line">keywords_keybert</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;Photovoltaics&#x27;</span>, <span class="string">&#x27;Renewable resource&#x27;</span>, <span class="string">&#x27;Desalination&#x27;</span>, <span class="string">&#x27;Irrigation&#x27;</span>]</span><br></pre></td></tr></table></figure><p><img src="111_textprocfn_06.png"><br></p></li><li><p>단어 네 개가 뽑혔습니다.</p></li><li><p>마지막 단계에서 <code>get_redirects()</code>를 사용했으니 사전도 업데이트가 되었을 것입니다.</p></li><li><p>확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.read_pickle(<span class="string">&quot;./data/corpus.pkl&quot;</span>)</span><br></pre></td></tr></table></figure><br></li></ul><h3 id="3-4-Keywords-merging"><a href="#3-4-Keywords-merging" class="headerlink" title="3.4. Keywords merging"></a>3.4. Keywords merging</h3><ul><li>세 가지 다른 방법으로 키워드를 뽑았습니다.</li></ul><ol><li>저자가 입력한 키워드</li><li>spaCy + textrank</li><li>KeyBERT </li></ol><ul><li>이 중 일부만 써도 되고, 여기에 사용되지 않은 다른 방식을 추가해도 좋습니다. 분석가의 선택입니다.</li><li>여기서는 이 세 방법으로 얻은 것들을 모두 취합하겠습니다.</li><li>중복이 있을 수 있으니 <code>list(dict.fromkeys())</code>를 사용해 중복을 제거합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keywords = <span class="built_in">list</span>(<span class="built_in">dict</span>.fromkeys(keywords_author + keywords_textrank + keywords_keybert))</span><br><span class="line">keywords</span><br></pre></td></tr></table></figure></li><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;Desalination deployment&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Energy&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Trends&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Upscaling&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;minimum cost&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Renewable energy&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Electrical energy&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;remote area&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Photovoltaics&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;self-charging fuel cell&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;brackish water pumping&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;irrigation purpose&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;grid extension&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Renewable resource&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Desalination&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Irrigation&#x27;</span>]</span><br></pre></td></tr></table></figure><br></li></ul><h2 id="4-영-한-번역"><a href="#4-영-한-번역" class="headerlink" title="4. 영-한 번역"></a>4. 영-한 번역</h2><h3 id="4-1-unicode-제거"><a href="#4-1-unicode-제거" class="headerlink" title="4.1. unicode 제거"></a>4.1. unicode 제거</h3><ul><li><p>TLDR로 만든 summary와 규칙 기반으로 추출한 독창성 관련 문장을 <a href="https://rapidapi.com/datascraper/api/google-translate20/">Google Translate</a>로 번역합니다.</p></li><li><p>그런데, 여기 문제가 하나 있습니다. 바로 <b>unicode</b>가 문제입니다.</p></li><li><p>unicode가 섞인 문장을 TLDR에 넣으면 제대로 동작하지 않기 때문에, unicode를 최대한 제거하고 보내야 합니다.</p></li><li><p>일전에 다른 곳에서 같은 문제로 골치를 앓다가 만든 사전이 있습니다.</p></li><li><p>외국어나 dash, hypen 등 <b>unicode 260종을 유사한 일반 글자로 변환하는 사전</b>입니다. (<a href="unicode_dict.zip">링크</a>)<br><br><img src="111_textprocfn_07.png" alt="어떤 심정으로 만든 사전일까요?"><br></p></li><li><p>이 사전을 사용해서 text에 있는 unicode를 일반 글자로 변환합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./dicts/unicode_dict.json&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    dict_unicode = json.load(f)</span><br><span class="line">ukeys = dict_unicode.keys()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># unicode filtering</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ufiltered</span>(<span class="params">text</span>):</span></span><br><span class="line">    text_ = deepcopy(text)</span><br><span class="line">    text_ufiltered = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(text_):</span><br><span class="line">        <span class="keyword">for</span> ukey <span class="keyword">in</span> ukeys:</span><br><span class="line">            <span class="keyword">if</span> ukey <span class="keyword">in</span> c:</span><br><span class="line">                ufiltered = c.replace(ukey, dict_unicode.get(ukey))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ufiltered = c</span><br><span class="line">            </span><br><span class="line">        text_ufiltered = text_ufiltered + ufiltered</span><br><span class="line">    <span class="keyword">return</span> text_ufiltered</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 함수 실행</span></span><br><span class="line">summary_ufiltered = get_ufiltered(summary)</span><br><span class="line">summary_ufiltered</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; A hybrid renewable energy systems (HRESs) comprises of photovoltaic (PV), and self-charging fuel cells (SCFC) is designed for securing electrical energy required to operate brackish water pumping (BWP) and reverse osmosis desalination (RO) plant of 150 m3 d-1 for irrigation purposes in remote areas. The study opens the way for using a fuel cell as an effective method for solving the energy intermittence/storage problems of renewable energy sources.&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-2-Google-Translate-번역"><a href="#4-2-Google-Translate-번역" class="headerlink" title="4.2. Google Translate 번역"></a>4.2. Google Translate 번역</h3><ul><li><p><a href="https://rapidapi.com/datascraper/api/google-translate20/">RapidAPI의 Google Translate</a>를 사용해 번역합니다.</p></li><li><p>글자 사이 빈 칸을 <code>%20</code>으로 변환하고 넣어야 합니다.</p></li><li><p>영문을 한글로 번역하는 기능만 넣었습니다.</p></li><li><p>하지만 독일어, 프랑스어, 일본어 등 Google Translate가 지원하는 모든 언어를 입출력에 사용할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_en2ko</span>(<span class="params">text, X_RapidAPI_Key=X_RapidAPI_Key, sl=<span class="string">&quot;en&quot;</span>, tl=<span class="string">&quot;ko&quot;</span></span>):</span></span><br><span class="line">    url = <span class="string">&quot;https://google-translate20.p.rapidapi.com/translate&quot;</span></span><br><span class="line">    </span><br><span class="line">    text_ = text.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;%20&quot;</span>)</span><br><span class="line">    payload = <span class="string">f&quot;text=<span class="subst">&#123;text_&#125;</span>&amp;tl=<span class="subst">&#123;tl&#125;</span>&amp;sl=<span class="subst">&#123;sl&#125;</span>&quot;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">        <span class="string">&quot;X-RapidAPI-Key&quot;</span>: X_RapidAPI_Key,</span><br><span class="line">        <span class="string">&quot;X-RapidAPI-Host&quot;</span>: <span class="string">&quot;google-translate20.p.rapidapi.com&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.request(<span class="string">&quot;POST&quot;</span>, url, data=payload, headers=headers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 함수 실행</span></span><br><span class="line">translated = get_en2ko(summary_ufiltered)</span><br><span class="line">translated = translated.json()[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;translation&quot;</span>]</span><br><span class="line">translated</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;태양광(PV)과 자체 충전 연료 전지(SCFC)로 구성된 하이브리드 재생 에너지 시스템(HRES)은 150m3 규모의 기수 펌프(BWP) 및 역삼투압 담수화(RO) 플랜트 운영에 필요한 전기 에너지를 확보하기 위해 설계되었습니다. d-1 외딴 지역의 관개 목적. 이 연구는 재생 가능 에너지원의 에너지 간헐성/저장 문제를 해결하기 위한 효과적인 방법으로 연료 전지를 사용하는 방법을 제시합니다.&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>독창성 관련 문구에도 동일하게 적용합니다.</p></li><li><p>여기는 문장이 여럿이니 함수를 호출하는 모양이 조금 달라집니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wesentences_ufiltered = [get_ufiltered(w) <span class="keyword">for</span> w <span class="keyword">in</span> wesentences]</span><br><span class="line">translated_we = [get_en2ko(w).json()[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;translation&quot;</span>] <span class="keyword">for</span> w <span class="keyword">in</span> wesentences_ufiltered]</span><br><span class="line">translated_we</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;제안 설계의 최적 구성은 최소 에너지 비용(COE)과 최소 총 현재 비용(NPC)을 기반으로 결정됩니다.&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;또한 PV/SCFC HRES의 최적 구성에 대해 독립형 디젤 발전(DG) 또는 계통 확장과의 비교를 수행합니다.&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;결과에 따르면 PV 어레이(66kW), FC(9kW), 변환기(25KW) - 전해조(15kW), 수소 실린더(70kg)는 총 NPC가 $115,649이고 단위 비용이 $0.062인 실행 가능한 경제적 옵션입니다. 전기&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;본 연구는 재생 가능 에너지원의 에너지 간헐성/저장 문제를 해결하기 위한 효과적인 방법으로 연료 전지를 사용할 수 있는 방법을 제시합니다.&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-정리"><a href="#5-정리" class="headerlink" title="5. 정리"></a>5. 정리</h2><ul><li><p>추출한 문헌 정보 중에서 키워드와 초록으로 내용을 요약했습니다.</p></li><li><p>이렇게 정리된 결과를 한 단락으로 요약합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;### 서지 정보 ###&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;# AUTHORS: \n\t<span class="subst">&#123;authors.replace(<span class="string">&quot;;&quot;</span>,<span class="string">&quot;; &quot;</span>)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;# TITLE: \n\t&quot;<span class="subst">&#123;title&#125;</span>&quot;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;# JOURNAL, DATE, DOI: \n\t<span class="subst">&#123;journal&#125;</span>, <span class="subst">&#123;date&#125;</span>, <span class="subst">&#123;doi&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;# AUTHOR KEYWORDS: \n\t<span class="subst">&#123;<span class="string">&quot;, &quot;</span>.join(keywords_author)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;\n### 내용 요약 ###&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;# 키워드(정렬): \n\t<span class="subst">&#123;<span class="string">&quot;, &quot;</span>.join(<span class="built_in">sorted</span>(keywords))&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;# 요약(국문): \n\t<span class="subst">&#123;translated&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;# 요약(영문): \n\t<span class="subst">&#123;summary&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;# 독창성 주장(국문): &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\t * &quot;</span> + <span class="string">&quot;\n\t * &quot;</span>.join(translated_we))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;# 독창성 주장(영문): &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\t * &quot;</span> + <span class="string">&quot;\n\t * &quot;</span>.join(wesentences))</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 서지 정보 ###</span></span><br><span class="line"><span class="comment"># AUTHORS: </span></span><br><span class="line">    Rezk, Hegazy; Sayed, Enas Taha; Al-Dhaifallah, Mujahed; Obaid, M.; El-Sayed, Abou Hashema M.; Abdelkareem, Mohammad Ali; Olabi, A. G.</span><br><span class="line"><span class="comment"># TITLE: </span></span><br><span class="line">    <span class="string">&quot;Fuel cell as an effective energy storage in reverse osmosis desalination plant powered by photovoltaic system&quot;</span></span><br><span class="line"><span class="comment"># JOURNAL, DATE, DOI: </span></span><br><span class="line">    Energy, 2019-05-15, 10.1016/j.energy.2019.02.167</span><br><span class="line"><span class="comment"># AUTHOR KEYWORDS: </span></span><br><span class="line">    Desalination deployment, Energy, Trends, Upscaling</span><br><span class="line"></span><br><span class="line"><span class="comment">### 내용 요약 ###</span></span><br><span class="line"><span class="comment"># 키워드(정렬): </span></span><br><span class="line">    Desalination, Desalination deployment, Electrical energy, Energy, Irrigation, Photovoltaics, Renewable energy, Renewable resource, Trends, Upscaling, brackish water pumping, grid extension, irrigation purpose, minimum cost, remote area, self-charging fuel cell</span><br><span class="line"><span class="comment"># 요약(국문): </span></span><br><span class="line">    태양광(PV)과 자체 충전 연료 전지(SCFC)로 구성된 하이브리드 재생 에너지 시스템(HRES)은 150m3 규모의 기수 펌프(BWP) 및 역삼투압 담수화(RO) 플랜트 운영에 필요한 전기 에너지를 확보하기 위해 설계되었습니다. d-1 외딴 지역의 관개 목적. 이 연구는 재생 가능한 에너지원의 에너지 간헐성/저장 문제를 해결하기 위한 효과적인 방법으로 연료 전지를 사용하는 방법을 제시합니다.</span><br><span class="line"><span class="comment"># 요약(영문): </span></span><br><span class="line">     A hybrid renewable energy systems (HRESs) comprises of photovoltaic (PV), and self-charging fuel cells (SCFC) is designed <span class="keyword">for</span> securing electrical energy required to operate brackish water pumping (BWP) and reverse osmosis desalination (RO) plant of 150 m3 d-1 <span class="keyword">for</span> irrigation purposes <span class="keyword">in</span> remote areas. The study opens the way <span class="keyword">for</span> using a fuel cell as an effective method <span class="keyword">for</span> solving the energy intermittence/storage problems of renewable energy sources.</span><br><span class="line"><span class="comment"># 독창성 주장(국문): </span></span><br><span class="line">     * 제안된 설계의 최적 구성은 최소 에너지 비용(COE)과 최소 총 현재 비용(NPC)을 기반으로 결정됩니다.</span><br><span class="line">     * 또한 PV/SCFC HRES의 최적 구성에 대해 독립형 디젤 발전(DG) 또는 계통 확장과의 비교를 수행합니다.</span><br><span class="line">     * 결과에 따르면 PV 어레이(66kW), FC(9kW), 변환기(25KW) - 전해조(15kW), 수소 실린더(70kg)는 총 NPC가 <span class="variable">$115</span>,649이고 단위 비용이 <span class="variable">$0</span>.062인 실행 가능한 경제적 옵션입니다. 전기</span><br><span class="line">     * 본 연구는 재생 가능 에너지원의 에너지 간헐성/저장 문제를 해결하기 위한 효과적인 방법으로 연료 전지를 사용할 수 있는 방법을 제시합니다.</span><br><span class="line"><span class="comment"># 독창성 주장(영문): </span></span><br><span class="line">     * An optimal configuration of the proposed design is determined based on minimum cost of energy (COE) and the minimum total net present cost (NPC)</span><br><span class="line">     * Moreover, a comparison with a stand-alone diesel generation (DG) or grid extension is carried out against the optimal configuration of PV/SCFC HRES</span><br><span class="line">     * Results show that PV array (66 kW), FC (9 kW), converter (25 KW) –Electrolyzer (15 kW), Hydrogen cylinder (70 kg) are the viable economic option with a total NPC of <span class="variable">$115</span>,649 and <span class="variable">$0</span>.062 unit cost of electricity</span><br><span class="line">     * This study opens the way <span class="keyword">for</span> using a fuel cell as an effective method <span class="keyword">for</span> solving the energy intermittence/storage problems of renewable energy sources.</span><br></pre></td></tr></table></figure><br></li><li><p>이제 시작인 일입니다.</p></li><li><p>많은 논문을 다루며 경험을 녹여서 자연어 처리 관련 세부 사항을 수정해야 합니다.</p></li><li><p>knowledge graph 적용은 본 글에서는 생략했습니다.</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/text-mining/">text mining</category>
      
      
    </item>
    
    <item>
      <title>1001 days commit Q&amp;A (2)</title>
      <link>https://jehyunlee.github.io/2022/08/12/Python-General-12-1001commit2/</link>
      <guid>https://jehyunlee.github.io/2022/08/12/Python-General-12-1001commit2/</guid>
      <pubDate>Fri, 12 Aug 2022 04:59:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;2019년 11월 9일부터 기록된 일일커밋이 2022년 8월 5일자로 1001일을 달성했습니다.&lt;/li&gt;
&lt;li&gt;스스로 조금 뿌듯해서 관련된 기록을 남겨보고 싶었습니다.&lt;/li&gt;
&lt;li&gt;커뮤니티 등을 통해 47분에게 받은 응답을 가상 </description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>2019년 11월 9일부터 기록된 일일커밋이 2022년 8월 5일자로 1001일을 달성했습니다.</li><li>스스로 조금 뿌듯해서 관련된 기록을 남겨보고 싶었습니다.</li><li>커뮤니티 등을 통해 47분에게 받은 응답을 가상 인터뷰 형식으로 정리합니다.</li></ul><h1 id="2-데이터-분석-amp-커리어"><a href="#2-데이터-분석-amp-커리어" class="headerlink" title="2.데이터 분석 &amp; 커리어"></a>2.데이터 분석 &amp; 커리어</h1><ul><li><p><b>Q10. 지금 하는 일은 무엇인지?</b><br><code>목승찬</code></p></li><li><p><b>A10. 정부출연연구소에서 데이터, AI등을 담당하고 있습니다.</b><br><br>여러 부서로부터 분석 지원 요청을 받아 공동연구를 합니다.<br>다양한 도메인을 접할 수 있다는 것이 장점과 단점으로 존재합니다.<br>요청을 하시는 분들께서는 도메인 전문가셔서, 분석 기법은 시행착오를 거치며 스스로 판단해야 합니다.<br><b>적용을 요청하신 기법과 최종적으로 적용한 기법이 상이</b>한 경우가 대부분입니다.</p><br></li><li><p><b>Q11. 딥러닝 활용한 프로젝트도 실무에서 하는지? 개인용 딥러닝 서버 스펙?</b><br><code>우드득</code>, <code>장민석</code></p></li><li><p><b>A11. 현재 진행하는 업무 중 하나만 딥러닝이고 나머지는 트리 모델을 씁니다.</b><br><br>딥러닝을 일부러 사용하지 않는 건 아닙니다.<br>제게 오는 데이터의 양이 적고 image, 자연어 처리를 하지 않기 때문입니다.<br><b>도메인 연구</b>의 일환이다 보니 <b>예측력보다 설명력이 중요</b>하기도 합니다.<br>간혹 필요할 때는 데스크탑에 설치된 GeForce RTX 2070을 사용합니다.<br></p><br></li><li><p><b>Q12. 지금의 모습을 언제부터 꿈꿨는지? 꿈을 이루기 위해 무엇을 했는지? 머신 러닝 입문 계기?</b><br><code>TY</code>, <code>라이언</code>, <code>제이</code></p></li><li><p><b>A12. 꿈꾼 적 없습니다. 코딩을 하며 숫자와 살 거라고는 상상도 못했습니다.</b><br><br>말씀드리자면 길지만 제가 꿈꾸던 모습과 지금의 모습은 아주 많이 다릅니다.<br>박사학위를 받은 분야도 다르고, 코딩을 조금씩 하게 된 것도 <b>박사학위를 받은 뒤</b>입니다.<br>당시는 시뮬레이션을 했는데 데이터를 복붙하며 처리하다 밤을 새고 나서 <b>이러느니 코딩하겠다</b>고 시작했습니다.<br>머신 러닝도 전 직장에서 알파고 이후, 2017년 부서가 만들어지면서 관리자(파트장)로 시작했습니다.<br>결국 수락했지만 이미 새로 시작되는 일마다 투입되는 일이 4년간 반복되어 지쳐있어 두 번을 거절했습니다.<br><b>“제가 뭘 안다고 하나요”</b>라는 항변에 당시 그룹장님의 <b>“넌 빨리 배우잖아.”</b>라는 말씀이 기억에 남습니다.<br></p><br></li><li><p><b>Q13. 실패의 기억?</b><br><code>신명진</code></p></li><li><p><b>A13. 성공과 실패를 뭐라고 정의하면 좋을까요?</b><br><br><b>내 의지대로 됐는지 여부</b>라면 대학원 졸업 이후 실패의 연속입니다.<br>애초에 한 분야의 전문가가 되고자 대학원에 진학했는데 그러지 못했기 때문입니다.<br>아무리 생각해봐도 저 개인의 힘으로는 어쩔 수 없는 큰 파도에 쓸린 느낌입니다.<br><br><img src="112_1001commit2_05.png" alt="박사학위 이후 인생유전"><br>하지만 <b>결과적으로 행복해졌는지</b> 여부를 따진다면 실패라고 부르기는 어려울지도 모릅니다.<br>본의 아니게 이런저런 변화를 겪었지만 한쪽 문이 닫히면서 다른 쪽 문이 열렸습니다.<br>여러 분야를 걸치면서 시야가 넓어졌고, 저쪽에서 배운 기술을 이쪽에서 발휘합니다.<br>지금도 같은 부서에 동료가 없는 것은 아쉽지만 외부에서 좋은 인연을 만나고 있습니다.<br><br><br><img src="112_1001commit2_04.png" alt="life flow"><br>써놓고 보니 오해하시는 분이 있으실까봐 약간의 항변을 덧붙입니다.<br>일을 못해서 계속 새로운 일을 시킨 게 아니라 그 반대에 가까웠던 것 같습니다.<br>정확히는 당시 새로운 일을 시키신 분들께 <b>“왜 저였나요?”</b>라고 여쭤봐야겠지만요.<br><br><img src="112_1001commit2_09.png" alt="2015~2017 수상 내역 (부분)"><br>가만히 있었으면 <b>“우리 나이때는 디테일보다 큰 그림 딱딱 짚어주는”</b> 관리자가 되었겠지만,<br>제가 본 저런 말을 하는 사람들은 헛다리만 짚고 있었습니다.<br>저런 선배가 되기는 싫었습니다.</p></li></ul><blockquote><p><a href="https://jehyunlee.github.io/2020/12/12/Python-DS-47-debun/">Pega x Codestates: 이세계에서 시작하는 데분러 생활</a><br><a href="https://jehyunlee.github.io/about/CurriculumVitae.pdf">Pega: 이력서</a><br><br></p></blockquote><ul><li><p><b>Q14. 데이터 분석 및 시각화를 하게 된 이유?</b><br><code>융</code></p></li><li><p><b>A14. 일이니까 했습니다.</b><br><br>제가 하는 일은 결과만 잘 나온다고 끝이 아닙니다. <b>원인을 파악하고 인사이트를 발굴해야 합니다.</b><br>그러다 보니 자연스럽게 머신 러닝보다 데이터 분석에 집중하게 되었습니다.<br>머신 러닝도 제게는 서비스보다 데이터 분석의 일환입니다.<br><b>데이터 시각화</b>도 머신 러닝과 데이터 분석을 하면서 자연스럽게 발을 들였습니다.<br>데이터 시각화에 쓰는 시간이 아깝다는 생각이 들면서 <b>익숙해지자</b>고 결심했습니다.<br>지금은 생각에서 그림으로 옮겨지는 시간이 제법 줄었습니다.<br>일전에 머신 러닝 결과를 발표한 박사님께 <b>EDA는 어떻게 하셨나요?</b>라고 질문했습니다.<br>그 박사님은 <b>그게 뭔가요?</b>라고 되물으셨습니다. 이건 좀 아닌 것 같습니다.<br>데이터는 들여다보지도 않고 모델만 돌리는 사람을 신뢰하기는 어렵습니다.<br></p><br></li><li><p><b>Q15. 태블로도 다루는지?</b><br><code>Jonsnow</code></p></li><li><p><b>A15. 아닙니다.</b><br><br>하지만 분석 결과 배포에 유리할 것으로 생각되어 관심을 가지고 있습니다.<br>아직은 아니지만 조만간 interactive plot을 많이 할 것 같습니다.<br></p><br></li><li><p><b>Q15. 다시 대학생이 된다면 무엇을 위해 어떤 준비를 할 것인지? 어릴 적으로 돌아간다면 어떤 업으로 살고 싶은지?</b><br><code>신명진</code>, <code>라이언</code></p></li><li><p><b>A15. 컴퓨터 그래픽스를 배우고 싶습니다.</b><br><br>어쩌면 당시 독학으로 <b>CAD</b>와 <b>포토샵</b>을 배웠던 덕에 여러 기회를 거쳐 여기까지 온 것 같습니다.<br>재미로 했던 CAD 3D 모델링 덕에 대학원 시절 FEM(유한요소) 모델을 어렵지 않게 만들 수 있었고,<br><b>전자현미경으로 직접 관찰한 결과를 시뮬레이션</b>할 수 있었습니다.<br><img src="112_1001commit2_02.png" alt="Jehyun Lee et al., Appl. Phys. Lett. 2011 (DOI: 10.1063/1.3623752)"><br><br>그런데 근본이 없이 눈과 손으로 배워서 하다 보니 기본기가 부족함을 자주 느낍니다.<br>학문의 초창기 신학을 포함한 <b>철학</b>, <b>과학</b>, <b>의학</b>이 구분되지 않았던 것 처럼,<br>컴퓨터과학의 초창기에는 <b>물리 시뮬레이션</b>과 <b>컴퓨터 그래픽스</b>가 구분되지 않았습니다.<br>근본을 제대로 익혔다면 더 나은 제가 되어 있을 것 같습니다.<br><br><img src="112_1001commit2_01.jpg" alt="Boeing man by William Fetter, an art director of the Boeing Company (1964)"><br></p><br> 그런데, 생각을 해보니 그 때도 <b>데이터를 모아서 분석하는 연구</b>를 했네요.당시 저 분야에서 물성의 분포를 확률적으로 다루기 시작하는 분들이 있었습니다.그 영향을 받아서 시도했던 것으로 기억이 납니다.</li></ul><p><img src="112_1001commit2_03.png" alt="Jehyun Lee et al., Appl. Phys. Lett. 2011 (DOI: 10.1063/1.3623752)"><br> <br></p><ul><li><p><b>Q16. 깃헙을 통해서 포지션 제안이 온 적이 있는지?</b><br><code>츄로오스</code></p></li><li><p><b>A16. 있습니다.</b><br></p><br></li><li><p><b>Q17. 분석가로서 커리어를 어떻게 정리하는지? 신입 데이터 사이언티스트에게 조언. 여러 프로젝트를 단기간씩 하는 것에 대한 조언?</b><br><code>김성호</code>, <code>김영동</code>, <code>난키</code></p></li><li><p><b>A17. 제가 조언을 할 수 있는 입장은 아닌 것 같습니다.</b><br><br>저도 과거의 경력과 사실상 단절하고 데이터 분석가로서 새로운 경력을 쌓아가는 중이기 때문입니다.<br><b>연구자</b>로서 논문을 출판하기도 해야겠지만 <b>개발자</b>속성을 띄고 있습니다.<br>모든 분야에서 동시에 인정받으면 좋겠지만 그러기 어려워서 나름의 순서를 정했습니다.<br>이 순서에서 딥러닝은 가장 뒤에 있습니다. 점점 더 문턱이 낮아지고 있다고 느껴서입니다.<br><b>그런데 여러 프로젝트를 동시에 하는 것은 좋지 않은 것 같습니다.</b><br>데이터 분석의 특성상 데이터에 코를 박고 모든 감각으로 흡수해서 단기 기억을 동원해야 합니다.<br>그러다보니 여러 프로젝트를 동시에 하면 효율이 극심하게 떨어집니다.<br><b>석사시절 실험할 때, 박사과정 이후 시뮬레이션을 할 때는 겪지 못했던 상황</b>입니다.<br>관련이 있을지 없을지도 모르는 인자들끼리 상관성을 파악하고 파생변수를 만들어야 하기 때문입니다.<br>이것도 훈련이라면 훈련이라고, 연습이라면 연습이라고 생각하고 있습니다.<br></p><br></li><li><p><b>Q18. 데이터 사이언스에서 기본적으로 갖춰야 할 개념</b><br><code>우왕</code></p></li><li><p><b>A18. 역시 제가 조언을 할 수 있는 입장은 아닌 것 같습니다.</b><br><br>제 생각만 말씀드리자면, <b>데이터 분포</b>와 <b>확률</b>에 대한 개념이 가장 중요할 것 같습니다.<br>하나를 더 보태면 분석가의 성격이 조금 <b>집요</b>할 필요가 있다고 생각합니다.<br>노이즈에 묻힌 데이터의 본 모습을 끄집어 내는게 간단하지는 않다고 느끼기 때문입니다.<br></p></li></ul><h1 id="3-생활"><a href="#3-생활" class="headerlink" title="3. 생활"></a>3. 생활</h1><ul><li><p><b>Q19. 하루 일과, 일-삶-배움의 균형은 괜찮은지? 업무 시간과 우선 순위는 어떻게 관리하는지?</b><br><code>게으른파이썬</code>, <code>김영동</code>, <code>냥</code>, <code>이종원</code>, <code>황성주</code></p></li><li><p><b>A19. 가족에게 어느 정도 희생을 강요하고 있다고 느낍니다.</b><br><br>아침 루틴을 마치고 출근해서 일을 한 뒤, 퇴근해서 가족과 시간을 보냅니다.<br>일주일에 두 번 아침식사 전에 전화 영어를 하고, 아침식사와 점심식사 후 30분 산책을 합니다.<br>이직 이후 가족과 보내는 시간이 크게 늘어난 것은 사실이지만, 바쁘면 여전히 야근과 주말 근무를 합니다.<br>업무 시간과 우선 순위는 <b>마감에 맞춰 정해진다</b>고 보는게 맞을 것입니다.<br>아침에 출근하면서 <b>하루를 시뮬레이션</b>하는데, 시간 관리 능력이 많이 부족하다고 느끼고 있습니다.<br>가족과 보내는 시간과 함께 <b>실무 능력</b>을 확보하고자 이직을 했습니다.<br>그래서 <b>술</b>을 거의 먹지 않습니다. 술을 먹으면 먹는 시간 + 회복 시간까지 손실이 생기기 때문입니다.<br>한 달에 맥주 한 두 캔 정도가 보통인 것 같고, 그나마 집에서 먹습니다.<br><b>술자리에서 오가는 말을 믿지 않기 때문</b>일지도 모릅니다.<br><br><img src="112_1001commit2_07.png" alt="이제현, Galaxy S2 (맨 왼쪽), Galaxy Note2 (두번째부터) + Autodesk Sketchbook (2013-2014)"></p><br></li><li><p><b>Q20. 명절, 육아 등 체력 관리</b><br><code>시나몬</code></p></li><li><p><b>A20. 체력은 타고난 면이 큰 것 같습니다.</b><br><br>하루에 다섯 시간만 자도 충분하다고 느끼고 며칠 무리를 해도 괜찮다고 느낍니다.<br><b>느낀다</b>고 말하는 것은, 그 때는 괜찮은데 마감이 지나면 후폭풍이 없지 않기 때문입니다.<br>전문가에게 받은 TCI(기질 및 성격 검사)에서 <b>인내심이 상위 3%라고 나왔습니다.</b><br>어쩌면 고통에 둔감한 건지도 모릅니다.<br></p><br></li><li><p><b>Q21. 페가에게 커피란?</b><br><code>엘카인</code></p></li><li><p><b>A21. 업무 전환 스위치입니다.</b><br><br>일을 시작할 때, 하는 일의 종목을 바꿀 때 커피를 마시면서 주위를 환기합니다.<br>하루를 시작할 때 정신을 차리는 <b>영약</b>이기도 합니다.<br><br><img src="112_1001commit2_06.png" alt="이제현, Galaxy S2 (세번째까지), Galaxy Note2 (맨 오른쪽) + Autodesk Sketchbook (2012-2013)"></p><br></li><li><p><b>Q22. 독서의 계기와 독서의 방법?</b><br><code>바로잡기</code></p></li><li><p><b>A22. 책에 따라 다릅니다.</b><br><br><b>즐기기 위해 읽는 책</b>이 있고 <b>살아남기 위해 읽는 책</b>이 있습니다.<br>즐기기 위해 읽는 책은 글자 그대로 재밌어서 보는 책입니다. 소설을 오래 못 읽어서 아쉽습니다.<br>살아남기 위해 읽는 책은 업무 관련한 책입니다.<br>두 번 볼 새가 없다는 것을 알고 있기 때문에 <b>한 번 읽을 때 머리에 넣으려고</b> 합니다.<br>슬렁슬렁 읽어서는 머리에 들어오지 않는 걸 경험으로 압니다. 새벽에 집중해서 읽습니다.<br></p><br></li><li><p><b>Q23. 인생에서 이루고 싶은 꿈/삶의 지향점?</b><br><code>최우성</code></p></li><li><p><b>A23. 있었는데 잊었습니다. 다시 찾고 있습니다.</b><br><br>약 10년간 급류에 휘말려서 눈앞의 목적이 <b>생존</b>이었습니다.<br>숨을 쉴 때마다 물을 먹으면서 괴로워하다가 정신을 차린지 얼마 되지 않습니다.<br>영화 gravity를 극장에서 보고 감동에 젖어 아래 그림을 그렸는데 저 심정으로 10년쯤 살았습니다.<br>한 대 얻어맞기 전에 뭔가 있었는데 잊어버렸습니다. 새로 찾아야 합니다. 좋은 게 있겠죠? :)<br><br><img src="112_1001commit2_08.png" alt="이제현, &quot;Gravity&quot;, Galaxy Note2 + Autodesk Sketchbook (2013.12.11)"></p><br></li></ul><h1 id="4-기타"><a href="#4-기타" class="headerlink" title="4. 기타"></a>4. 기타</h1><ul><li>공개적으로 답하기 어려운 질문, 제가 답하기에 지식과 생각이 너무 짧은 부분을 질문주신 분들이 있습니다.</li><li>이 분들께는 제가 <b>개인적으로 답을 드리겠습니다.</b></li><li>이 블로그에 이렇게 개인적인 글을 올리는 것은 처음입니다. 마지막일지도 모릅니다. </li><li>언젠가 소리소문 없이 지워질 수도 있습니다.</li><li>읽어주셔서 감사합니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/life/">life</category>
      
      
    </item>
    
  </channel>
</rss>
