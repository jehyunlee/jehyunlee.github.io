<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Pega Devlog</title>
    <link>https://jehyunlee.github.io/</link>
    
    <atom:link href="https://jehyunlee.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Pega&#39;s Development log for myself and others</description>
    <pubDate>Sun, 24 Apr 2022 12:19:00 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>reliability of Covid-19 self test kit</title>
      <link>https://jehyunlee.github.io/2022/04/23/Python-DS-99-covidprec/</link>
      <guid>https://jehyunlee.github.io/2022/04/23/Python-DS-99-covidprec/</guid>
      <pubDate>Sat, 23 Apr 2022 12:51:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;코로나-19 자가진단키트에서 두 줄이 떴습니다.&lt;/li&gt;
&lt;li&gt;올 게 왔나 싶으면서도, 이거 얼마나 믿을만한지 몹시 궁금했습니다.&lt;/li&gt;
&lt;li&gt;선별진료소 결과를 기다리며 분류 기초를 복습합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>코로나-19 자가진단키트에서 두 줄이 떴습니다.</li><li>올 게 왔나 싶으면서도, 이거 얼마나 믿을만한지 몹시 궁금했습니다.</li><li>선별진료소 결과를 기다리며 분류 기초를 복습합니다.</li></ul><h1 id="1-사건의-발단"><a href="#1-사건의-발단" class="headerlink" title="1. 사건의 발단"></a>1. 사건의 발단</h1><blockquote><p><a href="https://blog.naver.com/kfdazzang/222640236513">식품의약품안전처: 자가진단키트 양성예측도 76%</a><br><a href="https://www.khan.co.kr/national/health-welfare/article/202202080845011">경향신문: 자가검사키트, 민감도 특이도는 뭐고 양성예측도는 또 뭔가요?</a></p></blockquote><p><img src="99_cp_02.jpg"><br></p><ul><li><b>3일 전,</b> 안녕하시냐고 묻는 안녕하지 못한 내용의 문자가 왔다.</li><li>업무 효율화 관련해서 자주 뵙던 분이 걸렸단다. 문자로 안부를 여쭈니 다행히 괜찮다고 하신다.</li><li>바닷가에서 학회 발표를 준비하다 말고 10여분 차를 달려 읍내에 갔다.</li><li>병원에서 신속항원검사 음성확인서를 받았지만 기분 탓인지 목이 아프다.<br></li></ul><p><img src="99_cp_01.PNG" alt="잘 보면 보입니다."><br></p><ul><li>그리고 오늘, <b>자가진단키트에 매우 희미하지만 두 줄이 떴다.</b></li><li>주말 저녁이라 신속항원검사를 할 동네 병원은 모두 닫았고, 시청 선별진료소에서 검사를 했다.</li><li><b>“두 줄 맞습니다. 이쪽에서 검사받으세요. 결과는 내일 아침 9시 전에 나옵니다.”</b></li></ul><ul><li><p>훨씬 정확하다는 PCR 검사가 나오겠지만 <b>자가진단키트의 신뢰도가 궁금해졌다.</b></p></li><li><p><b>민감도<code>sensitivity</code> 90%</b>, <b>특이도<code>specificity</code> 99%</b>. </p></li><li><p>그런데 <b>양성예측도<code>positive predictive value (PPV)</code> 76%</b>.</p></li><li><p>내 밥벌이이고, 비슷한 문제를 몇 번이나 손계산으로 풀었는데도 왜 이런지 헷갈린다.</p></li><li><p>그래서 얼마나 잘 맞는 거냐는 기자의 마음이 이해가 간다.<br><br><img src="99_cp_03.PNG"><br></p></li><li><p>기자는 <b>“공식은 모르겠고”</b>라고 해도 되지만 난 그러면 안 된다.</p></li><li><p>당사자가 된 이상 최선을 다해 정리해보자.</p></li><li><p>지금처럼 이 문제에 진심인 적이 없다.</p></li></ul><h1 id="2-복잡한-분류-예측"><a href="#2-복잡한-분류-예측" class="headerlink" title="2. 복잡한 분류 예측"></a>2. 복잡한 분류 예측</h1><blockquote><p><a href="https://3months.tistory.com/318">쉽게 이해하는 특이도, 민감도, 양성 예측도</a><br><a href="https://en.wikipedia.org/wiki/Sensitivity_and_specificity">wikipedia: sensitivity and specificity</a></p></blockquote><ul><li>분류 예측 문제는 모델링보다 평가가 훨씬 복잡하다.</li><li>단순히 맞다/틀리다로 끝나는게 아니기 때문이다.</li></ul><ul><li>어떤 마을 1000명 중 100명이 폐암에 걸렸고, 이들이 병원에서 진단을 받는다고 하자.</li><li>진단 기기나 의사의 판단이 100% 정확하지 않기 때문에 <b>오진이 발생한다</b>.</li><li><b>병이 없는데 환자 진단을 받기도 하고</b>, <b>환자에게 정상이라고 하기도 한다</b>.<br><br><img src="99_cp_04.PNG"><br></li></ul><h2 id="2-1-전지적-의사-시점"><a href="#2-1-전지적-의사-시점" class="headerlink" title="2.1. 전지적 의사 시점"></a>2.1. 전지적 의사 시점</h2><ul><li>여기서 <b>진단을 잘 했다</b>는 둘로 나뉜다.</li><li><b>(1) 환자를 환자라고 하는 경우 : 민감도</b> = $\dfrac{90}{90+10} = 90$%</li><li><b>(2) 비환자를 비환자라고 하는 경우 : 특이도</b> = $\dfrac{800}{800+100} = 89$%</li><li>둘 다 준수하다.</li></ul><h2 id="2-2-환자의-시점"><a href="#2-2-환자의-시점" class="headerlink" title="2.2. 환자의 시점"></a>2.2. 환자의 시점</h2><ul><li>하지만 환자의 입장은 조금 다르다. <b>본인이 받은 진단의 신뢰도</b>가 중요하다.</li><li><b>(1) 양성(암) 진단을 받은 경우 : 양성 예측도</b> = $\dfrac{90}{90+100} = 47$%</li><li><b>(2) 음성(정상) 진단을 받은 경우 : 음성 예측도</b> = $\dfrac{800}{800+10} = 99$%</li><li>음성 예측도는 매우 높지만 양성 예측도가 크게 낮다. 데이터가 1:9로 불균일하기 때문이다. </li><li><b>귀찮은 의사가 대충 음성이라고 해도 맞출 확률이 90%인 것이다.</b></li></ul><h1 id="3-코로나-19"><a href="#3-코로나-19" class="headerlink" title="3. 코로나-19"></a>3. 코로나-19</h1><blockquote><p><a href="https://coronaboard.kr/">코로나-19 실시간 현황판</a><br><a href="https://jumin.mois.go.kr/">행정안전부: 주민등록 인구 통계</a><br><a href="https://www.hani.co.kr/arti/society/health/1029592.html">한겨레: ‘가짜양성’ 넷 중 하나… 자가키트 양성 뒤 PCR 음성 23.9%</a></p></blockquote><h2 id="3-1-자가진단키트-검사자-시점"><a href="#3-1-자가진단키트-검사자-시점" class="headerlink" title="3.1. 자가진단키트 검사자 시점"></a>3.1. 자가진단키트 검사자 시점</h2><ul><li>자가진단키트의 민감도와 특이도는 각기 90%와 99%.</li><li>그리고 2022.04.23. 현재 우리 나라의 누적 확진자는 <b>16,830,469명</b></li><li>우리 나라의 <b>총 인구는 51,610,695명</b> 고려시 <b>확진자 비율은 32.6%.</b></li><li>신속항원검사와 PCR로 <b>최종 검증이 된다 가정</b>하고 종합하면 다음과 같은 그림이 그려진다.<br></li></ul><p><img src="99_cp_05.PNG"><br></p><ul><li>PCR보다 <b>자가진단키트가 확진자를 3%가량 덜 잡아내고 있으며</b>,</li><li>(1) 양성(확진) 진단을 받은 경우 : 양성 예측도</b> = $\dfrac{29.3}{29.3 + 0.7} = 97.7$%</li><li>(2) 음성(미확진) 진단을 받은 경우 : 음성 예측도</b> = $\dfrac{66.7}{66.7 + 3.3} = 95.3$%</li><li><b>생각보다 자가진단키트가 믿을만 하다</b>는 결론인데,</li><li>한때 <a href="https://www.hani.co.kr/arti/society/health/1029592.html">자가키트의 신뢰성 문제</a>가 언론에 보도된 때는 2월 5일로 <b>오미크론이 본격적으로 유행하기 전</b>이었다. <br></li></ul><p><img src="99_cp_06.PNG"><br></p><ul><li>앞서 양성예측도 76% 계산시 전국민의 3%가 감염되었다는 것을 가정한 것에 비해 10배 가량 많기 때문에 <b>데이터 불균형에 의한 문제가 해소</b>되었다고 볼 수 있다.</li></ul><h2 id="3-2-유병률-영향"><a href="#3-2-유병률-영향" class="headerlink" title="3.2. 유병률 영향"></a>3.2. 유병률 영향</h2><ul><li>양성 예측도와 음성 예측도 모두 전국민 중 얼마나 병에 걸렸냐는 <b>유병률<code>prevalence</code></b>의 영향을 받는다.</li><li>수식으로 표현하면 다음과 같다.<br></li></ul><p>$$양성예측도 PPV = \frac{민감도 \cdot 유병률}{민감도 \cdot 유병률 + (1- 특이도) \cdot (1 - 유병률)}$$</p><br><p>$$음성예측도 NPV = \frac{특이도 \cdot (1-유병률)}{특이도 \cdot (1-유병률) + (1-민감도) \cdot 유병률}$$</p><ul><li>자가진단키트 기준인 <b>민감도 90%</b>와 <b>특이도 99%</b>를 넣고 그림을 그리면 이렇다.</li><li>데이터 불균형 문제가 해결되어 두 예측도가 모두 높은 상황임을 알 수 있다.</li></ul><p><img src="99_cp_07.PNG"><br></p><h2 id="3-3-민감도와-특이도-영향력"><a href="#3-3-민감도와-특이도-영향력" class="headerlink" title="3.3. 민감도와 특이도 영향력"></a>3.3. 민감도와 특이도 영향력</h2><ul><li><p>자가진단키트가 불량이거나 검사 방법이 제대로 이루어지지 않은 경우, </p></li><li><p><b>민감도와 특이도가 기대치에 미치지 못할 수 있다</b>.</p></li><li><p>특이도를 99%로 고정하고 민감도를 50%까지 떨어트리면 <b>양성예측도는 별 차이가 없는 반면 음성예측도가 80%까지 감소한다</b>.<br><br><img src="99_cp_08.PNG"><br></p></li><li><p>거꾸로, 민감도를 90%로 고정하고 특이도만 60%까지 떨어트리면 <b>양성예측도가 50% 수준으로 감소한다</b>. <br><br><img src="99_cp_09.PNG"><br></p></li><li><p>공장에서 제품이 제대로 나온다는 가정 하에, <b>올바른 검사 방법</b>이 가장 중요한 요소일지도 모른다.</p></li></ul><h1 id="4-결론"><a href="#4-결론" class="headerlink" title="4. 결론"></a>4. 결론</h1><ul><li><b>검사를 제대로 했다는 전제 하에,</b></li><li>즉 자가진단키트가 실제로 민감도 90%와 특이도 99%를 발휘한다는 전제 하에 상당히 믿을 만한 수준이다.</li><li>많은 분들이 코로나-19에 걸리지 않고 무사히 이 시기를 지나가기를 바란다.</li></ul><h1 id="5-에필로그"><a href="#5-에필로그" class="headerlink" title="5. 에필로그"></a>5. 에필로그</h1><blockquote><p><a href="https://www.docdocdoc.co.kr/news/articleView.html?idxno=2009532">청년의사: 신속항원진단키트로 입원 전 코로나 검사했더니 민감도 17.5%</a><br><a href="https://www.docdocdoc.co.kr/news/articleView.html?idxno=2022211&utm_source=dable">청년의사: 이비인후과 전문의 60% ‘자가검사키트 정확도 절반 이하’ 우려</a></p></blockquote><ul><li>PCR 검사 결과 음성.</li><li>결론적으로 위양성(False Positive)이었다.<br></li></ul><p><img src="99_cp_10.jpg"><br></p><ul><li>자가진단키트의 신뢰성에 대해 지속적으로 의문이 제기되고 있다.</li><li><b>민감도 문제가 특히 심각하다고 합니다.</b></li><li>모두 건강하자.<br></li></ul><p><img src="99_cp_11.png" alt="청년의사: 2021.04.10. 기사"><br></p><p><img src="99_cp_12.png" alt="청년의사: 2022.04.22. 기사"><br></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/statistics/">statistics</category>
      
      <category domain="https://jehyunlee.github.io/tags/classification/">classification</category>
      
      
    </item>
    
    <item>
      <title>ridge-map</title>
      <link>https://jehyunlee.github.io/2022/04/17/Python-DS-98-ridgemap/</link>
      <guid>https://jehyunlee.github.io/2022/04/17/Python-DS-98-ridgemap/</guid>
      <pubDate>Sat, 16 Apr 2022 20:12:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;지형을 중첩된 line plot으로 그리는 ridgemap 라이브러리를 소개합니다.&lt;/li&gt;
&lt;li&gt;Matplotlib 생태계의 일원으로 쉽게 사용할 수 있습니다.&lt;/li&gt;
&lt;li&gt;소스 코드를 조금 고쳐줄 필요가 있습니다.&lt;/li&gt;
&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>지형을 중첩된 line plot으로 그리는 ridgemap 라이브러리를 소개합니다.</li><li>Matplotlib 생태계의 일원으로 쉽게 사용할 수 있습니다.</li><li>소스 코드를 조금 고쳐줄 필요가 있습니다.</li></ul><h1 id="1-ridge-map"><a href="#1-ridge-map" class="headerlink" title="1. ridge-map"></a>1. ridge-map</h1><blockquote><p><a href="https://pypi.org/project/ridge-map/">pypi: ridge-map/</a></p></blockquote><ul><li>설명 대신 그림을 한 장 보여드리겠습니다.</li></ul><p><img src="98_ridgemap_01.png"><br></p><ul><li><p>아름다운 산악 지형의 풍경이 고전적인 느낌으로 그려져 있습니다.</p></li><li><p>이 그림은 ridge-map 라이브러리를 사용해서 그린 것으로, 코드는 다음과 같습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rm = RidgeMap((<span class="number">11.098251</span>,<span class="number">47.264786</span>,<span class="number">11.695633</span>,<span class="number">47.453630</span>))</span><br><span class="line">values = rm.get_elevation_data(num_lines=<span class="number">150</span>)</span><br><span class="line">values=rm.preprocess(</span><br><span class="line">    values=values,</span><br><span class="line">    lake_flatness=<span class="number">2</span>,</span><br><span class="line">    water_ntile=<span class="number">10</span>,</span><br><span class="line">    vertical_ratio=<span class="number">240</span>)</span><br><span class="line">rm.plot_map(values=values,</span><br><span class="line">            label=<span class="string">&#x27;Karwendelgebirge&#x27;</span>,</span><br><span class="line">            label_y=<span class="number">0.1</span>,</span><br><span class="line">            label_x=<span class="number">0.55</span>,</span><br><span class="line">            label_size=<span class="number">40</span>,</span><br><span class="line">            linewidth=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>별다른 설명이 없이도 대강 감이 오는 코드입니다.</p></li></ul><h1 id="2-ridge-map-설치"><a href="#2-ridge-map-설치" class="headerlink" title="2. ridge-map 설치"></a>2. ridge-map 설치</h1><blockquote><p><a href="https://github.com/ColCarroll/ridge_map/pull/34">ridge-map issue: Google font</a></p></blockquote><ul><li><p>설치는 어렵지 않습니다. pypi에서 다음 명령을 실행하면 간단히 이루어집니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install ridge_map</span><br></pre></td></tr></table></figure></li><li><p>하지만 약간의 문제가 있습니다.</p></li><li><p>기본적으로 사용하는 google font 경로가 바뀌면서 오류가 발생합니다.</p></li><li><p>이 때문에 <b>소스 코드 일부를 수정해야 합니다.</b></p></li></ul><ul><li>파이썬이 설치된 경로를 찾아 <code>파이썬설치경로/site-packages/ridge_map/ridge_map.py</code>를 수정합니다.</li><li>32번째 줄 <code>github_url</code>부분을 다음과 같이 바꿉니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github_url=<span class="string">&quot;https://github.com/google/fonts/blob/5c3d8ef085f3084db38936d0dcd39a567dbc1e01/ofl/cinzel/static/Cinzel-Regular.ttf?raw=true&quot;</span>, <span class="comment"># pylint: disable=line-too-long</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="3-지도-그리기"><a href="#3-지도-그리기" class="headerlink" title="3. 지도 그리기"></a>3. 지도 그리기</h1><ul><li>rige-map으로 지도를 그릴 수 있습니다.</li><li>지도를 그릴 때 필요한 첫 번째 요소는 <b>경도</b>와 <b>위도</b>입니다.</li><li><b>왼쪽 아래</b>와 <b>오른쪽 위</b>지점의 경도와 위도를 <b><code>Ridgemap()</code></b>에 차례로 입력합니다.</li><li>구글 지도에서 쉽게 위도와 경도를 확인할 수 있습니다.</li></ul><p><img src="98_ridgemap_02.png"><br></p><ul><li>구글 지도에서 한 지점을 클릭하면 빨간 마커가 생깁니다.</li><li>주소창 맨 오른쪽 끝에 숫자 두 개가 숨어 있습니다.</li><li>앞에서부터 해당 지점의 <b>위도</b>와 <b>경도</b>이므로 순서를 바꾸어 입력해야 합니다.</li></ul><h2 id="3-1-서울-지도"><a href="#3-1-서울-지도" class="headerlink" title="3.1. 서울 지도"></a>3.1. 서울 지도</h2><ul><li>서울의 좌표를 입력합니다.</li><li>구글 지도에서 대략 <code>(126.8403339,37.4157432,127.1661446,37.7104195)</code>로 입력했습니다.</li><li><code>rm.plot_map()</code>은 Matplotlib Axes 객체를 반환합니다.</li><li>이를 ax라는 이름으로 받아 <code>fig = ax.figure</code>로 Figure 객체를 추출하고,</li><li><code>fig.tight_layout()</code>로 여백을 줄이고 <code>fig.savefig()</code>로 파일로 저장합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rm = RidgeMap((<span class="number">126.8403339</span>,<span class="number">37.4157432</span>,<span class="number">127.1661446</span>,<span class="number">37.7104195</span>))</span><br><span class="line">values = rm.get_elevation_data(num_lines=<span class="number">150</span>)</span><br><span class="line">values=rm.preprocess(</span><br><span class="line">    values=values,</span><br><span class="line">    lake_flatness=<span class="number">2</span>,</span><br><span class="line">    water_ntile=<span class="number">10</span>,</span><br><span class="line">    vertical_ratio=<span class="number">100</span>)</span><br><span class="line">ax = rm.plot_map(values=values,</span><br><span class="line">            label=<span class="string">&#x27;Seoul, Korea&#x27;</span>,</span><br><span class="line">            label_y=<span class="number">0.1</span>,</span><br><span class="line">            label_x=<span class="number">0.7</span>,</span><br><span class="line">            label_size=<span class="number">40</span>,</span><br><span class="line">            linewidth=<span class="number">1.2</span>)</span><br><span class="line"></span><br><span class="line">fig = ax.figure</span><br><span class="line">fig.tight_layout()</span><br><span class="line">fig.savefig(<span class="string">&quot;98_ridgemap_03.png&quot;</span>)</span><br></pre></td></tr></table></figure><img src="98_ridgemap_03.png"><br></li></ul><h2 id="3-2-서울-지도-고도"><a href="#3-2-서울-지도-고도" class="headerlink" title="3.2. 서울 지도 + 고도"></a>3.2. 서울 지도 + 고도</h2><ul><li><p>선에 색을 입혀 고도를 표현할 수 있습니다.</p></li><li><p>위 코드의 <code>rm.plot_map()</code>에 두 줄을 추가합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kind=<span class="string">&quot;elevation&quot;</span>,</span><br><span class="line">line_color=plt.get_cmap(<span class="string">&#x27;gist_earth&#x27;</span>),</span><br></pre></td></tr></table></figure><p><img src="98_ridgemap_04.png"><br></p></li><li><p>북한산과 관악산이 잘 드러납니다.</p></li></ul><h2 id="3-3-Matplotlib-Axes-삽입"><a href="#3-3-Matplotlib-Axes-삽입" class="headerlink" title="3.3. Matplotlib Axes 삽입"></a>3.3. Matplotlib Axes 삽입</h2><ul><li><code>rm.plot_map()</code>은 Matplotlib Axes를 출력합니다.</li><li>따라서 Matplotlib에서 만들어둔 Figure와 Axes를 사용한 연출이 가능합니다.</li><li><code>rm.plot_map()</code> 안에 <code>ax=</code>매개변수를 삽입해서 출력 지점을 지정합니다.</li><li>서울, 대전, 목포, 제주 4개 지역을 한번에 표현합니다.</li><li>축적이 맞지 않음은 유의해야 합니다.</li></ul><ul><li><code>FontManager</code>로 글꼴을 바꿀 수 있습니다.</li><li>적절한 글꼴을 골라 경로를 지정하고, <code>Ridgemap()</code>에 <code>font=font.prop</code>을 추가합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ridge_map <span class="keyword">import</span> FontManager</span><br><span class="line">font = FontManager(<span class="string">&#x27;https://github.com/google/fonts/blob/main/ofl/arsenal/Arsenal-Bold.ttf?raw=true&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(ncols=<span class="number">2</span>, nrows=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">seoul = (<span class="number">126.8403339</span>, <span class="number">37.4157432</span>, <span class="number">127.1661446</span>, <span class="number">37.7104195</span>)</span><br><span class="line">daejeon = (<span class="number">127.2614837</span>, <span class="number">36.2194529</span>, <span class="number">127.6025534</span>, <span class="number">36.5002879</span>)</span><br><span class="line">mokpo = (<span class="number">126.3071108</span>, <span class="number">34.6873927</span>, <span class="number">126.5647852</span>, <span class="number">34.9315327</span>)</span><br><span class="line">jeju = (<span class="number">126.1623888</span>, <span class="number">33.1179613</span>, <span class="number">126.9962384</span>, <span class="number">33.7520832</span>)</span><br><span class="line"></span><br><span class="line">places = [seoul, daejeon, mokpo, jeju]</span><br><span class="line">names = [<span class="string">&quot;Seoul&quot;</span>, <span class="string">&quot;Daejeon&quot;</span>, <span class="string">&quot;Mokpo&quot;</span>, <span class="string">&quot;Jeju&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> place, name, ax <span class="keyword">in</span> <span class="built_in">zip</span>(places, names, axes.ravel()):</span><br><span class="line">    rm = RidgeMap(place, font=font.prop)</span><br><span class="line">    values = rm.get_elevation_data(num_lines=<span class="number">150</span>)</span><br><span class="line">    values=rm.preprocess(</span><br><span class="line">        values=values,</span><br><span class="line">        lake_flatness=<span class="number">2</span>,</span><br><span class="line">        water_ntile=<span class="number">10</span>,</span><br><span class="line">        vertical_ratio=<span class="number">100</span>)</span><br><span class="line">    rm.plot_map(values=values,</span><br><span class="line">                label=<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>, Korea&#x27;</span>,</span><br><span class="line">                label_y=<span class="number">0.1</span>,</span><br><span class="line">                label_x=<span class="number">0.45</span>,</span><br><span class="line">                label_size=<span class="number">20</span>,</span><br><span class="line">                linewidth=<span class="number">1.2</span>,</span><br><span class="line">                background_color=<span class="string">&quot;w&quot;</span>,</span><br><span class="line">                kind=<span class="string">&quot;elevation&quot;</span>,</span><br><span class="line">                line_color=plt.get_cmap(<span class="string">&#x27;gist_earth&#x27;</span>),</span><br><span class="line">                ax=ax)</span><br><span class="line">    </span><br><span class="line">fig = ax.figure</span><br><span class="line">fig.tight_layout()</span><br><span class="line">fig.savefig(<span class="string">&quot;98_ridgemap_05.png&quot;</span>)</span><br></pre></td></tr></table></figure><img src="98_ridgemap_05.png"><br></li></ul><h1 id="4-데이터"><a href="#4-데이터" class="headerlink" title="4. 데이터"></a>4. 데이터</h1><blockquote><p><a href="https://www2.jpl.nasa.gov/srtm/">NASA: Shuttle Radar Topography Mision (SRTM)</a></p></blockquote><ul><li>해발고도 데이터는 2000년에 수집된 NASA의 SRTM을 사용합니다.</li><li>1 arc-second 단위로, 약 30m 수준의 해상도를 보유하고 있습니다.</li><li>단 북위 60도와 남위 60도를 넘어서는 지역은 데이터가 없습니다.<br><br><img src="98_ridgemap_06.gif"><br></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/gis/">gis</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/ridge-map/">ridge-map</category>
      
      
    </item>
    
    <item>
      <title>AI를 하고 싶은 C-level의 흔한 실수들</title>
      <link>https://jehyunlee.github.io/2022/03/28/Python-DS-97-ceo_mistakes/</link>
      <guid>https://jehyunlee.github.io/2022/03/28/Python-DS-97-ceo_mistakes/</guid>
      <pubDate>Sun, 27 Mar 2022 17:13:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;&lt;a href=&quot;https://www.innopolis.or.kr/mps&quot;&gt;연구개발특구(innopolis)&lt;/a&gt;&lt;/b&gt;에서 CEO 대상 AI 인사이트 교육 발표를 했습니다. (22.03.24.)&lt;ul&gt;
&lt;li&gt;공지된 제목은 &lt;b</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b><a href="https://www.innopolis.or.kr/mps">연구개발특구(innopolis)</a></b>에서 CEO 대상 AI 인사이트 교육 발표를 했습니다. (22.03.24.)<ul><li>공지된 제목은 <b>데이터, 다이아몬드 또는 진흙</b>이었습니다만</li><li>제 앞에서 발표하신 고우영 님의 발표를 보고 연장선상에서 바꿨습니다.</li><li>수정된 제목은 <b>AI를 하고 싶은 C-level의 흔한 실수들</b>입니다.</li></ul></li></ul><ul><li>발표 영상입니다 (<a href="https://youtu.be/mcIU5Fk-pFo">Youtube Link</a>)<br></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/mcIU5Fk-pFo" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <ul><li><b>AI는 회사를 운영하는 방식을 바꾸는 일</b>이기 때문에 굵직한 의사 결정이 많이 필요합니다.<ul><li>“갖다쓰면 되겠지”, “남들도 한다는데”라는 마인드로는 실패할 확률이 매우 큽니다.</li><li>실무자가 필요로 하는 것이 무엇인지, 왜인지, 진짜인지를 알기 위해서라도 공부하셔야 합니다.</li><li>전 직장의 경험담을 위주로 구성했습니다. </li><li>전달력을 위해 여러 사례를 합치기도 했고 나누기도 했습니다. 이 점을 참고해 주시면 좋겠습니다.</li></ul></li></ul><p><img src="poster.jpg" alt="연구개발특구 행사 공지"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/AI-Frenz/">AI Frenz</category>
      
      <category domain="https://jehyunlee.github.io/tags/C-level/">C-level</category>
      
      
    </item>
    
    <item>
      <title>joinstyle &amp; capstyle</title>
      <link>https://jehyunlee.github.io/2022/01/24/Python-DS-96-joinstyle/</link>
      <guid>https://jehyunlee.github.io/2022/01/24/Python-DS-96-joinstyle/</guid>
      <pubDate>Sun, 23 Jan 2022 22:25:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;오늘은 매우 사소한 글입니다.&lt;/li&gt;
&lt;li&gt;Matplotlib에서 그려지는 선의 꼭지점과 끝점 표현입니다.&lt;/li&gt;
&lt;li&gt;사소하지만 신경을 거스르는 일을 해결합시다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-motivation-Pie</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>오늘은 매우 사소한 글입니다.</li><li>Matplotlib에서 그려지는 선의 꼭지점과 끝점 표현입니다.</li><li>사소하지만 신경을 거스르는 일을 해결합시다.</li></ul><h1 id="1-motivation-Pie-chart"><a href="#1-motivation-Pie-chart" class="headerlink" title="1. motivation: Pie chart"></a>1. motivation: Pie chart</h1><ul><li><p>다른 그림에 비해 자주 그리는 그림은 아닙니다.</p></li><li><p>그런 만큼 손에 익히기 쉽지 않은데, 정리를 한번 하겠습니다.</p></li><li><p>아보카도, 바나나, 체리 판매량이 각기 40, 70, 10이라고 하고,</p></li><li><p>상대적인 판매량을 그림으로 그린다고 칩시다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 판매량</span></span><br><span class="line">data = [<span class="number">40</span>, <span class="number">70</span>, <span class="number">10</span>]</span><br><span class="line"><span class="comment"># 레이블</span></span><br><span class="line">labels = [<span class="string">&quot;Abocado&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>]</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">12</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (A) 색과 글자 설정</span></span><br><span class="line">axs[<span class="number">0</span>].pie(data, labels=labels, labeldistance=<span class="number">0.7</span>, </span><br><span class="line">           colors=[<span class="string">&quot;g&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;r&quot;</span>],</span><br><span class="line">           textprops=&#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;fontsize&quot;</span>:<span class="string">&quot;14&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>, <span class="string">&quot;ha&quot;</span>:<span class="string">&quot;center&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (B) 부채꼴에 윤곽선 추가</span></span><br><span class="line">axs[<span class="number">1</span>].pie(data, labels=labels, labeldistance=<span class="number">0.7</span>, </span><br><span class="line">           colors=[<span class="string">&quot;g&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;r&quot;</span>], </span><br><span class="line">           textprops=&#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;fontsize&quot;</span>:<span class="string">&quot;14&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>, <span class="string">&quot;ha&quot;</span>:<span class="string">&quot;center&quot;</span>&#125;,</span><br><span class="line">           wedgeprops=&#123;<span class="string">&quot;ec&quot;</span>:<span class="string">&quot;w&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (C) 부채꼴 윤곽선 두껍게</span></span><br><span class="line">axs[<span class="number">2</span>].pie(data, labels=labels, labeldistance=<span class="number">0.7</span>, </span><br><span class="line">           colors=[<span class="string">&quot;g&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;r&quot;</span>], </span><br><span class="line">           textprops=&#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;fontsize&quot;</span>:<span class="string">&quot;14&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>, <span class="string">&quot;ha&quot;</span>:<span class="string">&quot;center&quot;</span>&#125;,</span><br><span class="line">           wedgeprops=&#123;<span class="string">&quot;ec&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;lw&quot;</span>:<span class="number">6</span>&#125;)</span><br><span class="line"></span><br><span class="line">titles = [<span class="string">&quot;(A)&quot;</span>, <span class="string">&quot;(B): (A) + wedgeprops&quot;</span>, <span class="string">&quot;(C): (B) + lw&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> title, ax <span class="keyword">in</span> <span class="built_in">zip</span>(titles, axs):</span><br><span class="line">    ax.set_title(title, fontsize=<span class="number">16</span>)</span><br><span class="line">    ax.set_aspect(<span class="number">1</span>)    </span><br></pre></td></tr></table></figure><p><img src="96_joinstyle_01.png"><br></p></li><li><p><code>colors</code> 매개변수로 색을 조정하고 <code>textprops</code> 매개변수로 글꼴만 좀 조정한 것이 (A)입니다.</p></li><li><p>(B)는 부채꼴에 경계선을 넣어서 틈을 살짝 벌렸습니다. <code>wedgeprops</code>를 사용합니다.</p></li><li><p>만들고 보니 좀 두꺼우면 좋겠다는 생각이 듭니다. <code>wedgeprops</code>에 <code>lw</code>를 넣어 line width를 두껍게 했습니다.</p></li></ul><ul><li>그런데 <b>cherry가 banana를 찌르고 있습니다.</b></li><li>사소하다면 사소한건데, 영 성가십니다. </li><li><b>원인을 파악하고 제거합시다.</b></li></ul><h1 id="2-별-그리기"><a href="#2-별-그리기" class="headerlink" title="2. 별 그리기"></a>2. 별 그리기</h1><ul><li>문제를 일반화하기 위해 별을 그리고 이 그림을 바꿔봅니다.</li><li><a href="https://jehyunlee.github.io/2021/12/28/Python-DS-94-rougier02/">지난 글</a>에서 다룬 <code>Path</code>와 <code>PathPatch</code>를 사용합니다.</li></ul><h2 id="2-1-별-만들기"><a href="#2-1-별-만들기" class="headerlink" title="2.1. 별 만들기"></a>2.1. 별 만들기</h2><ul><li><p>오각형 기반으로 별을 만들겠습니다.</p></li><li><p>어릴 때부터 별을 그리라면 이렇게 그렸죠. :)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.path <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> PathPatch</span><br><span class="line"></span><br><span class="line">xs = [np.cos(<span class="number">2</span>*np.pi*x/<span class="number">5</span> + <span class="number">0.5</span>*np.pi) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">ys = [np.sin(<span class="number">2</span>*np.pi*x/<span class="number">5</span> + <span class="number">0.5</span>*np.pi) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">ps = np.array(<span class="built_in">list</span>(<span class="built_in">zip</span>(xs, ys)))    </span><br><span class="line">ps</span><br></pre></td></tr></table></figure></li><li><p>실행 결과: 다섯 지점의 좌표를 만들었습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array([[ 6.12323400e-17,  1.00000000e+00],</span><br><span class="line">       [-9.51056516e-01,  3.09016994e-01],</span><br><span class="line">       [-5.87785252e-01, -8.09016994e-01],</span><br><span class="line">       [ 5.87785252e-01, -8.09016994e-01],</span><br><span class="line">       [ 9.51056516e-01,  3.09016994e-01]])</span><br></pre></td></tr></table></figure></li><li><p>이제 점따라 이어서 별을 그립니다.</p></li><li><p>어릴 때 그리던 그 순서대로 점 번호를 찍습니다.</p></li><li><p>마지막에 원점으로 돌아가는 것까지 잊지 말아야 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps_star = ps[[<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>]]</span><br><span class="line">ps_star</span><br></pre></td></tr></table></figure></li><li><p>실행 결과: 순서대로 점이 배열됩니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array([[ 6.12323400e-17,  1.00000000e+00],</span><br><span class="line">       [-5.87785252e-01, -8.09016994e-01],</span><br><span class="line">       [ 9.51056516e-01,  3.09016994e-01],</span><br><span class="line">       [-9.51056516e-01,  3.09016994e-01],</span><br><span class="line">       [ 5.87785252e-01, -8.09016994e-01],</span><br><span class="line">       [ 6.12323400e-17,  1.00000000e+00]])</span><br></pre></td></tr></table></figure></li><li><p><code>Path</code>와 <code>PathPatch</code>를 차례대로 적용해서 별을 그립니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">path_star = Path(ps_star)</span><br><span class="line">patch_star = PathPatch(path_star, fc=<span class="string">&quot;yellow&quot;</span>, ec=<span class="string">&quot;k&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">4</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.add_artist(patch_star)</span><br><span class="line">ax.set_xlim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">ax.set_ylim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br></pre></td></tr></table></figure><p><img src="96_joinstyle_02.png"><br></p></li><li><p>맘에 듭니다.</p></li><li><p>선을 굵게 합시다. PathPatch에 <code>lw</code> 매개변수를 추가합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">path_star = Path(ps_star)</span><br><span class="line">patch_star = PathPatch(path_star, fc=<span class="string">&quot;yellow&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, lw=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">4</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.add_artist(patch_star)</span><br><span class="line">ax.set_xlim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">ax.set_ylim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br></pre></td></tr></table></figure><p><img src="96_joinstyle_03.png"><br></p></li><li><p>시작점이자 끝점인 맨 위가 부러진 듯 보입니다.</p></li><li><p>끝점(caps)과 중간점(joints) 표현 방식이 달라서 그렇습니다.</p></li><li><p>일단 저 끝점을 중간점으로 만들어서 일관성을 줍시다.</p></li><li><p>한 포인트 더 붙이면 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ps_star = ps[[<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>]]  <span class="comment"># 맨 마지막에 2 추가</span></span><br><span class="line">path_star = Path(ps_star)</span><br><span class="line">patch_star = PathPatch(path_star, fc=<span class="string">&quot;yellow&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, lw=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">4</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.add_artist(patch_star)</span><br><span class="line">ax.set_xlim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">ax.set_ylim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br></pre></td></tr></table></figure><p><img src="96_joinstyle_04.png"><br></p></li></ul><h2 id="2-2-joinstyle"><a href="#2-2-joinstyle" class="headerlink" title="2.2. joinstyle"></a>2.2. <code>joinstyle</code></h2><blockquote><p><a href="https://matplotlib.org/stable/api/_enums_api.html?highlight=joinstyle#matplotlib._enums.JoinStyle">matplotlib._enums.Joinstyle</a></p></blockquote><ul><li><p>Matplotlib에서 꺾은선 그래프처럼 여러 선이 꺾이는 관절 표현은 <code>joinstyle</code> 매개변수로 결정합니다.</p></li><li><p><code>miter</code>, <code>round</code>, <code>bevel</code> 세 가지의 선택지가 있습니다.<br><br><img src="joinstyle.webp"><br></p></li><li><p>우리 별 그림에 이 셋을 적용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">joinstyles = [<span class="string">&quot;miter&quot;</span>, <span class="string">&quot;round&quot;</span>, <span class="string">&quot;bevel&quot;</span>]</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">12</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> js, ax <span class="keyword">in</span> <span class="built_in">zip</span>(joinstyles, axs):</span><br><span class="line">    patch_star = PathPatch(path_star, fc=<span class="string">&quot;yellow&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, lw=<span class="number">10</span>, joinstyle=js)</span><br><span class="line">    ax.add_artist(patch_star)</span><br><span class="line">    ax.set_xlim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">    ax.set_ylim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br></pre></td></tr></table></figure><p><img src="96_joinstyle_05.png"><br></p></li><li><p>왼쪽부터 <b>뾰족</b>, <b>둥글</b>, <b>판판</b>입니다.</p></li><li><p>기본값은 뾰족한 <code>miter</code>로 각도가 작을수록 먼 곳까지 꼭지점이 연장된다는 특징이 있습니다.</p></li><li><p>맨 위 pie chart 예제에서도 체리 판매량이 다른 둘보다 적어 꼭지점이 바나나를 찔렀습니다.</p></li><li><p><b><code>round</code>나 <code>bevel</code>을 사용하면 그럴 일이 없을 겁니다.</b> </p></li></ul><h1 id="3-원-그리기"><a href="#3-원-그리기" class="headerlink" title="3. 원 그리기"></a>3. 원 그리기</h1><ul><li>이번에는 조금 다른 예제를 확인합니다.</li><li>시작과 끝이 동일한 원을 점선으로 표현해서 짧은 선을 많이 그립니다.</li></ul><h2 id="3-1-원-만들기"><a href="#3-1-원-만들기" class="headerlink" title="3.1. 원 만들기"></a>3.1. 원 만들기</h2><ul><li>이번엔 <code>PathPatch</code>말고 <code>Circle</code>을 사용합니다.</li><li><code>Circle</code>로 원을 만들고 <code>add_artist()</code>로 붙입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Circle</span><br><span class="line"></span><br><span class="line">circle = Circle((<span class="number">0</span>, <span class="number">0</span>), <span class="number">1</span>, ls=<span class="string">&quot;:&quot;</span>, fc=<span class="string">&quot;beige&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, lw=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">4</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.add_artist(circle)</span><br><span class="line">ax.set_xlim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">ax.set_ylim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br></pre></td></tr></table></figure><img src="96_joinstyle_06.png"><br></li></ul><h2 id="3-2-joinstyle-capstyle"><a href="#3-2-joinstyle-capstyle" class="headerlink" title="3.2. joinstyle? capstyle!"></a>3.2. <code>joinstyle</code>? <code>capstyle</code>!</h2><ul><li><p>별 그림과 똑같이 joinstyle을 적용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">12</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j, ax <span class="keyword">in</span> <span class="built_in">zip</span>(joinstyles, axs):</span><br><span class="line">    circle = Circle((<span class="number">0</span>, <span class="number">0</span>), <span class="number">1</span>, ls=<span class="string">&quot;:&quot;</span>, fc=<span class="string">&quot;beige&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, lw=<span class="number">10</span>, joinstyle=j)</span><br><span class="line">    ax.add_artist(circle)</span><br><span class="line">    ax.set_xlim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">    ax.set_ylim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br></pre></td></tr></table></figure><p><img src="96_joinstyle_07.png"><br></p></li><li><p>별 그림과는 달리 변화가 없습니다.</p></li><li><p><b><code>joinstyle</code>은 선이 꺾이는 부분에 적용되는 매개변수</b>입니다.</p></li><li><p>원은 꺾이는 점이 없고 점선도 꺾인 곳이 없기에 아무런 변화가 없습니다.</p></li></ul><ul><li><p><b>선 끝에는 <code>capstyle</code>이 적용됩니다.</b></p></li><li><p>선택지는 <code>joinstyle</code>처럼 세 개지만 이름이 다릅니다.</p></li><li><p><code>butt</code>, <code>round</code>, <code>projecting</code>입니다.<br><br><img src="capstyle.webp"><br></p></li><li><p>확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">capstyles = [<span class="string">&quot;butt&quot;</span>, <span class="string">&quot;round&quot;</span>, <span class="string">&quot;projecting&quot;</span>]</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">12</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cs, ax <span class="keyword">in</span> <span class="built_in">zip</span>(capstyles, axs):</span><br><span class="line">    circle = Circle((<span class="number">0</span>, <span class="number">0</span>), <span class="number">1</span>, ls=<span class="string">&quot;:&quot;</span>, fc=<span class="string">&quot;beige&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, lw=<span class="number">10</span>, capstyle=cs)</span><br><span class="line">    ax.add_artist(circle)</span><br><span class="line">    ax.set_xlim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">    ax.set_ylim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br></pre></td></tr></table></figure><p><img src="96_joinstyle_08.png"><br></p></li><li><p>이제 차이가 보입니다.</p></li><li><p>joinstyle과 capstyle을 함께 표현합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">12</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> js, cs, ax <span class="keyword">in</span> <span class="built_in">zip</span>(joinstyles, capstyles, axs):</span><br><span class="line">    circle = Circle((<span class="number">0</span>, <span class="number">0</span>), <span class="number">1</span>, ls=<span class="string">&quot;:&quot;</span>, fc=<span class="string">&quot;beige&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, lw=<span class="number">10</span>, capstyle=cs)</span><br><span class="line">    ax.add_artist(circle)</span><br><span class="line">    patch_star = PathPatch(path_star, fc=<span class="string">&quot;yellow&quot;</span>, ec=<span class="string">&quot;r&quot;</span>, lw=<span class="number">10</span>, joinstyle=js)</span><br><span class="line">    ax.add_artist(patch_star)</span><br><span class="line">    ax.set_xlim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">    ax.set_ylim(-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">    ax.set_title(<span class="string">f&quot;joinstyle= &#x27;<span class="subst">&#123;js&#125;</span>&#x27;\ncapstype= &#x27;<span class="subst">&#123;cs&#125;</span>&#x27;&quot;</span>, pad=<span class="number">12</span>, fontsize=<span class="string">&quot;xx-large&quot;</span>)</span><br><span class="line">    ax.set_xticks([])</span><br><span class="line">    ax.set_yticks([])</span><br><span class="line">    ax.set_aspect(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="96_joinstyle_09.png"><br></p></li></ul><h1 id="4-다시-Pie-chart"><a href="#4-다시-Pie-chart" class="headerlink" title="4. 다시 Pie chart"></a>4. 다시 Pie chart</h1><ul><li><p>애초 우리 목적은 Pie chart였습니다.</p></li><li><p>맨 위 코드에 <code>joinstyle</code>만 <code>round</code>로 적용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="number">40</span>, <span class="number">70</span>, <span class="number">10</span>]</span><br><span class="line">labels = [<span class="string">&quot;Abocado&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>]</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">4</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.pie(data, labels=labels, labeldistance=<span class="number">0.7</span>, </span><br><span class="line">       colors=[<span class="string">&quot;g&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;r&quot;</span>], </span><br><span class="line">       textprops=&#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;fontsize&quot;</span>:<span class="string">&quot;14&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>, <span class="string">&quot;ha&quot;</span>:<span class="string">&quot;center&quot;</span>&#125;,</span><br><span class="line">       wedgeprops=&#123;<span class="string">&quot;ec&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;lw&quot;</span>:<span class="number">6</span>, <span class="string">&quot;joinstyle&quot;</span>:<span class="string">&quot;round&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">ax.set_aspect(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="96_joinstyle_10.png"><br></p></li><li><p><b>짜잔. 이제 깔끔합니다.</b></p></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/joinstyle/">joinstyle</category>
      
      <category domain="https://jehyunlee.github.io/tags/capstyle/">capstyle</category>
      
      
    </item>
    
    <item>
      <title>gravity</title>
      <link>https://jehyunlee.github.io/2022/01/13/Python-Physics-1-gravity/</link>
      <guid>https://jehyunlee.github.io/2022/01/13/Python-Physics-1-gravity/</guid>
      <pubDate>Thu, 13 Jan 2022 12:25:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;파이썬은 과학과 공학을 구현하기 좋습니다.&lt;/li&gt;
&lt;li&gt;간단한 몇 개의 코드로 방정식을 구현하고,&lt;/li&gt;
&lt;li&gt;시각화 기법을 사용해 우리 눈으로 봅니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-만유인력&quot;&gt;&lt;a href=&quot;#1-만유</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>파이썬은 과학과 공학을 구현하기 좋습니다.</li><li>간단한 몇 개의 코드로 방정식을 구현하고,</li><li>시각화 기법을 사용해 우리 눈으로 봅니다.</li></ul><h1 id="1-만유인력"><a href="#1-만유인력" class="headerlink" title="1. 만유인력"></a>1. 만유인력</h1><blockquote><p><a href="https://en.wikipedia.org/wiki/Gravity">wikipedia: gravity</a></p></blockquote><ul><li>질량이 있는 물체끼리는 끌어당기는 힘이 있습니다. <b>만유인력</b>이라고 합니다.</li><li>뉴턴이 발견한 것으로 유명하고, 중력파는 우주의 비밀을 여는 열쇠가 됩니다.</li><li>두 물체의 질량이 $m_1$, $m_2$, 거리가 $r$일 때 다음과 같은 방정식으로 표현됩니다.</li></ul><p>$$F = G\frac{m_1 m_2}{r^2}$$</p><ul><li>$G$는 중력 상수라고 하며 값은 $6.67 \times 10^{-11} [\textrm{m} \cdot \textrm{kg}^{-1}\textrm{s}^{-2}]$ 입니다.</li></ul><h1 id="2-자유-낙하"><a href="#2-자유-낙하" class="headerlink" title="2. 자유 낙하"></a>2. 자유 낙하</h1><ul><li>만유 인력을 일상의 물건들에서 느끼기엔 너무 미미하지만 지구나 태양이라면 이야기가 달라집니다.</li><li>위 식의 $m_2$에 지구의 질량을 넣고 $r$에 지구 반지름을 넣으면 <b>지구의 중력</b>이 됩니다.</li></ul><p>$$F = mg$$ </p><ul><li>중학교때 배운 식으로 정리되며, <b>중력 가속도</b> $g = 9.8 [\textrm{m} \cdot \textrm{s}^{-2}]$ 입니다.</li><li>간단히 물체의 자유 낙하를 시뮬레이션 합니다.</li></ul><h2 id="2-1-python-setting"><a href="#2-1-python-setting" class="headerlink" title="2.1. python setting"></a>2.1. python setting</h2><ul><li>기본 라이브러리를 불러오고 물체의 질량 등을 설정합니다.</li><li>연속적인 시간을 0.01초 단위로 끊어서 자유낙하를 모사하려고 합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 기본 라이브러리</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.set_style(<span class="string">&quot;white&quot;</span>)</span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 물체 </span></span><br><span class="line">mass = <span class="number">1</span>                     <span class="comment"># 질량 [kg] </span></span><br><span class="line">position = np.array([<span class="number">0</span>, <span class="number">10</span>]) <span class="comment"># x, y 위치 [m]</span></span><br><span class="line">v = np.array([<span class="number">0</span>, <span class="number">0</span>])         <span class="comment"># x, y 방향 초기 속도 [m/s]</span></span><br><span class="line">t = <span class="number">0</span>                        <span class="comment"># 초기 시간 [s]</span></span><br><span class="line">dt = <span class="number">0.01</span>                    <span class="comment"># 시간 단위 [s]</span></span><br><span class="line">g = np.array([<span class="number">0</span>, -<span class="number">9.8</span>])      <span class="comment"># 중력 가속도 [m/s]</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2-자유-낙하-시뮬레이션"><a href="#2-2-자유-낙하-시뮬레이션" class="headerlink" title="2.2. 자유 낙하 시뮬레이션"></a>2.2. 자유 낙하 시뮬레이션</h2><ul><li>지상 높이 10미터에서 땅에 떨어지는 시간을 살펴봅니다.</li><li>중학교에서 배우는 아래 공식에 $a$ 대신 $g$를 넣습니다.</li></ul><p>$$s = v_0 t + \frac{1}{2}at^2$$</p><ul><li><p>땅을 뚫고 들어가는 상황은 가정하지 않습니다.</p></li><li><p>초기 위치로 가정한 position의 y좌표 &gt; 0일 때만 계산합니다.</p></li><li><p>걸리는 <b>시간</b>은 <code>ts</code>리스트, 위치는 <code>positions</code>에 모읍니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 시뮬레이션</span></span><br><span class="line">ts = []</span><br><span class="line">positions = []</span><br><span class="line"><span class="keyword">while</span> position[<span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">    ts.append(t)</span><br><span class="line">    positions.append(position)</span><br><span class="line"></span><br><span class="line">    position = position + v*t + <span class="number">0.5</span> * g * t**<span class="number">2</span></span><br><span class="line">    t += dt</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 시각화</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">8</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">directions = [<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i, (ax, direction) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(axs, directions)):</span><br><span class="line">    ax.scatter(ts, np.array(positions)[:,i], alpha=<span class="number">0.3</span>, c=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">    ax.set_xlabel(<span class="string">&quot;time (s)&quot;</span>)</span><br><span class="line">    ax.set_title(<span class="string">f&quot;<span class="subst">&#123;direction&#125;</span> position (m)&quot;</span>, pad=<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p><img src="1_gravity_01.png"><br></p></li><li><p>좌우로 흔들릴 일은 없으므로 x position은 그대로</p></li><li><p>중력에 의해 떨어지기만 하므로 y position만 변화합니다.</p></li></ul><h2 id="2-3-자유-낙하-애니메이션"><a href="#2-3-자유-낙하-애니메이션" class="headerlink" title="2.3. 자유 낙하 애니메이션"></a>2.3. 자유 낙하 애니메이션</h2><ul><li><p>좀 재밌게 만들어 봅시다.</p></li><li><p>matplotlib의 애니메이션 기능을 이용해서 만들 수 있습니다.</p></li><li><p>물체의 위치를 표현할 scatter plot과 시간을 표현할 text를 내용만 비우고 만든 뒤에,</p></li><li><p>time step마다 각각의 데이터만 업데이트하는 방식을 사용했습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> animation</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">4</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">scatter, = ax.plot([], [], marker=<span class="string">&quot;o&quot;</span>, mfc=<span class="string">&quot;b&quot;</span>, mec=<span class="string">&quot;w&quot;</span>)</span><br><span class="line">time_text = ax.text(<span class="number">0.5</span>, <span class="number">0.9</span>, <span class="string">f&quot;&quot;</span>, transform=ax.transAxes, ha=<span class="string">&quot;center&quot;</span>)</span><br><span class="line"></span><br><span class="line">ax.set_ylim(<span class="number">0</span>, <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updatefig</span>(<span class="params">i</span>):</span>       </span><br><span class="line">    scatter.set_data(positions[i][<span class="number">0</span>], positions[i][<span class="number">1</span>])</span><br><span class="line">    time_text.set_text(<span class="string">f&quot;t = <span class="subst">&#123;ts[i]:<span class="number">.03</span>f&#125;</span> sec.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> fig,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ani = animation.FuncAnimation(fig, updatefig, interval=<span class="number">100</span>, blit=<span class="literal">True</span>, repeat=<span class="literal">False</span>, frames=<span class="built_in">len</span>(ts))</span><br><span class="line">ani.save(<span class="string">&quot;1_gravity_02.gif&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="1_gravity_02.gif"><br></p></li><li><p><code>ani.save()</code>명령으로 파일로 저장했습니다.</p></li><li><p>주피터 노트북이나 Google Colab에서 다음 코드를 사용하면 interactive animation을 얻을 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> HTML</span><br><span class="line">HTML(ani.to_jshtml())</span><br></pre></td></tr></table></figure><p><img src="1_gravity_11.gif"><br></p></li></ul><h1 id="3-움직이는-두-개의-물체"><a href="#3-움직이는-두-개의-물체" class="headerlink" title="3. 움직이는 두 개의 물체"></a>3. 움직이는 두 개의 물체</h1><h2 id="3-1-class로-물체-생성"><a href="#3-1-class로-물체-생성" class="headerlink" title="3.1. class로 물체 생성"></a>3.1. class로 물체 생성</h2><ul><li><p><b>지구 vs 물체</b> 대신 <b>물체 vs 물체</b> 구도가 되면 조금 복잡해집니다.</p></li><li><p>지구는 너무나 거대하기 때문에 상수로 놓을 수 있었지만 물체는 변수입니다.</p></li><li><p>서로 힘을 주고 받을 때 위치와 속도가 변합니다.</p></li><li><p>물체마다 받는 힘과 이로 인한 위치 변화 등을 계산합시다. <b>class</b>가 편합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Particle</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, mass, pos, v, fix=<span class="literal">False</span></span>):</span></span><br><span class="line">        self.mass = mass <span class="comment"># scalar  # 질량. scalar</span></span><br><span class="line">        self.pos = np.array(pos)   <span class="comment"># 위치 (x, y) 2D vector </span></span><br><span class="line">        self.v = np.array(v)       <span class="comment"># 속도 (x, y) 2D vector</span></span><br><span class="line">        self.a = np.array([<span class="number">0</span>,<span class="number">0</span>])   <span class="comment"># 가속도 (x, y) 2D vector</span></span><br><span class="line">        self.fix = fix             <span class="comment"># 고정 여부. True or False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, force</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.fix:           <span class="comment"># 고정이 되어 있지 않을 때만 데이터 업데이트</span></span><br><span class="line">            self.a = force/self.mass</span><br><span class="line">            self.pos = self.pos + (self.v * dt) + (<span class="number">0.5</span>*self.a * dt**<span class="number">2</span>)</span><br><span class="line">            self.v = self.v + self.a * dt</span><br></pre></td></tr></table></figure></li><li><p>이제 물체를 class로 정의할 준비가 되었습니다.</p></li><li><p>물체를 입자라는 뜻의 Particle로 부르겠습니다.</p></li><li><p>각각의 질량, 위치, 속도를 정하고 생성합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P1_mass, P2_mass = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">P1_pos, P2_pos = [<span class="number">1</span>, <span class="number">1</span>], [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">P1_v, P2_v = [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">P1 = Particle(P1_mass, P1_pos, P1_v)</span><br><span class="line">P2 = Particle(P2_mass, P2_pos, P2_v)</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-2-중력-계산-함수"><a href="#3-2-중력-계산-함수" class="headerlink" title="3.2. 중력 계산 함수"></a>3.2. 중력 계산 함수</h2><ul><li>물체들 간의 인력을 계산할 함수를 만듭니다.</li><li>맨 위의 방정식을 옮깁니다.</li><li>방정식에 따르면 거리가 너무 가까울 때 만유인력이 무한대로 증가하는 문제가 있습니다.</li><li><b>특정 거리<code>dist_cr</code> 미만으로 오면 인력을 0으로 강제</b>해서 관성으로만 움직이게 합니다.</li></ul><ul><li>만유인력 상수가 너무 작아서 임의로 크게 키웠습니다.</li><li>여기에 걸맞게 질량이 아주 커다란 천체들의 움직임이라고 생각할 수 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_force</span>(<span class="params">P_self, P_other, k=<span class="number">1</span>, dist_cr = <span class="number">0.02</span></span>):</span></span><br><span class="line">    pos_self = P_self.pos</span><br><span class="line">    pos_other = P_other.pos</span><br><span class="line">    rel_vec = pos_other - pos_self</span><br><span class="line">    dist = np.linalg.norm(rel_vec)    </span><br><span class="line"></span><br><span class="line">    mass_self = P_self.mass</span><br><span class="line">    mass_other = P_other.mass</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dist &lt; dist_cr:</span><br><span class="line">        force = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> rel_vec <span class="comment"># [0, 0]</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        force = k*mass_self*mass_other/ dist**<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> force * rel_vec/dist</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-3-두-물체간의-만유인력"><a href="#3-3-두-물체간의-만유인력" class="headerlink" title="3.3. 두 물체간의 만유인력"></a>3.3. 두 물체간의 만유인력</h2><ul><li><p>150번 iteration하면서 시간, 위치, 속도, 힘을 차례로 뽑아내며 업데이트합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">iter_max = <span class="number">150</span></span><br><span class="line"></span><br><span class="line">ts = []                  <span class="comment"># 시간</span></span><br><span class="line">P1_pos, P2_pos = [], []  <span class="comment"># 시간별 위치</span></span><br><span class="line">P1_v, P2_v = [], []      <span class="comment"># 시간별 속도</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iter_max):</span><br><span class="line">    <span class="comment"># time update</span></span><br><span class="line">    ts.append(i*dt)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># position update</span></span><br><span class="line">    P1_pos.append(P1.pos)</span><br><span class="line">    P2_pos.append(P2.pos)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># velocity update</span></span><br><span class="line">    P1_v.append(P1.v)</span><br><span class="line">    P2_v.append(P2.v)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># calculate force</span></span><br><span class="line">    P1_force = calc_force(P1, P2, k=<span class="number">10</span>)</span><br><span class="line">    P2_force = calc_force(P2, P1, k=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># update</span></span><br><span class="line">    P1.update(P1_force)</span><br><span class="line">    P2.update(P2_force)</span><br></pre></td></tr></table></figure></li><li><p>어떻게 움직였나 한번 봅시다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">P1_pos = np.array(P1_pos)</span><br><span class="line">P2_pos = np.array(P2_pos)</span><br><span class="line"></span><br><span class="line">plt.plot(P1_pos[:, <span class="number">0</span>], P1_pos[:, <span class="number">1</span>], <span class="string">&quot;o-&quot;</span>, label=<span class="string">&quot;P1&quot;</span>)</span><br><span class="line">plt.plot(P2_pos[:, <span class="number">0</span>], P2_pos[:, <span class="number">1</span>], <span class="string">&quot;o-&quot;</span>, label=<span class="string">&quot;P2&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;position&quot;</span>, pad=<span class="number">12</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure><p><img src="1_gravity_03.png"></p></li><li><p><b>뭔가 이상합니다.</b></p></li><li><p>시작점은 P1이 [1, 1], P2가 [-1, -1]이었습니다.</p></li><li><p>서로 끌어당기다가 한가운데인 [0, 0]에서 만나야 할 것 같은데 한참을 더 지나갑니다.</p></li><li><p>x방향 속도를 그려봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(np.array(P1_v)[:, <span class="number">0</span>], <span class="string">&quot;o-&quot;</span>, label=<span class="string">&quot;P1&quot;</span>)</span><br><span class="line">plt.plot(np.array(P2_v)[:, <span class="number">0</span>], <span class="string">&quot;o-&quot;</span>, label=<span class="string">&quot;P2&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;x-directional velocity (m/s&quot;</span>, pad=<span class="number">12</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure><p><img src="1_gravity_04.png"></p></li><li><p>120번째 step 부근에서 속도가 크게 빨라졌다가 감소하지만 부호는 바뀌지 않습니다.</p></li><li><p>원점을 지나 힘이 거꾸로 작용해도 관성에 의해 서로를 지나쳤고, </p></li><li><p>이 때 작용하는 힘은 다시 불러오기엔 역부족인 듯 합니다.</p></li></ul><h2 id="3-4-동영상-제작-함수"><a href="#3-4-동영상-제작-함수" class="headerlink" title="3.4. 동영상 제작 함수"></a>3.4. 동영상 제작 함수</h2><ul><li><p>동영상으로 확실하게 살펴봅니다.</p></li><li><p>왠지 앞으로 동영상을 자주 만들 것 같습니다.</p></li><li><p>N개의 입자를 다룰 수 있도록 앞의 코드를 일반화합니다.</p></li><li><p><b>질량에 따라 입자의 크기와 색이 바뀌도록</b> 설정을 해두고,</p></li><li><p><b>컬러맵을 사용해서 입자마다 다른 색을 두르도록</b>합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cmap = plt.get_cmap(<span class="string">&quot;tab10&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_animation</span>(<span class="params">Ps, Ps_pos, ts, title, legend=<span class="literal">True</span></span>):</span></span><br><span class="line">    fig, ax = plt.subplots(figsize=(<span class="number">4</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    mfcs = [<span class="string">&quot;k&quot;</span> <span class="keyword">if</span> P.mass &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;w&quot;</span> <span class="keyword">for</span> P <span class="keyword">in</span> Ps]</span><br><span class="line">    mss = [<span class="number">12</span>*np.sqrt(<span class="built_in">abs</span>(P.mass)) <span class="keyword">for</span> P <span class="keyword">in</span> Ps]</span><br><span class="line">    plots = [ax.plot([], [], marker=<span class="string">&quot;o&quot;</span>, mfc=mfc, mec=cmap(j/<span class="number">10</span>), mew=<span class="number">3</span>, ms=ms, label=<span class="string">f&quot;P<span class="subst">&#123;j+<span class="number">1</span>&#125;</span>&quot;</span>) </span><br><span class="line">             <span class="keyword">for</span> j, (P_pos, mfc, ms) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(Ps_pos, mfcs, mss))]</span><br><span class="line">    time_text = ax.text(<span class="number">0.5</span>, <span class="number">0.9</span>, <span class="string">f&quot;&quot;</span>, transform=ax.transAxes, ha=<span class="string">&quot;center&quot;</span>)</span><br><span class="line">    title = ax.set_title(title, pad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">    ax.set_xlim(-<span class="number">1.1</span>, <span class="number">1.1</span>)</span><br><span class="line">    ax.set_ylim(-<span class="number">1.1</span>, <span class="number">1.1</span>)</span><br><span class="line">    <span class="keyword">if</span> legend:</span><br><span class="line">        ax.legend(loc=<span class="string">&quot;lower right&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updatefig</span>(<span class="params">i</span>):</span></span><br><span class="line">        [plot[<span class="number">0</span>].set_data(P_pos[i][<span class="number">0</span>], P_pos[i][<span class="number">1</span>]) <span class="keyword">for</span> plot, P_pos <span class="keyword">in</span> <span class="built_in">zip</span>(plots, Ps_pos)]       </span><br><span class="line">        time_text.set_text(<span class="string">f&quot;t = <span class="subst">&#123;ts[i]:<span class="number">.03</span>f&#125;</span> sec.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> fig,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ani = animation.FuncAnimation(fig, updatefig, interval=<span class="number">100</span>, blit=<span class="literal">True</span>, repeat=<span class="literal">False</span>, frames=<span class="built_in">len</span>(ts))</span><br><span class="line">    <span class="keyword">return</span> ani</span><br></pre></td></tr></table></figure></li><li><p>아까 데이터를 다시 넣어 애니메이션을 만듭니다.</p></li><li><p><b>서로를 지나쳐간 뒤에 속도가 줄어드는 모습</b>이 관찰됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ani = gen_animation([P1, P2], [P1_pos, P2_pos], ts, <span class="string">&quot;position in xy coordinate&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="1_gravity_05.gif"><br></p></li></ul><h1 id="4-고정된-물체와-움직이는-물체"><a href="#4-고정된-물체와-움직이는-물체" class="headerlink" title="4. 고정된 물체와 움직이는 물체"></a>4. 고정된 물체와 움직이는 물체</h1><h2 id="4-1-N개의-물체-사이-만유인력"><a href="#4-1-N개의-물체-사이-만유인력" class="headerlink" title="4.1. N개의 물체 사이 만유인력"></a>4.1. N개의 물체 사이 만유인력</h2><ul><li>이제 우리는 만유인력을 계산하고 그릴 수 있습니다.</li><li>N개의 물체를 그리는 함수를 만들었으니, <b>N개의 물체 사이 힘을 계산하는 함수</b>도 만듭시다.</li><li>2중 for loop을 사용해서 모든 입자간의 인력을 계산하여 총 합을 구합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_force</span>(<span class="params">Ps, k=<span class="number">10</span>, iter_max=<span class="number">150</span></span>):</span></span><br><span class="line">    Ps_pos = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> Ps:</span><br><span class="line">        Ps_pos.append([])</span><br><span class="line"></span><br><span class="line">    ts = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iter_max):</span><br><span class="line">        <span class="comment"># time update</span></span><br><span class="line">        ts.append(i*dt)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># position update</span></span><br><span class="line">        <span class="keyword">for</span> P, P_pos <span class="keyword">in</span> <span class="built_in">zip</span>(Ps, Ps_pos):</span><br><span class="line">            P_pos.append(P.pos)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># calculate force</span></span><br><span class="line">        P_splits = [[P, <span class="built_in">list</span>(<span class="built_in">set</span>(Ps) - <span class="built_in">set</span>([P]))] <span class="keyword">for</span> P <span class="keyword">in</span> Ps]</span><br><span class="line">        <span class="keyword">for</span> j, (P_self, P_others) <span class="keyword">in</span> <span class="built_in">enumerate</span>(P_splits):</span><br><span class="line">            P_self_force = np.array([<span class="number">0.0</span>, <span class="number">0.0</span>])</span><br><span class="line">            <span class="keyword">for</span> P_other <span class="keyword">in</span> P_others:</span><br><span class="line">                P_self_force += calc_force(P_self, P_other, k=k)</span><br><span class="line">            <span class="comment"># update force</span></span><br><span class="line">            P_self.update(P_self_force)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ps, Ps_pos, ts</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-2-고정된-물체와-던져진-물체"><a href="#4-2-고정된-물체와-던져진-물체" class="headerlink" title="4.2. 고정된 물체와 던져진 물체"></a>4.2. 고정된 물체와 던져진 물체</h2><ul><li><p>1번 물체 P1은 원점 [0,0]에 고정하고</p></li><li><p>2번 물체 P2는 [0, 0.7]에서 $-x$방향으로 던집니다.</p></li><li><p><b>P2의 속도에 따른 궤적 변화</b>를 살펴봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 물체 정의</span></span><br><span class="line">P1_mass, P2_mass = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">P1_pos, P2_pos = [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0.7</span>]</span><br><span class="line">P1_v, P2_v = [<span class="number">0</span>, <span class="number">0</span>], [-<span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line">P1_fix, P2_fix = <span class="literal">True</span>, <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">P1 = Particle(P1_mass, P1_pos, P1_v, P1_fix)</span><br><span class="line">P2 = Particle(P2_mass, P2_pos, P2_v, P2_fix)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 만유인력 계산, 시각화</span></span><br><span class="line">Ps = [P1, P2]</span><br><span class="line">Ps, Ps_pos, ts = run_force(Ps, k=<span class="number">10</span>, iter_max=<span class="number">150</span>)</span><br><span class="line">ani = gen_animation(Ps, Ps_pos, ts, <span class="string">&quot;position in xy coordinate&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="1_gravity_06.gif"><br></p></li><li><p><b>SF영화에서 많이 본 듯한 모습</b>이 관찰됩니다.</p></li><li><p>중앙의 P1을 축으로 빙 돌아 자신이 온 방향으로 나갑니다.</p></li></ul><ul><li>이번엔 P2를 조금 빠르게 던집니다.</li><li>나머진 가만히 두고 position 초기화, velocity 재설정만 추가합니다.</li><li>만유인력과 원심력이 같아지는 속도에서는 물체가 지표면에서 추락하지 않고 궤도를 그립니다.</li><li>우리가 사용한 질량 등을 넣으면 다음과 같이 정리됩니다.</li></ul><p>$$ v = \sqrt{\frac{km_1}{r}} = 3.8 [\textrm{m}/\textrm{s}]$$</p><ul><li><p>이를 <b>제1 우주 속도</b>라고 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 시작점과 속도 재설정</span></span><br><span class="line">P1_pos, P2_pos = [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0.7</span>]</span><br><span class="line">P1_v, P2_v = [<span class="number">0</span>, <span class="number">0</span>], [-<span class="number">3.8</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">P1 = Particle(P1_mass, P1_pos, P1_v, P1_fix)</span><br><span class="line">P2 = Particle(P2_mass, P2_pos, P2_v, P2_fix)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 만유인력 계산, 시각화</span></span><br><span class="line">Ps = [P1, P2]</span><br><span class="line">Ps, Ps_pos, ts = run_force(Ps, k=<span class="number">10</span>, iter_max=<span class="number">150</span>)</span><br><span class="line">ani = gen_animation(Ps, Ps_pos, ts, <span class="string">&quot;position in xy coordinate&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="1_gravity_07.gif"><br></p></li><li><p>쪼개진 시간과 유효숫자 등의 차이로 원궤도에서는 다소 어긋났습니다.</p></li><li><p>하지만 <b>전반적으로 원을 그리며 제 자리로 옵니다.</b></p></li></ul><ul><li><b>더 빠르면?</b> 말할 것도 없습니다.</li><li>도망가 버립니다.</li><li>속도를 $5 [\textrm{m}/\textrm{s}]$로 빠르게 했을 때 그림입니다.<br><br><img src="1_gravity_08.gif"><br></li></ul><h1 id="5-마이너스-질량"><a href="#5-마이너스-질량" class="headerlink" title="5. 마이너스 질량"></a>5. 마이너스 질량</h1><ul><li><p>실제로는 불가능하지만 코드에는 마이너스 질량을 넣을 수 있습니다.</p></li><li><p><b>10배 무거운 마이너스 질량의 벽</b>을 뚫을 수 있나 봅시다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">P0_mass, P1_mass, P2_mass, P3_mass, P4_mass = <span class="number">1</span>, -<span class="number">10</span>, -<span class="number">10</span>, -<span class="number">10</span>, -<span class="number">10</span></span><br><span class="line">P0_pos, P1_pos, P2_pos, P3_pos, P4_pos = [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0.7</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0.7</span>], [-<span class="number">0.7</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">0.7</span>]</span><br><span class="line">P0_v, P1_v, P2_v, P3_v, P4_v = [<span class="number">3</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">P0_fix, P1_fix, P2_fix, P3_fix, P4_fix = <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">P0 = Particle(P0_mass, P0_pos, P0_v, P0_fix)</span><br><span class="line">P1 = Particle(P1_mass, P1_pos, P1_v, P1_fix)</span><br><span class="line">P2 = Particle(P2_mass, P2_pos, P2_v, P2_fix)</span><br><span class="line">P3 = Particle(P3_mass, P3_pos, P3_v, P3_fix)</span><br><span class="line">P4 = Particle(P4_mass, P4_pos, P4_v, P4_fix)</span><br><span class="line"></span><br><span class="line">Ps = [P0, P1, P2, P3, P4]</span><br><span class="line">Ps, Ps_pos, ts = run_force(Ps, k=<span class="number">10</span>, iter_max=<span class="number">50</span>)</span><br><span class="line">ani = gen_animation(Ps, Ps_pos, ts, <span class="string">&quot;position in xy coordinate&quot;</span>, legend=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="1_gravity_09.gif"><br></p></li><li><p>$(3, 1) [\textrm{m}/\textrm{s}]$로는 부족합니다. 못 나갑니다.</p></li><li><p>$(5, 2) [\textrm{m}/\textrm{s}]$는 어떨까요?<br><br><img src="1_gravity_10.gif"><br></p></li><li><p>몸부림 끝에 탈출에 성공합니다.</p></li></ul><h1 id="6-정전기력"><a href="#6-정전기력" class="headerlink" title="6. 정전기력"></a>6. 정전기력</h1><ul><li>만유인력 방정식은 <b>정전기력<code>electrostatic force</code>과 매우 비슷합니다.</b></li><li>전하 $q_1$과 $q_2$를 가진 전하 두 개가 거리 $r$만큼 멀리 있다면 이들 사이에는 아래 힘이 작용합니다.</li></ul><p>$$F = k\frac{q_1 q_2}{r^2}$$</p><ul><li><p>상수 $k$는 $8.99 \times 10^9 [N \cdot m^2 \cdot C^{-2}]$ 입니다.</p></li><li><p>일반적으로 만유인력보다 훨씬 강하기 때문에 우리 일상에서 자주 볼 수 있습니다.<br><br><img src="1_gravity_12.gif" alt="전설이 되어버린 일렉트릭 정화: EXID"><br></p></li><li><p>정전기력은 부호가 다르면 끌어당기고 부호가 같면 밀칩니다.</p></li><li><p>위에서 마이너스 질량을 사용한 예시는 같은 부호의 정전기력 시각화로 볼 수도 있습니다.</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Physics/">Physics</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/numpy/">numpy</category>
      
      
    </item>
    
    <item>
      <title>colorsys - Conversions between Color Systems</title>
      <link>https://jehyunlee.github.io/2022/01/04/Python-DS-95-tiger/</link>
      <guid>https://jehyunlee.github.io/2022/01/04/Python-DS-95-tiger/</guid>
      <pubDate>Mon, 03 Jan 2022 22:25:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;이미지를 처리하는 파이썬 라이브러리는 많습니다.&lt;/li&gt;
&lt;li&gt;가장 잘 알려진 opencv와 pillow를 비롯해서 matplotlib도 이미지 처리를 합니다.&lt;/li&gt;
&lt;li&gt;colorsys라는 파이썬 기본 라이브러리가 있습니다.&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>이미지를 처리하는 파이썬 라이브러리는 많습니다.</li><li>가장 잘 알려진 opencv와 pillow를 비롯해서 matplotlib도 이미지 처리를 합니다.</li><li>colorsys라는 파이썬 기본 라이브러리가 있습니다.</li><li>색 공간을 변환하는 라이브러리인데, 이것만 잘 써도 할 수 있는 게 많습니다.</li></ul><h1 id="1-예제-이미지"><a href="#1-예제-이미지" class="headerlink" title="1. 예제 이미지"></a>1. 예제 이미지</h1><blockquote><p><a href="https://commons.wikimedia.org/wiki/File:Siberischer_tiger_de_edit02.jpg">wikimedia commons: Siberischer tiger de dedit02.jpg</a></p></blockquote><ul><li>예제로 사용할 이미지를 가져옵니다.</li><li>호랑이 해이니 호랑이 사진을 사용해 보겠습니다.</li><li>저작권 걱정이 없는 <a href="https://commons.wikimedia.org/wiki/File:Siberischer_tiger_de_edit02.jpg">wikimedia</a>에서 사진을 내려받아 <code>tiger.jpg</code>라고 저장합니다.</li></ul><p><img src="tiger_8.png"><br></p><h1 id="2-Python에서-읽기"><a href="#2-Python에서-읽기" class="headerlink" title="2. Python에서 읽기"></a>2. Python에서 읽기</h1><ul><li><p>먼저 기본 라이브러리를 부르고</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure></li><li><p>이미지를 불러옵니다.</p></li><li><p><code>plt.imread()</code>명령으로 읽은 이미지는 numpy array로 저장됩니다.</p></li><li><p><code>.shape</code>으로 dimension을 확인하면 1200 x 1600 x 3입니다.</p></li><li><p>세로 1200, 가로 1600의 3차원(RGB) 이미지입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img_org = plt.imread(<span class="string">&quot;tiger.jpg&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(img_org.shape)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">8</span>, <span class="number">6</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.imshow(img_org)</span><br><span class="line">ax.set_xticks([])</span><br><span class="line">ax.set_yticks([])</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1200, 1600, 3)</span><br></pre></td></tr></table></figure><p><img src="tiger_1.png"><br></p></li></ul><h1 id="3-CIELab-color-space"><a href="#3-CIELab-color-space" class="headerlink" title="3. CIELab color space"></a>3. CIELab color space</h1><blockquote><p><a href="https://colorspacious.readthedocs.io/en/latest/">colorspacious</a><br><a href="https://jehyunlee.github.io/2021/03/22/Python-DS-63-mpl_colors_qualitative/">Pega Devlog: 색의 속성에 대한 단어들</a></p></blockquote><ul><li><p>사람이 인지하는 밝은 정도, 즉 <b>휘도(luminance)</b>를 파악합니다.</p></li><li><p>그림을 구성하는 RGB를 [colorspacious] 라이브러리의 <code>cspace_converter</code>를 사용해 <b>CIELab 색공간으로 변환</b>합니다.</p></li><li><p>CIELab 색공간의 첫번째 채널이 <b>$L^*$</b>, 즉 휘도입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># convert to CIELab</span></span><br><span class="line"><span class="keyword">from</span> colorspacious <span class="keyword">import</span> cspace_converter</span><br><span class="line"></span><br><span class="line">img_lab = cspace_converter(<span class="string">&quot;sRGB1&quot;</span>, <span class="string">&quot;CAM02-UCS&quot;</span>)(img_org/<span class="number">255</span>)</span><br><span class="line"><span class="built_in">print</span>(img_lab.shape)</span><br><span class="line">img_L = img_lab[:,:,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">8</span>, <span class="number">6</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.imshow(img_L, cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">ax.set_xticks([])</span><br><span class="line">ax.set_yticks([])</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1200, 1600, 3)</span><br></pre></td></tr></table></figure><p><img src="tiger_2.png"><br></p></li><li><p>흑백 사진으로 변환되었습니다.</p></li><li><p>여기 보이는 회색조가 우리 눈이 느끼는 밝기입니다.</p></li></ul><h1 id="4-HLS-color-space"><a href="#4-HLS-color-space" class="headerlink" title="4. HLS color space"></a>4. HLS color space</h1><blockquote><p><a href="https://en.wikipedia.org/wiki/HSL_and_HSV">wikipedia: HSL and HSV</a><br><a href="https://docs.python.org/3/library/colorsys.html">python colorsys</a></p></blockquote><ul><li><p>HSV (hue, saturation, value) 색공간과 더불어 HSL, 또는 HLS 색 공간이 사용됩니다.</p></li><li><p>색상(hue)과 명도(lightness), 채도(saturation)를 따로 조정할 수 있다는 장점이 있습니다.<br><br><img src="tiger_9.png"><br></p></li><li><p>python에 기본으로 내장된 <b><code>colorsys</code> 라이브러리는 색 공간 변환에 충실합니다.</b></p></li><li><p>RGB, YIQ, HLS, HSV 공간을 오가는 기능을 간단하게 제공합니다.</p></li><li><p>호랑이 이미지를 HLS 공간으로 바꾸어 hue, lightness, saturation 분포를 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> colorsys</span><br><span class="line"></span><br><span class="line">img_hls = np.array([colorsys.rgb_to_hls(*c) <span class="keyword">for</span> c <span class="keyword">in</span> (img_org/<span class="number">255</span>).reshape((<span class="number">1600</span>*<span class="number">1200</span>, <span class="number">3</span>))]).T</span><br><span class="line"><span class="built_in">print</span>(img_hls.shape)</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">8</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, (title, ax) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>([<span class="string">&quot;hue&quot;</span>, <span class="string">&quot;lightness&quot;</span>, <span class="string">&quot;saturation&quot;</span>], axs)):</span><br><span class="line">    sns.histplot(img_hls[i], kde=<span class="literal">True</span>, bins=np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">21</span>), ax=ax)</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;xx-large&quot;</span>, pad=<span class="number">8</span>)</span><br></pre></td></tr></table></figure><p><img src="tiger_3.png"><br></p></li><li><p>lightness를 보면 어두운 부분이 많은 것 같고,</p></li><li><p>saturation을 보면 원색에 가까운 비중이 상당히 높습니다.</p></li><li><p><b>hue가 좀 독특한데, 왼쪽에 몰려 있습니다.</b></p></li><li><p>잘못 처리한 것이 아닌지, hue의 숫자가 의미하는 색을 출력합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hue check</span></span><br><span class="line">hues = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">21</span>)[:<span class="number">20</span>]</span><br><span class="line">rgbs = <span class="built_in">list</span>(<span class="built_in">map</span>(colorsys.hls_to_rgb, *np.array([[h, <span class="number">0.5</span>, <span class="number">1</span>] <span class="keyword">for</span> h <span class="keyword">in</span> hues]).T))</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(ncols=<span class="number">10</span>, nrows=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> ax, rgb, hue <span class="keyword">in</span> <span class="built_in">zip</span>(axes.ravel(), rgbs, hues):</span><br><span class="line">    ax.set_facecolor(rgb)</span><br><span class="line">    ax.set_xticks([])</span><br><span class="line">    ax.set_yticks([])</span><br><span class="line">    ax.set_xlabel(<span class="string">f&quot;<span class="subst">&#123;hue:<span class="number">.2</span>f&#125;</span>&quot;</span>, fontsize=<span class="string">&quot;x-large&quot;</span>, labelpad=<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p><img src="tiger_4.png"><br></p></li><li><p>히스토그램에서 hue가 몰려 있는 0.25 아래 부분은 빨강, 주황, 노랑, 연두입니다.</p></li><li><p><b>호랑이와 들판을 이루고 있는 색</b>입니다. 그럴 만 하네요. 정상입니다. :)</p></li><li><p>호랑이 그림에서 hue, lightness, saturation이 어떻게 분포하고 있는지를 봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">8</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, (title, ax) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>([<span class="string">&quot;hue&quot;</span>, <span class="string">&quot;lightness&quot;</span>, <span class="string">&quot;saturation&quot;</span>], axs)):</span><br><span class="line">    vmax = <span class="number">0.3</span> <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    im = ax.imshow(img_hls[i].reshape(<span class="number">1200</span>, <span class="number">1600</span>), cmap=<span class="string">&quot;rainbow&quot;</span>, vmin=<span class="number">0</span>, vmax=vmax)</span><br><span class="line">    plt.colorbar(im, orientation=<span class="string">&quot;horizontal&quot;</span>, ax=ax)</span><br><span class="line">    ax.set_xticks([])</span><br><span class="line">    ax.set_yticks([])</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;xx-large&quot;</span>, pad=<span class="number">8</span>)</span><br></pre></td></tr></table></figure><p><img src="tiger_5.png"><br></p></li><li><p>hue만 범위를 0-0.3으로 그리고 나머지는 0-1로 그렸습니다.</p></li><li><p>범위를 쉽게 파악하고자 의도적으로 rainbow colormap을 사용했습니다.</p></li><li><p><b>배경과 호랑이는 hue와 lightness로 쉽게 구분됩니다.</b></p></li><li><p>배경 일부에 호랑이와 hue가 같은 구간이 있는데 <b>lightness를 섞으면 같이 구분할 수 있습니다.</b></p></li></ul><ul><li><p>lightness threshold를 0.4로 고정하고</p></li><li><p>hue threshold (<code>h_th</code>)를 0.1~0.3으로 바꾸면서 호랑이 선택 범위를 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tiger selection</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"></span><br><span class="line">img_hls_tiger = deepcopy(img_hls)</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">8</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">h_ths = [<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>]</span><br><span class="line"><span class="keyword">for</span> h_th, ax <span class="keyword">in</span> <span class="built_in">zip</span>(h_ths, axs):</span><br><span class="line">    chk_tiger = np.where((img_hls[<span class="number">0</span>] &lt; h_th) &amp; (img_hls[<span class="number">1</span>] &gt; <span class="number">0.4</span>), <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    ax.imshow(chk_tiger.reshape(<span class="number">1200</span>, <span class="number">1600</span>), cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    ax.set_xticks([])</span><br><span class="line">    ax.set_yticks([])</span><br><span class="line">    ax.set_title(<span class="string">f&quot;<span class="subst">&#123;h_th&#125;</span>&quot;</span>, fontsize=<span class="string">&quot;xx-large&quot;</span>, pad=<span class="number">8</span>)</span><br></pre></td></tr></table></figure><p><img src="tiger_6.png"><br></p></li><li><p>다른 데는 비슷한데 <b>호랑이 이마와 왼쪽 뺨</b>에서 차이가 보입니다.</p></li><li><p>0.3으로 올리면 얼굴은 검은 줄무늬를 제외하고 거의 선택이 되고 배경으로 넘어가지 않네요.</p></li><li><p>hue threshold를 0.3으로 설정합니다.</p></li></ul><ul><li><p>1600 x 1200개의 픽셀 중 hue는 0.3 미만, lightness는 0.4 초과하는 범위를 잡습니다.</p></li><li><p>호랑이 얼굴의 명도는 올리고 채도는 낮춰서 <b>하얀 장로 호랑이 느낌</b>이 들도록 바꿉니다.</p></li><li><p><del>사실 올해가 검은 호랑이 해라 검게 하고 싶었는데 어떻게 해도 안예쁘더군요.</del></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">idx_tiger = np.where((img_hls[<span class="number">0</span>] &lt; <span class="number">0.3</span>) &amp; (img_hls[<span class="number">1</span>] &gt; <span class="number">0.4</span>))[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> idx_tiger:</span><br><span class="line">    img_hls_tiger[<span class="number">1</span>, idx] = <span class="built_in">min</span>(img_hls_tiger[<span class="number">1</span>, idx]+<span class="number">0.6</span>, <span class="number">1</span>)</span><br><span class="line">    img_hls_tiger[<span class="number">2</span>, idx] = <span class="built_in">max</span>(img_hls_tiger[<span class="number">2</span>, idx]-<span class="number">0.6</span>, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">img_rgb_tiger = np.array([colorsys.hls_to_rgb(*c) <span class="keyword">for</span> c <span class="keyword">in</span> img_hls_tiger.T])</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">8</span>, <span class="number">6</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.imshow(img_rgb_tiger.reshape(<span class="number">1200</span>, <span class="number">1600</span>, <span class="number">3</span>))</span><br><span class="line">ax.set_xticks([])</span><br><span class="line">ax.set_yticks([])</span><br></pre></td></tr></table></figure><p><img src="tiger_7.png"><br></p></li><li><p><b>호랑이 해 모두 새해 복 많이 받으시기 바랍니다.</b></p></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/colorsys/">colorsys</category>
      
      
    </item>
    
    <item>
      <title>Sci Vis) 2. In a Far Distance Galaxy</title>
      <link>https://jehyunlee.github.io/2021/12/28/Python-DS-94-rougier02/</link>
      <guid>https://jehyunlee.github.io/2021/12/28/Python-DS-94-rougier02/</guid>
      <pubDate>Mon, 27 Dec 2021 15:50:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Scientific Visualization: Python + Matplotlib&lt;/strong&gt; 책에는 최고 수준의 시각화 기술이 담겼습니다.&lt;/li&gt;
&lt;li&gt;높은 수준에 비해 설명이 다소 짧아 초심자에게 어려워 보였습</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><strong>Scientific Visualization: Python + Matplotlib</strong> 책에는 최고 수준의 시각화 기술이 담겼습니다.</li><li>높은 수준에 비해 설명이 다소 짧아 초심자에게 어려워 보였습니다.</li><li>저자인 Nicolas P. Rougier 박사님의 허가 하에 일부를 해설합니다.</li><li>이 시리즈는 해외 독자를 위해 영어를 회색 상자 안에 병기합니다.</li></ul><style>    .en {        background-color: #EEEEEE;        padding: 0px;        margin-top: 0px;        margin-bottom: 0px;        margin-left: 0px;        margin-right: 0px;    }</style><div class="en" bgcolor="#AAAAAA"><ul><li> <b>Scientific Visualization: Python + Matplotlib</b> contains cutting-edge visualization skills and examples of Matplotlib and Python.  </li><li> Despite its high quality content, relatively short explanations in the book may prevent the readers from fully grasping all of its contents.  </li><li> With the permission of the author, Dr. Nicolas P. Rougier, I'll try to help the beginners understand the more complex concepts within the book by providing explanations and commentary where needed.  </li><li> This series will be posted in <b>English</b> as well as Korean, for international readers.  </ul></div><p><blockquote><p><b>영어 감수:</b> <a href="mailto:jsleeindex@gmail.com">EY한영회계법인 이지수 시니어</a></p></blockquote><blockquote><p><a href="https://github.com/rougier/scientific-visualization-book">Scientific Visualization: Python + Matplotlib</a><br><a href="https://github.com/rougier">github: Nicolas P. Rougier</a></p></blockquote><p><img src="92_rougier01_13.png"><br></p><h1 id="1-Star-Wars-text"><a href="#1-Star-Wars-text" class="headerlink" title="1. Star Wars text"></a>1. Star Wars text</h1><blockquote><p><a href="https://github.com/jehyunlee/scientific-visualization-book/blob/master/code/typography/text-starwars.py">text-starwars.py</a></p></blockquote><p><img src="text-starwars_org.png"><br></p><ul><li>이번에 살펴볼 그림은 영화 스타워즈의 도입부처럼 글자들이 무한 원점을 향해 소멸하는 모양입니다.</li><li>글자의 크기 뿐 아니라 색상도 점차 희미해져가는 모습입니다.</li></ul><div class="en"><ul><li> This time we are going to plot lines of texts vanishing towards the point at infinity, like the lines of texts at the beginning of a Star Wars movie.</li><li> Not only does the size of the font diminish as the text approach infinity, the opacity of the text also diminish. </li></ul></div><h1 id="2-prerequisites"><a href="#2-prerequisites" class="headerlink" title="2. prerequisites"></a>2. prerequisites</h1><ul><li>이번 코드는 딱 하나의 기술만 알면 됩니다.</li><li>바로 <b>어떻게 글자의 형상을 변환하는지</b>입니다.</li><li>원본 코드를 이해하기 위해서 예제 코드를 먼저 봅시다.</li></ul><div class="en"><ul><li> We have only one skill to learn:</li><li> <b>How to transform shapes of the letters.</b></li><li> Let's take a look at the example codes to understand the Nicolas's.</li></ul></div><h2 id="2-1-import-libraries"><a href="#2-1-import-libraries" class="headerlink" title="2.1. import libraries"></a>2.1. import libraries</h2><ul><li>기본 라이브러리와 함께 <b>텍스트 형상을 제어할 라이브러리</b>를 불러옵니다.</li><li>text를 Path로 만드는 <code>TextPath</code>와 Path를 Patch로 만드는 <code>PathPatch</code>를 불러옵니다.</li></ul><div class="en"><ul><li> We need to import <b>text shape control libraries</b> as well as basic ones.</li><li> <b><code>TextPath</code></b> to convert text to Path object and <b><code>PathPatch</code></b> to turn Path into Patch is imported.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.textpath <span class="keyword">import</span> TextPath</span><br><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> PathPatch</span><br></pre></td></tr></table></figure><h2 id="2-2-prepare-an-example-text"><a href="#2-2-prepare-an-example-text" class="headerlink" title="2.2. prepare an example text"></a>2.2. prepare an example text</h2><ul><li>복잡한 수식으로 이루어진 예제 텍스트를 준비합니다.</li><li>Matplotlib의 <code>Axes.text()</code>명령으로 한 가운데 큼지막하게 넣습니다.</li></ul><div class="en"><ul><li> An example text made up of complicated mathematics equation is prepared.</li><li> The text is placed at the center of the figure with <code>Axes.text()</code> function of Matplotlib.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">eq = <span class="string">r&quot;$\left[\sum_&#123;n=1&#125;^\infty\frac&#123;-e^&#123;i\pi&#125;&#125;&#123;2^n&#125;\right]$!&quot;</span></span><br><span class="line">txt = ax.text(<span class="number">0.5</span>, <span class="number">0.5</span>, eq, ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>, fontsize=<span class="number">90</span>)</span><br></pre></td></tr></table></figure><p><img src="94_rougier02_01.png"><br></p><h2 id="2-3-Text-to-Path"><a href="#2-3-Text-to-Path" class="headerlink" title="2.3. Text to Path"></a>2.3. <code>Text</code> to <code>Path</code></h2><blockquote><p><a href="https://matplotlib.org/stable/api/textpath_api.html">matplotlib.textpath</a></p></blockquote><ul><li><code>Text</code> 객체를 <code>Path</code>객체로 바꿉니다.</li><li><code>Path</code> 객체는 일종의 다각형으로 <b>꼭지점(vertices)과 모서리(edges), 그리고 구성 형상(codes)으로 이루어져 있습니다</b>.</li><li><code>Path</code> 객체로 변환하고 vertices를 추출해서 좌표를 확인합니다.</li></ul><div class="en"><ul><li> It's time to convert <code>Text</code> object into <code>Path</code> object.</li><li> <code>Path</code> object is consisted of <b>points(vertices), lines(edges) and shapes(codes)</b>.</li><li> We will be able to check the coordinates of the vertices after conversion by extracting vertices.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eq_path = TextPath((<span class="number">0</span>, <span class="number">0</span>), eq, size=<span class="number">90</span>) </span><br><span class="line"><span class="comment"># (0, 0)  : no offset</span></span><br><span class="line"><span class="comment"># size=90 : font size in points</span></span><br><span class="line"></span><br><span class="line">V = eq_path.vertices</span><br><span class="line">xmin, xmax = V[:, <span class="number">0</span>].<span class="built_in">min</span>(), V[:, <span class="number">0</span>].<span class="built_in">max</span>()</span><br><span class="line">ymin, ymax = V[:, <span class="number">1</span>].<span class="built_in">min</span>(), V[:, <span class="number">1</span>].<span class="built_in">max</span>()</span><br><span class="line"><span class="built_in">print</span>(xmin, xmax, ymin, ymax)</span><br></pre></td></tr></table></figure><ul><li><p>실행 결과:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.5 420.0953767578125 -86.41370141006101 140.0</span><br></pre></td></tr></table></figure></li><li><p>위 그림 눈금에 보이는 것보다 크기가 훨씬 큽니다.</p></li><li><p>화면의 눈금은 아무렇게나 적힌 값이고 치수는 points 단위입니다.</p></li></ul><div class="en"><ul><li> It is much larger than values seen from the ticks.</li><li> It should be noted that the tick labels are arbitrary, and the unit of dimension is points.</li></ul></div><ul><li>이제 <code>Path</code> 객체를 그림에 붙여봅니다.</li><li><code>Path</code>를 <code>Patch</code>로 변환한 뒤 <code>Axes.add_artist()</code>명령으로 붙입니다.</li><li>추출한 vertices를 함께 그려 비교합니다.</li></ul><div class="en"><ul><li> Let's put <code>Path</code> object onto the Axes.</li><li> <code>Path</code> is going to be turned into <code>Patch</code> object, then pasted by <code>Axes.add_artist()</code> function.</li><li> The vertices extracted from the <code>TextPath</code> will be drawn together for comparison.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.transforms <span class="keyword">import</span> IdentityTransform</span><br><span class="line"></span><br><span class="line"><span class="comment"># patch creation. IndentityTransform() does nothing.</span></span><br><span class="line">eq_patch = PathPatch(eq_path, ec=<span class="string">&quot;k&quot;</span>, fc=<span class="string">&quot;w&quot;</span>, transform=IdentityTransform())</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># text (original)</span></span><br><span class="line">ax.text(<span class="number">0.5</span>, <span class="number">0.5</span>, eq, ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>, fontsize=<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># vertices from Path</span></span><br><span class="line">ax.plot(V[:, <span class="number">0</span>], V[:, <span class="number">1</span>], <span class="string">&quot;o-&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Patch</span></span><br><span class="line">ax.add_artist(eq_patch)</span><br></pre></td></tr></table></figure><p><img src="94_rougier02_02.png"><br></p><ul><li><b>뭔가 잘못된 것 같아 보입니다.</b></li><li>Text, Path vertices와 Patch의 크기와 위치가 맞지 않습니다.</li><li>각기 원점의 정의와 화면에 표시되는 크기 기준이 달라서 그렇습니다.</li></ul><div class="en"><ul><li> <b>It seems something went wrong.</b></li><li> The sizes and locations of the Text, Path vertices and Patch are not coincide.</li><li> It's because of the mismatches of definitions on origin and size.</li></ul></div><h2 id="2-4-apply-offset"><a href="#2-4-apply-offset" class="headerlink" title="2.4. apply offset"></a>2.4. apply offset</h2><ul><li>위치 조정을 위해 <b>offset 설정</b>이 필요하며 다음과 같은 과정을 거쳐 진행됩니다.<br> ① <code>AuxTransformBox</code> 객체 생성<br> ② <code>AuxTransformBox</code>에 <code>Patch</code> 추가<br> ③ <b>offset</b> 지정<br> ④ <code>Matplotlib.Axes</code>에 <code>add_artist()</code>로 <code>AuxTransformBox</code> 객체 추가</li></ul><div class="en"><ul><li> <b>Setting offset</b> is required to adjust position.</li>   ① create <code>AuxTransformBox</code> object<br>   ② Add <code>Patch</code> on <code>AuxTransformBox</code><br>   ③ apply <b>offset</b><br>   ④ Add <code>AuxTransformBox</code> on <code>Matplotlib.Axes</code> using <code>add_artist()</code><br></ul></div><ul><li>③ 없이 Patch를 붙이면 다음과 같습니다.</li></ul><div class="en"><ul><li> At first, let's take a look without ③ applying offset.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.offsetbox <span class="keyword">import</span> AuxTransformBox</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">eq_patch = PathPatch(eq_path, ec=<span class="string">&quot;k&quot;</span>, fc=<span class="string">&quot;w&quot;</span>, transform=IdentityTransform())</span><br><span class="line">offsetbox = AuxTransformBox(IdentityTransform()) <span class="comment"># ①</span></span><br><span class="line">offsetbox.add_artist(eq_patch) <span class="comment"># ②</span></span><br><span class="line"></span><br><span class="line">ax.add_artist(offsetbox) <span class="comment"># ④</span></span><br></pre></td></tr></table></figure><p><img src="94_rougier02_04.png"><br></p><ul><li>이제 ③ <b>offset</b> 지정을 추가합니다.</li></ul><div class="en"><ul><li> Now we apply offset(③).</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">eq_patch = PathPatch(eq_path, ec=<span class="string">&quot;k&quot;</span>, fc=<span class="string">&quot;w&quot;</span>, transform=IdentityTransform())</span><br><span class="line">offsetbox = AuxTransformBox(IdentityTransform()) <span class="comment"># ①</span></span><br><span class="line">offsetbox.add_artist(eq_patch) <span class="comment"># ②</span></span><br><span class="line">offsetbox.set_offset((<span class="number">120</span>, <span class="number">48</span>)) <span class="comment"># ③</span></span><br><span class="line">ax.add_artist(offsetbox) <span class="comment"># ④</span></span><br></pre></td></tr></table></figure><p><img src="94_rougier02_05.png"><br></p><h2 id="2-5-manipulate-coordinates"><a href="#2-5-manipulate-coordinates" class="headerlink" title="2.5. manipulate coordinates"></a>2.5. manipulate coordinates</h2><ul><li>방금 우리는 <code>set_offset()</code>을 이용해서 Patch의 위치를 변경했습니다.</li><li>하지만 vertex 좌표를 조정하고 Path를 재구성해서 위치를 변경할 수도 있습니다.</li></ul><div class="en"><ul><li> We modified position of the Patch by applying <code>set_offset()</code>.</li><li> But there is another way - manipulating vertices coordinates and reconstructing Path.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.path <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="comment"># path from text</span></span><br><span class="line">eq_path = TextPath((<span class="number">0.5</span>, <span class="number">0.5</span>), eq, size=<span class="number">90</span>)</span><br><span class="line">Vc = eq_path.vertices  <span class="comment"># vertices coordinates</span></span><br><span class="line">codes = eq_path.codes  <span class="comment"># codes: Path parts</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ranges of coordinates</span></span><br><span class="line">xcmin, xcmax = Vc[:, <span class="number">0</span>].<span class="built_in">min</span>(), Vc[:, <span class="number">0</span>].<span class="built_in">max</span>()</span><br><span class="line">ycmin, ycmax = Vc[:, <span class="number">1</span>].<span class="built_in">min</span>(), Vc[:, <span class="number">1</span>].<span class="built_in">max</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;before centering: [<span class="subst">&#123;xcmin:<span class="number">.2</span>f&#125;</span>, <span class="subst">&#123;xcmax:<span class="number">.2</span>f&#125;</span>, <span class="subst">&#123;ycmin:<span class="number">.2</span>f&#125;</span>, <span class="subst">&#123;ycmax:<span class="number">.2</span>f&#125;</span>]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># X centering</span></span><br><span class="line">Px = Vc[:, <span class="number">0</span>] - (xcmax + xcmin)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Y centering</span></span><br><span class="line">Py = Vc[:, <span class="number">1</span>] - (ycmax + ycmin)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># coordinates check: centering</span></span><br><span class="line">xpmin, xpmax = Px.<span class="built_in">min</span>(), Px.<span class="built_in">max</span>()</span><br><span class="line">ypmin, ypmax = Py.<span class="built_in">min</span>(), Py.<span class="built_in">max</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;after centering: [<span class="subst">&#123;xpmin:<span class="number">.2</span>f&#125;</span>, <span class="subst">&#123;xpmax:<span class="number">.2</span>f&#125;</span>, <span class="subst">&#123;ypmin:<span class="number">.2</span>f&#125;</span>, <span class="subst">&#123;ypmax:<span class="number">.2</span>f&#125;</span>]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create new Path</span></span><br><span class="line">path_new = Path(np.array([Px, Py]).T, codes=codes)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># convert Path to Patch</span></span><br><span class="line">patch = PathPatch(path_new, facecolor=<span class="string">&quot;w&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, zorder=<span class="number">2</span>) </span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">ax.plot(Px, Py, <span class="string">&quot;o-&quot;</span>)  <span class="comment"># Path vetices</span></span><br><span class="line">ax.add_artist(patch)   <span class="comment"># Patch from Path</span></span><br><span class="line">ax.set_xlim((-<span class="number">250</span>, <span class="number">250</span>))</span><br><span class="line">ax.set_ylim((-<span class="number">150</span>, <span class="number">150</span>))</span><br></pre></td></tr></table></figure><ul><li>실행 결과: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before centering: [0.50, 420.10, -86.41, 140.00]</span><br><span class="line">after centering: [-209.80, 209.80, -113.21, 113.21]</span><br></pre></td></tr></table></figure></li></ul><p><img src="94_rougier02_06.png"><br></p><ul><li>Path vertices와 재구성한 Path를 겹쳐 그려보니 정확히 일치합니다. </li><li>Patch에는 없는 선이 Path vertices에 보입니다. <b>개별 다각형에 대한 정보가 없어서 그렇습니다.</b> </li><li><b><code>Path()</code> 실행시 <b><code>codes</code></b>를 추가함으로써 구분</b>되었습니다.</li></ul><div class="en"><ul><li> Reconstructed Path and Path vertices are prefectly overlapped.</li><li> Some lines that weren’t visible on the Patch can be seen on Path vertices. This is due to the <b>absence of information on individual polygons.</b></li><li> <codes>codes</codes> <b>is applied to distinguish each polygon parts.</b></li></ul></div><ul><li><b>꼭지점 좌표를 수정해서 Path를 재구성할 수 있다</b>는 말은 여러 <b>변형을 가할 수 있다</b>는 뜻입니다.</li><li>아래 부분은 늘리고 위 부분을 좁히면 그림을 앞으로 기울인 듯한 효과가 납니다.</li><li><b>스타워즈 오프닝</b>이 이렇게 시작합니다.</li></ul><div class="en"><ul><li> Since <b>the Path can be reconstructed after vertex coordinates modification, other transformation can be applied.</b></li><li> If we stretch the bottom and shrink the top, the figure seems to be tilted forward.</li><li> This is how the <b>Star Wars intro crawl</b> starts.</li></ul></div>&#123;% youtube tGsKzZtRwxw %&#125;<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># path from text</span></span><br><span class="line">eq_path = TextPath((<span class="number">0.5</span>, <span class="number">0.5</span>), eq, size=<span class="number">90</span>)</span><br><span class="line">Vc = eq_path.vertices</span><br><span class="line">codes = eq_path.codes</span><br><span class="line">xcmin, xcmax = Vc[:, <span class="number">0</span>].<span class="built_in">min</span>(), Vc[:, <span class="number">0</span>].<span class="built_in">max</span>()</span><br><span class="line">ycmin, ycmax = Vc[:, <span class="number">1</span>].<span class="built_in">min</span>(), Vc[:, <span class="number">1</span>].<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># X centering</span></span><br><span class="line">Px = Vc[:, <span class="number">0</span>] - (xcmax + xcmin)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Y centering</span></span><br><span class="line">Py = Vc[:, <span class="number">1</span>] - (ycmax + ycmin)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># X rescaling &lt;-- here!</span></span><br><span class="line">xfactor = <span class="number">0.002</span></span><br><span class="line">Px *= <span class="number">1</span> - (Py * xfactor)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create new Path</span></span><br><span class="line">path_new = Path(np.array([Px, Py]).T, codes=codes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># convert Path to Patch</span></span><br><span class="line">patch = PathPatch(path_new, facecolor=<span class="string">&quot;w&quot;</span>, ec=<span class="string">&quot;k&quot;</span>) </span><br></pre></td></tr></table></figure><p><img src="94_rougier02_07.png"><br></p><ul><li><b>이미지를 몇 겹으로 쌓은 효과</b>를 낼 수도 있습니다.</li><li>Patch를 y 축 방향으로 조금씩 움직이면서 색을 점점 밝게 입혀 보겠습니다.</li></ul><div class="en"><ul><li> We can <b>stack different layers of images on top of each other.</b></li><li> We will move The Patch along the y-axis a little bit, and apply brighter colors on it as it moves.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">ax.set_xlim((-<span class="number">250</span>, <span class="number">250</span>))</span><br><span class="line">ax.set_ylim((-<span class="number">150</span>, <span class="number">180</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    eq_path = TextPath((<span class="number">0.5</span>, <span class="number">0.5</span>), eq, size=<span class="number">90</span>)</span><br><span class="line">    Vc = eq_path.vertices</span><br><span class="line">    codes = eq_path.codes</span><br><span class="line">    xcmin, xcmax = Vc[:, <span class="number">0</span>].<span class="built_in">min</span>(), Vc[:, <span class="number">0</span>].<span class="built_in">max</span>()</span><br><span class="line">    ycmin, ycmax = Vc[:, <span class="number">1</span>].<span class="built_in">min</span>(), Vc[:, <span class="number">1</span>].<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># X centering</span></span><br><span class="line">    Px = Vc[:, <span class="number">0</span>] - (xcmax + xcmin)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Y centering</span></span><br><span class="line">    Py = Vc[:, <span class="number">1</span>] - (ycmax + ycmin)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># X rescaling</span></span><br><span class="line">    xfactor = <span class="number">0.002</span></span><br><span class="line">    Px *= <span class="number">1</span> - (Py * xfactor)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Y shifting</span></span><br><span class="line">    Py += i * <span class="number">15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># create new Path</span></span><br><span class="line">    path_new = Path(np.array([Px, Py]).T, codes=codes)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># convert Path to Patch</span></span><br><span class="line">    patch = PathPatch(path_new, facecolor=<span class="string">f&quot;<span class="subst">&#123;i*<span class="number">0.4</span>&#125;</span>&quot;</span>, ec=<span class="string">&quot;k&quot;</span>) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ax.add_artist(patch)</span><br></pre></td></tr></table></figure><p><img src="94_rougier02_08.png"><br></p><h1 id="3-In-Far-Distance-Galaxy"><a href="#3-In-Far-Distance-Galaxy" class="headerlink" title="3. In Far Distance Galaxy"></a>3. In Far Distance Galaxy</h1><ul><li><b>Zen of Python을 스타워즈 스타일로 변형합니다.</b></li><li>한 줄씩 읽어서 Patch로 바꾸어 점점 흐리게 기울인 듯 변형합니다.</li></ul><div class="en"><ul><li> <b>Zen of Python is going to be transformed to Star-Wars crawl style.</b></li><li> It will be transformed to tilted Patch line by line, and dimmed gradually.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">text = [</span><br><span class="line">    <span class="string">&quot;Beautiful is better than ugly.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Explicit is better than implicit.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Simple is better than complex.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Complex is better than complicated.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Flat is better than nested.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sparse is better than dense.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Readability counts.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># enlarged by 2 x 2</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">8.5</span>, <span class="number">4</span>))</span><br><span class="line">ax = fig.add_axes([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], aspect=<span class="number">1</span>, xlim=[-<span class="number">40</span>, <span class="number">40</span>], ylim=[-<span class="number">1</span>, <span class="number">25</span>])</span><br><span class="line">ax.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line"></span><br><span class="line">y = <span class="number">0</span></span><br><span class="line">size = <span class="number">6</span></span><br><span class="line">xfactor = <span class="number">1</span> / <span class="number">50</span></span><br><span class="line">yfactor = <span class="number">1</span> / <span class="number">120</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(text[::-<span class="number">1</span>]):</span><br><span class="line">    path = TextPath((<span class="number">0</span>, <span class="number">0</span>), line, size=size)</span><br><span class="line">    V = path.vertices</span><br><span class="line">    codes = path.codes</span><br><span class="line">    xmin, xmax = V[:, <span class="number">0</span>].<span class="built_in">min</span>(), V[:, <span class="number">0</span>].<span class="built_in">max</span>()</span><br><span class="line">    ymin, ymax = V[:, <span class="number">1</span>].<span class="built_in">min</span>(), V[:, <span class="number">1</span>].<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># X centering</span></span><br><span class="line">    Px = V[:, <span class="number">0</span>] - (xmax + xmin) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Moving whole text at y coordinates</span></span><br><span class="line">    Py = V[:, <span class="number">1</span>] + y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Rescaling along y</span></span><br><span class="line">    Py *= <span class="number">1</span> - (Py * yfactor)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Rescaling along x</span></span><br><span class="line">    Px *= <span class="number">1</span> - (Py * xfactor)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Update interlines</span></span><br><span class="line">    y += size * (<span class="number">1</span> - ymin * yfactor)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># create new Path</span></span><br><span class="line">    path_new = Path(np.array([Px, Py]).T, codes=codes)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># convert Path to Patch</span></span><br><span class="line">    patch = PathPatch(path_new, facecolor=<span class="string">&quot;%.2f&quot;</span> % (i / <span class="number">10</span>), linewidth=<span class="number">0</span>, clip_on=<span class="literal">False</span>)</span><br><span class="line">    ax.add_artist(patch)</span><br></pre></td></tr></table></figure><p><img src="text-starwars_org.png"><br></p><ul><li><b>스타워즈 원본에 가깝도록 색을 노랗게 바꿔보겠습니다.</b></li><li>Nicolas의 원본처럼 맨 앞을 선명하게 하고 뒤로 갈수록 어둡게 만듭니다.</li><li>Python의 기본 라이브러리인 <code>colorsys</code>를 사용해 RGB 색공간을 HLS 공간으로 바꾸어 밝기만 조정합니다.</li></ul><div class="en"><ul><li> <b>Additionally, we are going to paint it in yellow color, closer to the original Star Wars intro.</b></li><li> Nicolas's idea - clear in front and dim far above - will be maintained.</li><li> <code>colorsys</code>, a default library of Python will be used to control lightness in HLS space, instaed of RGB color space.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">8.5</span>, <span class="number">4</span>), facecolor=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">ax = fig.add_axes([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], aspect=<span class="number">1</span>, xlim=[-<span class="number">40</span>, <span class="number">40</span>], ylim=[-<span class="number">1</span>, <span class="number">25</span>])</span><br><span class="line">ax.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line"></span><br><span class="line">y = <span class="number">0</span></span><br><span class="line">size = <span class="number">6</span></span><br><span class="line">xfactor = <span class="number">1</span> / <span class="number">50</span></span><br><span class="line">yfactor = <span class="number">1</span> / <span class="number">120</span></span><br><span class="line">c = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>) <span class="comment"># yellow</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(text[::-<span class="number">1</span>]):</span><br><span class="line">    path = TextPath((<span class="number">0</span>, <span class="number">0</span>), line, size=size)</span><br><span class="line">    V = path.vertices</span><br><span class="line">    codes = path.codes</span><br><span class="line">    xmin, xmax = V[:, <span class="number">0</span>].<span class="built_in">min</span>(), V[:, <span class="number">0</span>].<span class="built_in">max</span>()</span><br><span class="line">    ymin, ymax = V[:, <span class="number">1</span>].<span class="built_in">min</span>(), V[:, <span class="number">1</span>].<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># New Path</span></span><br><span class="line">    <span class="comment"># X centering</span></span><br><span class="line">    Px = V[:, <span class="number">0</span>] - (xmax + xmin) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Moving whole text at y coordinates</span></span><br><span class="line">    Py = V[:, <span class="number">1</span>] + y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Rescaling along y</span></span><br><span class="line">    Py *= <span class="number">1</span> - (Py * yfactor)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Rescaling along x</span></span><br><span class="line">    Px *= <span class="number">1</span> - (Py * xfactor)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Update interlines</span></span><br><span class="line">    y += size * (<span class="number">1</span> - ymin * yfactor)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># new path</span></span><br><span class="line">    path_new = Path(np.array([Px, Py]).T, codes=codes)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Display</span></span><br><span class="line">    hls = <span class="built_in">list</span>(colorsys.rgb_to_hls(*c))</span><br><span class="line">    hls[<span class="number">1</span>] -= <span class="number">0.07</span> * i</span><br><span class="line">    rgb = colorsys.hls_to_rgb(*hls)</span><br><span class="line">    patch = PathPatch(path_new, facecolor=rgb, edgecolor=<span class="string">&quot;none&quot;</span>, linewidth=<span class="number">0</span>, clip_on=<span class="literal">False</span>)</span><br><span class="line">    ax.add_artist(patch)</span><br></pre></td></tr></table></figure><p><img src="text-starwars.png"><br></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/Nicolas-P-Rougier/">Nicolas P. Rougier</category>
      
      
    </item>
    
    <item>
      <title>사례로 들여다보는 데이터 시각화 Q&amp;A</title>
      <link>https://jehyunlee.github.io/2021/12/04/Python-DS-93-nia_datavis_qa/</link>
      <guid>https://jehyunlee.github.io/2021/12/04/Python-DS-93-nia_datavis_qa/</guid>
      <pubDate>Sat, 04 Dec 2021 06:07:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;한국지능정보사회진흥원(NIA)&lt;/b&gt;에서 또 다른 기회를 주셨습니다. (21.12.03.)&lt;ul&gt;
&lt;li&gt;데이터 시각화를 잘 하는 방법에 대한 개괄적인 발표였습니다.&lt;/li&gt;
&lt;li&gt;발표를 녹화하지 않아 동영상은 제공이 불가합니다</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b>한국지능정보사회진흥원(NIA)</b>에서 또 다른 기회를 주셨습니다. (21.12.03.)<ul><li>데이터 시각화를 잘 하는 방법에 대한 개괄적인 발표였습니다.</li><li>발표를 녹화하지 않아 동영상은 제공이 불가합니다.</li><li><b><a href="https://kr.object.gov-ncloudstorage.com/open-bucket/boards/1638517226205-211203_NIA_%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EA%B0%81%ED%99%94-%EC%95%95%EC%B6%95%EB%90%A8.pdf">발표자료는 여기에서 다운로드</a></b>받으실 수 있습니다.</li></ul></li></ul><ul><li><b>사전 질문이 매우 많았습니다.</b><ul><li>NIA에서 일차 추려주셨는데도 수를 세어보니 <b>56개</b>더군요.</li><li>많은 분들의 관심에 감사드리며, 한편으로는 제한된 시간에 답을 충분히 드리지 못해 죄송스럽습니다.</li></ul></li></ul><ul><li>아쉬운 대로 본 블로그를 통해 답변을 정리해 드립니다.<ul><li>제가 모든 것을 충분히 알지 못합니다. 이 점을 감안하시고 제 의견이라고 들어주시면 감사하겠습니다.</li><li>본 글을 작성하면서 <b>질문을 다시 분류하고 묶었으며 받은 질문 텍스트를 그대로 사용했습니다.</b></li><li><b>비슷한 질문도 많이 주셨습니다.</b> 이들은 한 번에 묶어서 답변을 드립니다.</li></ul></li></ul><p><img src="93_nia_datavis_qa.png"><br></p><style>    .en {        background-color: #EEEEFF;        padding: 0px;        margin-top: 0px;        margin-bottom: 0px;        margin-left: 0px;        margin-right: 0px;    }</style><h3 id="1-사례"><a href="#1-사례" class="headerlink" title="1. 사례"></a>1. 사례</h3><li><b>1-1. 에기원에서 진행하는 데이터분석 사례 중 인사이트 도출이 잘 된 예시들은?</b></li> <li><b>1-2. Output을 활용, 분석하여 outcome을 도출, 계량 할 수 있을지?</b></li>    <details><summary>답변 보기/접기</summary><div class="en"><li>데이터 담당자로서 연구부서 분들의 데이터를 받아 시각화를 수행하며 협업을 진행하고 있습니다.</li><li>그러나 아쉽게도 많은 해당 업무들이 논문 출판 및 실증 진행중이라 먼저 보여드리기 어렵습니다.</li><li>모쪼록 양해 바랍니다.</li><p><li><a href="https://www.nature.com/articles/s41598-021-83315-9.pdf"><b>논문으로 출판된 사례</b></a>를 하나 말씀드리면 다음과 같습니다.</li>  <li>3가지 인자가 2가지 특성에 미치는 영향을 살펴본 연구입니다.</li> <li>EDA나 머신러닝 모델링 만으로는 설명이 충분치 않던 상황입니다.</li><li><b>1,000개의 시뮬레이션 데이터</b>로 믿을 만한 머신러닝 모델을 만든 후, 이 모델을 이용해 <b>42,875개</b>의 가상 데이터를 만든 뒤 <b>이들의 연관성을 3D contour 두 개</b>로 시각화하여 간결하게 설명하고 리뷰어를 이해시킬 수 있었습니다.</li><img src="93_nia_datavis_qa_14.png"></div></details><p><li><b>1-3. CFD 해석 데이타도 데이터 시각화 가능한가요?</b></li>    <details><summary>답변 보기/접기</summary><div class="en"><li>네. 가능합니다.</li><li>일반적으로 CFD(유체열역학) 해석 데이터라고 하면 온도나 유량, 유속을 컬러맵으로 나타낸 것을 말합니다.</li><li>CFD라는 단어를 사용하신 시점에서 이 것을 모르고 계시지는 않을 것 같습니다.</li><img src="https://scanscot.com/web/wp-content/uploads/2014/09/Abaqus_cfd_valve_anim.gif"><p><li>저희 연구원 내 다른 부서 분께서 모델별로 도출된 CFD 데이터를 추출하여 추가 해석을 수행한 경험이 있습니다.</li><li>실증 진행중이라 보안상 자세한 내용은 말씀드리지 못했지만 관련 기술은 아래 글에 정리했습니다.</li>  <li><a href="https://jehyunlee.github.io/2021/07/10/Python-DS-80-mpl3d2/"><b>2가지 인자를 바꾸어가며 최적의 조건을 찾고 확인하는 연구였습니다 (링크)</b></a></li> <img src="https://jehyunlee.github.io/2021/07/10/Python-DS-80-mpl3d2/mpl3d_scatter.gif"></div></details><p><li><b>1-4. 한국에서의 성공사례</b></li> <li><b>1-5. 데이터 시각화의 중요성이 드러나는 사례가 궁금합니다</b></li> <li><b>1-6. 데이터 시각화를 통해 문제를 해결하신 사례가 궁금합니다</b></li> <li><b>1-7. 독창적인 생각을 통해서 데이터 분석을 성공적으로 해낸 사례</b></li> <li><b>1-8. 가장 임팩트 있었던 시각화 사례가 있으셨을까요?</b></li>     <details><summary>답변 보기/접기</summary><div class="en""><li>데이터 분석에 기반하여 기사를 쓰고 사회에 영향력을 미치는 분들이 있습니다. </li> <li>데이터 저널리즘이라고 하고, 많은 분들이 좋은 기사를 쓰고 계십니다: <a href="http://datajournalismawards.kr/">http://datajournalismawards.kr/</a></li><li>데이터의 효과적 전달과 올바른 쓰임을 가장 진지하게 고민하시는 분들이시니 둘러보기를 권합니다.</li>  </div><img src="93_nia_datavis_qa_01.png"></details><p><h3 id="2-고충"><a href="#2-고충" class="headerlink" title="2. 고충"></a>2. 고충</h3><li><b>2-1. 데이터 시각화는 의사결정을 도와주는 도구로 알고 있습니다. 아무리 좋은 도구를 가지고 있어도(데이터를 잘 뽑고 시각화를 잘해도) 본래의 목적인 의사결정이 그에 못지 않게 이상한 방향(이럴거면 뭐하러 시각화했나 하는 방향)으로 이뤄지는 경우도 있나요? 있다면 빈도와 사례도 부탁 드립니다.</b></li>     <details><summary>답변 보기/접기</summary><div class="en""><li>흔히 <b>답정너</b>라고 말하는 상황에 답답함을 느끼시는 듯 합니다.</li><li>데이터 분석을 하는 분이라면 상당히 자주 겪는 일이 아닌가 싶네요. </li><li>회사마다 사람마다 다르겠지만 제 경험상 50% 정도 저런 일이 있는 것 같습니다.</li>    <li>하지만 의견이 받아들여지지 않았다고 상대방이 답을 정해놨다고 보기는 힘들 수 있습니다.</li>  <li>분석에 동원된 <b>데이터는 전체 업무의 일부</b>이기 때문에 더 넓게 봐야 하는 의사결정자는 다른 결정을 내릴 수 있습니다.</li>  <li>예를 들어, 데이터에 드러나지 않는 <b>가격 협상력</b>을 유지하기 위해 당장 약간의 손해를 안고 더 비싼 업체를 일부 활용하기도 합니다.</li>  <li>데이터 분석 결과 기각 사유가 더 넓은 시야와 고민이 아니라면 더 좋은 곳을 찾아 떠날 수도 있을 것입니다.</li>  </div><img src="93_nia_datavis_qa_02.png"></details><p> <h3 id="3-시각화-공부와-교육"><a href="#3-시각화-공부와-교육" class="headerlink" title="3. 시각화 공부와 교육"></a>3. 시각화 공부와 교육</h3><li><b>3-1. 적절한 시각화를 선택하는 기준은 무엇인가요?</b></li><li><b>3-2. 데이터시각화 입문하기위한 좋은 학습콘텐츠나 서적 부탁드립니다!</b></li><li><b>3-3. 데이터 시각화는 어떤점을 표현해야 시각회에 극대화를 시킬 수 있을까요?</b></li><li><b>3-4. 데이터 시각화를 구현할 때 고려사항을 설명해주셨으면 좋겠습니다.</b></li>    <li><b>3-5. 많은 시각화 예시와 시각화시 어떤 관점으로 보는게 가장 효율적이고 데이터에 대한 특성별 시각화 방안이 궁금합니다.</b></li><li><b>3-6. 시각화의 구조를 심리학적 상황별 기능별로 한분야를 택해서 설명 부탁드립니다.</b></li><li><b>3-7. 데이터 시각화를 잘 구성하기 위한 머리속의 구상(예., 데이터 구성/논리적 연결/표현 등은 어떻게?)은 어떤 자세(설계, 개발)를 가져야 할까요?</b></li><li><b>3-8. 데이터 시각화를 활용하기 위해 일반인이 길러야 할 능력은 무엇일까? (ex 엑셀)</b></li><li><b>3-9. 데이터 종류에 따른 시각화 방법이 다른데 주로 어떤 기준으로 결정하나요?</b></li><li><b>3-10. 요새 각 카테고리별 비중에 대한 데이터를 많이 다루면서 항상 고민이 되는 부분이 있는데요, 보통 비율을 표현할때 파이차트 혹은 누적막대차트를 사용하게 됩니다. 단순히 한 시점에 대해서는 저렇게 표현해도 괜찮지만 여러 시점을 비교하며 보여줄때 어떤 그래프가 효율적일까요?</b></li>    <details><summary>답변 보기/접기</summary><div class="en""><li>20C 말 인지 심리학을 비롯한 인지 과학은 많은 사실을 알아냈습니다.</li>  <li>기하학적 요소와 주관적 아름다움이 인지에 미치는 영향을 알게 되었으므로 이 지식을 활용하는 것이 합리적입니다.</li>  <li>예를 들어, <b>시간에 따른 비율 변화</b>는 stream graph나 ridge plot을 쓰시면 좋습니다</li><p><li>클라우스 윌케의 <a href="http://www.yes24.com/Product/Goods/87631760"><b>데이터 시각화 교과서</b></a>를 추천드리며,</li>  <li>더 깊은 이해를 위해서는 <a href="http://www.yes24.com/Product/Goods/19013968"><b>데이터 시각화, 인지과학을 만나다</b></a>를 권합니다.</li>  <li>두 번째 책은 아쉽지만 절판되었습니다. 도서관 등을 찾아보시면 좋겠습니다.</li>  <li>Python의 가장 대표적인 시각화 라이브러리는 Matplotlib인데, 이를 다루는 시중의 기술서는 아쉬운 점이 많습니다.</li><li>책 몇 권을 봤는데 <a href="https://matplotlib.org/stable/gallery/index.html"><b>공식 홈페이지 예제 (링크)</b></a>, 그 중에서도 초급 수준만을 번역해 놓은 수준이더군요.</li>  <li>차라리 그 돈은 다른 데 쓰고 공식 홈페이지를 보는 게 낫다는 생각이 들었습니다.</li>    </div><img src="93_nia_datavis_qa_03.png"><img src="93_nia_datavis_qa_04.png"><img src="93_nia_datavis_qa_05.png"><img src="93_nia_datavis_qa_12.png"><img src="93_nia_datavis_qa_10.png"></details><p> <li><b>3-11. 데이터 시각화를 잘 하기 위한 통찰력을 얻는 소스가 있으신가요?</b></li>    <li><b>3-12. 초보자가 데이터분석 공부하기 좋은 방법을 알려주세요.</b></li><li><b>3-13. 데이터 분석을 위한 기초 학습은 어떤 것부터 하면 좋을까요? </b></li><li><b>3-14. 다른 사람이 시각화 한 것을 많이 찾아보는 것도 도움이 될까요?</b></li><li><b>3-15. 쉽게 이해할수있는 시각화를 만들려면 ui/ux가 매우 중요한데, 시각화하는 사람은 이미 데이터에 대한 이해가 있기때문에 시각화자료를 볼 사람들에겐 여전히 어려운 시각화 자료를 만들 수 있다고 생각합니다. 시각화하실때 이러한 갭을 최소화하기위해서 어떻게 하시나요</b></li>    <details><summary>답변 보기/접기</summary><div class="en""><li>글을 잘 쓰려면 <b>많이 읽고(多讀), 많이 쓰고(多作), 많이 생각하라(多商量)</b>는 말이 있습니다.</li>  <li>시각화도, 그 무엇도 비슷하다고 생각합니다.</li><li>좋은 그림을 많이 보고, 많이 그려보고, 많이 생각하는 것이 처음이자 끝이 아닐까요?</li>    <p><li>다만 데이터 시각화를 잘 하겠다고 <b>데이터 시각화만 많이 보지는 않았으면</b> 좋겠습니다.</li>  <li>데이터 시각화는 회화, 영화 등 시각적 예술활동을 데이터에 적용한 것이니 시야를 넓히면 더 좋습니다.</li>  <li>고전미술, 웹툰, 영화 포스터, 광고 등 많은 작품에서 영감을 받으시기를 바랍니다.</li>  <li>코드가 손가락에 스며들도록 연습해야 하는 것은 말할 것도 없고,</li>  <li>키보드와 모니터를 치우고 백지와 펜을 들어 코드의 제약 없이 스케치하는 연습도 좋습니다.</li>  <li>생각은 혼자 하기보다는 동료나 대중의 반응을 보면서 feedback loop을 형성하시길 바랍니다.</li>  <li>주신 질문처럼 <b>분석가가 데이터에 너무 익숙해서 문제가 되기도 합니다</b>. 낯선 시각의 피드백이 필요합니다.</li>  </div><img src="93_nia_datavis_qa_06.png"></details><p> <li><b>3-16. 학생들에게 데이터시각화가 중요하다는 것을 알려줄만한 쉬운 사례가 있다면 소개부탁드립니다~</b></li>    <details><summary>답변 보기/접기</summary><div class="en""><li>나이팅게일의 rose chart와 hans rosling의 animated bubble chart가 대표적일 것입니다.</li>  <li>나이팅게일을 <b>백의의 천사</b>로만 알고 있다면 <a href="https://www.sedaily.com/NewsVIew/1OFW72CBYO"><b>망치로 창고 열쇠를 부순 백의의 전사 (링크)</b></a>라는 사실도 알려주면 어떨까요? <li><a href="https://en.wikipedia.org/wiki/Anscombe%27s_quartet"><b>Anscombe's quartet (링크)</b></a>이나 Autodesk의 <a href="https://www.autodesk.com/research/publications/same-stats-different-graphs"><b>datasaurus (링크)</b></a>도 자주 인용되지요 :)</li>  </div><img src="93_nia_datavis_qa_07.jpg"><img src="93_nia_datavis_qa_08.gif"><img src="93_nia_datavis_qa_09.gif"></details><p> <li><b>3-17. 학교에서 데이터 사례 수업을 하려고 하는데 쓸만한 데이터를 어디서 찾을 수 있을까요?(공공데이터 포털 말구요 ㅠㅠ!)</b></li>    <details><summary>답변 보기/접기</summary><div class="en""><li>제가 교육 현장을 질문자만큼 잘 몰라서 <b>서울고등학교 송석리 선생님</b>의 말씀을 전달해 드립니다.</li>  <li>선생님께서 한성과학고에 재직중이던 2019년 PyCon Korea에서 <a href="https://www.youtube.com/watch?v=9FCNiijm3Jc"><b>교육의 미래를 바꾸는 오늘의 파이써니스쿨 (링크)</b></a>이라는 발표를 하셨습니다.</li>  <li>학생들이 (과거의 저보다 훨씬) 열정적으로 참여한 모습을 보고 신기해서 <b>"과학고라고 해도 관심이 없는 학생도 있었을텐데 어떻게 저런 참여를 이끌었는지"</b>를 질문드렸습니다.</li>  <li>선생님의 대답은 <b>"학생들 본인들의 데이터로 수업을 했다. 자기 스스로에게는 누구나 관심이 있다."</b>였습니다.</li>  <li>생각해보니 저도 고등학교때 한 친구가 공학용 계산기로 자리 추첨 프로그램을 만들어서 매주 자리를 뽑은 기억이 있습니다.</li>  <li>본인의 일주일 짝과 자리가 결정되는 그 순간 저를 포함한 모두가 초인적인 집중력을 발휘했습니다. ^^;</li>  </div><img src="93_nia_datavis_qa_13.png"></details><p> <li><b>3-18. 쉽게따라하기 좋은 데이터 시각화 방법에 대해서 궁금합니다.</b></li><li><b>3-19. 파이썬 기반으로 여러 모델을 만들고 개발했지만.. 시각화는 거의 제대로 해본적이 없습니다. 사실 제게는 모델 만드는 것보다 파이썬으로 예쁘게 제대로 시각화하는게 더 어렵고 귀찮더라구요... 소요되는 시간이 더 많이 소요되고.. 피땀은 배신하지 않겠지만, 혹시 쉽게 파이썬 기반으로 시각화를 예쁘게 하는 쉬운 방법이 있는지.. 만약 없다면 혹시 쉽게 파이썬 기반 시각화 코딩을 익히는 방법이 있는지 궁금합니다.</b></li>    <details><summary>답변 보기/접기</summary><div class="en""><li>먼저 <b>쉽게</b>, <b>귀찮더라</b>라는 단어와 <b>좋은</b>, <b>예쁘게</b>라는 단어의 조합에 이의를 제기하고 싶습니다.</li>  <li><b>"베끼기 좋은 코드 알려주세요"</b>로 해석할 수도 있겠지만 설마 이건 아니라고 생각합니다. 검색하면 나오거든요.</li>  <li>분야를 막론하고 뭔가 잘 했다는 느낌을 받으셨다면 그건 창조자의 뼈를 깎는 노력이 배어 나왔기 때문입니다.</li>  <li>노력 없이 좋은 결과를 내는 천재들도 있습니다만 타고 나야 하니 본 질문이나 답변의 대상이 될 수 없겠죠.</li>  <li><b>쉽게 익히는 방법이 있을지도 모르겠지만 아쉽게도 저는 알지 못합니다.</b> 그냥 매일 조금씩이나마 꾸준히 하는 법 밖에는요.</li><p> <li><b>"그래서 넌 뭘 얼마나 열심히 했는데?"</b>라고 물어보신다면, <b>"내게 코딩 실력이 부족하구나."</b>를 느낀 2019년 여름 이후 일일 커밋을 하고 있습니다. 오늘(12/4)까지 757일째입니다.</li><li><b>1000일이 넘는 분들도 있습니다.</b> 스스로 아직 많이 부족하다고 느끼고 있고, 더 열심히 하려고 노력하고 있습니다.</li>  <li>따라하기 좋은 예제는 라이브러리 공식 홈페이지, Kaggle Notebook, 여러 블로그에서 찾을 수 있습니다.</li>  <li>목표를 세우셨다면 <b>그냥 묵묵히 정진하는 것</b>이 답입니다. 진심을 담아 응원하겠습니다. :)</li>  </div><img src="93_nia_datavis_qa_11.png"><img src="93_nia_datavis_qa_13.jpeg"></details><p> <h3 id="4-시각화-도구"><a href="#4-시각화-도구" class="headerlink" title="4. 시각화 도구"></a>4. 시각화 도구</h3><li><b>4-1. 다양한 데이터 작성 툴이 있습니다. 엑셀, R, 파이썬 등. 디자인 전공자들에게 추천하는 툴이 있으신가요?</b></li><li><b>4-2. 초보 및 전문가를 위한 데이터 시각화를 설계/개발하기 위한 요구사항은 어떻게 될까요? </b></li><li><b>4-3. 데이터 시각화에서 가장 많이 이용하는 툴은 어떤 것인가요?</b></li><li><b>4-4. 시각화를 어떤식으로 보여주실지는 모르겠지만, 시각화에 태블로 역량이 중요하다고 생각하시나요.</b></li><li><b>4-5. 평소에 시각화자료 올려주시는거 즐겨보고 있습니다. 요즘은 어떤 패키지가 유행인가요?</b></li><li><b>4-6. 사례에 사용하시는 기술들도 함께 나눠주세요!</b></li><li><b>4-7. 인터렉티브한 시각화를 위해서 가장 선호하는 방법은 무엇인가요?</b></li>    <details><summary>답변 보기/접기</summary><div class="en""><li>가장 좋은 도구는 본인이 속한 환경에 따라 달라진다고 생각합니다. </li>  <li>실시간으로 데이터를 받아 보여주는 대시보드를 만든다면 tableau, power BI 등이 유용하실 것이고</li>  <li>통계 문제를 많이 푼다면 R이, 머신러닝이나 다른 앱과 연동한다면 Python이 가장 좋을 겁니다.</li>  <li>코딩을 잘 모르는 분들을 상대해야 한다면 엑셀만한 게 없을지도 모릅니다.</li><p>  <li>저는 <b>python만 사용</b>합니다. 웹으로 deploy할 일이 없고 복잡한 수식을 풀 일이 종종 있기 때문입니다.</li>  <li>python 중에서도 <b>matplotlib을 포함한 관련 생태계</b>(seaborn, geopandas, sklearn-plot, yellowbrick)만 사용합니다.</li>  <li>제가 쓰는 라이브러리들이 다 matplotlib을 활용하고 있기 때문이고, interactive한 결과물을 만들 필요가 없기 때문입니다.</li>  <li>조만간 web deploy를 할 것 같습니다. 같은 이유로 plot.ly를 배울까 생각중입니다.</li><li>본인의 필요에 따라 배우고 활용하시는게 가장 좋지 않을까요? :)</li><p><li>유행 따라 주무기를 바꾸는 것을 선호하지 않습니다.</li><li>크리티컬한 문제가 없다면 <b>내 손에 스며든 도구가 최적의 도구</b>라고 생각합니다.</li><li>이 도구로 할 수 없는 일을 해야만 하면 기꺼이 최선을 다해 바꾸겠지만요.</li> </div></details><p> <h3 id="5-노하우"><a href="#5-노하우" class="headerlink" title="5. 노하우"></a>5. 노하우</h3><li><b>5-1. 시각화에서 가장 조심할점은 무엇인가요?</b></li>  <li><b>5-2. 데이터 시각화를 구현할 때 고려사항을 설명해주셨으면 좋겠습니다.</b></li>  <li><b>5-3. 데이터 시각화를 하는데 있어 가장 사람들이 실수하는 것이 무엇입니까.</b></li>  <li><b>5-4. 데이터를 시각화하면 데이터를 쉽게 이해하는데 많은 도움이 된다고 이해하고 있습니다만, 간혹 잘못된(?) 데이터 시각화는 자칫 데이터에 대한 잘못된 이해 또는 오해를 불러오기도 한다고 생각합니다, 이러한 오해의 요소가 있다면 데이터 시각화 과정에서 주의해야 할, 또는 피해야할 부분은 무엇일까요? 데이터 시각화의 휴먼에러(?)를 줄일 수 있는 방법에 대해서 알고 싶습니다 </b></li>    <details><summary>답변 보기/접기</summary><div class="en"><li>데이터 시각화는 분석가의 의지를 담아 데이터를 그림으로 표현하는 작업이라 생각합니다.</li>  <li><b>생각이 없어도 문제</b>가 되고,</li>  <li><b>생각이 너무 많아도 문제</b>가 되고,</li>  <li><b>생각이 잘못되면 당연히 문제</b>가 될 것입니다.</li><p><li>아무 생각이 없이 그림을 그리면 <b>메시지 전달력</b>이 떨어지기도 하고, <b>허위 상관</b>이 중요한 듯 그려집니다.</li>  <li>메시지를 전달하겠다고 힘을 주는 건 좋은데 <b>주관이나 주장이 fact를 가리면 곤란</b>합니다.</li>  <li>이런 일들은 gray zone에서 벌어지는 일이 많아서 <b>"이 선 넘어가면 나쁜 놈"</b>식의 말씀을 드리기는 참 어렵습니다.</li><p><li>일단 <b>사실에 근거해서</b>, <b>한 마디로 정리하라면 뭐라고 할까? 그게 그림에 보이나?</b>를 염두에 두고, <b>작업에 매몰되지 않도록 시차를 두기도 하고 산책도 하고 중간 중간 다른 이들에게 보이기도 하면</b> 좀 낫지 않을까 싶습니다.</li>  <img src="93_nia_datavis_qa_15.png"><p><li>가장 흔한 실수는 <b>하던 대로만, 배운 대로만 하는 관성</b>이 아닐까 생각합니다.</li><li>선배의 말을 경청하는 것과 선배의 말만 듣는 것은 완전 다릅니다.</li><li>단적인 예로 <b>학회장 포스터가 천편일률적입니다.</b> 자기 주장이나 발견을 더 잘 드러내고자 하면 저렇게는 안 만들 것 같습니다.</li></div><img src="93_nia_datavis_qa_17.png"></details><p> <li><b>5-5. 여러가지 시각화 방법중 데이터와 연계해서 빠르게 효과적인 시각화 방법을 찾는 노하우가 있을까요?</b></li><li><b>5-6. 데이터 시각화를 하다보면 시각화자체에 시간이 많이 소요됩니다. 데이터를 이해하고 인사이트를얻는데 시간을 더 투자하고 시각화자체는 효율적으로하는 방법이있을까요 </b></li><li><b>5-7. 데이터 시각화는 데이터를 보고 딱 떠오르는 것에 대해 시각화를 하는 건가요? 아니면 이런저런 시행착오를 통해 점진적으로 만드는 건가요</b></li><li><b>5-8. 현업에서 특별히 보고를 위한 플롯이 아니라면 최소의 템플릿이나 컨벤션이 있는지?</b></li><li><b>5-9. 데이터를 이용해서 기존의 방식처럼 일반적인 차트를 구성해서 보여주고 있는 경우 pandas등을 통해서 좀더 데이터를 다양하게 다루기 위해서 시도해보고 있습니다. 머신러닝, 딥러닝을 통해서 좀더 데이터를 다루고 싶은데 기준과 데이터의 접근법등이 뚜렷한 기준이 없기에 고민이 됩니다.</b></li>    <details><summary>답변 보기/접기</summary><div class="en"><li>빠르게 찾는 방법은 저도 알고 싶습니다. 시간이 많이 소요되거든요 ^^;</li>  <li>일단 데이터를 받으면 목적에 따라 scatter plot, bar plot, line plot 등을 그려봅니다.</li>  <li>분포 같은 통계적 양상이 중요한 경우에는 kde plot도 그려보고요.</li>  <li>인자가 좀 많은데 서로 연관성을 봐야 한다 싶으면 3D plot도 그립니다.</li>  <li>한 마디로, <b>할 수 있는 건 다 해 보느라 시간이 많이 갑니다.</b></li><p><li><b>시각화에 드는 시간을 줄이려고 노력을 합니다.</b></li>  <li>파워포인트 템플릿을 바꾸지 않습니다 - 하얀 백지만 씁니다. 전체 색조가 바뀌거나 크기가 바뀌면 다 바뀌거든요.</li>  <li>색을 고르는 데 시간을 들이지 않습니다 - 색을 이리 저리 바꾸다 보면 시간이 증발합니다.</li>  <li>코드를 짜기 전에 산책을 하거나 백지에 손으로 그립니다 - 최대한 생각을 미리 많이 하면 몸이 편해지더군요.</li>  <li><b>엄청난 시행착오를 전제하는 작업</b>이라 생각합니다.</li>  <li><b>경험</b>이 쌓이고 코딩 같은 <b>스킬</b>이 늘면 엉뚱한 짓에 소모되는 시간은 적을 것 같네요.</li></div></details><p> <li><b>5-10. 추천하는 보고서 양식(markdown, web 등)</b></li>    <details><summary>답변 보기/접기</summary><div class="en"><li><b>직장에서 정해주는 대로</b> 하는 주의입니다.</li>  <li>미생에도 장그래가 폴더 정리하는 에피소드가 나오듯, 조직에서는 전체의 흐름에 맞추는 게 더 낫습니다.</li><li>제 힘으로 어쩔 수 없는 일도 많아서 군말없이 문서는 hwp, 발표는 ppt를 사용하고 있습니다.</li>    </div></details><p> <li><b>5-11. 인공지능 모델을 구축하기에 앞서 EDA, 혹은 데이터 시각화를 통해 확인해야 할 부분들이 어떤 것이 있을지 궁금합니다</b></li><li><b>5-12. 데이터시각화를 활용하기 위해서 선형수학이라던가 누적분포함수 등 수학적 기본지식이 꼭 필요한가요? </b></li><li><b>5-13. 데이터 시각화라고 하면 시각화를 위한 데이터 전처리가 포함되나요?</b></li>    <details><summary>답변 보기/접기</summary><div class="en"><li><b>"EDA의 절반 이상은 시각화"</b>라는 말을 많이 듣고 저도 많이 합니다.</li>  <li>데이터 시각화를 통해 기본적으로 데이터의 분포 양상과 인자간 상관성을 확인합니다.</li>  <li>그러나 파생변수를 만들 때마다 이 파생변수에 대한 일이 생겨나고, PCA같은 차원 축소나 클러스터링이 더해지기도 합니다.</li>  <li>일이 많기도 하지만 <b>내가 뭘 하는지</b> 정확히 파악하지 않으면 엉뚱한 판단을 하기 너무 좋습니다.</li>  <li>이를 예방할 수 있는 유일한 백신은 <b>탄탄한 수학적 지식</b>이라고 생각합니다.</li>  <li>통계 전문가가 될 필요까지는 없겠지만 <b>내가 뭘 하는지 알 만큼은 알아야 합니다.</b></li><li><a href="https://www.sjsu.edu/faculty/guangliang.chen/Math250.html">San Jose State University에는 이런 강좌도 있습니다.</a></li></div><img src="93_nia_datavis_qa_16.png"></details><p> <h3 id="6-기타"><a href="#6-기타" class="headerlink" title="6. 기타"></a>6. 기타</h3><ul><li>어딘가에 속하기 어려운 질문들에 대해 최대한 단답형으로 답을 달았습니다.</li><li>답을 드리기 어려운 질문들(ex. 인공태양에 관심이 있습니다)은 생략했음을 양해해 주시기 바랍니다.</li></ul><li><b>6-1. 취준생 포토폴리오에 꼭 넣었으면 하는 시각화 방법은 무엇이 있을까요?</b></li>    <details><summary>답변 보기/접기</summary><div class="en"><li>뻔한 답이지만, <b>회사가 원하는 기술</b>을 넣으셔야 하지 않을까요?</li>  <li>데이터 분석의 정확성이 중요한 회사라면 현란한 tableau보다 정확한 정보를 잡아내는 능력이 필요하겠지만,</li><li>대중을 상대로 한 대시보드 제작사라면 주의를 끌 수 있는 디자인 능력이 중요할 겁니다.</li><li>뭐가 되었듯 <b>경쟁자들을 압도할만한 레벨</b>을 담으실 수 있기를 바랍니다.</li></div></details><p> <li><b>6-2. 온라인에서 내려받은 실시간 데이터를 처리하여 다시 온라인 게시하고 싶습니다. 온라인 데이터 송수신 경험이 없는데 따라하기 좋은 길라잡이 좀 추천 부탁드립니다.</b></li>    <details><summary>답변 보기/접기</summary><div class="en"><li>Open API를 써서 데이터를 다운받아 본 적은 있지만 결과물을 웹으로는 게시해 본 적이 없습니다.</li>  <li>구글링해보니 글이 많이 나오네요. <a href="https://velog.io/@1yangsh/python-Open-API-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0">이런 글들 (링크)</a>을 참고하시면 좋을 듯 합니다.</li></div></details><p> <li><b>6-3. 데이터 분석 직무로 취업을 준비하는 학생입니다. 데이터 분석 공부를 할수록 도메인의 지식의 중요성을 느끼고 있는데 여러가지 도메인 지식을 쌓기 위한 노력이 궁금합니다.</b></li>    <details><summary>답변 보기/접기</summary><div class="en"><li>한 분야의 지식(도메인 지식)을 익히는 데는 적잖은 노력과 비용이 소요됩니다.</li>  <li>괜히 대학에서 4년간 가르치는 걸로 모자라 대학원까지 가기도 하는 게 아니거든요.</li>  <li>데이터 관점에서 도메인을 접근해서 진짜로 깊이 알기는 굉장히 어렵다고 생각합니다.</li>  <li><b>핵심 개념</b>중심으로 파악하면 일단 큰 실수는 면할 수 있다고 생각합니다.</li>  <li>스스로의 노력으로 개념과 흐름을 얼추 파악한 뒤에 인맥을 최대한으로 활용해 <b>도메인 전문가</b>를 찾고 잦은 대화를 통해 갭을 줄여 나가는 것이 가장 좋을 것이라 생각합니다.</li>  </div></details><p> <li><b>6-4. 시각화로 돈 버는 방법은 어떤 것들이 있는지</b></li>    <details><summary>답변 보기/접기</summary><div class="en"><li><a href="https://www.indeed.com/career-advice/finding-a-job/data-visualization-jobs-with-salary"><b>10 visualization career paths</b></a>에 따르면 대략 10가지 정도의 길이 있습니다.</li>  <li>미국 기준이긴 하지만 연소득도 33,583 USD부터 124,518 USD까지 있네요.</li><li><a href="https://www.glassdoor.com/Salaries/data-visualizer-salary-SRCH_KO0,15.htm"><b>glassdoor</b></a>에 따르면 84,775 USD가 평균이라고 합니다.</li><li>데이터 시각화 직군이 특별히 있는 경우는 모르겠지만 그렇지 않으면 속한 회사의 급여 체계에 따르는 것이 보통이 아닐까 합니다.</li><li>하지만 최근 등장한 NFT 시장을 이용하면 <b>data art</b>로 소득을 올릴 수도 있습니다. <a href="https://towardsdatascience.com/creating-generative-art-nfts-from-genomic-data-16a48ae4df99">(관련 기사 링크)</a></li><li>아래 그림은 R로 그려진 data art입니다 <a href="https://generative.substack.com/p/generative-art-and-r">(원문)</a></li></div><img src="https://cdn.substack.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff4605b82-0c61-48f2-85f1-8345fd5312dc_900x894.png"></details><p> <h3 id="7-마치며"><a href="#7-마치며" class="headerlink" title="7. 마치며"></a>7. 마치며</h3><ul><li>총 50개가 넘는 질문에 제 나름의 최선을 다해 답을 드렸습니다.</li><li>발표시간의 제약으로 드리지 못한 답이 조금이나마 전달되었기를 바랍니다.</li></ul><ul><li>처음에 말씀드렸듯 저도 이 답이 100점이라고는 생각하지 않습니다.</li><li>하지만 이 시점의 제가 드릴 수 있는 최선이라고 생각합니다.</li><li>여러분 스스로 더 좋은 답을 찾으시길 바랍니다.</li></ul><p><img src="datavis.png" alt="NIA 공지"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/NIA/">NIA</category>
      
      
    </item>
    
    <item>
      <title>Sci Vis) 1. Rotated histogram</title>
      <link>https://jehyunlee.github.io/2021/12/02/Python-DS-92-rougier01/</link>
      <guid>https://jehyunlee.github.io/2021/12/02/Python-DS-92-rougier01/</guid>
      <pubDate>Thu, 02 Dec 2021 00:50:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Scientific Visualization: Python + Matplotlib&lt;/strong&gt; 책에는 최고 수준의 시각화 기술이 담겼습니다.&lt;/li&gt;
&lt;li&gt;높은 수준에 비해 설명이 다소 짧아 초심자에게 어려워 보였습</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><strong>Scientific Visualization: Python + Matplotlib</strong> 책에는 최고 수준의 시각화 기술이 담겼습니다.</li><li>높은 수준에 비해 설명이 다소 짧아 초심자에게 어려워 보였습니다.</li><li>저자인 Nicolas P. Rougier 박사님의 허가 하에 일부를 해설합니다.</li><li>이 시리즈는 해외 독자를 위해 영어를 회색 상자 안에 병기합니다.</li></ul><style>    .en {        background-color: #EEEEEE;        padding: 0px;        margin-top: 0px;        margin-bottom: 0px;        margin-left: 0px;        margin-right: 0px;    }</style><div class="en" bgcolor="#AAAAAA"><ul><li> <b>Scientific Visualization: Python + Matplotlib</b> contains cutting-edge visualization skills and examples of Matplotlib and Python.  </li><li> Despite its high quality content, relatively short explanations in the book may prevent the readers from fully grasping all of its contents.  </li><li> With the permission of the author, Dr. Nicolas P. Rougier, I'll try to help the beginners understand the more complex concepts within the book by providing explanations and commentary where needed.  </li><li> This series will be posted in <b>English</b> as well as Korean, for international readers.  </ul></div><p><blockquote><p><b>영어 감수:</b> <a href="mailto:jsleeindex@gmail.com">EY한영회계법인 이지수 시니어</a></p></blockquote><blockquote><p><a href="https://github.com/rougier/scientific-visualization-book">Scientific Visualization: Python + Matplotlib</a><br><a href="https://github.com/rougier">github: Nicolas P. Rougier</a></p></blockquote><p><img src="92_rougier01_13.png"><br></p><h1 id="1-Rotated-Histogram"><a href="#1-Rotated-Histogram" class="headerlink" title="1. Rotated Histogram"></a>1. Rotated Histogram</h1><blockquote><p><a href="https://github.com/rougier/scientific-visualization-book/blob/master/code/coordinates/transforms-hist.py">transforms-hist.py</a></p></blockquote><p><img src="92_rougier01_12.png"><br></p><ul><li>이번에 살펴볼 그림은 scatter plot에 histogram이 겹친 모양입니다.</li><li>데이터의 PC1 축 방향으로 돌려 놓인 histogram은 PC2 방향의 데이터 분포를 나타내고 있습니다.</li></ul><div class="en"><ul><li> We are going to investigate a scatter plot with a histogram.</li><li> The histogram is rotated and placed along PC1 axis, representing data distribution along the PC2's direction.</li></ul></div><h1 id="2-Matplotlib-coding"><a href="#2-Matplotlib-coding" class="headerlink" title="2. Matplotlib coding"></a>2. Matplotlib coding</h1><ul><li>저자는 Matplotlib 자체 기능만을 사용해서 그렸습니다.</li><li>저자의 코드를 따라가며 어떻게 그렸는지 확인해 보겠습니다.</li></ul><div class="en"><ul><li> The author created the figure with Matplotlib only.</li><li> We'll see the author's code is working by following every step.</li></ul></div><h2 id="2-1-import-libraries"><a href="#2-1-import-libraries" class="headerlink" title="2.1. import libraries"></a>2.1. import libraries</h2><ul><li>코드는 라이브러리를 불러오는 것부터 시작합니다.</li><li><code>Polygon</code>, <code>Affine2D</code>, <code>floating_axes</code>처럼 전에 보기 힘들었던 기능을 불러옵니다.</li><li>numpy random seed를 설정하여 재현성을 확보합니다.</li></ul><div class="en"><ul><li> We start by importing the libraries.</li><li> Unlike "normal" visualizations, the modules named <code>Polygon</code>, <code>Affine2D</code>, <code>floating_axes</code> are imported.</li><li> Reproducibality is secured by setting numpy random seed.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Polygon</span><br><span class="line"><span class="keyword">from</span> matplotlib.transforms <span class="keyword">import</span> Affine2D</span><br><span class="line"><span class="keyword">import</span> mpl_toolkits.axisartist.floating_axes <span class="keyword">as</span> floating_axes</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reroducibility seed</span></span><br><span class="line">np.random.seed(<span class="number">123</span>)</span><br></pre></td></tr></table></figure><h2 id="2-2-Affine-transformation"><a href="#2-2-Affine-transformation" class="headerlink" title="2.2. Affine transformation"></a>2.2. Affine transformation</h2><blockquote><p><a href="https://mathworld.wolfram.com/AffineTransformation.html">Affine Transformation</a></p></blockquote><ul><li>Affine 변환은 공선성과 거리 비율을 유지하는 모든 종류의 형태 변환을 말합니다.</li><li>Matplotlib은 2차원 Affine 변환을 구현하는 <code>Affine2D</code> 함수를 지원합니다.</li><li>본격적으로 코드를 들여다보기 전에 <code>Affine2D</code> 용법을 확인합니다.</li></ul><div class="en"><ul><li> An affine transformation is any transformation that preserves collinearity (i.e., all points lying on a line initially still lie on a line after transformation) and ratios of distances (e.g., the midpoint of a line segment remains the midpoint after transformation).</li><li> Matplotlib provides <code>Affine2D</code> function in which 2-dimensional Affine transformation is implemented.</li><li> Before diving into the original code, we need to learn how to use <code>Affine2D</code>.</li></ul></div><ul><li>7개의 점으로 이루어진 예제 데이터 <b>S0</b>을 만듭니다. 각 점은 x, y 좌표가 있으므로 형상은 (7, 2)가 됩니다.</li><li>각 점마다 다른 색을 입히기 위해 0부터 1까지 7개의 값 데이터 <b>Sc</b>를 만듭니다. <code>numpy.linspace()</code>를 사용합니다.</li><li><code>Affine2D().rotate_deg(30).transform(S0)</code> 명령으로 <b>S0</b>를 30도 회전해 <b>S1</b>을 얻습니다. 방향은 반시계 방향입니다.</li></ul><div class="en"><ul><li> <b>S0</b>, sample data consisted of 7 points, is prepared on cartesian coordinate system. Each point has x and y coordinate, therefore shape of S0 is (7, 2).</li><li> <b>Sc</b>, a dataset with 7 values are prepared by using <code>numpy.linspace()</code> to paint each point with a differnt color.</li><li> <b>S1</b> is obtained by rotating <b>S0</b> by 30 degree in a counterclockwise direction by using <code>Affine2D().rotate_deg(30).transform(S0)</code>.</li></ul></div><ul><li><b>S0</b>과 <b>S1</b>를 그려 데이터가 의도대로 변환되었음을 확인합니다.</li></ul><div class="en"><ul><li> Successful rotational transform is confirmed by visualization of <b>S0</b> and <b>S1</b>.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># numpy array</span></span><br><span class="line">S0 = np.array([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">3</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line">Sc = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">len</span>(S0))</span><br><span class="line">S1 = Affine2D().rotate_deg(<span class="number">30</span>).transform(S0)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Visualize</span></span><br><span class="line">fig_s, axs_s = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">6</span>, <span class="number">3</span>), sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax_s, S, t <span class="keyword">in</span> <span class="built_in">zip</span>(axs_s, [S0, S1], [<span class="number">0</span>, <span class="number">30</span>]):</span><br><span class="line">    ax_s.scatter(S[:, <span class="number">0</span>], S[:, <span class="number">1</span>], c=Sc, s=<span class="number">100</span>, ec=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">       </span><br><span class="line">    ax_s.set_aspect(<span class="number">1</span>)</span><br><span class="line">    ax_s.set_ylim(-<span class="number">0.5</span>, <span class="number">4.5</span>)</span><br><span class="line">    ax_s.set_title(<span class="string">f&quot;rotation = <span class="subst">&#123;t&#125;</span>$^o$&quot;</span>, fontsize=<span class="string">&quot;large&quot;</span>)</span><br><span class="line">    </span><br><span class="line">fig_s.tight_layout()</span><br></pre></td></tr></table></figure><p><img src="92_rougier01_02.png"><br></p><ul><li>다른 방식으로도 변환할 수 있습니다. Matplotlib Rectangle 객체 <b>R0</b>을 대상으로 합니다.</li><li><b>Rt</b>라는 이름의 변환을 선언하고 <code>R0.set_transform(Rt)</code>를 적용하면 <b>R0</b>의 좌표가 바뀝니다.</li></ul><div class="en"><ul><li> We can get the same result by using a different method. We will rotate <b>R0</b>, a Matplotlib Rectangle object.</li><li> Declerating <b>Rt</b> as the designation and applying <code>R0.set_transform(Rt)</code> to <b>R0</b> changes the coordinates of itself.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Rectangle</span><br><span class="line"></span><br><span class="line">R0 = Rectangle((<span class="number">0</span>, <span class="number">0</span>), <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax_s <span class="keyword">in</span> axs_s:</span><br><span class="line">    R0 = Rectangle((<span class="number">0</span>, <span class="number">0</span>), <span class="number">3</span>, <span class="number">3</span>, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;c&quot;</span>, zorder=-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> ax_s == axs_s[<span class="number">1</span>]:</span><br><span class="line">        Rt = Affine2D().rotate_deg(<span class="number">30</span>) + axs_s[<span class="number">1</span>].transData</span><br><span class="line">        R0.set_transform(Rt)</span><br><span class="line">    ax_s.add_patch(R0)</span><br><span class="line">    </span><br><span class="line">fig_s.tight_layout()</span><br><span class="line">display(fig_s)</span><br></pre></td></tr></table></figure><p><img src="92_rougier01_03.png"><br></p><ul><li>(150, 2) 데이터 <b>Z0</b>를 생성하고 같은 방식으로 원본 데이터를 35도 회전해 <b>Z1</b>를 만듭니다.</li><li><b>Z1</b>의 x, y 평균([ 0.13746892, -0.02793329])을 구해 <b>Zm</b>에 저장합니다.</li></ul><div class="en"><ul><li> Create (150, 2) points data <b>Z0</b> then rotate 35 degree in the same manner to generate <b>Z1</b>.</li><li> Calculate mean of <b>Z1</b> ([ 0.13746892, -0.02793329]) and store it as <b>Zm</b>.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generate some data</span></span><br><span class="line">Z0 = np.random.normal(<span class="number">0</span>, (<span class="number">1.25</span>, <span class="number">0.75</span>), (<span class="number">150</span>, <span class="number">2</span>))  <span class="comment"># Z0: 2D random points array</span></span><br><span class="line">Z1 = Affine2D().rotate_deg(<span class="number">35</span>).transform(Z0)      <span class="comment"># Z1: rotated Z0</span></span><br><span class="line">Zm = Z1.mean(axis=<span class="number">0</span>)                              <span class="comment"># mean of Z1. Zm = np.array([ 0.13746892, -0.02793329])</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Visualize</span></span><br><span class="line">fig_r, axs_r = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">6</span>, <span class="number">3</span>), sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> Z, ax, t <span class="keyword">in</span> <span class="built_in">zip</span>([Z0, Z1], axs_r, [<span class="number">0</span>, <span class="number">35</span>]):</span><br><span class="line">    ax.scatter(Z[:,<span class="number">0</span>], Z[:,<span class="number">1</span>], c=np.linspace(<span class="number">0</span>, <span class="number">1</span>, Z.shape[<span class="number">0</span>]))</span><br><span class="line">    ax.axhline(<span class="number">0</span>, c=<span class="string">&quot;k&quot;</span>, zorder=-<span class="number">1</span>)</span><br><span class="line">    ax.axvline(<span class="number">0</span>, c=<span class="string">&quot;k&quot;</span>, zorder=-<span class="number">1</span>)</span><br><span class="line">    ax.set_title(<span class="string">f&quot;rotation = <span class="subst">&#123;t&#125;</span>$^o$&quot;</span>, fontsize=<span class="string">&quot;large&quot;</span>)</span><br><span class="line"></span><br><span class="line">Zall = np.concatenate([Z0, Z1])    </span><br><span class="line">xmin, xmax = Zall[:,<span class="number">0</span>].<span class="built_in">min</span>(), Zall[:,<span class="number">0</span>].<span class="built_in">max</span>()</span><br><span class="line">ymin, ymax = Zall[:,<span class="number">1</span>].<span class="built_in">min</span>(), Zall[:,<span class="number">1</span>].<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line">axs_s[<span class="number">0</span>].set_xlim(xmin, xmax)</span><br><span class="line"></span><br><span class="line">fig_r.tight_layout()</span><br></pre></td></tr></table></figure><p><img src="92_rougier01_14.png"><br></p><h2 id="2-3-Principal-Component-Analysis-PCA"><a href="#2-3-Principal-Component-Analysis-PCA" class="headerlink" title="2.3. Principal Component Analysis (PCA)"></a>2.3. Principal Component Analysis (PCA)</h2><ul><li><code>numpy.linalg.eig</code>를 사용해 PCA를 수행합니다.</li><li>eigenvalue <b>V</b>와 eigenvector <b>W</b>로부터 PC1과 PC2를 구하고 각각 <b>T</b>(PC1)와 <b>O</b>(PC1과 직각. PC2)으로 복사합니다. </li></ul><div class="en"><ul><li> Perform PCA using <code>numpy.linalg.eig()</code>.</li><li> Get PC1 and PC2 from the eigenvalue <b>V</b> and eigenvector <b>W</b>, and copy them as <b>T</b>(tangent to PC1) and <b>O</b>(orthogonal to PC1, equivalent to PC2).</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Principal components analysis</span></span><br><span class="line"><span class="comment"># Note that for some seeds, the PC1 and PC2 needs to be inverted</span></span><br><span class="line"><span class="comment"># It could be fixed by looking at the orientation but I&#x27;m lazy</span></span><br><span class="line">W, V = np.linalg.eig(np.cov(Z1.T))                 <span class="comment"># W: eigenvalues, V: eigenvectors</span></span><br><span class="line">PC1, PC2 = V[np.argsort(<span class="built_in">abs</span>(W))]                   <span class="comment"># PC1, PC2: 1st and 2nd Principal components</span></span><br><span class="line"><span class="keyword">if</span> PC2[<span class="number">1</span>] &lt; <span class="number">0</span>:                                     <span class="comment"># to make PC2 &quot;upwards&quot;</span></span><br><span class="line">    PC2 = -PC2</span><br><span class="line">    </span><br><span class="line">rotation = <span class="number">180</span> * np.arctan2(*PC1) / np.pi</span><br><span class="line">T = np.array([PC1[<span class="number">0</span>], PC1[<span class="number">1</span>]])                     <span class="comment"># tangent vector of PC1 (a deep copy of PC1)</span></span><br><span class="line">O = np.array([PC2[<span class="number">0</span>], PC2[<span class="number">1</span>]])                     <span class="comment"># orthogonal vector of PC1 (a deep copy of PC2)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># visualize</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">ax.scatter(Z1[:,<span class="number">0</span>], Z1[:,<span class="number">1</span>], c=<span class="string">&quot;lightgray&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pc, c <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="string">&quot;PC1&quot;</span>, <span class="string">&quot;PC2&quot;</span>], [<span class="string">&quot;b&quot;</span>, <span class="string">&quot;r&quot;</span>]):</span><br><span class="line">    ax.arrow(<span class="number">0</span>, <span class="number">0</span>, *<span class="built_in">eval</span>(pc), width=<span class="number">0.1</span>, length_includes_head=<span class="literal">True</span>, ec=<span class="string">&quot;none&quot;</span>, fc=c)</span><br><span class="line">    ax.text(*<span class="built_in">eval</span>(pc), pc, ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;bottom&quot;</span>, fontsize=<span class="string">&quot;large&quot;</span>, color=c)</span><br><span class="line"></span><br><span class="line">ax.set_aspect(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="92_rougier01_15.png"><br></p><ul><li><b>rotation</b>, <b>T</b>, <b>O</b>를 확인합니다.</li></ul><div class="en"><ul><li> Let's take a look at <b>rotation</b>, <b>T</b>, and <b>O</b>.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;rotation = <span class="subst">&#123;rotation&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;tangent vector = <span class="subst">&#123;T&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;orthogonal vector = <span class="subst">&#123;O&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과 <div class="en">output</div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rotation = 37.89555000213857</span><br><span class="line">tangent vector = [0.61422391 0.78913179]</span><br><span class="line">orthogonal vector = [-0.78913179  0.61422391]</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-4-scatter-plot-and-PC1-axis"><a href="#2-4-scatter-plot-and-PC1-axis" class="headerlink" title="2.4. scatter plot and PC1 axis"></a>2.4. scatter plot and PC1 axis</h2><ul><li>이제 본격적으로 시각화를 수행합니다.</li><li>scatter plot을 그리고 x, y 축의 범위와 값을 지정합니다.</li><li>PC1 축을 따라 점선을 긋습니다.</li></ul><div class="en"><ul><li> Finally data visualization is about to begin.</li><li> Draw a scatter plot; subsidiary x, y ticks and ticklabels are controlled.</li><li> PC1 axis is marked as a dashed line.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Draw</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">ax1 = fig.add_axes([<span class="number">0.05</span>, <span class="number">0.05</span>, <span class="number">0.9</span>, <span class="number">0.9</span>], aspect=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Main scatter plot</span></span><br><span class="line">ax1.scatter(Z1[:, <span class="number">0</span>], Z1[:, <span class="number">1</span>], s=<span class="number">50</span>, fc=<span class="string">&quot;C0&quot;</span>, ec=<span class="string">&quot;white&quot;</span>, lw=<span class="number">0.75</span>)</span><br><span class="line">ax1.set_xlim([-<span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line">ax1.set_xticks([-<span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line">ax1.set_xticklabels([])</span><br><span class="line">ax1.set_ylim([-<span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line">ax1.set_yticks([-<span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line">ax1.set_yticklabels([])</span><br><span class="line">ax1.spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">ax1.spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Draw main PCA axis</span></span><br><span class="line">P0 = np.vstack([Zm - T * <span class="number">10</span>, Zm + T * <span class="number">10</span>])         <span class="comment"># P0 : endpoints of a long line along PC1</span></span><br><span class="line">ax1.plot(P0[:, <span class="number">0</span>], P0[:, <span class="number">1</span>], color=<span class="string">&quot;black&quot;</span>, linestyle=<span class="string">&quot;--&quot;</span>, linewidth=<span class="number">0.75</span>, zorder=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><img src="92_rougier01_05.png"><br></p><h2 id="2-5-Bounding-box-along-PCA-axes"><a href="#2-5-Bounding-box-along-PCA-axes" class="headerlink" title="2.5. Bounding box along PCA axes"></a>2.5. Bounding box along PCA axes</h2><ul><li>데이터 전체를 감싸는 bounding box를 그릴 차례입니다.</li><li>데이터 <b>Z1</b>을 x축을 따라 역회전시킨 후 y 절대값의 최대치로부터 box 높이의 절반 <b>d</b>를 구합니다.</li><li><b>O</b>, <b>T</b>, <b>d</b>로부터 bounding box의 네 꼭지점을 구해 <b>P2</b>에 저장합니다.</li><li>마지막으로 <b>P2</b>로부터 Polygon 객체를 생성해 <code>ax1.add_patch()</code>로 그림에 붙입니다.</li></ul><div class="en"><ul><li> It's time to draw bounding box around the points.</li><li> Rotate the <b>Z1</b> along its X-axis, then find <b>d</b> which is half of the box's abolute y value.</li><li> Get 4 points of the bounding box from <b>O</b>, <b>T</b> and <b>d</b>, store as <b>P2</b>.</li><li> Finally, create Polygon object from <b>P2</b> and add it by using <code>ax1.add_patch()</code>. </li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Compute the width of the distribution along orthogonal direction to the PCA</span></span><br><span class="line"><span class="comment"># main axis. This is made by rotating points and taking max on the Y axis.</span></span><br><span class="line">transform = Affine2D().rotate_deg(-rotation)</span><br><span class="line">P1 = transform.transform(Z1 - Z1.mean(axis=<span class="number">0</span>))     <span class="comment"># P1 : rotated Z1, along x-axis</span></span><br><span class="line">d = np.<span class="built_in">abs</span>(P1[:, <span class="number">1</span>]).<span class="built_in">max</span>()                         <span class="comment"># d  : max. distance between P0 and Z1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Draw a rectangle surrounding the distribution &amp; oriented along PCA main axis</span></span><br><span class="line">P2 = np.vstack(                                    <span class="comment"># P2 : rectangle surrounding Z1</span></span><br><span class="line">    [</span><br><span class="line">        Zm - <span class="number">10</span> * T - d * O,</span><br><span class="line">        Zm + (<span class="number">6</span> - d) * T - d * O,</span><br><span class="line">        Zm + (<span class="number">6</span> - d) * T + d * O,</span><br><span class="line">        Zm - <span class="number">10</span> * T + d * O,</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line">ax1.add_patch(</span><br><span class="line">    Polygon(</span><br><span class="line">        P2,</span><br><span class="line">        closed=<span class="literal">True</span>,</span><br><span class="line">        fill=<span class="literal">True</span>,</span><br><span class="line">        edgecolor=<span class="string">&quot;None&quot;</span>,</span><br><span class="line">        facecolor=<span class="string">&quot;C0&quot;</span>,</span><br><span class="line">        alpha=<span class="number">0.1</span>,</span><br><span class="line">        zorder=-<span class="number">50</span>,</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="92_rougier01_06.png"><br></p><ul><li>bounding box에 윤곽선을 추가하고 축 위에 평균 <b>Zm</b>을 표시하는 삼각형 마커를 추가합니다.</li><li><b>Zm</b>, <b>d</b>, <b>T</b>, <b>O</b>로부터 윤곽선 좌표 <b>P3</b>과 <b>P4</b>를 구해 <code>ax1.plot()</code>으로 조금 진한 윤곽선을 입힙니다.</li></ul><div class="en"><ul><li> Boundary of the bounding box should be more clear, and the triangle markers denoting means <b>Zm</b> should be visible on each axis.</li><li> Get the coordinates of the outline, <b>P3</b> and <b>P4</b>, from <b>Zm</b>, <b>d</b>, <b>T</b> and <b>O</b>, then apply a slightly darker outline by using the command <code>ax1.plot()</code>.</li> </ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># P3, P4 : edges of P2 parallel to PC1</span></span><br><span class="line">P3 = np.vstack([Zm - <span class="number">10</span> * T, Zm + (<span class="number">6</span> - d) * T]) - d * O  </span><br><span class="line">plt.plot(P3[:, <span class="number">0</span>], P3[:, <span class="number">1</span>], color=<span class="string">&quot;C0&quot;</span>, linestyle=<span class="string">&quot;-&quot;</span>, linewidth=<span class="number">0.75</span>, alpha=<span class="number">0.25</span>)</span><br><span class="line">P4 = np.vstack([Zm - <span class="number">10</span> * T, Zm + (<span class="number">6</span> - d) * T]) + d * O</span><br><span class="line">plt.plot(P4[:, <span class="number">0</span>], P4[:, <span class="number">1</span>], color=<span class="string">&quot;C0&quot;</span>, linestyle=<span class="string">&quot;-&quot;</span>, linewidth=<span class="number">0.75</span>, alpha=<span class="number">0.25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Some markers on the axis to show the mean (we could compute exactly the delta</span></span><br><span class="line"><span class="comment"># for placing the marker but it is not the point of this example)</span></span><br><span class="line">ax1.scatter(Zm[<span class="number">0</span>], -<span class="number">2.85</span>, s=<span class="number">50</span>, color=<span class="string">&quot;black&quot;</span>, marker=<span class="string">&quot;v&quot;</span>, clip_on=<span class="literal">False</span>)</span><br><span class="line">ax1.scatter(-<span class="number">2.85</span>, Zm[<span class="number">1</span>], s=<span class="number">50</span>, color=<span class="string">&quot;black&quot;</span>, marker=<span class="string">&quot;&lt;&quot;</span>, clip_on=<span class="literal">False</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="92_rougier01_07.png"><br></p><h2 id="2-6-Add-Axes-for-rotated-histogram"><a href="#2-6-Add-Axes-for-rotated-histogram" class="headerlink" title="2.6. Add Axes for rotated histogram"></a>2.6. Add Axes for rotated histogram</h2><ul><li>이번 시각화의 하일라이트, 회전된 histogram을 붙일 차례입니다.</li><li>회전된 histogram을 붙이기 위해서는 정확한 자리에 정확한 각도와 크기로 새 Axes를 형성하고</li><li>이 Axes 위에 histogram을 회전시켜 붙여야 합니다.</li></ul><div class="en"><ul><li> The next step is the grand finale of this visualization, the rotated histogram.</li><li> In order to add rotated histogram, new Axes should be formed at the exact site with the exact angle and size.</li><li> And then histogram is added with the rotation.</li></ul></div><ul><li>정사각형 모양의 공간을 PC1 방향의 연장선에 형성할 것입니다.</li><li>높이와 너비는 <b>P2</b>로 만들어진 Polygon의 높이와 동일합니다.</li><li>histogram이 놓일 공간의 중심 좌표 <b>C</b>를 구합니다.</li></ul><div class="en"><ul><li> We are now going to form a square shaped space in the direction, and as an extension, of <b>PC1</b>.</li><li> The height and width of the space is same as the height of Polygon based on <b>P2</b>.</li><li> The center coordinate <b>C</b> of the histogram space is calculated.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Compute the center of the histogram</span></span><br><span class="line">C = Zm + <span class="number">6</span> * T</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># visualization</span></span><br><span class="line">ax1.scatter(*C, s=<span class="number">100</span>, c=<span class="string">&quot;orange&quot;</span>, marker=<span class="string">&quot;X&quot;</span>, zorder=<span class="number">1</span>)</span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure><p><img src="92_rougier01_08.png"><br></p><ul><li>histogram이 놓일 공간의 높이 <b>h0</b>와 너비 <b>w0</b>를 구합니다.</li></ul><div class="en"><ul><li> Calculate the height <b>h0</b> and width <b>w0</b> of the histogram space.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. Compute the coordinate and the size in normalized figure coordinates</span></span><br><span class="line">x, y = fig.transFigure.inverted().transform(ax1.transData.transform(C))</span><br><span class="line">xo, yo = fig.transFigure.inverted().transform(ax1.transData.transform(C + <span class="number">2</span> * d * O))</span><br><span class="line">h0 = w0 = np.sqrt((xo - x) ** <span class="number">2</span> + (yo - y) ** <span class="number">2</span>)    <span class="comment"># preparation of the histogram Axes</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#visualize</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.lines <span class="keyword">as</span> lines</span><br><span class="line"></span><br><span class="line">text_xy = fig.text(x, y, <span class="string">&quot;(x, y)&quot;</span>, c=<span class="string">&quot;r&quot;</span>, zorder=<span class="number">1</span>,</span><br><span class="line">                   ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;large&quot;</span>)</span><br><span class="line">text_xyo = fig.text(xo, yo, <span class="string">&quot;(xo, yo)&quot;</span>, c=<span class="string">&quot;r&quot;</span>, zorder=<span class="number">1</span>,</span><br><span class="line">                    ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;large&quot;</span>)</span><br><span class="line">line_hw = fig.add_artist(lines.Line2D([x, xo], [y, yo], c=<span class="string">&quot;orange&quot;</span>, ls=<span class="string">&quot;:&quot;</span>))</span><br><span class="line">text_hw = fig.text((x+xo)/<span class="number">2</span>, (y+yo)/<span class="number">2</span>, <span class="string">&quot;h = w&quot;</span>, c=<span class="string">&quot;r&quot;</span>, </span><br><span class="line">                   ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;large&quot;</span>)</span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure><p><img src="92_rougier01_09.png"><br></p><blockquote><p><a href="https://matplotlib.org/stable/gallery/axisartist/demo_floating_axes.html">matplotlib: mpl_toolkits.axisartist.floating_axes</a></p></blockquote><p><img src="92_rougier01_16.png"><br></p><ul><li>이 치수를 바탕으로 histogram이 놓일 Axes <b>ax2</b>를 생성합니다.</li><li>불규칙한 Axes를 만들 때 <code>floating_axes</code>를 사용합니다.</li></ul><div class="en"><ul><li> Based on this dimensions Axes for histogram, <b>ax2</b> is generated.</li><li> <code>floating_axes</code> is used for irregular Axes.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3. Create the secondary axis</span></span><br><span class="line"><span class="comment">#    Warning: it must be squared, ie. xmax-xmin = ymax-ymin</span></span><br><span class="line"><span class="comment">#    It is possible to have non squared axis, but it would complicate things.</span></span><br><span class="line">xmin, xmax = -<span class="number">16</span>, <span class="number">16</span></span><br><span class="line">ymin, ymax = <span class="number">0</span>, xmax - xmin</span><br><span class="line">transform = Affine2D().rotate_deg(-rotation)</span><br><span class="line">helper = floating_axes.GridHelperCurveLinear(transform, (xmin, xmax, ymin, ymax))</span><br><span class="line">ax2 = floating_axes.FloatingSubplot(fig, <span class="number">111</span>, grid_helper=helper, zorder=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. We know the size of the axis we want but it is rotated. When we specify</span></span><br><span class="line"><span class="comment">#    the size and position, it related to the non-rotate axis and we thus need</span></span><br><span class="line"><span class="comment">#    to compute the bounding box. To do that, we rotate the four coordinates</span></span><br><span class="line"><span class="comment">#    from which we deduce the bounding box coordinates.</span></span><br><span class="line">transform = Affine2D().rotate_deg(-rotation)</span><br><span class="line">R = transform.transform(                            <span class="comment"># outline of the histogram Axes</span></span><br><span class="line">    [</span><br><span class="line">        (x - w0 / <span class="number">2</span>, y - h0 / <span class="number">2</span>),</span><br><span class="line">        (x + w0 / <span class="number">2</span>, y - h0 / <span class="number">2</span>),</span><br><span class="line">        (x - w0 / <span class="number">2</span>, y + h0 / <span class="number">2</span>),</span><br><span class="line">        (x + w0 / <span class="number">2</span>, y + h0 / <span class="number">2</span>),</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line">w1 = R[:, <span class="number">0</span>].<span class="built_in">max</span>() - R[:, <span class="number">0</span>].<span class="built_in">min</span>()                  <span class="comment"># width of the histogram Axes</span></span><br><span class="line">h1 = R[:, <span class="number">1</span>].<span class="built_in">max</span>() - R[:, <span class="number">1</span>].<span class="built_in">min</span>()                  <span class="comment"># height of the histogram Axes</span></span><br><span class="line">ax2.set_position((x - w1 / <span class="number">2</span>, y - h1 / <span class="number">2</span>, w1, h1))</span><br><span class="line">fig.add_subplot(ax2)                                <span class="comment"># Adding histogram Axes</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># visualization</span></span><br><span class="line"><span class="keyword">for</span> text <span class="keyword">in</span> fig.texts:</span><br><span class="line">    text.set_zorder(<span class="number">1</span>)</span><br><span class="line">ax2.set_zorder(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure><p><img src="92_rougier01_10.png"><br></p><h2 id="2-7-Add-Rotated-histogram-and-axis-settings"><a href="#2-7-Add-Rotated-histogram-and-axis-settings" class="headerlink" title="2.7. Add Rotated histogram and axis settings"></a>2.7. Add Rotated histogram and axis settings</h2><ul><li>이제 공간이 마련되었으니 histogram을 붙일 차례입니다.</li><li>회전된 공간에 데이터를 넣으려면 <code>ax2.get_aux_axes(transform)</code>을 사용해 별도의 Axes를 만들어야 합니다.</li><li>PC2 방향의 histogram을 얻기 위해 <code>numpy.histogram(-Z @ PC1)</code>을 사용했습니다. <b>PC1에 수직 방향의 빈도를 구하라</b>는 뜻입니다.</li></ul><div class="en"><ul><li> Since the new Axes is prepared, it is time to add the histogram.</li><li> To visualize data on a rotated space, another Axes should be generated using <code>ax2.get_aux_axes(transform)</code>.</li><li> <code>numpy.histogram(-Z1 @ PC1)</code> is used to obtain histogram along the PC2 axis. The code means <b>return data frequences orthogonal to PC1 axis</b>.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5. Some decoration the secondary axis</span></span><br><span class="line">ax2.axis[<span class="string">&quot;left&quot;</span>].major_ticklabels.set_visible(<span class="literal">False</span>)</span><br><span class="line">ax2.axis[<span class="string">&quot;bottom&quot;</span>].major_ticklabels.set_visible(<span class="literal">False</span>)</span><br><span class="line">ax2.axis[<span class="string">&quot;bottom&quot;</span>].major_ticks.set_tick_out(<span class="literal">True</span>)</span><br><span class="line">ax2.axis[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">ax2.axis[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">ax2.axis[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">ax2.set_xticks([<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">ax2.patch.set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. Display the histogram, taking care of the extents of the X axis</span></span><br><span class="line">counts, bins = np.histogram(-Z1 @ PC1, bins=<span class="number">12</span>)     <span class="comment"># histogram of -Z1 orthogonal to PC1 direction with 12 bins</span></span><br><span class="line">X0 = (bins - bins[<span class="number">0</span>]) / (bins[-<span class="number">1</span>] - bins[<span class="number">0</span>])        <span class="comment"># X0 : normalized bins range [0, 1]</span></span><br><span class="line">X1 = xmin + (xmax - xmin) * X0                      <span class="comment"># X1 : stretched bins range [xmin, xmax] = [-16, 16]</span></span><br><span class="line">Y = np.array(counts)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This auxiliary axis is necessary to draw stuff (no real idea why)</span></span><br><span class="line">ax2_aux = ax2.get_aux_axes(transform)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plotting histogram </span></span><br><span class="line">ax2_aux.hist(X1[:-<span class="number">1</span>], X1, weights=Y, facecolor=<span class="string">&quot;C0&quot;</span>, edgecolor=<span class="string">&quot;white&quot;</span>, linewidth=<span class="number">0.25</span>)</span><br><span class="line"></span><br><span class="line">text_xy.remove()</span><br><span class="line">text_xyo.remove()</span><br><span class="line">text_hw.remove()</span><br><span class="line">line_hw.remove()</span><br><span class="line"></span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure><p><img src="92_rougier01_11.png"><br></p><ul><li>마지막으로 히스토그램 숫자를 기입합니다.</li></ul><div class="en"><ul><li> At last, put numbers on top of the bars of histogram.</li></ul></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 7. Adding some labels</span></span><br><span class="line">dx, dy = (X1[<span class="number">1</span>] - X1[<span class="number">0</span>]) / <span class="number">2</span>, <span class="number">0.75</span></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(X1, Y):</span><br><span class="line">    ax2_aux.text(</span><br><span class="line">        x + dx,</span><br><span class="line">        y + dy,</span><br><span class="line">        <span class="string">&quot;%d&quot;</span> % y,</span><br><span class="line">        ha=<span class="string">&quot;center&quot;</span>,</span><br><span class="line">        va=<span class="string">&quot;center&quot;</span>,</span><br><span class="line">        size=<span class="number">8</span>,</span><br><span class="line">        rotation=-rotation,</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure><p><img src="92_rougier01_12.png"><br></p><h1 id="3-Conclusion"><a href="#3-Conclusion" class="headerlink" title="3. Conclusion"></a>3. Conclusion</h1><ul><li>코드를 여러 부분으로 나누어 그림이 만들어지는 과정을 코드와 함께 살펴봤습니다.</li><li>리뷰 과정에서 원본을 일부 수정한 Pull Request가 적용되었습니다. 이 글은 수정본을 기반으로 작성되었습니다.</li><li>Matplotlib은 표현력이 매우 강한 라이브러리입니다. </li><li>여러분의 상상을 실현하는 데, Nicolas의 훌륭한 코드를 이해하는 데 도움이 되시길 바랍니다.</li></ul><div class="en"><ul><li> In this article we divide the source code into many parts, and looked through how the final figure was created.</li><li> A couple of changes were suggested as a form of Pull Request to correct small errors, and accepted. This article is written based on the revised version of mine.</li><li> Matplotlib is a library with a strong power of expression.</li><li> I hope this article to be an assistant to realize your imagination, as well as help you understand Nicolas's excellent code.</li></ul></div>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/Nicolas-P-Rougier/">Nicolas P. Rougier</category>
      
      
    </item>
    
    <item>
      <title>NIA Data Story - Movie) 0. intro</title>
      <link>https://jehyunlee.github.io/2021/11/29/Python-DS-91-movie01/</link>
      <guid>https://jehyunlee.github.io/2021/11/29/Python-DS-91-movie01/</guid>
      <pubDate>Mon, 29 Nov 2021 11:50:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;한국지능정보사회진흥원(NIA) 요청으로 데이터 스토리를 작성했습니다.&lt;/li&gt;
&lt;li&gt;1971-2020, 50년간 국내 개봉작을 데이터의 형태로 경험했습니다.&lt;/li&gt;
&lt;li&gt;시각화 코드를 조금 자세히 풀어서 전달드리고자 합니다.&lt;/l</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>한국지능정보사회진흥원(NIA) 요청으로 데이터 스토리를 작성했습니다.</li><li>1971-2020, 50년간 국내 개봉작을 데이터의 형태로 경험했습니다.</li><li>시각화 코드를 조금 자세히 풀어서 전달드리고자 합니다.</li></ul><h1 id="1-“빅”데이터-검수-문제"><a href="#1-“빅”데이터-검수-문제" class="headerlink" title="1. “빅”데이터 검수 문제"></a>1. “빅”데이터 검수 문제</h1><blockquote><p><a href="http://www.bigdata-map.kr/">통합 데이터 지도</a></p></blockquote><ul><li>최근 전에 없이 국가적인 단위에서 데이터 수집 사업이 수행되었습니다.</li><li>앞으로 다가올 데이터 기반 사회를 위한 기초공사입니다.</li></ul><ul><li>그러나 <b>수집된 데이터의 유효성을 검증하기는 참으로 어렵습니다.</b></li><li>데이터가 한 두 개도 아니고 일일이 열어보기 어려울 뿐더러, </li><li><b>데이터가 있다</b>와 <b>쓸만한 데이터가 있다</b>는 것은 완전히 다른 차원의 문제입니다.<br><img src="91_movie01_5.png"><br></li></ul><ul><li>NIA의 데이터 검증 의지를 가지신 분들 덕택에 모니터링단으로 활동할 수 있었습니다.</li><li>적지 않은 문제를 발견해 공식 보고와 함께 여러 제언을 드렸습니다.</li><li>그 중 가장 강하게 말씀드린 것은 <b>데이터는 활용될 때 검증된다</b>는 것,</li><li>그리고 <b>사람의 힘으로는 불가능하니 자동 검수 시스템이 필요하다</b>는 것이었습니다.<br><br><img src="91_movie01_4.png"><br></li></ul><ul><li>작년 AI Festival에서 이 말씀을 발표드리는 한편 신문에 기고문도 실었습니다.<ul><li>해당 발표와 기고문은 <a href="https://jehyunlee.github.io/2020/09/03/Python-DS-33-aifestival_bigdatareality/">여기서 보실 수 있습니다.</a></li></ul></li></ul><p><img src="91_movie01_6.png" alt="2020 AI Festival 발표 영상"><br></p><h1 id="2-NIA-데이터-스토리"><a href="#2-NIA-데이터-스토리" class="headerlink" title="2. NIA 데이터 스토리"></a>2. NIA 데이터 스토리</h1><blockquote><p><a href="http://www.bigdata-map.kr/datastory">데이터 스토리</a></p></blockquote><ul><li>다행히 NIA에 비슷한 생각을 하는 분들이 있으셨습니다.</li><li><b>적재된 데이터를 소비자가 구매하기 전에 스토리로 가공하여 게시</b>하셨습니다.</li><li>많은 분들이 글을 써 주셨고, 제게도 기회가 주어졌습니다.<br><br><img src="91_movie01_3.png"><br></li></ul><ul><li>데이터 스토리 작성을 위해 여러 데이터를 살펴보았고, 문제점을 찾을 때마다 보고를 했습니다.</li><li>그리고 영화 데이터에 정착하여 <b>영화 데이터를 분석한 스토리</b>를 기고했습니다.</li><li><b>1971년 이후 50년간의 개봉 영화 23,409편</b>을 대상으로 삼았습니다.</li><li><b>(1) 장르 <a href="https://bit.ly/3xhc8BV">[Link]</a></b>와 <b>(2) 박스오피스 <a href="https://bit.ly/3cBpZK3">[Link]</a></b> 두 편으로 나누어 작성했습니다.<br><br><img src="91_movie01_7.png"><br></li></ul><ul><li>제 글에 점수를 주라면 100점 만점에 60~70점 정도 되는 것 같습니다.</li><li>너무 힘이 들어간 부분도 있고, 지쳐 힘이 빠진 부분도 있습니다.</li><li>이렇게 긴 분석 글을 처음 쓰다 보니 결과물을 볼 때 많이 아쉬운 것이 사실입니다.</li><li>한편 부족하나마 제 성장에도 보탬이 된 것이 사실입니다.</li></ul><h1 id="3-과정"><a href="#3-과정" class="headerlink" title="3. 과정"></a>3. 과정</h1><ul><li>데이터 스토리는 <b><a href="https://github.com/niadatamap/DataMap_DataStory/raw/master/2021/23/">소스 코드까지 제출하여 공개</a>했습니다.</b></li><li>그러나 <b>저 그림을 그리기 위해 생각한 과정들,</b></li><li>그리고 <b>저 그림의 코드는 왜 저렇게 작성되었는지</b>는 충분히 설명되지 않았습니다.</li></ul><ul><li>앞으로 여러 개의 글을 통해 이 점을 메꾸려고 합니다.</li><li>여러분께서 보시고 좋은 점은 교사로, 부족한 점은 반면교사로 활용하시면 좋겠습니다.</li><li>이 글을 쓰는 과정이 제 성장의 거름이 되었듯 여러분의 성장에도 보탬이 되기를 바랍니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/Google-Colab/">Google Colab</category>
      
      <category domain="https://jehyunlee.github.io/tags/open-API/">open API</category>
      
      <category domain="https://jehyunlee.github.io/tags/NIA-data-story/">NIA data story</category>
      
      
    </item>
    
    <item>
      <title>2D distribution</title>
      <link>https://jehyunlee.github.io/2021/11/22/Python-DS-90-density2d/</link>
      <guid>https://jehyunlee.github.io/2021/11/22/Python-DS-90-density2d/</guid>
      <pubDate>Mon, 22 Nov 2021 11:50:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;2차원 공간의 데이터 분포를 표현합니다.&lt;/li&gt;
&lt;li&gt;많이 사용하는 기능이면서도 막상 쓰려면 디테일에 발목을 잡힙니다.&lt;/li&gt;
&lt;li&gt;Matplotlib, seaborn에 이어 mpl-scatter-density도 알아봅니다.&lt;/</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>2차원 공간의 데이터 분포를 표현합니다.</li><li>많이 사용하는 기능이면서도 막상 쓰려면 디테일에 발목을 잡힙니다.</li><li>Matplotlib, seaborn에 이어 mpl-scatter-density도 알아봅니다.</li></ul><h1 id="1-2D-data-distribution"><a href="#1-2D-data-distribution" class="headerlink" title="1. 2D data distribution"></a>1. 2D data distribution</h1><ul><li>데이터가 2차원으로 분포하는 경우는 매우 흔합니다.</li><li>N차원으로 분포하는 데이터의 두 차원만 떼어 보여주는 경우도 많고</li><li>머신러닝 모델의 예측 성능을 평가하는 parity plot도 그렇습니다.</li></ul><ul><li><p>먼저 필수 라이브러리를 불러오고</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure></li><li><p>2차원에 분포한 데이터를 만듭니다.</p></li><li><p>$y = x^2$를 사용해서 막대기같은 데이터보다는 조금 보기 좋은 모양을 만듭니다.</p></li><li><p>데이터는 1만개입니다. 0이 많은 숫자를 쓸 때 천 단위로 _를 넣어주면 읽기 좋습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">10_000</span>) + np.random.normal(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10_000</span>)</span><br><span class="line">y = np.power(x, <span class="number">2</span>)/<span class="number">14</span> + np.random.normal(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10_000</span>)</span><br></pre></td></tr></table></figure></li></ul><h1 id="2-정석-scatter-plot"><a href="#2-정석-scatter-plot" class="headerlink" title="2. 정석, scatter plot"></a>2. 정석, scatter plot</h1><ul><li><p>x, y 공간에 분포한 데이터 시각화의 정석은 scatter plot입니다.</p></li><li><p>경험으로부터 좁은 공간에 밀집한 점은 서로를 가린다는 것을 알고 있습니다.</p></li><li><p><code>alpha=0.1</code>로 투명도 90%를 설정해서 겹친 점이 보이게 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">8</span>, <span class="number">4</span>), </span><br><span class="line">                        gridspec_kw=&#123;<span class="string">&quot;wspace&quot;</span>:<span class="number">0.1</span>, <span class="string">&quot;hspace&quot;</span>:<span class="number">0.1</span>&#125;,</span><br><span class="line">                        sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>, constrained_layout=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># scatter plot</span></span><br><span class="line">axs[<span class="number">0</span>].scatter(x, y, s=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># scatter plot with transparancy</span></span><br><span class="line">axs[<span class="number">1</span>].scatter(x, y, s=<span class="number">3</span>, alpha=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># titles</span></span><br><span class="line">titles = [<span class="string">&quot;Matplotlib scatter (alpha=1)&quot;</span>, <span class="string">&quot;Matplotlib scatter (alpha=0.1)&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, titles):</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;x-large&quot;</span>, pad=<span class="number">16</span>)</span><br><span class="line">    ax.set_aspect(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="90_density2d_01.png"><br></p></li><li><p>반투명이 적용되지 않은 왼쪽은 데이터의 위치는 보이지만 밀도가 보이지 않습니다.</p></li><li><p>반투명을 90% 적용한 오른쪽은 데이터의 밀도는 보이지만 경계가 잘 보이지 않습니다.</p></li><li><p>고급 방법이 필요합니다.</p></li></ul><h1 id="3-2D-histogram-hexbin-KDE-plot"><a href="#3-2D-histogram-hexbin-KDE-plot" class="headerlink" title="3. 2D histogram, hexbin, KDE plot"></a>3. 2D histogram, hexbin, KDE plot</h1><ul><li>1D에서 많이 쓰는 histogram과 KDE plot은 2D에도 적용 가능합니다.</li><li>2D 공간을 육각으로 나누는 hexbin도 사용할 만 합니다.</li></ul><ul><li><p>조금 색다른 colormap을 사용합시다.</p></li><li><p><a href="https://jehyunlee.github.io/2020/12/28/Python-DS-51-cmocean/">전에 작성한 글에서 <b>cmocean</b>이라는 colormap set을 소개했습니다.</a></p></li><li><p> 얼음을 정말 그럴듯하게 표현하는 <b>ice</b> colormap이 있습니다.<br><img src="https://jehyunlee.github.io/2020/12/28/Python-DS-51-cmocean/giphy.gif"><br></p></li><li><p>ice colormap을 cmap이라는 변수에 넣어서 사용하기로 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cmocean.cm <span class="keyword">as</span> cmo</span><br><span class="line">cmap = cmo.ice</span><br><span class="line">cmap</span><br></pre></td></tr></table></figure><p><img src="90_density2d_06.png"><br></p></li></ul><ul><li><p>Matplotlib의 <b>hist2d</b>, <b>hexbin</b>,</p></li><li><p>seaborn의 <b>kdeplot</b>에 ice colormap을 입혀 사용합니다.</p></li><li><p><code>sns.kdeplot()</code>은 <code>fill=True</code>를 추가하면 등고선이 아니라 면을 칠합니다.</p></li><li><p><code>levels</code>에 충분히 큰 값을 넣어서 매끄러운 그라데이션을 구현합니다.</p></li><li><p>바탕이 텅 비어버리므로 <code>set_facecolor(&#39;k&#39;)</code>를 넣어서 배경을 검게 한번 더 칠합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(ncols=<span class="number">2</span>, nrows=<span class="number">2</span>, figsize=(<span class="number">8</span>, <span class="number">8</span>), </span><br><span class="line">                         gridspec_kw=&#123;<span class="string">&quot;wspace&quot;</span>:<span class="number">0.1</span>, <span class="string">&quot;hspace&quot;</span>:<span class="number">0.1</span>&#125;,</span><br><span class="line">                         sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>, constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2D histogram</span></span><br><span class="line">axes[<span class="number">0</span>, <span class="number">0</span>].hist2d(x, y, cmap=cmap, bins=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># hexbin</span></span><br><span class="line">axes[<span class="number">0</span>, <span class="number">1</span>].hexbin(x, y, cmap=cmap, gridsize=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2D KDE plot (contour)</span></span><br><span class="line">sns.kdeplot(x, y, cmap=cmap, ax=axes[<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2D KDE plot (fill)</span></span><br><span class="line">sns.kdeplot(x, y, cmap=cmap, fill=<span class="literal">True</span>, thread=<span class="number">0</span>, levels=<span class="number">20</span>, ax=axes[<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">axes[<span class="number">1</span>, <span class="number">1</span>].set_facecolor(<span class="string">&quot;k&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># titles</span></span><br><span class="line">titles = [<span class="string">&quot;Matplotlib hist2d&quot;</span>, <span class="string">&quot;Matplotlib hexbin&quot;</span>, <span class="string">&quot;seaborn kdeplot&quot;</span>, <span class="string">&quot;seaborn kdeplot(fill=True)&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axes.ravel(), titles):</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;x-large&quot;</span>, pad=<span class="number">16</span>)</span><br><span class="line">    ax.set_aspect(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="90_density2d_02.png"><br></p></li><li><p>코딩을 한 보람이 비로소 느껴집니다.</p></li></ul><h1 id="4-colorbar-달기"><a href="#4-colorbar-달기" class="headerlink" title="4. colorbar 달기"></a>4. colorbar 달기</h1><ul><li>데이터의 밀도를 표현하는 그림에서 색이 나타내는 데이터의 수나 밀도는 중요하지 않을 지도 모릅니다.</li><li>그러나 교양 삼아 colorbar를 붙이는 방법을 짚고 넘어갑시다.</li><li>필요할 때 붙이려면 은근히 안 붙습니다.</li></ul><ul><li><b><code>Matplotlib hist2d</code></b>은 return하는 여러 값 중 맨 마지막이 그림입니다.</li><li>맨 마지막만 <code>im0</code>라는 이름으로 받아서 이를 <code>plt.colorbar()</code>에 넣습니다.</li><li><b><code>Matplotlib hexbin</code></b>은 곧장 그림을 return합니다.</li><li>그대로 <code>im1</code>로 받아서 넣습니다.</li><li>Matplotlib에서 만든 colorbar는 <code>set_label</code>로 이름을 추가할 수 있습니다.</li></ul><ul><li><b><code>seaborn KDE plot</code></b>은 자체에 colorbar 출력을 결정하는 매개변수가 있습니다.</li><li><code>cbar=True</code>로 놓고 <code>cbar_kws</code>에 속성을 결정하는 키워드를 딕셔너리 형식으로 추가합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(ncols=<span class="number">2</span>, nrows=<span class="number">2</span>, figsize=(<span class="number">8</span>, <span class="number">7</span>), </span><br><span class="line">                         gridspec_kw=&#123;<span class="string">&quot;wspace&quot;</span>:<span class="number">0.1</span>, <span class="string">&quot;hspace&quot;</span>:<span class="number">0.1</span>&#125;,</span><br><span class="line">                         sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>, constrained_layout=<span class="literal">True</span>)</span><br><span class="line">axs = axes.ravel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2D histogram</span></span><br><span class="line">_, _, _, im0 = axs[<span class="number">0</span>].hist2d(x, y, cmap=cmap, bins=<span class="number">30</span>)</span><br><span class="line">cbar0 = plt.colorbar(im0, ax=axs[<span class="number">0</span>])</span><br><span class="line">cbar0.set_label(<span class="string">&quot;data counts&quot;</span>, fontsize=<span class="string">&quot;large&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># hexbin</span></span><br><span class="line">im1 = axs[<span class="number">1</span>].hexbin(x, y, cmap=cmap, gridsize=<span class="number">30</span>)</span><br><span class="line">cbar1 = plt.colorbar(im1, ax=axs[<span class="number">1</span>])</span><br><span class="line">cbar1.set_label(<span class="string">&quot;data counts&quot;</span>, fontsize=<span class="string">&quot;large&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2D KDE plot (contour)</span></span><br><span class="line">sns.kdeplot(x, y, cmap=cmap, ax=axs[<span class="number">2</span>], </span><br><span class="line">            cbar=<span class="literal">True</span>, cbar_kws=&#123;<span class="string">&quot;label&quot;</span>:<span class="string">&quot;data density&quot;</span>, <span class="string">&quot;format&quot;</span>:<span class="string">&quot;%.3f&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2D KDE plot (fill)</span></span><br><span class="line">sns.kdeplot(x, y, cmap=cmap, fill=<span class="literal">True</span>, thresh=<span class="number">0</span>, levels=<span class="number">20</span>, ax=axs[<span class="number">3</span>], </span><br><span class="line">            cbar=<span class="literal">True</span>, cbar_kws=&#123;<span class="string">&quot;label&quot;</span>:<span class="string">&quot;data density&quot;</span>, <span class="string">&quot;format&quot;</span>:<span class="string">&quot;%.3f&quot;</span>&#125;)</span><br><span class="line">axs[<span class="number">3</span>].set_facecolor(<span class="string">&quot;k&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># titles</span></span><br><span class="line">titles = [<span class="string">&quot;Matplotlib hist2d&quot;</span>, <span class="string">&quot;Matplotlib hexbin&quot;</span>, <span class="string">&quot;seaborn kdeplot&quot;</span>, <span class="string">&quot;seaborn kdeplot(fill=True)&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axes.ravel(), titles):</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;x-large&quot;</span>, pad=<span class="number">16</span>)</span><br><span class="line">    ax.set_aspect(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><img src="90_density2d_03.png"><br></li></ul><h1 id="5-mpl-scatter-density"><a href="#5-mpl-scatter-density" class="headerlink" title="5. mpl-scatter-density"></a>5. mpl-scatter-density</h1><blockquote><p><a href="https://pypi.org/project/mpl-scatter-density/">mpl-scatter-density</a></p></blockquote><ul><li><p><a href="https://pypi.org/project/mpl-scatter-density/">mpl-scatter-density</a>라는 라이브러리가 있습니다.</p></li><li><p><b>scatter plot을 그리면 점의 밀도를 계산해서 색을 입혀주는 라이브러리</b>입니다.</p></li><li><p>위에서 살펴본 Matplotlib, seaborn 자체 기능과 얼마나 비슷하고 다른지 살펴봅니다.</p></li><li><p>먼저, 노트북 셀 안에서 설치합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!pip install mpl-scatter-density</span><br></pre></td></tr></table></figure></li><li><p>공식 홈페이지에 나온 설명을 따라 그립니다.</p></li><li><p>공식 홈페이지에는 Figure와 Axes를 따로 그리면서 <code>ax = fig.add_subplot(1, 1, 1, projection=&#39;scatter_density&#39;)</code>를 사용했습니다.</p></li><li><p><code>plt.subplots()</code>를 사용할 때는 <code>subplot_kw=&#123;&quot;projection&quot;:&quot;scatter_density&quot;&#125;</code>를 추가하면 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mpl_scatter_density</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">9</span>, <span class="number">3</span>), subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;scatter_density&quot;</span>&#125;,</span><br><span class="line">                        gridspec_kw=&#123;<span class="string">&quot;wspace&quot;</span>:<span class="number">0.1</span>&#125;, constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># scatter plot with transparancy</span></span><br><span class="line">axs[<span class="number">0</span>].scatter(x, y, s=<span class="number">3</span>, alpha=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># scatter density</span></span><br><span class="line">axs[<span class="number">1</span>].scatter_density(x, y, cmap=cmap, dpi=<span class="number">36</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># scatter density with colormap</span></span><br><span class="line">im2 = axs[<span class="number">2</span>].scatter_density(x, y, cmap=cmap, dpi=<span class="number">36</span>)</span><br><span class="line">plt.colorbar(im2, ax=axs[<span class="number">2</span>], shrink=<span class="number">0.86</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># titles</span></span><br><span class="line">titles = [<span class="string">&quot;Matplotlib scatter (alpha=0.1)&quot;</span>, <span class="string">&quot;scatter_density&quot;</span>, <span class="string">&quot;scatter_density with colorbar&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, titles):</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;x-large&quot;</span>, pad=<span class="number">16</span>)</span><br><span class="line">    ax.set_aspect(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="90_density2d_04.png"><br></p></li><li><p>scatter plot과 비슷한 명령이면서도 점의 밀도에 따라 밝기가 달라졌습니다.</p></li><li><p>위 코드를 보면 해상도를 의미하는 <b><code>dpi</code></b>라는 매개변수가 사용되었습니다.</p></li><li><p><b>Axes를 가로세로 구간으로 나누어 각 구간 안에 들어오는 점의 수를 세는 것</b>입니다.</p></li><li><p><b>음? Matplotlib hist2d랑 같은 것 아닌가 모르겠습니다?</b></p></li></ul><h1 id="6-Matplotlib-hist2d-vs-mpl-scatter-density"><a href="#6-Matplotlib-hist2d-vs-mpl-scatter-density" class="headerlink" title="6. Matplotlib hist2d vs mpl-scatter-density"></a>6. Matplotlib hist2d vs mpl-scatter-density</h1><ul><li><p><b>Matplotlib hist2d와 1:1로 비교</b>합니다.</p></li><li><p>Matplotlib hist2d는 <code>bins</code> 매개변수로 해상도를 조절합니다.</p></li><li><p>두 명령을 번갈아 사용하며 다양한 <code>bins</code>와 <code>dpi</code> 매개변수를 적용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(nrows=<span class="number">2</span>, ncols=<span class="number">4</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>), subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;scatter_density&quot;</span>&#125;,</span><br><span class="line">                         sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>,</span><br><span class="line">                         gridspec_kw=&#123;<span class="string">&quot;wspace&quot;</span>:<span class="number">0.1</span>, <span class="string">&quot;hspace&quot;</span>:<span class="number">0.15</span>&#125;, constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># hist2d</span></span><br><span class="line">axs_h2 = axes[<span class="number">0</span>, :]</span><br><span class="line">bins = [<span class="number">20</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">160</span>]</span><br><span class="line"><span class="keyword">for</span> ax, b <span class="keyword">in</span> <span class="built_in">zip</span>(axs_h2, bins):</span><br><span class="line">    ax.hist2d(x, y, bins=b, cmap=cmap)</span><br><span class="line">    ax.set_title(<span class="string">f&quot;\n\nbins=<span class="subst">&#123;b&#125;</span>&quot;</span>, fontsize=<span class="string">&quot;x-large&quot;</span>)</span><br><span class="line">fig.text(<span class="number">0.5</span>, <span class="number">0.95</span>, <span class="string">&quot;Matplotlib hist2d&quot;</span>, ha=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;xx-large&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># scatter_density</span></span><br><span class="line">axs_sd = axes[<span class="number">1</span>, :]</span><br><span class="line">dpis = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">36</span>, <span class="number">60</span>]</span><br><span class="line"><span class="keyword">for</span> ax, d <span class="keyword">in</span> <span class="built_in">zip</span>(axs_sd, dpis):</span><br><span class="line">    ax.scatter_density(x, y, dpi=d, cmap=cmap)</span><br><span class="line">    ax.set_title(<span class="string">f&quot;\ndpi=<span class="subst">&#123;d&#125;</span>&quot;</span>, fontsize=<span class="string">&quot;x-large&quot;</span>)</span><br><span class="line">fig.text(<span class="number">0.5</span>, <span class="number">0.45</span>, <span class="string">&quot;scatter-density&quot;</span>, ha=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;xx-large&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="90_density2d_05.png"><br></p></li><li><p><b>두 명령의 결과가 거의 동일합니다</b></p></li><li><p>원리가 같기 때문에 당연한 결과입니다. 실행 시간도 체감할 수 없을만큼 차이가 나지 않습니다.</p></li><li><p>둘이 만드는 객체를 비교합니다. 먼저 Matplotlib hist2d입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Matplotlib hist2d</span></span><br><span class="line">axes[<span class="number">0</span>, <span class="number">0</span>].get_children()[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;matplotlib.collections.QuadMesh at 0x7f1d06764510&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>이번에는 scatter-density 입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># scatter-density</span></span><br><span class="line">axes[<span class="number">1</span>, <span class="number">0</span>].get_children()[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mpl_scatter_density.scatter_density_artist.ScatterDensityArtist at 0x7f1d066f97d0&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li>별도의 라이브러리를 사용하고 projection을 따로 지정하는 만큼 별도의 객체를 생성하고 있습니다.</li></ul><h1 id="7-결론"><a href="#7-결론" class="headerlink" title="7. 결론"></a>7. 결론</h1><ul><li>scatter-density는 원리와 출력물의 외관이 Matplotlib hist2d와 같은 결과물을 내놓습니다.</li><li>라이브러리가 크게 부담스럽지 않아 추가로 설치하는 것은 괜찮습니다.</li><li>그러나 함수의 매개변수가 적어 표현력이 제한되어 있고 결과물이 Matplotlib 표준이 아니라는 점이 아쉽습니다.</li><li>특별한 이유가 있지 않다면 <b>Matplotlib hist2d를 사용하는 것을 권장드립니다.</b></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/scatter-density/">scatter-density</category>
      
      
    </item>
    
    <item>
      <title>material property visualization</title>
      <link>https://jehyunlee.github.io/2021/11/17/Python-DS-89_matprop/</link>
      <guid>https://jehyunlee.github.io/2021/11/17/Python-DS-89_matprop/</guid>
      <pubDate>Wed, 17 Nov 2021 04:50:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;초심자를 위한 소재 물성 시각화 tutorial입니다.&lt;/li&gt;
&lt;li&gt;여러 물질의 friction stress와 elastic modulus 데이터를 읽어들이고,&lt;/li&gt;
&lt;li&gt;이들의 연산 결과를 막대 그래프로 표현하고 강조하는 과</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>초심자를 위한 소재 물성 시각화 tutorial입니다.</li><li>여러 물질의 friction stress와 elastic modulus 데이터를 읽어들이고,</li><li>이들의 연산 결과를 막대 그래프로 표현하고 강조하는 과정입니다.</li></ul><h1 id="1-논문-데이터-추출"><a href="#1-논문-데이터-추출" class="headerlink" title="1. 논문 데이터 추출"></a>1. 논문 데이터 추출</h1><blockquote><p><a href="https://www.sciencedirect.com/science/article/pii/S1359645419302174?via=ihub">Yoshida et al, Acta Materialia, “Effect of elemental combination on friction stress and Hall-Petch relationship in face-centered cubic high / medium entropy alloys” (2020)</a></p></blockquote><ul><li><p>실제 논문에 출판된 데이터와 그림을 활용합니다.<br><br><img src="89_matprop_17.png"><br></p></li><li><p>본 논문은 데이터를 파일로 제공하지 않습니다.</p></li><li><p>그러나 다행히 데이터 수가 많지 않아 한땀한땀 손으로 정리할 수 있었습니다.</p></li><li><p><a href="frictionstress.xlsx">엑셀에서 정리된 데이터를 여기서 다운로드합니다. (Link)</a></p></li></ul><h1 id="2-데이터-시각화-Excel"><a href="#2-데이터-시각화-Excel" class="headerlink" title="2. 데이터 시각화 @Excel"></a>2. 데이터 시각화 @Excel</h1><ul><li><p>엑셀에서 데이터를 불러옵니다.<br><br><img src="89_matprop_12.png" alt="drawing" width="400"/><br></p></li><li><p>논문의 Figure 5는 friction stress $\sigma_0$을 elastic modulus $E$로 normalize한 값을 그린 것입니다.</p></li><li><p>불러온 데이터에는 항목이 없으므로 수식을 입력해 만듭니다.<br><br><img src="89_matprop_13.png" alt="drawing" width="400"/><br></p></li></ul><ul><li>셀 하나에 수식을 입력하고 긁으면 모든 소재의 데이터가 생성됩니다.</li><li>엑셀은 이럴 때 참 편리합니다.<br><br><img src="89_matprop_14.png" alt="drawing" width="400"/><br></li></ul><ul><li><p><b>가로 막대 그래프</b>를 그립니다.</p></li><li><p>원본의 세로 막대 그래프는 소재명이 90º 회전해 있어 읽기 힘들기 때문입니다.<br><br><img src="89_matprop_15.png" alt="drawing" width="400"/><br></p></li><li><p>방금 만든 데이터를 기준으로 전체 데이터를 <b>오름차순 정렬</b>합니다. </p></li><li><p>글자 크기, bar 색상, 윤곽선 색과 굵기 등을 조정합니다.</p></li></ul><ul><li>막대를 한 번 클릭하여 전체 막대를 선택 후 전체 색을 바꾼 뒤,</li><li>해당 막대를 한 번씩 클릭하여 면과 선의 색상을 선택합니다.<ul><li><b>총 20번 가량 클릭</b>해야 합니다.</li><li>막대 하나당 막대 + 면 색 + 선 색 + 선 굵기 조정 <b>4회</b> 클릭을 해야 하기 때문입니다.</li></ul></li></ul><ul><li>여기서는 Friction Stress가 <b>0.6보다 큰 데이터</b>에 의미가 있고,</li><li>$\text{(CoNi)}_{80}\text{Cr}_{20}$ 데이터가 중요한 데이터라고 가정하고 강조했습니다.</li><li>과정은 생략했습니다. <b>캡처하다 지쳤습니다 (…)</b><br><br><img src="89_matprop_16.png" alt="drawing" width="400"/><br></li></ul><h1 id="3-데이터-시각화-Python"><a href="#3-데이터-시각화-Python" class="headerlink" title="3. 데이터 시각화 @Python"></a>3. 데이터 시각화 @Python</h1><ul><li>이와 유사한 그림을 python에서 그립니다.</li><li>순서는 똑같습니다.</li><li><b>데이터를 불러오고, 처리하고, 그림을 그리고, 수정합니다.</b></li></ul><h2 id="3-1-데이터-불러오기"><a href="#3-1-데이터-불러오기" class="headerlink" title="3.1. 데이터 불러오기"></a>3.1. 데이터 불러오기</h2><ul><li><p>pandas를 이용해서 데이터를 읽습니다.</p></li><li><p>pandas는 python에서 사용하는 엑셀 같은 라이브러리입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df_fs = pd.read_excel(<span class="string">&quot;frictionstress.xlsx&quot;</span>)</span><br><span class="line">df_fs</span><br></pre></td></tr></table></figure><p><img src="89_matprop_01.png"><br></p></li><li><p>읽은 파일에서 x, y 인자를 뽑아냅니다.</p></li><li><p>pandas로 읽은 데이터는 컴퓨터가 DataFrame이라는 형식으로 가지고 있습니다.</p></li><li><p>DataFrame에서 첫번째 열을 가지고 오는 명령은 <code>df.iloc[:, 0].values.copy()</code> 입니다.</p><ul><li><b><code>df.iloc[:, 0]</code> :</b> df라는 데이터프레임의 첫번째 열, 모든 행을 선택한다는 뜻입니다.<br>두 번째, 세 번째 열은 <b><code>열의 위치 - 1</code></b>을 입력하여 1, 2를 넣습니다.</li><li><b><code>.values</code> :</b> index 없이 데이터 값만 가져오라는 뜻입니다.</li><li><b><code>.copy()</code> :</b> 사본을 만듭니다. 그렇지 않으면 원본 데이터가 훼손될 수 있습니다.</li></ul></li><li><p>friction stress를 elastic modulus로 나눠 변수를 생성합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 합금 이름</span></span><br><span class="line">alloy = df_fs.iloc[:, <span class="number">0</span>].values.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># elastic modulus</span></span><br><span class="line">ela = df_fs.iloc[:, <span class="number">1</span>].values.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># friction stress</span></span><br><span class="line">sigma = df_fs.iloc[:, <span class="number">2</span>].values.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># normalized friction stress</span></span><br><span class="line">sigma_norm = sigma / ela</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-2-가로-막대-그래프-그리기"><a href="#3-2-가로-막대-그래프-그리기" class="headerlink" title="3.2. 가로 막대 그래프 그리기"></a>3.2. 가로 막대 그래프 그리기</h2><ul><li><p>시각화 라이브러리로 matplotlib을 사용합니다.</p></li><li><p>그 중에서도 그림을 그리는 명령어들이 들어있는 <code>matplotlib.pyplot</code>을 불러옵니다.</p></li><li><p>저 이름을 다 쓰기 힘드니 <code>plt</code>라는 별명을 지어줍니다.</p></li><li><p>한편 seaborn을 사용해서 전체적인 색상과 글꼴 크기를 설정합니다.</p></li><li><p>seaborn도 <code>sns</code>라는 별명을 지어서 데려옵니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br></pre></td></tr></table></figure></li><li><p>이제 그림을 그립니다.</p></li></ul><ul><li>그래프를 그리기 전 도화지를 깔고 네모칸을 치듯 같은 작업을 합니다.</li><li>도화지는 Figure, 데이터가 들어가는 네모칸은 Axes라고 합니다.</li><li>각기 <code>fig</code>, <code>ax</code>라고 이름을 지어줍니다.</li><li>이 공간을 한 번에 만드는 명령은 <code>plt.subplots()</code>입니다.</li><li>그림 크기<code>figsize</code>를 <code>(6, 6)</code>으로 지정합니다. 단위는 인치입니다.</li></ul><ul><li>가로 막대 그래프 명령은 <code>barh(독립변수, 종속변수)</code>입니다.</li><li>가로 막대 그래프이기 때문에 독립변수가 y축에, 종속변수가 x축에 놓입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 시각화 설정</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line">sns.set_style(<span class="string">&quot;white&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 시각화</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line">ax.barh(alloy, sigma_norm)</span><br></pre></td></tr></table></figure><img src="89_matprop_02.png"><br></li></ul><h2 id="3-3-데이터-순서-정렬"><a href="#3-3-데이터-순서-정렬" class="headerlink" title="3.3. 데이터 순서 정렬"></a>3.3. 데이터 순서 정렬</h2><ul><li>순서가 들쭉날쭉이라 보기 좋지 않습니다.</li><li>물질명이나 데이터 순으로 정렬을 해 주면 훨씬 좋아집니다.</li><li>데이터 크기 순으로 정렬합니다.</li></ul><ul><li><p>pandas에서 정렬하는 명령은 <code>sort_values(정렬할 데이터)</code>입니다.</p></li><li><p>물질명과 데이터를 함께 정렬해야 하기 때문에 DataFrame에 <code>sigma_norm</code>을 추가하고 나서 전체 정렬합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df_fs[<span class="string">&quot;sigma_norm&quot;</span>] = sigma_norm</span><br><span class="line">df_fs = df_fs.sort_values(<span class="string">&quot;sigma_norm&quot;</span>)</span><br><span class="line">df_fs</span><br></pre></td></tr></table></figure><p><img src="89_matprop_03.png"><br></p></li><li><p>크기 순으로 잘 정렬되었습니다.</p></li><li><p>다시 데이터를 뽑아서 다시 그립니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alloy = df_fs.iloc[:, <span class="number">0</span>].values.copy()</span><br><span class="line">sigma_norm = df_fs.iloc[:, <span class="number">3</span>].values.copy()</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line">ax.barh(alloy, sigma_norm)</span><br></pre></td></tr></table></figure><p><img src="89_matprop_04.png"><br></p></li></ul><h2 id="3-4-그래프-꾸미기"><a href="#3-4-그래프-꾸미기" class="headerlink" title="3.4. 그래프 꾸미기"></a>3.4. 그래프 꾸미기</h2><ul><li>엑셀에서 막대를 선택할 때는 클릭을 했습니다.</li><li>python에서 막대를 선택할 때는 막대 객체(object)를 부릅니다.</li><li>여기서 막대를 부르는 명령은 <code>patches()</code>입니다.</li><li><b><code>bars = ax.patches()</code></b>라는 명령을 내리면 막대들이 list 형식으로 저장됩니다.</li><li>여기에 <b><code>[순서-1]</code></b>을 넣어서 특정 막대를 지정합니다. 뒤에서부터 셀 때는 음수로 셉니다.</li></ul><ul><li><p>이렇게 특정한 막대에 색을 칠합니다.</p></li><li><p>면 색을 칠하는 명령은 <code>set_facecolor()</code></p></li><li><p>윤곽선을 칠하는 명령은 <code>set_edgecolor()</code></p></li><li><p>윤곽선 두께를 지정하는 명령은 <code>set_linewidth()</code>입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line">ax.barh(alloy, sigma_norm, fc=<span class="string">&quot;lightgray&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 막대들 모으기</span></span><br><span class="line">bars = ax.patches</span><br><span class="line">bars[-<span class="number">3</span>].set_facecolor(<span class="string">&quot;yellow&quot;</span>)</span><br><span class="line">bars[-<span class="number">3</span>].set_edgecolor(<span class="string">&quot;k&quot;</span>)</span><br><span class="line">bars[-<span class="number">3</span>].set_linewidth(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="89_matprop_05.png"><br></p></li><li><p>노랗게 칠한 위에서 세번째 막대(<code>bars[-3]</code>)외는 모두 회색입니다.</p></li><li><p><code>ax.barh()</code>에 <code>fc=&#39;lightgray&#39;</code>를 넣어서 그렇습니다.</p></li><li><p>fc는 facecolor의 약자입니다. <code>facecolor=&#39;lightgray&#39;</code>라고 넣어도 똑같습니다.</p></li></ul><ul><li>이제 <b>0.6이 넘는 물질들을 색칠</b>합니다.</li><li>반복작업에는 <code>for</code>를 사용합니다.</li><li><code>for bar in bars</code>라고 하면, bars에 포함된 요소들을 bar라는 이름으로 하나씩 가져옵니다.</li><li>그리고 bar의 길이가 0.6이 넘으면 색을 바꿉니다. </li><li>조건문은 <code>if</code>입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line">ax.barh(alloy, sigma_norm, fc=<span class="string">&quot;lightgray&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 막대들 모으기</span></span><br><span class="line">bars = ax.patches</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> bar <span class="keyword">in</span> bars:</span><br><span class="line">    <span class="keyword">if</span> bar.get_width() &gt; <span class="number">0.6</span>:</span><br><span class="line">        bar.set_facecolor(<span class="string">&quot;orange&quot;</span>)</span><br><span class="line">        bar.set_linewidth(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">bars[-<span class="number">3</span>].set_facecolor(<span class="string">&quot;yellow&quot;</span>)</span><br><span class="line">bars[-<span class="number">3</span>].set_edgecolor(<span class="string">&quot;k&quot;</span>)</span><br><span class="line">bars[-<span class="number">3</span>].set_linewidth(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><img src="89_matprop_18.png"><br></li></ul><h2 id="3-5-제목-달기"><a href="#3-5-제목-달기" class="headerlink" title="3.5. 제목 달기"></a>3.5. 제목 달기</h2><ul><li>제목을 다는 명령은 <code>set_title()</code>입니다.</li><li><code>pad</code>를 넣으면 네모칸(Axes)과 제목 사이 띄우는 거리를 지정합니다.</li><li><b>$\TeX$</b>를 지원합니다. <a href="https://matplotlib.org/stable/tutorials/text/mathtext.html">자세한 사례는 여기를 참고합시다: Link</a></li><li><a href="https://matplotlib.org/stable/tutorials/text/usetex.html">더 자세히 알고 싶으면 여기를 보셔도 좋습니다: Link</a></li><li>위 첨자나 그리스어 같은 수학식을 사용할 때는 $ 두 개 사이에 TeX 문법을 사용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line">ax.barh(alloy, sigma_norm, fc=<span class="string">&quot;lightgray&quot;</span>)</span><br><span class="line"></span><br><span class="line">bars = ax.patches</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> bar <span class="keyword">in</span> bars:</span><br><span class="line">    <span class="keyword">if</span> bar.get_width() &gt; <span class="number">0.6</span>:</span><br><span class="line">        bar.set_facecolor(<span class="string">&quot;orange&quot;</span>)</span><br><span class="line">        bar.set_linewidth(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">bars[-<span class="number">3</span>].set_facecolor(<span class="string">&quot;yellow&quot;</span>)</span><br><span class="line">bars[-<span class="number">3</span>].set_edgecolor(<span class="string">&quot;k&quot;</span>)</span><br><span class="line">bars[-<span class="number">3</span>].set_linewidth(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 제목 달기</span></span><br><span class="line">ax.set_title(<span class="string">&quot;Friction Stress ($\sigma_0 / E$, 10$^&#123;-3&#125;$)&quot;</span>, pad=<span class="number">20</span>)</span><br></pre></td></tr></table></figure><img src="89_matprop_19.png"><br></li></ul><h2 id="3-6-x축-눈금-지정"><a href="#3-6-x축-눈금-지정" class="headerlink" title="3.6. x축 눈금 지정"></a>3.6. x축 눈금 지정</h2><ul><li>엑셀에서 0부터 0.3 간격으로 1.2까지 x축 눈금을 지정했습니다.</li><li>우리 그림은 0부터 0.25 간격으로 1.0까지 있고, 그 이상은 눈금이 없습니다.</li><li>x축 눈금 지정 명령은 <code>set_xticks()</code>입니다. 여기에 <code>[0. 0.3, 0.6, 0.9, 1.2]</code>를 넣습니다.</li></ul><ul><li>일일이 치기 귀찮으면 수치 연산을 담당하는 numpy 기능을 사용하면 좋습니다. </li><li><code>import numpy as np</code>로 numpy를 불러오고,</li><li><code>xticks= np.linspace(0, 1.2, 5)</code>라고 하면 0에서 1.2까지 5등분한 결과가 들어갑니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line">ax.barh(alloy, sigma_norm, fc=<span class="string">&quot;lightgray&quot;</span>)</span><br><span class="line"></span><br><span class="line">bars = ax.patches</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> bar <span class="keyword">in</span> bars:</span><br><span class="line">    <span class="keyword">if</span> bar.get_width() &gt; <span class="number">0.6</span>:</span><br><span class="line">        bar.set_facecolor(<span class="string">&quot;orange&quot;</span>)</span><br><span class="line">        bar.set_linewidth(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">bars[-<span class="number">3</span>].set_facecolor(<span class="string">&quot;yellow&quot;</span>)</span><br><span class="line">bars[-<span class="number">3</span>].set_edgecolor(<span class="string">&quot;k&quot;</span>)</span><br><span class="line">bars[-<span class="number">3</span>].set_linewidth(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">ax.set_title(<span class="string">&quot;Friction Stress ($\sigma_0 / E$, 10$^&#123;-3&#125;$)&quot;</span>, pad=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># x축 눈금 지정</span></span><br><span class="line">xticks = np.linspace(<span class="number">0</span>, <span class="number">1.2</span>, <span class="number">5</span>)</span><br><span class="line">ax.set_xticks(xticks)</span><br></pre></td></tr></table></figure><img src="89_matprop_20.png"><br></li></ul><h2 id="3-7-엑셀-재현은-여기까지"><a href="#3-7-엑셀-재현은-여기까지" class="headerlink" title="3.7. 엑셀 재현은 여기까지."></a>3.7. 엑셀 재현은 여기까지.</h2><ul><li>여기까지 엑셀에서 만든 그림을 재현했습니다.</li><li>잘 몰라도 클릭을 하면 메뉴가 화면에 떠서 찾아볼 수 있는 엑셀이랑 좀 다릅니다.</li><li>명령어를 알아야 그림을 고칠 수 있고 타이핑을 해야 하기 때문에 적잖이 불편할 수도 있습니다.</li></ul><ul><li>하지만 <b>코딩의 장점은 자동화</b>에 있습니다.</li><li>같은 작업을 여러번 해야 한다면 엑셀에서 여는 것보다 코드를 저장해두는 편이 이득입니다.</li></ul><h1 id="4-엑셀을-넘어서"><a href="#4-엑셀을-넘어서" class="headerlink" title="4. 엑셀을 넘어서"></a>4. 엑셀을 넘어서</h1><ul><li>엑셀의 표현력을 뛰어넘어 봅시다.</li><li><b>텍스트에 아래 첨자</b>를 넣고</li><li><b>텍스트마다 다른 색</b>을 칠합니다.</li><li>찾아보니 엑셀에서 안 되는 건 아닌 듯 한데 많이 성가신 듯 합니다. (쉽게 하시는 분 제보주세요)</li></ul><h2 id="4-1-테두리-제거-배경-눈금-추가"><a href="#4-1-테두리-제거-배경-눈금-추가" class="headerlink" title="4.1. 테두리 제거, 배경 눈금 추가"></a>4.1. 테두리 제거, 배경 눈금 추가</h2><ul><li>네모난 테두리 중 맨 왼쪽을 제외하면 쓸모가 없습니다. </li><li>필요가 없는 것은 과감히 지웁니다.</li><li>테두리는 <code>spines</code>라고 부르고, 안 보이는 명령은 <code>set_visible(False)</code>입니다.</li></ul><ul><li>배경 눈금을 넣는 명령은 <code>grid</code>입니다.</li><li>x축 눈금에서 올리는 눈금이므로 <code>axis=&#39;x&#39;</code>를 넣습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line">ax.barh(alloy, sigma_norm, fc=<span class="string">&quot;lightgray&quot;</span>)</span><br><span class="line"></span><br><span class="line">bars = ax.patches</span><br><span class="line"><span class="keyword">for</span> bar <span class="keyword">in</span> bars:</span><br><span class="line">    <span class="keyword">if</span> bar.get_width() &gt; <span class="number">0.6</span>:</span><br><span class="line">        bar.set_facecolor(<span class="string">&quot;orange&quot;</span>)</span><br><span class="line">        bar.set_linewidth(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">bars[-<span class="number">3</span>].set_facecolor(<span class="string">&quot;yellow&quot;</span>)</span><br><span class="line">bars[-<span class="number">3</span>].set_edgecolor(<span class="string">&quot;k&quot;</span>)</span><br><span class="line">bars[-<span class="number">3</span>].set_linewidth(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">ax.set_title(<span class="string">&quot;Friction Stress ($\sigma_0 / E$, 10$^&#123;-3&#125;$)&quot;</span>, pad=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">xticks = np.linspace(<span class="number">0</span>, <span class="number">1.2</span>, <span class="number">5</span>)</span><br><span class="line">ax.set_xticks(xticks)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 테두리 지우기</span></span><br><span class="line">ax.spines[[<span class="string">&quot;top&quot;</span>, <span class="string">&quot;right&quot;</span>, <span class="string">&quot;bottom&quot;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 눈금 넣기</span></span><br><span class="line">ax.grid(axis=<span class="string">&quot;x&quot;</span>)</span><br></pre></td></tr></table></figure><img src="89_matprop_21.png"><br></li></ul><h2 id="4-2-물질명-아래첨자-추가"><a href="#4-2-물질명-아래첨자-추가" class="headerlink" title="4.2. 물질명 아래첨자 추가"></a>4.2. 물질명 아래첨자 추가</h2><ul><li>맨 위 물질명이 $\text{Co20(CrNi)80}$이라고 되어 있는데,</li><li>20과 80은 조성을 표현하는 숫자이므로 $\text{Co}_{20}\text{(CrNi)}_{80}$ 이어야 합니다.</li><li>독립변수인 alloy에서 아래첨자가 적용될 것들을 바꾼 뒤 <code>set_yticklabels()</code>로 넣으면 적용됩니다.</li><li>이 때 눈금 레이블이 붙을 자리를 알려주는 <code>set_yticks()</code>가 함께 가야 합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line">ax.barh(alloy, sigma_norm, fc=<span class="string">&quot;lightgray&quot;</span>)</span><br><span class="line"></span><br><span class="line">bars = ax.patches</span><br><span class="line"><span class="keyword">for</span> bar <span class="keyword">in</span> bars:</span><br><span class="line">    <span class="keyword">if</span> bar.get_width() &gt; <span class="number">0.6</span>:</span><br><span class="line">        bar.set_facecolor(<span class="string">&quot;orange&quot;</span>)</span><br><span class="line">        bar.set_linewidth(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">bars[-<span class="number">3</span>].set_facecolor(<span class="string">&quot;yellow&quot;</span>)</span><br><span class="line">bars[-<span class="number">3</span>].set_edgecolor(<span class="string">&quot;k&quot;</span>)</span><br><span class="line">bars[-<span class="number">3</span>].set_linewidth(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">ax.set_title(<span class="string">&quot;Friction Stress ($\sigma_0 / E$, 10$^&#123;-3&#125;$)&quot;</span>, pad=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">xticks = np.linspace(<span class="number">0</span>, <span class="number">1.2</span>, <span class="number">5</span>)</span><br><span class="line">ax.set_xticks(xticks)</span><br><span class="line"></span><br><span class="line">ax.spines[[<span class="string">&quot;top&quot;</span>, <span class="string">&quot;right&quot;</span>, <span class="string">&quot;bottom&quot;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line">ax.grid(axis=<span class="string">&quot;x&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># alloy 이름에 아래첨자 추가</span></span><br><span class="line">yticks = ax.get_yticks()</span><br><span class="line">yticklabels = alloy</span><br><span class="line">yticklabels[<span class="number">1</span>] = <span class="string">&quot;(CoNi)$_&#123;95&#125;$Cr$_5$&quot;</span></span><br><span class="line">yticklabels[-<span class="number">3</span>] = <span class="string">&quot;(CoNi)$_&#123;80&#125;$Cr$_&#123;20&#125;$&quot;</span></span><br><span class="line">yticklabels[-<span class="number">1</span>] = <span class="string">&quot;Co$_&#123;20&#125;$(CrNi)$_&#123;80&#125;$&quot;</span></span><br><span class="line">ax.set_yticks(yticks)</span><br><span class="line">ax.set_yticklabels(yticklabels)</span><br></pre></td></tr></table></figure><img src="89_matprop_22.png"><br></li></ul><h2 id="4-3-물질-이름-글꼴-색-크기"><a href="#4-3-물질-이름-글꼴-색-크기" class="headerlink" title="4.3. 물질 이름 글꼴 색, 크기"></a>4.3. 물질 이름 글꼴 색, 크기</h2><ul><li>특정 막대만 다시 칠했던 것과 같은 요령으로 특정 글자만 색을 바꿉니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yticks = ax.get_yticks()</span><br><span class="line">yticklabels = ax.get_yticklabels()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 물질 이름 색상, 크기 수정</span></span><br><span class="line"><span class="keyword">for</span> bar, ytl <span class="keyword">in</span> <span class="built_in">zip</span>(bars, yticklabels):</span><br><span class="line">    <span class="keyword">if</span> bar.get_width() &gt; <span class="number">0.6</span>:</span><br><span class="line">        ytl.set_color(<span class="string">&quot;peru&quot;</span>)</span><br><span class="line">    ytl.set_fontsize(<span class="string">&quot;small&quot;</span>)</span><br><span class="line">        </span><br><span class="line">yticklabels[-<span class="number">3</span>].set_fontweight(<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">yticklabels[-<span class="number">3</span>].set_fontsize(<span class="string">&quot;medium&quot;</span>)</span><br><span class="line"></span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure><img src="89_matprop_23.png"><br></li></ul><h2 id="4-4-그림을-파일로-저장"><a href="#4-4-그림을-파일로-저장" class="headerlink" title="4.4. 그림을 파일로 저장"></a>4.4. 그림을 파일로 저장</h2><ul><li>파일을 그림으로 저장하기도 수월합니다.</li><li><code>fig.savefig(파일명)</code>을 하면 되는데,</li><li><code>fig.tight_layout()</code>을 붙여 주면 그림이 잘리는 일이 예방됩니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig.tight_layout()</span><br><span class="line">fig.savefig(<span class="string">&quot;matprop.png&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-5-마치며"><a href="#4-5-마치며" class="headerlink" title="4.5. 마치며"></a>4.5. 마치며</h2><ul><li>엑셀에서 그릴 수 있는 그림을 <b>굳이</b> 파이썬으로 그렸습니다.</li><li>파이썬을 처음 접하는 분들께는 낯설고 험한 길일 수 있습니다.</li><li>그러나 처음의 고비를 넘으면 엑셀에서는 상상도 못할 그림을 그릴 수 있습니다.</li></ul><p><img src="89_matprop_24.png" alt="https://github.com/rougier/scientific-visualization-book"><br></p><ul><li>위 그림은 Nicolas Rougier라는 분이 Matplotlib으로 그린 그림입니다.</li><li>뚜벅뚜벅, 남들과 다른 퀄리티를 향해 한 걸음 떼어보시기 바랍니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      
    </item>
    
    <item>
      <title>solar radiation - time and space</title>
      <link>https://jehyunlee.github.io/2021/11/09/Python-DS-88_gpd_mpl/</link>
      <guid>https://jehyunlee.github.io/2021/11/09/Python-DS-88_gpd_mpl/</guid>
      <pubDate>Tue, 09 Nov 2021 10:38:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;한국에너지기술연구원은 천리안 위성 기반 전국 전일사량 데이터를 제공합니다.&lt;/li&gt;
&lt;li&gt;천리안 1호 위성 데이터는 2012년 1월부터 2019년 12월까지,&lt;/li&gt;
&lt;li&gt;천리안 2호 위성 데이터는 2019년 9월부터 2020년 </description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>한국에너지기술연구원은 천리안 위성 기반 전국 전일사량 데이터를 제공합니다.</li><li>천리안 1호 위성 데이터는 2012년 1월부터 2019년 12월까지,</li><li>천리안 2호 위성 데이터는 2019년 9월부터 2020년 8월까지 데이터를 제공합니다.</li><li>이 데이터 중 천리안 1호 데이터를 받아 분석합니다.</li></ul><h1 id="1-데이터-다운로드"><a href="#1-데이터-다운로드" class="headerlink" title="1. 데이터 다운로드"></a>1. 데이터 다운로드</h1><blockquote><p><a href="https://www.data.go.kr/data/15066413/fileData.do">공공데이터포털 신재생자원지도 데이터: 태양자원 천리안 1호 수평면 전일사량</a></p></blockquote><p><img src="88_gpd_mpl_28.png"><br></p><ul><li>다운로드를 클릭하면 189 MB짜리 .csv 파일이 다운로드 됩니다.</li><li>파일 이름은 <code>한국에너지기술연구원_신재생자원지도데이터_태양자원_천리안1호_수평면전일사량_20191231.csv</code>입니다.</li></ul><h1 id="2-데이터-분석"><a href="#2-데이터-분석" class="headerlink" title="2. 데이터 분석"></a>2. 데이터 분석</h1><h2 id="2-1-기본-설정"><a href="#2-1-기본-설정" class="headerlink" title="2.1. 기본 설정"></a>2.1. 기본 설정</h2><ul><li>주피터 노트북을 열고 기본 설정을 합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 시각화 설정</span></span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line">sns.set_style(<span class="string">&quot;white&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 한글 사용 설정</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>]=[<span class="string">&#x27;NanumGothic&#x27;</span>, <span class="string">&#x27;sans-serif&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2-데이터-불러오기"><a href="#2-2-데이터-불러오기" class="headerlink" title="2.2. 데이터 불러오기"></a>2.2. 데이터 불러오기</h2><ul><li><p>작업폴더 아래 <code>data</code>폴더를 만들고 다운받은 파일을 넣습니다.</p></li><li><p>pandas를 이용해 데이터를 불러옵니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">&quot;./data/한국에너지기술연구원_신재생자원지도데이터_태양자원_천리안1호_수평면전일사량_20191231.csv&quot;</span>, </span><br><span class="line">                 encoding=<span class="string">&quot;euc-kr&quot;</span>)  <span class="comment"># 한글 인코딩</span></span><br><span class="line">df.to_pickle(<span class="string">&quot;./data/KIER.pkl&quot;</span>)      <span class="comment"># 백업</span></span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><p><img src="88_gpd_mpl_19.png"><br></p></li><li><p>위도와 경도, 그리고 시간별 숫자가 있습니다.</p></li><li><p>위도와 경도는 지구상의 지점을 지칭하고 시간별 숫자는 월별 평균 일사량을 구합니다.</p></li><li><p>직진에 의해 태양으로부터 전달되는 일사량과 구름에 의해 산란된 값을 합친 값입니다.</p></li><li><p>산란된 일사량을 산란일사라고 하는데, 에너지기술연구원에서는 도메인 지식 기반으로 계산하여 추론합니다.</p></li></ul><ul><li><p>데이터 형상을 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.shape</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(291924, 98)</span><br></pre></td></tr></table></figure></li><li><p>약 100개 가량의 열과 30만개 행으로 구성되어 있습니다.</p></li><li><p>98개 행은 12개월 x 8년 + 위도, 경도입니다.</p></li></ul><h1 id="3-시간에-대한-변화"><a href="#3-시간에-대한-변화" class="headerlink" title="3. 시간에 대한 변화"></a>3. 시간에 대한 변화</h1><h2 id="3-1-광주광역시-데이터-추출"><a href="#3-1-광주광역시-데이터-추출" class="headerlink" title="3.1. 광주광역시 데이터 추출"></a>3.1. 광주광역시 데이터 추출</h2><ul><li>광주광역시의 좌표는 북위 35.1595º, 동경 126.8526º 입니다.</li><li>광주광역시와 가장 가까이 위치한 지점의 좌표를 탐색합니다.</li><li>위도와 경도 모두 가까워야 하므로 제곱의 합이 최소인 지점을 구합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 광주광역시 위경도 : 35.1595° N, 126.8526° E</span></span><br><span class="line">idx = np.argmin(np.power(df[<span class="string">&quot;lon&quot;</span>]-<span class="number">35.1595</span>, <span class="number">2</span>) + np.power(df[<span class="string">&quot;lat&quot;</span>]-<span class="number">126.8526</span>, <span class="number">2</span>))</span><br><span class="line">df.iloc[idx]</span><br></pre></td></tr></table></figure><img src="88_gpd_mpl_20.png"><br></li></ul><ul><li><p>시간에 대한 일사량을 확인하려면 시간과 일사량 데이터가 필요합니다.</p></li><li><p>월과 일사량 데이터를 가져옵니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">months = <span class="built_in">list</span>(df.columns)[<span class="number">2</span>:]</span><br><span class="line">irrs = df.iloc[idx][<span class="number">2</span>:]</span><br></pre></td></tr></table></figure></li><li><p>추출한 데이터를 그림으로 그립니다.</p></li><li><p><code>ax.set_title()</code>명령으로 데이터 이름을 제목으로 붙입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 변화율 시각화</span></span><br><span class="line">ax.plot(months, irrs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 제목 추가</span></span><br><span class="line">ax.set_title(<span class="string">&quot;수평면 전일사량 [kWh/(m$^2 \cdot$day)]&quot;</span>, pad=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><img src="88_gpd_mpl_15.png"><br></p></li></ul><h2 id="3-2-범위-및-눈금-간격-지정"><a href="#3-2-범위-및-눈금-간격-지정" class="headerlink" title="3.2. 범위 및 눈금 간격 지정"></a>3.2. 범위 및 눈금 간격 지정</h2><ul><li>x축 눈금이 빼곡하게 적혀서 보이지 않습니다.</li><li><code>MultipleLocator</code>를 사용해서 1월 데이터에만 눈금을 답니다.</li><li><code>ax.set_xlim()</code>을 사용해서 x축 범위를 지정합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.ticker <span class="keyword">import</span> MultipleLocator</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>, <span class="number">4</span>))</span><br><span class="line">ax.plot(months, irrs)</span><br><span class="line">ax.set_title(<span class="string">&quot;수평면 전일사량 [kWh/(m$^2 \cdot$day)]&quot;</span>, pad=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># x축 범위 지정</span></span><br><span class="line">ax.set_xlim(<span class="number">0</span>, <span class="built_in">len</span>(months)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># x축 눈금 간격 지정</span></span><br><span class="line">ax.xaxis.set_major_locator(MultipleLocator(<span class="number">12</span>))</span><br></pre></td></tr></table></figure><img src="88_gpd_mpl_16.png"><br></li></ul><h2 id="3-3-눈금-글자-크기-축소"><a href="#3-3-눈금-글자-크기-축소" class="headerlink" title="3.3. 눈금 글자 크기 축소"></a>3.3. 눈금 글자 크기 축소</h2><ul><li>글자를 조금 줄이면 좋을 것 같습니다.</li><li>일사량 데이터이므로 따뜻한 느낌을 주는 오렌지색으로 바꿉니다.</li><li>1월마다 눈금을 만들어 올립니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.ticker <span class="keyword">import</span> MultipleLocator</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>, <span class="number">4</span>))</span><br><span class="line">ax.plot(months, irrs, c=<span class="string">&quot;orange&quot;</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;수평면 전일사량 [kWh/(m$^2 \cdot$day)]&quot;</span>, pad=<span class="number">10</span>)</span><br><span class="line">ax.set_xlim(<span class="number">0</span>, <span class="built_in">len</span>(months)-<span class="number">1</span>)</span><br><span class="line">ax.xaxis.set_major_locator(MultipleLocator(<span class="number">12</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># x축과 y축 눈금 글자 크기 축소</span></span><br><span class="line">ax.tick_params(axis=<span class="string">&quot;both&quot;</span>, labelsize=<span class="string">&quot;small&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># x축 눈금에서 grid 생성</span></span><br><span class="line">ax.grid(axis=<span class="string">&quot;x&quot;</span>)</span><br></pre></td></tr></table></figure><img src="88_gpd_mpl_17.png"><br></li></ul><h2 id="3-4-선-아래-채색"><a href="#3-4-선-아래-채색" class="headerlink" title="3.4. 선 아래 채색"></a>3.4. 선 아래 채색</h2><ul><li>조금 심심하다 싶습니다.</li><li><code>ax.stackplot()</code>명령을 사용해 선 아래를 색으로 칠합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.ticker <span class="keyword">import</span> MultipleLocator</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># stackplot</span></span><br><span class="line">ax.stackplot(months, irrs, colors=<span class="string">&quot;orange&quot;</span>, ec=<span class="string">&quot;brown&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">ax.set_title(<span class="string">&quot;수평면 전일사량 [kWh/(m$^2 \cdot$day)]&quot;</span>, pad=<span class="number">10</span>)</span><br><span class="line">ax.set_xlim(<span class="number">0</span>, <span class="built_in">len</span>(months)-<span class="number">1</span>)</span><br><span class="line">ax.xaxis.set_major_locator(MultipleLocator(<span class="number">12</span>))</span><br><span class="line">ax.tick_params(axis=<span class="string">&quot;both&quot;</span>, labelsize=<span class="string">&quot;small&quot;</span>)</span><br><span class="line">ax.grid(axis=<span class="string">&quot;x&quot;</span>)</span><br></pre></td></tr></table></figure><img src="88_gpd_mpl_21.png"><br></li></ul><h1 id="4-공간-분포"><a href="#4-공간-분포" class="headerlink" title="4. 공간 분포"></a>4. 공간 분포</h1><h2 id="4-1-데이터-정돈"><a href="#4-1-데이터-정돈" class="headerlink" title="4.1. 데이터 정돈"></a>4.1. 데이터 정돈</h2><ul><li>한반도를 포함한 주변 영역의 데이터를 2차원 공간에 그립시다.</li><li>데이터프레임 컬럼 이름이 너무 깁니다.</li><li>단위는 따로 적어두면 됩니다. 불필요한 부분을 제거합시다.</li><li>위도와 경도도 영어로 바꿉니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cols = <span class="built_in">list</span>(df.columns)</span><br><span class="line">cols_short = [<span class="string">&quot;lon&quot;</span>, <span class="string">&quot;lat&quot;</span>] + [c.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>] <span class="keyword">for</span> c <span class="keyword">in</span> cols[<span class="number">2</span>:]]</span><br><span class="line">df.columns = cols_short</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><img src="88_gpd_mpl_22.png"><br></li></ul><h2 id="4-2-scatter-plot"><a href="#4-2-scatter-plot" class="headerlink" title="4.2. scatter plot"></a>4.2. scatter plot</h2><ul><li><p>2차원 공간에 데이터를 점으로 찍어서 그림을 그립니다.</p></li><li><p>2012년 1월 데이터만 그립니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.scatter(df[<span class="string">&quot;lat&quot;</span>], df[<span class="string">&quot;lon&quot;</span>], c=df[<span class="string">&quot;2012-01&quot;</span>], cmap=<span class="string">&quot;inferno&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="88_gpd_mpl_01.png"><br></p></li><li><p>Matplotlib에서 제공하는 그림 크기가 가로가 길고 세로가 작아 짓눌린 모양입니다.</p></li><li><p>세로로 긴 도화지를 깔고 종횡비(aspect ratio)를 1:1로 맞춥니다.</p></li><li><p>실제 형상을 반영하기 위해서입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">6.67</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.scatter(df[<span class="string">&quot;lat&quot;</span>], df[<span class="string">&quot;lon&quot;</span>], c=df[<span class="string">&quot;2012-01&quot;</span>], cmap=<span class="string">&quot;inferno&quot;</span>)</span><br><span class="line">ax.set_aspect(<span class="string">&quot;equal&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="88_gpd_mpl_02.png"><br></p></li></ul><h2 id="4-3-좌표계-변환"><a href="#4-3-좌표계-변환" class="headerlink" title="4.3. 좌표계 변환"></a>4.3. 좌표계 변환</h2><ul><li><p>위쪽이 넓고 아래가 좁은 모양입니다.</p></li><li><p>그림 아래와 왼쪽에 놓인 숫자는 경도와 위도입니다.</p></li><li><p>경도와 위도는 곡면상에 놓인 그림이기 때문에 이렇게 그리면 왜곡이 발생합니다.</p></li><li><p><code>pyproj</code> 라이브러리를 사용해 UTM-K 좌표계로 변경합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyproj <span class="keyword">import</span> Transformer</span><br><span class="line"></span><br><span class="line">transformer = Transformer.from_crs(<span class="string">&quot;epsg:4326&quot;</span>, <span class="string">&quot;epsg:5178&quot;</span>)</span><br><span class="line">coord_UTMK = transformer.transform(df[<span class="string">&quot;lon&quot;</span>], df[<span class="string">&quot;lat&quot;</span>])</span><br><span class="line">coord_UTMK</span><br></pre></td></tr></table></figure><p><img src="88_gpd_mpl_23.png"><br></p></li><li><p>변환된 좌표계를 기존 데이터에 붙여 데이터프레임을 만듭니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df_u = pd.DataFrame(data=np.array(coord_UTMK).T, columns=[<span class="string">&quot;y&quot;</span>, <span class="string">&quot;x&quot;</span>])</span><br><span class="line">df_u = pd.concat([df_u, df.iloc[:, <span class="number">2</span>:]], axis=<span class="number">1</span>)</span><br><span class="line">df_u.head()</span><br></pre></td></tr></table></figure><p><img src="88_gpd_mpl_24.png"><br></p></li></ul><h2 id="4-4-UTM-K-좌표계-scatter-plot"><a href="#4-4-UTM-K-좌표계-scatter-plot" class="headerlink" title="4.4. UTM-K 좌표계 scatter plot"></a>4.4. UTM-K 좌표계 scatter plot</h2><ul><li><p>변환된 좌표계를 사용해 scatter plot을 그립니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">6.67</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.scatter(df_u[<span class="string">&quot;x&quot;</span>], df_u[<span class="string">&quot;y&quot;</span>], c=df_u[<span class="string">&quot;2012-01&quot;</span>], cmap=<span class="string">&quot;inferno&quot;</span>)</span><br><span class="line">ax.set_aspect(<span class="string">&quot;equal&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="88_gpd_mpl_03.png"><br></p></li><li><p>이제 그림이 정상적으로 보입니다.</p></li><li><p>경기 동북부~강원도 서부 지역을 확대해 봅시다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">6.67</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.scatter(df_u[<span class="string">&quot;x&quot;</span>], df_u[<span class="string">&quot;y&quot;</span>], c=df_u[<span class="string">&quot;2012-01&quot;</span>], cmap=<span class="string">&quot;inferno&quot;</span>)</span><br><span class="line">ax.set_aspect(<span class="string">&quot;equal&quot;</span>)</span><br><span class="line">ax.set_xlim(<span class="number">1e6</span>, <span class="number">1e6</span>+<span class="number">10000</span>)</span><br><span class="line">ax.set_ylim(<span class="number">2e6</span>, <span class="number">2e6</span>+<span class="number">10000</span>)</span><br></pre></td></tr></table></figure><p><img src="88_gpd_mpl_04.png"><br></p></li><li><p>확대해보니 점만 가득합니다.</p></li><li><p>scatter plot이라 점만 찍어 그린 것입니다.</p></li><li><p>위쪽 그림을 보니 아래쪽에 굵은 펜이 지나간 듯한 흔적이 보이기도 합니다.</p></li></ul><ul><li><p>조금 더 넓게 봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">6.7</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">ax.scatter(df_u[<span class="string">&quot;x&quot;</span>].iloc[:<span class="number">1000</span>], </span><br><span class="line">           df_u[<span class="string">&quot;y&quot;</span>].iloc[:<span class="number">1000</span>], </span><br><span class="line">           c=df_u[<span class="string">&quot;2012-01&quot;</span>].iloc[:<span class="number">1000</span>], cmap=<span class="string">&quot;inferno&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="88_gpd_mpl_29.png"><br></p></li><li><p>가로 세로도 맞지 않습니다.</p></li><li><p>원래 데이터도 좀 이랬고, 좌표 변환의 여파이기도 합니다.</p></li></ul><h2 id="4-5-2D-image-변환"><a href="#4-5-2D-image-변환" class="headerlink" title="4.5. 2D image 변환"></a>4.5. 2D image 변환</h2><ul><li>이처럼 x와 y가 쌍으로 얽힌 데이터를 2D로 표현하는 가장 정석적인 방법은 meshgrid를 만드는 것입니다.</li><li>그러나 이는 x, y 데이터가 격자모양으로 예쁘게 정리되었을 때나 가능합니다.</li><li>위성 영상은 x, y 위치가 조금씩 틀어져있기 때문에 grid를 만들기 적절치 않습니다.</li><li>이럴 때 <code>triplot</code>, <code>tricontourf</code>, <code>tricontour</code>를 사용하기 좋습니다.</li></ul><ul><li><p>명령어의 기능을 확인하기 위해 30만개 데이터 중 100개만 추출합니다.</p></li><li><p>그리고 같은 데이터를 세 가지 명령을 사용해 그립니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">df_us = df_u.sample(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># visualize</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">9</span>, <span class="number">6.67</span>), sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>, constrained_layout=<span class="literal">True</span>)</span><br><span class="line">axs[<span class="number">0</span>].triplot(df_us[<span class="string">&quot;x&quot;</span>], df_us[<span class="string">&quot;y&quot;</span>], lw=<span class="number">0.5</span>)</span><br><span class="line">axs[<span class="number">1</span>].triplot(df_us[<span class="string">&quot;x&quot;</span>], df_us[<span class="string">&quot;y&quot;</span>], lw=<span class="number">0.5</span>, c=<span class="string">&quot;w&quot;</span>)</span><br><span class="line">axs[<span class="number">2</span>].triplot(df_us[<span class="string">&quot;x&quot;</span>], df_us[<span class="string">&quot;y&quot;</span>], lw=<span class="number">0.5</span>, c=<span class="string">&quot;k&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">1</span>].tricontourf(df_us[<span class="string">&quot;x&quot;</span>], df_us[<span class="string">&quot;y&quot;</span>], df_us[<span class="string">&quot;2012-01&quot;</span>], cmap=<span class="string">&quot;inferno&quot;</span>, levels=<span class="number">5</span>)</span><br><span class="line">axs[<span class="number">2</span>].tricontour(df_us[<span class="string">&quot;x&quot;</span>], df_us[<span class="string">&quot;y&quot;</span>], df_us[<span class="string">&quot;2012-01&quot;</span>], cmap=<span class="string">&quot;inferno&quot;</span>, levels=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [<span class="string">&quot;triplot&quot;</span>, <span class="string">&quot;tricontourf&quot;</span>, <span class="string">&quot;tricontour&quot;</span>]):</span><br><span class="line">    ax.set_aspect(<span class="string">&quot;equal&quot;</span>)</span><br><span class="line">    ax.set_title(title, pad=<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p><img src="88_gpd_mpl_05.png"><br></p></li><li><p><code>ax.triplot()</code>은 주어진 (x, y) 데이터끼리 연결해 삼각형 mesh를 만듭니다.</p></li><li><p><code>ax.tricontourf()</code>는 (x, y) 위치데이터에 node의 값 데이터를 적용해 삼각형 내 interpolation을 합니다.</p></li><li><p><code>levels=5</code>로 지정했기 때문에 공간이 다섯 개의 색상 구간으로 나뉘었고 색상 사이 경계선이 보입니다.</p></li><li><p><code>ax.tricontour()</code>는 이 경계선에 contour line을 그립니다.</p></li></ul><ul><li>이 방식을 사용해 2D에 분포된 데이터를 그림으로 표현할 수 있습니다.</li><li>일사량 데이터를 보이는데 <code>ax.triplot()</code>은 의미가 없으니 나머지 둘만 그립니다.</li><li>level도 10개로 설정해 더 많은 구간을 표현합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">6</span>, <span class="number">6.67</span>), sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>, constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">0</span>].tricontourf(df_u[<span class="string">&quot;x&quot;</span>], df_u[<span class="string">&quot;y&quot;</span>], df_u[<span class="string">&quot;2012-01&quot;</span>], cmap=<span class="string">&quot;inferno&quot;</span>, levels=<span class="number">10</span>)</span><br><span class="line">axs[<span class="number">1</span>].tricontour(df_u[<span class="string">&quot;x&quot;</span>], df_u[<span class="string">&quot;y&quot;</span>], df_u[<span class="string">&quot;2012-01&quot;</span>], cmap=<span class="string">&quot;inferno&quot;</span>, levels=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [<span class="string">&quot;tricontourf&quot;</span>, <span class="string">&quot;tricontour&quot;</span>]):</span><br><span class="line">    ax.set_aspect(<span class="string">&quot;equal&quot;</span>)</span><br><span class="line">    ax.set_title(title, pad=<span class="number">20</span>)</span><br></pre></td></tr></table></figure><img src="88_gpd_mpl_06.png"><br></li></ul><h2 id="4-6-지도-윤곽선-표시-1-geopandas-dataset"><a href="#4-6-지도-윤곽선-표시-1-geopandas-dataset" class="headerlink" title="4.6. 지도 윤곽선 표시 (1) geopandas dataset"></a>4.6. 지도 윤곽선 표시 (1) geopandas dataset</h2><ul><li>geopandas 라이브러리에는 세계 지도와 주요 도시가 들어있습니다.</li><li>이를 활용해 한반도와 주변국의 윤곽선을 그립니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"></span><br><span class="line">world = gpd.read_file(gpd.datasets.get_path(<span class="string">&#x27;naturalearth_lowres&#x27;</span>))</span><br><span class="line">cities = gpd.read_file(gpd.datasets.get_path(<span class="string">&#x27;naturalearth_cities&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 국경 데이터</span></span><br><span class="line">world.head(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><img src="88_gpd_mpl_25.png"><br></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 도시 데이터</span></span><br><span class="line">cities.head(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><img src="88_gpd_mpl_26.png"><br></p><ul><li><p>공간을 마련하고 한반도와 서울을 표시합니다.</p></li><li><p>geopandas 자체 기능을 사용해 국경을 그립니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots()</span><br><span class="line">world[world[<span class="string">&quot;name&quot;</span>] == <span class="string">&quot;South Korea&quot;</span>].plot(ax=ax)</span><br><span class="line">cities[cities[<span class="string">&quot;name&quot;</span>]==<span class="string">&quot;Seoul&quot;</span>].plot(ax=ax, c=<span class="string">&quot;yellow&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="88_gpd_mpl_07.png"><br></p></li><li><p>자, 그런데 x와 y축 눈금을 보면 위도와 경도입니다.</p></li><li><p>앞에서 우리는 UTM-K 좌표계로 데이터 전체를 변환했습니다.</p></li><li><p>역시 geopandas 자체 기능을 사용해 데이터를 변환하고 다시 그립니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 좌표계 변환</span></span><br><span class="line">world = world.to_crs(<span class="string">&quot;EPSG:5178&quot;</span>)</span><br><span class="line">cities = cities.to_crs(<span class="string">&quot;EPSG:5178&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 시각화</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">world[world[<span class="string">&quot;name&quot;</span>] == <span class="string">&quot;South Korea&quot;</span>].plot(ax=ax)</span><br><span class="line">cities[cities[<span class="string">&quot;name&quot;</span>]==<span class="string">&quot;Seoul&quot;</span>].plot(ax=ax, c=<span class="string">&quot;yellow&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="88_gpd_mpl_08.png"><br></p></li><li><p>간편한 명령으로 손쉽게 좌표계가 변환되었습니다.</p></li><li><p>일사량 데이터와 겹쳐봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">6.67</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">ax.tricontourf(df_u[<span class="string">&quot;x&quot;</span>], df_u[<span class="string">&quot;y&quot;</span>], df_u[<span class="string">&quot;2012-01&quot;</span>], cmap=<span class="string">&quot;inferno&quot;</span>, levels=<span class="number">10</span>)</span><br><span class="line">ax.set_aspect(<span class="string">&quot;equal&quot;</span>)</span><br><span class="line"></span><br><span class="line">world[world[<span class="string">&quot;name&quot;</span>] == <span class="string">&quot;South Korea&quot;</span>].plot(ax=ax, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;w&quot;</span>)</span><br><span class="line">world[world[<span class="string">&quot;name&quot;</span>] == <span class="string">&quot;North Korea&quot;</span>].plot(ax=ax, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;w&quot;</span>)</span><br><span class="line">world[world[<span class="string">&quot;name&quot;</span>] == <span class="string">&quot;Japan&quot;</span>].plot(ax=ax, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlim(df_u[<span class="string">&quot;x&quot;</span>].<span class="built_in">min</span>(), df_u[<span class="string">&quot;x&quot;</span>].<span class="built_in">max</span>())</span><br><span class="line">ax.set_ylim(df_u[<span class="string">&quot;y&quot;</span>].<span class="built_in">min</span>(), df_u[<span class="string">&quot;y&quot;</span>].<span class="built_in">max</span>())</span><br></pre></td></tr></table></figure><p><img src="88_gpd_mpl_09.png"><br></p></li><li><p>디테일이 영 아쉽습니다.</p></li><li><p>심지어 제주도도 없는데 혹시나 싶어 북한과 일본까지 다 끌어와도 그려지지 않습니다.</p></li></ul><h2 id="4-7-지도-윤곽선-표시-2-shape-file"><a href="#4-7-지도-윤곽선-표시-2-shape-file" class="headerlink" title="4.7. 지도 윤곽선 표시 (2) shape file"></a>4.7. 지도 윤곽선 표시 (2) shape file</h2><ul><li><p>외부 저장소에서 시도 경계선 데이터를 가져옵니다.</p></li><li><p><a href="http://www.gisdeveloper.co.kr/?p=2332">여기에서 다운로드받을 수 있습니다.</a></p></li><li><p><code>geopandas.read_file()</code>명령으로 열어 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_shp = gpd.read_file(<span class="string">&quot;./CTPRVN_202101/TL_SCCO_CTPRVN.shp&quot;</span>, encoding=<span class="string">&quot;euc-kr&quot;</span>)</span><br><span class="line">df_shp.head()</span><br></pre></td></tr></table></figure><p><img src="88_gpd_mpl_27.png"><br></p></li><li><p>이번엔 그림으로 확인합니다.</p></li><li><p>특별시, 광역시, 도의 경계선이 선명하게 드러납니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax = df_shp.plot()</span><br><span class="line">fig = ax.figure</span><br></pre></td></tr></table></figure><p><img src="88_gpd_mpl_10.png"><br></p></li></ul><h2 id="4-8-일사량-데이터와-overlap"><a href="#4-8-일사량-데이터와-overlap" class="headerlink" title="4.8. 일사량 데이터와 overlap"></a>4.8. 일사량 데이터와 overlap</h2><ul><li><p>아까 살펴본 2012년 1월 데이터에 겹쳐봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">6.67</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">ax.tricontourf(df_u[<span class="string">&quot;x&quot;</span>], df_u[<span class="string">&quot;y&quot;</span>], df_u[<span class="string">&quot;2012-01&quot;</span>], cmap=<span class="string">&quot;inferno&quot;</span>, levels=<span class="number">10</span>)</span><br><span class="line">ax.set_aspect(<span class="string">&quot;equal&quot;</span>)</span><br><span class="line"></span><br><span class="line">df_shp.plot(ax=ax, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;w&quot;</span>, lw=<span class="number">1</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlim(df_u[<span class="string">&quot;x&quot;</span>].<span class="built_in">min</span>(), df_u[<span class="string">&quot;x&quot;</span>].<span class="built_in">max</span>())</span><br><span class="line">ax.set_ylim(df_u[<span class="string">&quot;y&quot;</span>].<span class="built_in">min</span>(), df_u[<span class="string">&quot;y&quot;</span>].<span class="built_in">max</span>())</span><br></pre></td></tr></table></figure><p><img src="88_gpd_mpl_11.png"><br></p></li><li><p>그럴싸합니다!</p></li><li><p>추운 겨울을 그려봤으니 6개월 지난 7월 그림을 그려봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">6.67</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">ax.tricontourf(df_u[<span class="string">&quot;x&quot;</span>], df_u[<span class="string">&quot;y&quot;</span>], df_u[<span class="string">&quot;2012-07&quot;</span>], cmap=<span class="string">&quot;inferno&quot;</span>, levels=<span class="number">10</span>)</span><br><span class="line">ax.set_aspect(<span class="string">&quot;equal&quot;</span>)</span><br><span class="line"></span><br><span class="line">df_shp.plot(ax=ax, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;w&quot;</span>, lw=<span class="number">1</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlim(df_u[<span class="string">&quot;x&quot;</span>].<span class="built_in">min</span>(), df_u[<span class="string">&quot;x&quot;</span>].<span class="built_in">max</span>())</span><br><span class="line">ax.set_ylim(df_u[<span class="string">&quot;y&quot;</span>].<span class="built_in">min</span>(), df_u[<span class="string">&quot;y&quot;</span>].<span class="built_in">max</span>())</span><br></pre></td></tr></table></figure><p><img src="88_gpd_mpl_12.png"><br></p></li><li><p>데이터가 바뀌어 색상 분포가 달라졌습니다.</p></li><li><p>그런데 뭔가 수상합니다.</p></li><li><p>1월 데이터는 아주 밝았는데 7월 데이터는 어두침침합니다.</p></li><li><p>여름 일사량이 겨울보다 적다는 게 정상일까요?</p></li></ul><ul><li><p>확인을 위해 각각 colorbar를 붙여봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">6.67</span>), constrained_layout=<span class="literal">True</span>, sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">im0 = axs[<span class="number">0</span>].tricontourf(df_u[<span class="string">&quot;x&quot;</span>], df_u[<span class="string">&quot;y&quot;</span>], df_u[<span class="string">&quot;2012-01&quot;</span>], cmap=<span class="string">&quot;inferno&quot;</span>, levels=<span class="number">10</span>)</span><br><span class="line">im1 = axs[<span class="number">1</span>].tricontourf(df_u[<span class="string">&quot;x&quot;</span>], df_u[<span class="string">&quot;y&quot;</span>], df_u[<span class="string">&quot;2012-07&quot;</span>], cmap=<span class="string">&quot;inferno&quot;</span>, levels=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, im, month <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [im0, im1], [<span class="string">&quot;2012-01&quot;</span>, <span class="string">&quot;2012-07&quot;</span>]):</span><br><span class="line">    df_shp.plot(ax=ax, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;w&quot;</span>, lw=<span class="number">1</span>, alpha=<span class="number">0.5</span>, zorder=<span class="number">2</span>)</span><br><span class="line">    im = ax.tricontourf(df_u[<span class="string">&quot;x&quot;</span>], df_u[<span class="string">&quot;y&quot;</span>], df_u[month], cmap=<span class="string">&quot;inferno&quot;</span>, levels=<span class="number">10</span>)</span><br><span class="line">    ax.set_aspect(<span class="string">&quot;equal&quot;</span>)</span><br><span class="line">    ax.set_title(month, pad=<span class="number">20</span>)</span><br><span class="line">    ax.set_xlim(df_u[<span class="string">&quot;x&quot;</span>].<span class="built_in">min</span>(), df_u[<span class="string">&quot;x&quot;</span>].<span class="built_in">max</span>())</span><br><span class="line">    ax.set_ylim(df_u[<span class="string">&quot;y&quot;</span>].<span class="built_in">min</span>(), df_u[<span class="string">&quot;y&quot;</span>].<span class="built_in">max</span>())</span><br><span class="line"></span><br><span class="line">    plt.colorbar(im, ax=ax)</span><br></pre></td></tr></table></figure><p><img src="88_gpd_mpl_13.png"><br></p></li><li><p>2월은 최대값이 3을 넘지 않는데 비해 7월은 5.4에 달합니다.</p></li><li><p>최소값도 0.6과 1.8로 큰 차이가 납니다.</p></li><li><p>두 그림이 다른 기준으로 그려져서 문제가 생긴 것입니다. </p></li><li><p>위 코드의 6번째 줄에 colormap의 최소값<code>vmin</code>과 최대값<code>vmax</code>를 똑같이 지정해서 같은 기준으로 색을 입힙니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">im = ax.tricontourf(df_u[<span class="string">&quot;x&quot;</span>], df_u[<span class="string">&quot;y&quot;</span>], df_u[month], cmap=<span class="string">&quot;inferno&quot;</span>, levels=<span class="number">10</span>, vmin=<span class="number">0</span>, vmax=<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p><img src="88_gpd_mpl_14.png"><br></p></li><li><p>확실히 1월에 비해 7월의 햇살이 더 쨍쨍합니다.</p></li></ul><h1 id="5-시간과-공간-데이터-시각화"><a href="#5-시간과-공간-데이터-시각화" class="headerlink" title="5. 시간과 공간 데이터 시각화"></a>5. 시간과 공간 데이터 시각화</h1><ul><li>공간 데이터는 1개월마다 평균치가 저장되므로 이를 늘어놓으면 시간에 따른 변화를 볼 수 있습니다.</li><li>2012년 1월부터 12월까지 공간데이터를 for 문을 사용해 반복합니다.</li><li>공통으로 적용된 colorbar는 12개 Axes의 우측에 <code>ScalarMappable()</code>을 사용해 놓습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> cm</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(ncols=<span class="number">6</span>, nrows=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>), constrained_layout=<span class="literal">True</span>, sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">axs = axes.ravel()</span><br><span class="line"><span class="keyword">for</span> i, ax <span class="keyword">in</span> <span class="built_in">enumerate</span>(axs, <span class="number">1</span>):</span><br><span class="line">    month = <span class="string">f&quot;2012-<span class="subst">&#123;i:02d&#125;</span>&quot;</span></span><br><span class="line">    df_shp.plot(ax=ax, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;w&quot;</span>, lw=<span class="number">1</span>, alpha=<span class="number">0.5</span>, zorder=<span class="number">2</span>)</span><br><span class="line">    im = ax.tricontourf(df_u[<span class="string">&quot;x&quot;</span>], df_u[<span class="string">&quot;y&quot;</span>], df_u[month], cmap=<span class="string">&quot;inferno&quot;</span>, levels=<span class="number">10</span>, vmin=<span class="number">0</span>, vmax=<span class="number">6</span>)</span><br><span class="line">    ax.set_aspect(<span class="string">&quot;equal&quot;</span>)</span><br><span class="line">    ax.set_title(month, pad=<span class="number">10</span>)</span><br><span class="line">    ax.set_xlim(df_u[<span class="string">&quot;x&quot;</span>].<span class="built_in">min</span>(), df_u[<span class="string">&quot;x&quot;</span>].<span class="built_in">max</span>())</span><br><span class="line">    ax.set_ylim(df_u[<span class="string">&quot;y&quot;</span>].<span class="built_in">min</span>(), df_u[<span class="string">&quot;y&quot;</span>].<span class="built_in">max</span>())</span><br><span class="line">    ax.axis(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># colorbar</span></span><br><span class="line">cbar = cm.ScalarMappable(cmap=<span class="string">&quot;inferno&quot;</span>)</span><br><span class="line">cbar.set_clim(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">plt.colorbar(cbar, ax=axes[:,-<span class="number">1</span>], fraction=<span class="number">0.2</span>, pad=<span class="number">0.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># figure title</span></span><br><span class="line">fig.suptitle(<span class="string">&quot;수평면 전일사량 [kWh/(m$^2 \cdot$day)]&quot;</span>, color=<span class="string">&quot;gray&quot;</span>, fontsize=<span class="string">&quot;medium&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br></pre></td></tr></table></figure><img src="88_gpd_mpl_18.png"><br></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/geopandas/">geopandas</category>
      
      <category domain="https://jehyunlee.github.io/tags/proj/">proj</category>
      
      
    </item>
    
    <item>
      <title>modifying seaborn violin plot</title>
      <link>https://jehyunlee.github.io/2021/10/21/Python-DS-87_violinplotedit/</link>
      <guid>https://jehyunlee.github.io/2021/10/21/Python-DS-87_violinplotedit/</guid>
      <pubDate>Thu, 21 Oct 2021 00:11:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;Seaborn violin plot은 아름답습니다.&lt;/li&gt;
&lt;li&gt;매끈한 곡선은 데이터의 분포를 직관적으로 알게 해 줍니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;color&lt;/code&gt;와 &lt;code&gt;palette&lt;/code&gt; 매개변수로 viol</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>Seaborn violin plot은 아름답습니다.</li><li>매끈한 곡선은 데이터의 분포를 직관적으로 알게 해 줍니다.</li><li><code>color</code>와 <code>palette</code> 매개변수로 violin plot의 색을 지정할 수 있습니다.</li><li>그러나 특정 violin plot만 색을 바꾸어 강조하는 방법은 잘 알려져있지 않습니다.</li></ul><h1 id="1-예제-데이터"><a href="#1-예제-데이터" class="headerlink" title="1. 예제 데이터"></a>1. 예제 데이터</h1><ul><li>seaborn의 tips 데이터셋을 사용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 기본 시각화 설정</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line">sns.set_style(<span class="string">&quot;white&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 데이터셋 불러오기</span></span><br><span class="line">df = sns.load_dataset(<span class="string">&quot;tips&quot;</span>)</span><br><span class="line">df</span><br></pre></td></tr></table></figure><img src="violinplotedit01.png"><br></li></ul><h1 id="2-seaborn-violin-plot"><a href="#2-seaborn-violin-plot" class="headerlink" title="2. seaborn violin plot"></a>2. seaborn violin plot</h1><h2 id="2-1-기본-plot"><a href="#2-1-기본-plot" class="headerlink" title="2.1. 기본 plot"></a>2.1. 기본 plot</h2><ul><li><p>요일별 팁 분포를 그려봅니다.</p></li><li><p><code>seaborn.violinplot()</code>을 사용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">sns.violinplot(data=df, x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, ax=ax)</span><br></pre></td></tr></table></figure><p><img src="violinplotedit02.png"><br></p></li><li><p>기본 설정인 <code>tab10</code> palette에 따라 violin plot이 채색되었습니다.</p></li></ul><h2 id="2-2-일괄-색-변경-color"><a href="#2-2-일괄-색-변경-color" class="headerlink" title="2.2. 일괄 색 변경: color"></a>2.2. 일괄 색 변경: <code>color</code></h2><ul><li>color 매개변수를 사용하면 violin plot들의 face color를 일괄적으로 바꿀 수 있습니다.</li><li><code>color=&quot;gold&quot;</code>를 적용한 결과입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">sns.violinplot(data=df, x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, </span><br><span class="line">               color=<span class="string">&quot;gold&quot;</span>, ax=ax)</span><br></pre></td></tr></table></figure><img src="violinplotedit07.png"><br></li></ul><h2 id="2-3-팔레트-변경-palette"><a href="#2-3-팔레트-변경-palette" class="headerlink" title="2.3. 팔레트 변경: palette"></a>2.3. 팔레트 변경: <code>palette</code></h2><ul><li><p>color 대신 palette 매개변수를 사용하면 violin plot마다 다른 색이 적용됩니다.</p></li><li><p>기본값으로 <code>tab10</code>이 적용되어 있지만, 만약 <code>sns.set_palette()</code>명령으로 기본값을 바꾸었다면 다른 색들이 입혀집니다.</p></li><li><p>전체 palette를 바꾸지 않아도 <code>sns.violinplot()</code>안에 <code>palette</code>매개변수를 지정하면 해당 plot에 한해 palette가 바뀝니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">sns.violinplot(data=df, x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, </span><br><span class="line">               palette=<span class="string">&quot;rainbow&quot;</span>, ax=ax)</span><br></pre></td></tr></table></figure><p><img src="violinplotedit08.png"><br></p></li><li><p><code>color</code>매개변수나 <code>palette</code> 매개변수나 전체를 일괄적으로 바꾸는 것입니다.</p></li><li><p>만약 이 중에서 <b>일요일만 색을 바꾸고 싶다</b>면 옵션이 없습니다.</p></li></ul><h1 id="3-Matplotlib-객체지향-적용"><a href="#3-Matplotlib-객체지향-적용" class="headerlink" title="3. Matplotlib 객체지향 적용"></a>3. Matplotlib 객체지향 적용</h1><h2 id="3-1-seaborn-violin-plot-해부"><a href="#3-1-seaborn-violin-plot-해부" class="headerlink" title="3.1. seaborn violin plot 해부"></a>3.1. seaborn violin plot 해부</h2><blockquote><p><a href="https://matplotlib.org/stable/api/artist_api.html">matplotlib.artist</a><br><a href="https://matplotlib.org/stable/tutorials/intermediate/artists.html">matplotlib: Artist tutorial</a></p></blockquote><ul><li>seaborn은 Matplotlib을 편하게 쓰기 위해 만든 라이브러리입니다.</li><li>따라서 seaborn으로 그린 그림은 모두 Matplotlib 객체로 이루어져 있습니다.</li><li>Figure와 Axes를 제외한 구성 요소는 Artist로 이루어져 있고, Artist엔 여러 분류가 있습니다.</li></ul><p><img src="violinplotedit10.png" alt="Artist class"><br></p><ul><li>이 수많은 것들 중 <b>Collection</b>에 주목합시다.</li><li>낯설게 보일 지 모르지만 파워포인트에서 여러 도형을 그룹으로 묶어놓은 것이라고 생각할 수 있습니다.</li><li>파워포인트에서 그룹에 속한 도형의 선이나 색을 일괄적으로 바꿀 수 있는 것처럼 Matplotlib의 Collection도 포함된 여러 객체의 속성을 한번에 바꿀 수 있습니다.</li></ul><ul><li><p>violin plot으로 어떤 Collection들이 생성되었는지 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(ax.collections))</span><br><span class="line">ax.collections</span><br></pre></td></tr></table></figure><ul><li>실행 결과: 8개의 collections가 있습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">[&lt;matplotlib.collections.PolyCollection at 0x7f61db670a50&gt;,</span><br><span class="line"> &lt;matplotlib.collections.PathCollection at 0x7f61db719490&gt;,</span><br><span class="line"> &lt;matplotlib.collections.PolyCollection at 0x7f61db680ad0&gt;,</span><br><span class="line"> &lt;matplotlib.collections.PathCollection at 0x7f61db680550&gt;,</span><br><span class="line"> &lt;matplotlib.collections.PolyCollection at 0x7f61db68c9d0&gt;,</span><br><span class="line"> &lt;matplotlib.collections.PathCollection at 0x7f61db6e1cd0&gt;,</span><br><span class="line"> &lt;matplotlib.collections.PolyCollection at 0x7f61db699ad0&gt;,</span><br><span class="line"> &lt;matplotlib.collections.PathCollection at 0x7f61db699510&gt;]</span><br></pre></td></tr></table></figure></li></ul></li><li><p><b>PolyCollection</b>과 <b>PathCollection</b>이 번갈아 등장합니다.</p></li><li><p>PolyCollection은 간단히 <b>다각형 객체</b>입니다.</p></li><li><p>PathCollection은 간단히 <b>Matplotlib에서 사전 정의된 도형</b>입니다.</p></li><li><p>뭔지 잘 모르겠지만 일단 이렇게만 넘어갑시다. </p></li></ul><ul><li><p>이번에는 <b>Line2D</b>객체를 살펴봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(ax.lines))</span><br><span class="line">ax.lines</span><br></pre></td></tr></table></figure><ul><li>실행 결과: 8개의 lines객체가 있습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">[&lt;matplotlib.lines.Line2D at 0x7f61db670f10&gt;,</span><br><span class="line">&lt;matplotlib.lines.Line2D at 0x7f61db680290&gt;,</span><br><span class="line">&lt;matplotlib.lines.Line2D at 0x7f61db680e90&gt;,</span><br><span class="line">&lt;matplotlib.lines.Line2D at 0x7f61db68c2d0&gt;,</span><br><span class="line">&lt;matplotlib.lines.Line2D at 0x7f61db68cdd0&gt;,</span><br><span class="line">&lt;matplotlib.lines.Line2D at 0x7f61db699250&gt;,</span><br><span class="line">&lt;matplotlib.lines.Line2D at 0x7f61db699e90&gt;,</span><br><span class="line">&lt;matplotlib.lines.Line2D at 0x7f61db6a62d0&gt;]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>이들의 정체는 바로 이렇습니다.</p><ul><li><b>PolyCollection</b>은 <b>violin plot</b></li><li><b>PathCollection</b>은 <b>median marker</b></li><li>첫번째 <b>Line2D</b>는 <b>whisker</b></li><li>두번째 <b>Line2D</b>는 <b>box</b>입니다.<details><summary><b>시각화 코드 보기/접기</b></summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">df_sample = df.query(<span class="string">&quot;day == &#x27;Sun&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">subfigs = fig.subfigures(<span class="number">1</span>, <span class="number">2</span>, width_ratios=[<span class="number">1</span>, <span class="number">4</span>])</span><br><span class="line">axs_all = subfigs[<span class="number">0</span>].subplots(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">sns.violinplot(data=df_sample, y=<span class="string">&quot;total_bill&quot;</span>, ax=axs_all)</span><br><span class="line">axs_all.set_yticks([])</span><br><span class="line">axs_all.set_ylabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">subfigs[<span class="number">1</span>].set_facecolor(<span class="string">&quot;beige&quot;</span>)</span><br><span class="line">axs_parts = subfigs[<span class="number">1</span>].subplots(<span class="number">1</span>, <span class="number">4</span>, sharey=<span class="literal">True</span>)</span><br><span class="line">titles = [<span class="string">&quot;violin plot\n\n&quot;</span>, <span class="string">&quot;median\n\n&quot;</span>, <span class="string">&quot;whisker\n\n&quot;</span>, <span class="string">&quot;box\n\n&quot;</span>]</span><br><span class="line">artists = [<span class="string">&quot;collections[0]\n&quot;</span>, <span class="string">&quot;collections[1]\n&quot;</span>, <span class="string">&quot;lines[0]\n&quot;</span>, <span class="string">&quot;lines[1]\n&quot;</span>]</span><br><span class="line">objects = [<span class="string">&quot;PolyCollection&quot;</span>, <span class="string">&quot;PathCollection&quot;</span>, <span class="string">&quot;Line2D&quot;</span>, <span class="string">&quot;Line2D&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i, (ax, title, artist, <span class="built_in">object</span>) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(axs_parts, titles, artists, objects)):</span><br><span class="line">    sns.violinplot(data=df_sample, y=<span class="string">&quot;total_bill&quot;</span>, ax=ax)</span><br><span class="line">    parts = ax.collections + ax.lines</span><br><span class="line">    [p.remove() <span class="keyword">for</span> pi, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(parts) <span class="keyword">if</span> i != pi]</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;small&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">    ax.text(<span class="number">0.5</span>, <span class="number">1.05</span>, artist, transform=ax.transAxes, ha=<span class="string">&quot;center&quot;</span>, color=<span class="string">&quot;brown&quot;</span>, fontsize=<span class="string">&quot;x-small&quot;</span>)</span><br><span class="line">    ax.text(<span class="number">0.5</span>, <span class="number">1.05</span>, <span class="built_in">object</span>, transform=ax.transAxes, ha=<span class="string">&quot;center&quot;</span>, color=<span class="string">&quot;gray&quot;</span>, fontsize=<span class="string">&quot;x-small&quot;</span>)</span><br><span class="line">    ax.set_xticks([])</span><br><span class="line">    ax.set_yticks([])</span><br><span class="line">    ax.set_ylabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">subfigs[<span class="number">1</span>].suptitle(<span class="string">&quot;Anatomy of seaborn violin plot&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><img src="violinplotedit11.png"><br></p><ul><li>whisker와 box는 box-whisker plot의 그것들이 맞습니다.</li></ul><h2 id="3-2-객체-제어"><a href="#3-2-객체-제어" class="headerlink" title="3.2. 객체 제어"></a>3.2. 객체 제어</h2><ul><li>일단 객체로 분리되면 그 다음은 수월합니다.</li><li><code>.get_속성()</code> 명령으로 속성을 가져오고 <code>.set_속성(속성값)</code> 명령으로 속성을 바꿀 수 있습니다.</li></ul><ul><li><p>우리 목적은 <b>일요일 데이터 강조</b>입니다.</p></li><li><p><b>일요일</b> 데이터를 강조하기 위해 나머지 톤을 죽입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">sns.violinplot(data=df, x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, ax=ax,</span><br><span class="line">               color=<span class="string">&quot;lavender&quot;</span>, linewidth=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure></li><li><p>매우 밋밋한 그림이 됩니다.</p></li><li><p>여기에 몇 가지 코드를 추가합니다.</p></li><li><p>먼저, <b>일요일 violin plot</b>의 facecolor와 edgecolor, linewidth를 바꿉니다.</p></li><li><p>하나 건너 하나 있는 <code>PolyCollection</code>을 가져오기 위해 <code>if i%2 == 0</code>을 사용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># violin plot: PolyCollection</span></span><br><span class="line">violins = [c <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(ax.collections) <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>]  </span><br><span class="line">[v.set_edgecolor(<span class="string">&quot;k&quot;</span>) <span class="keyword">for</span> v <span class="keyword">in</span> violins]  <span class="comment"># 전체 violin edgecolor 변경</span></span><br><span class="line">violins[<span class="number">3</span>].set_facecolor(<span class="string">&quot;gold&quot;</span>)     <span class="comment"># Sunday violin facecolor 변경</span></span><br><span class="line">violins[<span class="number">3</span>].set_linewidth(<span class="number">1</span>)          <span class="comment"># Sunday violin linewidth 변경</span></span><br><span class="line">violins[<span class="number">3</span>].set_edgecolor(<span class="string">&quot;k&quot;</span>)        <span class="comment"># Sunday violin edgecolor 변경</span></span><br></pre></td></tr></table></figure></li><li><p>이번엔 <b>marker를 조금 크고 귀엽게</b> 만듭니다.</p></li><li><p>일요일 뿐 아니라 <b>전체 데이터</b>에 적용합니다.</p></li><li><p>PolyCollection 밑에 있는<code>PathCollection</code>을 가져오기 위해 <code>if i%2 == 1</code>을 사용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># median marker: PathCollection</span></span><br><span class="line">markers = [c <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(ax.collections) <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">1</span>]  </span><br><span class="line">markers[<span class="number">3</span>].set_facecolor(<span class="string">&quot;w&quot;</span>)         <span class="comment"># Sunday median facecolor 변경</span></span><br><span class="line">markers[<span class="number">3</span>].set_edgecolor(<span class="string">&quot;k&quot;</span>)         <span class="comment"># Sunday median edgecolor 변경</span></span><br><span class="line">[m.set_sizes([<span class="number">50</span>]) <span class="keyword">for</span> m <span class="keyword">in</span> markers]  <span class="comment"># 전체 median size 변경</span></span><br></pre></td></tr></table></figure></li><li><p>Line2D 객체들 차례입니다.</p></li><li><p><b>일요일 box plot 색을 검정</b>으로 만듭니다.</p></li><li><p><b>굵기 조정은 모두에게 적용</b>합니다.</p></li><li><p><code>i%2 == 0</code>과 <code>i%2 == 1</code>을 번갈아 사용해서 box와 whisker를 번갈아 선택합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># box-whisker: Line2D</span></span><br><span class="line">ls = [l <span class="keyword">for</span> i, l <span class="keyword">in</span> <span class="built_in">enumerate</span>(ax.lines)]</span><br><span class="line">ls[-<span class="number">2</span>].set_color(<span class="string">&quot;k&quot;</span>)                 <span class="comment"># Sunday whisker 색상 변경</span></span><br><span class="line">ls[-<span class="number">1</span>].set_color(<span class="string">&quot;k&quot;</span>)                 <span class="comment"># Sunday box 색 변경</span></span><br><span class="line">[l.set_linewidth(<span class="number">1</span>) <span class="keyword">for</span> i, l <span class="keyword">in</span> <span class="built_in">enumerate</span>(ls) <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>] <span class="comment"># 전체 box, whisher 굵기 변경</span></span><br><span class="line">[l.set_linewidth(<span class="number">5</span>) <span class="keyword">for</span> i, l <span class="keyword">in</span> <span class="built_in">enumerate</span>(ls) <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">1</span>] <span class="comment"># 전체 box, whisher 굵기 변경</span></span><br></pre></td></tr></table></figure></li><li><p>이 코드들을 더하면 이런 그림이 나옵니다.<br><img src="violinplotedit05.png"><br></p></li><li><p>마지막으로 불필요한 요소를 제거합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ax.set_ylim(<span class="number">0</span>, )</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;total bill ($)&quot;</span>)</span><br><span class="line">ax.spines[[<span class="string">&quot;left&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;right&quot;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line">ax.grid(axis=<span class="string">&quot;y&quot;</span>, lw=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="violinplotedit06.png"><br></p></li></ul><h2 id="3-3-응용-hue-amp-split"><a href="#3-3-응용-hue-amp-split" class="headerlink" title="3.3. 응용: hue &amp; split"></a>3.3. 응용: hue &amp; split</h2><ul><li>seaborn violin plot에 hue와 split을 적용하면 의미 전달도 좋고 그림도 제법 멋집니다.</li><li>여기에도 위에서 사용한 기술을 똑같이 적용할 수 있지만, 주의사항이 하나 있습니다.</li><li>반쪽짜리 violin plot 두 개와 center marker가 번갈아 나오기 때문에 list comprehension을 조금 바꿔야 합낟.</li><li><code>i%3 == 0</code>은 Male violin plot, <code>i%3 == 1</code>은 Female violin plot, <code>i%3 == 2</code>는 center marker입니다. <details>  <summary><b>시각화 코드 보기/접기</b></summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">sns.violinplot(data=df, x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, ax=ax,</span><br><span class="line">               color=<span class="string">&quot;pink&quot;</span>, hue=<span class="string">&quot;sex&quot;</span>, split=<span class="literal">True</span>, linewidth=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### violin plot: PolyCollection</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Male</span></span><br><span class="line">violins_M = [c <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(ax.collections) <span class="keyword">if</span> i%<span class="number">3</span> == <span class="number">0</span>]  </span><br><span class="line">[v.set_edgecolor(<span class="string">&quot;gray&quot;</span>) <span class="keyword">for</span> v <span class="keyword">in</span> violins_M]</span><br><span class="line">[v.set_linewidth(<span class="number">1</span>) <span class="keyword">for</span> v <span class="keyword">in</span> violins_M]</span><br><span class="line">violins_M[<span class="number">3</span>].set_facecolor(<span class="string">&quot;gold&quot;</span>)  <span class="comment"># Sunday violin facecolor 변경</span></span><br><span class="line">violins_M[<span class="number">3</span>].set_linewidth(<span class="number">1</span>)          <span class="comment"># Sunday violin facecolor 변경</span></span><br><span class="line">violins_M[<span class="number">3</span>].set_edgecolor(<span class="string">&quot;k&quot;</span>)        <span class="comment"># Sunday violin edgecolor 변경</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Female</span></span><br><span class="line">violins_F = [c <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(ax.collections) <span class="keyword">if</span> i%<span class="number">3</span> == <span class="number">1</span>]  </span><br><span class="line">[v.set_edgecolor(<span class="string">&quot;gray&quot;</span>) <span class="keyword">for</span> v <span class="keyword">in</span> violins_F]</span><br><span class="line">[v.set_linewidth(<span class="number">1</span>) <span class="keyword">for</span> v <span class="keyword">in</span> violins_F]</span><br><span class="line">violins_F[<span class="number">3</span>].set_facecolor(<span class="string">&quot;orange&quot;</span>)  <span class="comment"># Sunday violin facecolor 변경</span></span><br><span class="line">violins_F[<span class="number">3</span>].set_linewidth(<span class="number">1</span>)          <span class="comment"># Sunday violin facecolor 변경</span></span><br><span class="line">violins_F[<span class="number">3</span>].set_edgecolor(<span class="string">&quot;k&quot;</span>)        <span class="comment"># Sunday violin edgecolor 변경</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># median marker: PathCollection</span></span><br><span class="line">markers = [c <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(ax.collections) <span class="keyword">if</span> i%<span class="number">3</span> == <span class="number">2</span>]  </span><br><span class="line">markers[<span class="number">3</span>].set_facecolor(<span class="string">&quot;w&quot;</span>)         <span class="comment"># Sunday median facecolor 변경</span></span><br><span class="line">markers[<span class="number">3</span>].set_edgecolor(<span class="string">&quot;k&quot;</span>)         <span class="comment"># Sunday median edgecolor 변경</span></span><br><span class="line">[m.set_sizes([<span class="number">50</span>]) <span class="keyword">for</span> m <span class="keyword">in</span> markers]  <span class="comment"># 전체 median size 변경</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # box-whisker: Line2D</span></span><br><span class="line">ls = [l <span class="keyword">for</span> i, l <span class="keyword">in</span> <span class="built_in">enumerate</span>(ax.lines)]</span><br><span class="line">ls[-<span class="number">2</span>].set_color(<span class="string">&quot;k&quot;</span>)                 <span class="comment"># Sunday whisker 색상 변경</span></span><br><span class="line">ls[-<span class="number">1</span>].set_color(<span class="string">&quot;k&quot;</span>)                 <span class="comment"># Sunday box 색 변경</span></span><br><span class="line">[l.set_linewidth(<span class="number">1</span>) <span class="keyword">for</span> i, l <span class="keyword">in</span> <span class="built_in">enumerate</span>(ls) <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>] <span class="comment"># 전체 box, whisher 굵기 변경</span></span><br><span class="line">[l.set_linewidth(<span class="number">5</span>) <span class="keyword">for</span> i, l <span class="keyword">in</span> <span class="built_in">enumerate</span>(ls) <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">1</span>] <span class="comment"># 전체 box, whisher 굵기 변경</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # spines 제거, grid 추가, xlabel 제거, ylabel 제거</span></span><br><span class="line">ax.set_ylim(<span class="number">0</span>, )</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;total bill ($)&quot;</span>)</span><br><span class="line">ax.spines[[<span class="string">&quot;left&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;right&quot;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line">ax.grid(axis=<span class="string">&quot;y&quot;</span>, lw=<span class="number">1</span>)</span><br><span class="line">legend = ax.legend()</span><br><span class="line">legend.remove()</span><br><span class="line">fig.legend(loc=<span class="string">&quot;upper right&quot;</span>, ncol=<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ul><p><img src="violinplotedit09.png"><br></p><h1 id="4-결론"><a href="#4-결론" class="headerlink" title="4. 결론"></a>4. 결론</h1><ul><li>seaborn violin plot도 결국 Matplotlib 객체 모음입니다.</li><li>여러분의 아이디어를 객체 지향 방식에 마음껏 실어 나르기 바랍니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      
    </item>
    
    <item>
      <title>데이터 분석, 의심에서 전달까지</title>
      <link>https://jehyunlee.github.io/2021/10/14/Python-DS-86-datadoubt/</link>
      <guid>https://jehyunlee.github.io/2021/10/14/Python-DS-86-datadoubt/</guid>
      <pubDate>Thu, 14 Oct 2021 00:40:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;한국지능정보사회진흥원(NIA)&lt;/b&gt;에서 기회를 주셔서 발표를 하게 되었습니다. (21.10.08.)&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.bigdata-map.kr/&quot;&gt;통합 데이터 지도&lt;/a&gt; 활성화 노력의 일환입니</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b>한국지능정보사회진흥원(NIA)</b>에서 기회를 주셔서 발표를 하게 되었습니다. (21.10.08.)<ul><li><a href="http://www.bigdata-map.kr/">통합 데이터 지도</a> 활성화 노력의 일환입니다.</li><li>아직 부족한 점이 있을 수도 있지만 적극적으로 피드백을 구하며 점진적으로 보완하고 있습니다.</li><li>많이 활용하시고 피드백을 주시면 서로 좋을 것 같습니다.</li></ul></li></ul><ul><li>그리고 어제 <b>AI Frenz</b>에서 또다시 기회를 주셨네요. (21.10.13.)<ul><li>데이터를 다루면서 느낀 경험, 보고를 하고 받으며 느낀 경험을 정리했습니다.</li><li><b><a href="http://www.bigdata-map.kr/board/review/64?fromBoard=review">발표자료는 여기에서 다운로드</a></b> 받으실 수 있습니다.</li></ul></li></ul><ul><li>발표 영상입니다 (<a href="https://youtu.be/T4jtifT8sJw">Youtube Link</a>)<br></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/T4jtifT8sJw" frameborder="0" loading="lazy" allowfullscreen></iframe></div><br><p><img src="NIA.jpg" alt="NIA 공지"><br></p><p><img src="AIFrenz.png" alt="AI Frenz 공지"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/AI-Frenz/">AI Frenz</category>
      
      <category domain="https://jehyunlee.github.io/tags/NIA/">NIA</category>
      
      
    </item>
    
    <item>
      <title>Population by gender and age</title>
      <link>https://jehyunlee.github.io/2021/10/05/Python-DS-85-popkr/</link>
      <guid>https://jehyunlee.github.io/2021/10/05/Python-DS-85-popkr/</guid>
      <pubDate>Tue, 05 Oct 2021 04:31:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;Matplotlib 객체지향 방식은 훌륭합니다.&lt;/li&gt;
&lt;li&gt;객체를 섬세하게 제어할 수 있고, 시각화 함수를 만들기도 좋습니다.&lt;/li&gt;
&lt;li&gt;데이터 정리부터 객체지향 방식으로 그림을 그리는 예제를 만들어 보았습니다.&lt;/li&gt;
&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>Matplotlib 객체지향 방식은 훌륭합니다.</li><li>객체를 섬세하게 제어할 수 있고, 시각화 함수를 만들기도 좋습니다.</li><li>데이터 정리부터 객체지향 방식으로 그림을 그리는 예제를 만들어 보았습니다.</li></ul><h1 id="1-목표"><a href="#1-목표" class="headerlink" title="1. 목표"></a>1. 목표</h1><ul><li><p>우리나라 인구 데이터로부터 이런 그림을 그릴 것입니다.<br><br><img src="85_popkr_18.png"><br></p></li><li><p>한번 그리고 말 것이 아닙니다.</p></li><li><p>시나 도 이름을 입력하면 데이터만 바뀐 같은 형식의 그림을 찍어낼 것입니다.<br><br><img src="85_popkr_26.png"><br></p></li></ul><h1 id="2-데이터-준비"><a href="#2-데이터-준비" class="headerlink" title="2. 데이터 준비"></a>2. 데이터 준비</h1><blockquote><p><a href="http://www.yes24.com/Product/Goods/72227684">모두의 데이터 분석 with 파이썬</a><br><a href="https://jumin.mois.go.kr/index.jsp#">주민등록 인구 및 세대현황</a></p></blockquote><ul><li><a href="http://www.yes24.com/Product/Goods/72227684">모두의 데이터 분석 with 파이썬</a>에는 인구 데이터를 내려받아 분포를 bar plot으로 표현하는 내용이 있습니다.</li><li>같은 데이터를 조금 더 깔끔하게, 조금 체계적으로 만들어 보겠습니다.</li></ul><h2 id="2-1-데이터-다운로드"><a href="#2-1-데이터-다운로드" class="headerlink" title="2.1. 데이터 다운로드"></a>2.1. 데이터 다운로드</h2><ul><li><p>아래와 같이 <b>주민등록 인구 및 세대현황</b>자료에서 csv 파일을 다운받습니다.<br></p></li><li><p><a href="202108_202108_%EC%97%B0%EB%A0%B9%EB%B3%84%EC%9D%B8%EA%B5%AC%ED%98%84%ED%99%A9_%EC%9B%94%EA%B0%84.csv">파일 다운로드</a><br><img src="85_popkr_27.png"><br></p></li><li><p>주피터 노트북을 켜고 데이터 분석을 준비합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 시각화 설정</span></span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line">sns.set_style(<span class="string">&quot;white&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux 한글 사용 설정</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>]=[<span class="string">&#x27;NanumGothic&#x27;</span>, <span class="string">&#x27;sans-serif&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2-데이터-전처리"><a href="#2-2-데이터-전처리" class="headerlink" title="2.2. 데이터 전처리"></a>2.2. 데이터 전처리</h2><ul><li><p>다운받은 파일을 파이썬으로 열어봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_popkr = pd.read_csv(<span class="string">&quot;202108_202108_연령별인구현황_월간.csv&quot;</span>, encoding=<span class="string">&quot;euc-kr&quot;</span>)</span><br><span class="line">df_popkr.head()</span><br></pre></td></tr></table></figure><p><img src="85_popkr_01.png"><br></p></li><li><p>연령대와 성별이 column으로 정리되어 있고 행정구역들이 첫번째 column에 나열되어 있습니다.</p></li><li><p>분석하기에 좋은 모양은 아닙니다. 전처리를 들어갑니다.</p></li></ul><h3 id="2-2-1-데이터-내용-정리"><a href="#2-2-1-데이터-내용-정리" class="headerlink" title="2.2.1. 데이터 내용 정리"></a>2.2.1. 데이터 내용 정리</h3><ul><li><p>행정구역에서 불필요한 번호를 떼어냅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_popkr[<span class="string">&quot;행정구역&quot;</span>] = df_popkr[<span class="string">&quot;행정구역&quot;</span>].<span class="built_in">str</span>.split(<span class="string">&quot;(&quot;</span>).<span class="built_in">str</span>[<span class="number">0</span>]</span><br><span class="line">df_popkr.head()</span><br></pre></td></tr></table></figure><p><img src="85_popkr_02.png"><br></p></li><li><p>행정구역에서 번호가 떨어진 뒤에 빈 칸이 붙어 있습니다.</p></li><li><p>숫자들 사이에는 자리수를 표현하는 쉼표(,)가 붙어 있습니다.</p></li><li><p><code>df.replace()</code>로 처리합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df_popkr.replace(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;&quot;</span>, regex=<span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">df_popkr.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>, regex=<span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">df_popkr.head()</span><br></pre></td></tr></table></figure><p><img src="85_popkr_03.png"><br></p></li></ul><h3 id="2-2-2-성별-분리"><a href="#2-2-2-성별-분리" class="headerlink" title="2.2.2. 성별 분리"></a>2.2.2. 성별 분리</h3><ul><li>남성과 여성 데이터를 따로 그릴 것입니다. 데이터부터 분리합니다.</li><li>먼저 남성 데이터를 정리합니다.</li><li>컬럼명에 <b>“남”</b>이 있는 것들을 골라냅니다.</li><li>그 중에서도 불필요한 내용을 제거하기 위해 <b>“세”</b>가 있는 것만 또 따로 분리합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_popkrM = df_popkr.<span class="built_in">filter</span>(like=<span class="string">&quot;남&quot;</span>).<span class="built_in">filter</span>(like=<span class="string">&quot;세&quot;</span>)</span><br><span class="line">df_popkrM.head()</span><br></pre></td></tr></table></figure><img src="85_popkr_04.png"><br></li></ul><h3 id="2-2-3-행-열-전환"><a href="#2-2-3-행-열-전환" class="headerlink" title="2.2.3. 행-열 전환"></a>2.2.3. 행-열 전환</h3><ul><li>데이터를 편하게 다루려면 열에 지역명, 행에 나이대를 놓는 것이 좋습니다.</li><li><code>df.T</code>로 행과 열을 바꾼 뒤 <code>df.astype(int</code>)로 정수형으로 변환합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df_popkrMT = df_popkrM.T</span><br><span class="line">df_popkrMT.columns = df_popkr[<span class="string">&quot;행정구역&quot;</span>].values</span><br><span class="line">df_popkrMT = df_popkrMT.astype(<span class="built_in">int</span>)</span><br><span class="line">df_popkrMT.head()</span><br></pre></td></tr></table></figure><img src="85_popkr_05.png"><br></li></ul><h3 id="2-2-4-“나이”만-남기기"><a href="#2-2-4-“나이”만-남기기" class="headerlink" title="2.2.4. “나이”만 남기기"></a>2.2.4. “나이”만 남기기</h3><ul><li>나이 정보가 index로 오긴 했지만 불필요한 정보들이 많습니다.</li><li><code>pd.Series.str.split()</code>을 사용해 나이만 남깁니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df_popkrMT[<span class="string">&quot;나이&quot;</span>] = df_popkrMT.index.<span class="built_in">str</span>.split(<span class="string">&quot;_&quot;</span>).<span class="built_in">str</span>[<span class="number">2</span>]</span><br><span class="line">df_popkrMT.reset_index(drop=<span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">df_popkrMT</span><br></pre></td></tr></table></figure><img src="85_popkr_06.png"><br></li></ul><h3 id="2-2-5-여성-데이터-정리"><a href="#2-2-5-여성-데이터-정리" class="headerlink" title="2.2.5. 여성 데이터 정리"></a>2.2.5. 여성 데이터 정리</h3><ul><li>같은 요령으로 여성 데이터도 정리합니다.</li><li>위에서 뭔가 복잡하게 한 것 같지만 코드 6줄로 정리됩니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df_popkrF = df_popkr.<span class="built_in">filter</span>(like=<span class="string">&quot;여&quot;</span>).<span class="built_in">filter</span>(like=<span class="string">&quot;세&quot;</span>)</span><br><span class="line">df_popkrFT = df_popkrF.T</span><br><span class="line">df_popkrFT.columns = df_popkr[<span class="string">&quot;행정구역&quot;</span>].values</span><br><span class="line">df_popkrFT = df_popkrFT.astype(<span class="built_in">int</span>)</span><br><span class="line">df_popkrFT[<span class="string">&quot;나이&quot;</span>] = df_popkrFT.index.<span class="built_in">str</span>.split(<span class="string">&quot;_&quot;</span>).<span class="built_in">str</span>[<span class="number">2</span>]</span><br><span class="line">df_popkrFT.reset_index(drop=<span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">df_popkrFT.head(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><img src="85_popkr_07.png"><br></li></ul><h1 id="3-데이터-시각화"><a href="#3-데이터-시각화" class="headerlink" title="3. 데이터 시각화"></a>3. 데이터 시각화</h1><ul><li>이제 정리한 데이터를 그림으로 표현할 차례입니다.</li><li>글의 맨 처음에서 어떻게 그리겠다는 것을 먼저 보여드리긴 했지만 여기서 고민이 필요합니다.</li><li><b>남 vs 여</b>구도를 어떻게 살릴지,</li><li><b>연령대간 변화율</b>이 아닌 <b>연령대별 데이터</b>를 어떻게 표현할지에 대한 고민입니다.</li></ul><ul><li>성별, 연령별 인구 분포는 많이 사용하는 형식이 있습니다.</li><li><b>등을 맞대고 있는 구도</b>로 <b>남 vs 여</b>를 표현합니다.</li><li><b>bar plot</b>으로 <b>해당 구간의 데이터</b>에 집중합니다.<br><br><img src="85_popkr_08.jpg" alt="대강 이런 그림입니다."><br></li></ul><h2 id="3-1-Axes-제작"><a href="#3-1-Axes-제작" class="headerlink" title="3.1. Axes 제작"></a>3.1. Axes 제작</h2><ul><li><code>plt.subplots()</code>명령으로 <code>fig</code>(Figure)와 <code>axs</code>(Axes)를 동시에 생성합니다.</li><li><code>ncols=2</code>로 bar plot이 들어갈 Axes를 두 개 만듭니다.</li><li><code>gridspec_kw=&#123;&quot;wspace&quot;:0&#125;</code>으로 Axes 사이 간격을 없앱니다.</li><li><code>sharey=True</code>로 두 Axes의 y 범위를 통일합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, sharey=<span class="literal">True</span>, </span><br><span class="line">                        figsize=(<span class="number">10</span>, <span class="number">5</span>), gridspec_kw=&#123;<span class="string">&quot;wspace&quot;</span>:<span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure><img src="85_popkr_09.png"><br></li></ul><h2 id="3-2-bar-plot"><a href="#3-2-bar-plot" class="headerlink" title="3.2. bar plot"></a>3.2. bar plot</h2><ul><li>공간이 준비됐으니 데이터를 넣습니다.</li><li><code>ax.barh()</code>명령으로 가로 bar plot을 그립니다.</li><li>x에 나이, y에 전국 인구 수를 넣습니다.</li><li>남성은 green, 여성은 darkorange로 표현합니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, sharey=<span class="literal">True</span>, figsize=(<span class="number">10</span>, <span class="number">5</span>), gridspec_kw=&#123;<span class="string">&quot;wspace&quot;</span>:<span class="number">0</span>&#125;)</span><br><span class="line">axs[<span class="number">0</span>].barh(df_popkrMT[<span class="string">&quot;나이&quot;</span>], df_popkrMT[<span class="string">&quot;전국&quot;</span>], color=<span class="string">&quot;green&quot;</span>)</span><br><span class="line">axs[<span class="number">1</span>].barh(df_popkrFT[<span class="string">&quot;나이&quot;</span>], df_popkrFT[<span class="string">&quot;전국&quot;</span>], color=<span class="string">&quot;darkorange&quot;</span>)</span><br></pre></td></tr></table></figure><img src="85_popkr_10.png"><br></li></ul><h2 id="3-3-남성-좌우-반전"><a href="#3-3-남성-좌우-반전" class="headerlink" title="3.3. 남성 좌우 반전"></a>3.3. 남성 좌우 반전</h2><ul><li>남녀가 등을 맞대고 있도록 표현하려면 남성 데이터의 좌우를 뒤집어야 합니다.</li><li>데이터 범위의 최대값<code>xmax</code>을 충분히 큰 수로 지정하고,</li><li><b>남성은 xmax에서 0으로, 여성은 0에서 xmax로 가도록</b> 지정합니다.</li><li><code>ax.set_xlim()</code>을 사용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, sharey=<span class="literal">True</span>, figsize=(<span class="number">10</span>, <span class="number">5</span>), gridspec_kw=&#123;<span class="string">&quot;wspace&quot;</span>:<span class="number">0</span>&#125;)</span><br><span class="line">axs[<span class="number">0</span>].barh(df_popkrMT[<span class="string">&quot;나이&quot;</span>], df_popkrMT[<span class="string">&quot;전국&quot;</span>], color=<span class="string">&quot;green&quot;</span>)</span><br><span class="line">axs[<span class="number">1</span>].barh(df_popkrFT[<span class="string">&quot;나이&quot;</span>], df_popkrFT[<span class="string">&quot;전국&quot;</span>], color=<span class="string">&quot;darkorange&quot;</span>)</span><br><span class="line"></span><br><span class="line">xmax = <span class="number">4.5e6</span></span><br><span class="line">axs[<span class="number">0</span>].set_xlim(xmax, <span class="number">0</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_xlim(<span class="number">0</span>, xmax)</span><br></pre></td></tr></table></figure><img src="85_popkr_11.png"><br></li></ul><h2 id="3-4-xticklabels-수정"><a href="#3-4-xticklabels-수정" class="headerlink" title="3.4. xticklabels 수정"></a>3.4. xticklabels 수정</h2><ul><li>x축 눈금 레이블(xticklabels)이 0부터 4까지 적혀있고 1e6이라는 숫자가 함께 있습니다.</li><li>$0 \times 10^6$ ~ $4\times 10^6$ 이라는 의미이지만 잘 읽히지 않습니다.</li><li>$4\times 10^6$은 우리 뇌 속에서 <b>4,000,000</b>이 되고, 다시 <b>4백만</b>이 됩니다.</li><li>이럴 바에는 그냥 <b>4백만</b>이라고 써 주는게 낫습니다. </li><li><code>f-string</code>과 list comprehension을 이용해 xticklabels를 수정합니다.</li><li>Axes 두 개에 똑같은 일을 해야 합니다. <code>for loop</code>으로 반복시킵니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, sharey=<span class="literal">True</span>, figsize=(<span class="number">10</span>, <span class="number">5</span>), gridspec_kw=&#123;<span class="string">&quot;wspace&quot;</span>:<span class="number">0</span>&#125;)</span><br><span class="line">axs[<span class="number">0</span>].barh(df_popkrMT[<span class="string">&quot;나이&quot;</span>], df_popkrMT[<span class="string">&quot;전국&quot;</span>], color=<span class="string">&quot;green&quot;</span>)</span><br><span class="line">axs[<span class="number">1</span>].barh(df_popkrFT[<span class="string">&quot;나이&quot;</span>], df_popkrFT[<span class="string">&quot;전국&quot;</span>], color=<span class="string">&quot;darkorange&quot;</span>)</span><br><span class="line"></span><br><span class="line">xmax = <span class="number">4.5e6</span></span><br><span class="line">axs[<span class="number">0</span>].set_xlim(xmax, <span class="number">0</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_xlim(<span class="number">0</span>, xmax)</span><br><span class="line"></span><br><span class="line">xticks = np.arange(<span class="number">0</span>, xmax, <span class="number">1e6</span>)</span><br><span class="line"><span class="keyword">for</span> ax <span class="keyword">in</span> axs:</span><br><span class="line">    ax.set_xticks(xticks)</span><br><span class="line">    ax.set_xticklabels([<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">int</span>(x*<span class="number">1e-6</span>)&#125;</span>백만&quot;</span> <span class="keyword">if</span> x != <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;0&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> xticks])</span><br></pre></td></tr></table></figure><img src="85_popkr_12.png"><br></li></ul><h2 id="3-5-title-grid-추가"><a href="#3-5-title-grid-추가" class="headerlink" title="3.5. title, grid 추가"></a>3.5. title, grid 추가</h2><ul><li><p>남성과 여성을 나란히 그렸으니 어디가 어디인지 적어줘야 합니다.</p></li><li><p>중앙에서 좌우로 뻗은 막대들이 언뜻 보면 비슷합니다.</p></li><li><p><b>정량적인 비교</b>를 돕기 위해 grid를 추가합니다.</p></li><li><p>제목은 <code>ax.set_title()</code>, 눈금은 <code>ax.grid()</code>명령입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, sharey=<span class="literal">True</span>, figsize=(<span class="number">10</span>, <span class="number">5</span>), gridspec_kw=&#123;<span class="string">&quot;wspace&quot;</span>:<span class="number">0</span>&#125;)</span><br><span class="line">axs[<span class="number">0</span>].barh(df_popkrMT[<span class="string">&quot;나이&quot;</span>], df_popkrMT[<span class="string">&quot;전국&quot;</span>], color=<span class="string">&quot;green&quot;</span>)</span><br><span class="line">axs[<span class="number">1</span>].barh(df_popkrFT[<span class="string">&quot;나이&quot;</span>], df_popkrFT[<span class="string">&quot;전국&quot;</span>], color=<span class="string">&quot;darkorange&quot;</span>)</span><br><span class="line"></span><br><span class="line">xmax = <span class="number">4.5e6</span></span><br><span class="line">axs[<span class="number">0</span>].set_xlim(xmax, <span class="number">0</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_xlim(<span class="number">0</span>, xmax)</span><br><span class="line"></span><br><span class="line">xticks = np.arange(<span class="number">0</span>, xmax, <span class="number">1e6</span>)</span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [<span class="string">&quot;남성&quot;</span>, <span class="string">&quot;여성&quot;</span>]):</span><br><span class="line">    ax.set_xticks(xticks)</span><br><span class="line">    ax.set_xticklabels([<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">int</span>(x*<span class="number">1e-6</span>)&#125;</span>백만&quot;</span> <span class="keyword">if</span> x != <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;0&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> xticks])</span><br><span class="line">    ax.grid(c=<span class="string">&quot;lightgray&quot;</span>)</span><br><span class="line">    ax.set_title(title, color=<span class="string">&quot;gray&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>, pad=<span class="number">16</span>)</span><br></pre></td></tr></table></figure><p><img src="85_popkr_13.png"><br></p></li><li><p>이제 <b>남성과 여성의 차이</b>가 조금 눈에 들어옵니다.</p></li><li><p>70대 여성은 2백만명이 넘지만 70대 남성은 2백만명이 못 됩니다.</p></li><li><p>10세 미만은 여성보다 남성이 더 많습니다.</p></li></ul><h2 id="3-6-text-추가"><a href="#3-6-text-추가" class="headerlink" title="3.6. text 추가"></a>3.6. text 추가</h2><ul><li>grid 덕택에 조금은 읽기가 수월해졌지만 정확한 값은 보이지 않습니다.</li><li><b>숫자는 신빙성을 부여합니다. 활용성도 높아집니다.</b></li><li><code>ax.text()</code>명령으로 글자를 넣을 수 있습니다.</li></ul><ul><li><p>그런데 어디에 넣을까요?</p></li><li><p>막대 끝에 넣으면 어떨까요? 데이터의 편차가 돋보일 것입니다.</p></li><li><p>bar plot은 Matplotlib이 patch라는 객체로 관리합니다.</p></li><li><p><code>ax.patches[0]</code>이라면 맨 처음에 붙인 객체를 의미합니다.</p></li><li><p><code>ax.patches</code>와 for loop을 결합하면 하나씩 순회하면서 숫자를 달아봅시다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, sharey=<span class="literal">True</span>, figsize=(<span class="number">10</span>, <span class="number">5</span>), gridspec_kw=&#123;<span class="string">&quot;wspace&quot;</span>:<span class="number">0</span>&#125;)</span><br><span class="line">axs[<span class="number">0</span>].barh(df_popkrMT[<span class="string">&quot;나이&quot;</span>], df_popkrMT[<span class="string">&quot;전국&quot;</span>], color=<span class="string">&quot;green&quot;</span>)</span><br><span class="line">axs[<span class="number">1</span>].barh(df_popkrFT[<span class="string">&quot;나이&quot;</span>], df_popkrFT[<span class="string">&quot;전국&quot;</span>], color=<span class="string">&quot;darkorange&quot;</span>)</span><br><span class="line"></span><br><span class="line">xmax = <span class="number">4.5e6</span></span><br><span class="line">axs[<span class="number">0</span>].set_xlim(xmax, <span class="number">0</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_xlim(<span class="number">0</span>, xmax)</span><br><span class="line"></span><br><span class="line">xticks = np.arange(<span class="number">0</span>, xmax, <span class="number">1e6</span>)</span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [<span class="string">&quot;남성&quot;</span>, <span class="string">&quot;여성&quot;</span>]):</span><br><span class="line">    ax.set_xticks(xticks)</span><br><span class="line">    ax.set_xticklabels([<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">int</span>(x*<span class="number">1e-6</span>)&#125;</span>백만&quot;</span> <span class="keyword">if</span> x != <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;0&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> xticks])</span><br><span class="line">    ax.grid(c=<span class="string">&quot;lightgray&quot;</span>)</span><br><span class="line">    ax.set_title(title, color=<span class="string">&quot;gray&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>, pad=<span class="number">16</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> ax <span class="keyword">in</span> axs:</span><br><span class="line">    <span class="keyword">for</span> i, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(ax.patches):</span><br><span class="line">        w = p.get_width()</span><br><span class="line">        ax.text(w, i, <span class="string">f&quot; <span class="subst">&#123;<span class="built_in">format</span>(w, <span class="string">&#x27;,&#x27;</span>)&#125;</span> &quot;</span>, </span><br><span class="line">                fontsize=<span class="string">&quot;x-small&quot;</span>, va=<span class="string">&quot;center&quot;</span>, ha=<span class="string">&quot;right&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="85_popkr_14.png"><br></p></li><li><p>2중 for loop으로 Axes마다, patch마다 숫자를 달았습니다.</p></li><li><p><code>ax.patch</code>에 <code>.get_width()</code>를 적용해서 위치를 구했습니다.</p></li><li><p><code>format()</code>으로 천 단위마다 쉼표를 추가했고, ha=”right”로 우측 정렬을 했습니다.</p></li><li><p>그런데 여성 데이터마저 우측 정렬이 되어버렸습니다. <code>if</code>를 사용해 여성은 좌측 정렬을 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, sharey=<span class="literal">True</span>, figsize=(<span class="number">10</span>, <span class="number">5</span>), gridspec_kw=&#123;<span class="string">&quot;wspace&quot;</span>:<span class="number">0</span>&#125;)</span><br><span class="line">axs[<span class="number">0</span>].barh(df_popkrMT[<span class="string">&quot;나이&quot;</span>], df_popkrMT[<span class="string">&quot;전국&quot;</span>], color=<span class="string">&quot;green&quot;</span>)</span><br><span class="line">axs[<span class="number">1</span>].barh(df_popkrFT[<span class="string">&quot;나이&quot;</span>], df_popkrFT[<span class="string">&quot;전국&quot;</span>], color=<span class="string">&quot;darkorange&quot;</span>)</span><br><span class="line"></span><br><span class="line">xmax = <span class="number">6e6</span></span><br><span class="line">axs[<span class="number">0</span>].set_xlim(xmax, <span class="number">0</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_xlim(<span class="number">0</span>, xmax)</span><br><span class="line"></span><br><span class="line">xticks = np.arange(<span class="number">0</span>, xmax, <span class="number">1e6</span>)</span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [<span class="string">&quot;남성&quot;</span>, <span class="string">&quot;여성&quot;</span>]):</span><br><span class="line">    ax.set_xticks(xticks)</span><br><span class="line">    ax.set_xticklabels([<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">int</span>(x*<span class="number">1e-6</span>)&#125;</span>백만&quot;</span> <span class="keyword">if</span> x != <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;0&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> xticks])</span><br><span class="line">    ax.grid(c=<span class="string">&quot;lightgray&quot;</span>)</span><br><span class="line">    ax.set_title(title, color=<span class="string">&quot;gray&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>, pad=<span class="number">16</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> ax <span class="keyword">in</span> axs:</span><br><span class="line">    <span class="keyword">for</span> i, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(ax.patches):</span><br><span class="line">        w = p.get_width()</span><br><span class="line">        <span class="keyword">if</span> ax == axs[<span class="number">0</span>]:</span><br><span class="line">            ha = <span class="string">&quot;right&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ha = <span class="string">&quot;left&quot;</span></span><br><span class="line">        </span><br><span class="line">        ax.text(w, i, <span class="string">f&quot; <span class="subst">&#123;<span class="built_in">format</span>(w, <span class="string">&#x27;,&#x27;</span>)&#125;</span> &quot;</span>, </span><br><span class="line">                fontsize=<span class="string">&quot;x-small&quot;</span>, va=<span class="string">&quot;center&quot;</span>, ha=ha)</span><br></pre></td></tr></table></figure><p><img src="85_popkr_15.png"><br></p></li></ul><h2 id="3-7-전체-제목-추가-세부-수정"><a href="#3-7-전체-제목-추가-세부-수정" class="headerlink" title="3.7. 전체 제목 추가, 세부 수정"></a>3.7. 전체 제목 추가, 세부 수정</h2><ul><li>이제 거의 다 그렸습니다. 한번씩 보면서 맘에 들지 않는 부분을 수정합니다.</li><li>먼저 <b>grid와 글자가 너무 난잡합니다.</b></li><li><code>ax.grid(axis=&quot;x&quot;)</code>로 세로선만 남깁니다. </li><li>숫자 색상에 남성과 여성에 사용한 색상을 적용합니다.</li><li>그리고 왼쪽은 남성, 오른쪽은 여성이지만 <b>이게 어디 데이터인지</b>가 없네요.</li><li><code>fig.suptitle()</code>로 추가합니다.</li><li>구성요소간 간격 정리를 위해 <code>fig.tight_layout()</code>을 사용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, sharey=<span class="literal">True</span>, figsize=(<span class="number">10</span>, <span class="number">5</span>), gridspec_kw=&#123;<span class="string">&quot;wspace&quot;</span>:<span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line">c_M = <span class="string">&quot;green&quot;</span></span><br><span class="line">c_F = <span class="string">&quot;darkorange&quot;</span></span><br><span class="line">axs[<span class="number">0</span>].barh(df_popkrMT[<span class="string">&quot;나이&quot;</span>], df_popkrMT[<span class="string">&quot;전국&quot;</span>], color=c_M)</span><br><span class="line">axs[<span class="number">1</span>].barh(df_popkrFT[<span class="string">&quot;나이&quot;</span>], df_popkrFT[<span class="string">&quot;전국&quot;</span>], color=c_F)</span><br><span class="line"></span><br><span class="line">xmax = <span class="number">6e6</span></span><br><span class="line">axs[<span class="number">0</span>].set_xlim(xmax, <span class="number">0</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_xlim(<span class="number">0</span>, xmax)</span><br><span class="line"></span><br><span class="line">xticks = np.arange(<span class="number">0</span>, xmax, <span class="number">1e6</span>)</span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [<span class="string">&quot;남성&quot;</span>, <span class="string">&quot;여성&quot;</span>]):</span><br><span class="line">    ax.set_xticks(xticks)</span><br><span class="line">    ax.set_xticklabels([<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">int</span>(x*<span class="number">1e-6</span>)&#125;</span>백만&quot;</span> <span class="keyword">if</span> x != <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;0&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> xticks])</span><br><span class="line">    ax.grid(axis=<span class="string">&quot;x&quot;</span>, c=<span class="string">&quot;lightgray&quot;</span>)</span><br><span class="line">    ax.set_title(title, color=<span class="string">&quot;gray&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>, pad=<span class="number">16</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> ax <span class="keyword">in</span> axs:</span><br><span class="line">    <span class="keyword">for</span> i, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(ax.patches):</span><br><span class="line">        w = p.get_width()</span><br><span class="line">        <span class="keyword">if</span> ax == axs[<span class="number">0</span>]:</span><br><span class="line">            ha = <span class="string">&quot;right&quot;</span></span><br><span class="line">            c = c_M</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ha = <span class="string">&quot;left&quot;</span></span><br><span class="line">            c = c_F</span><br><span class="line">        </span><br><span class="line">        ax.text(w, i, <span class="string">f&quot; <span class="subst">&#123;<span class="built_in">format</span>(w, <span class="string">&#x27;,&#x27;</span>)&#125;</span> &quot;</span>, </span><br><span class="line">                c=c, fontsize=<span class="string">&quot;x-small&quot;</span>, va=<span class="string">&quot;center&quot;</span>, ha=ha, </span><br><span class="line">                fontweight=<span class="string">&quot;bold&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">fig.suptitle(<span class="string">&quot;                 전국&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><img src="85_popkr_17.png"><br></li></ul><h2 id="3-8-함수로-만들기"><a href="#3-8-함수로-만들기" class="headerlink" title="3.8. 함수로 만들기"></a>3.8. 함수로 만들기</h2><ul><li><p>이제 조금 쓸만해진 것 같습니다.</p></li><li><p>전국 말고 시도별 데이터도 시각화하고 싶은데, 그 때마다 코드를 복붙하기 불편합니다.</p></li><li><p><b>함수로 만들어버립니다.</b></p></li><li><p>변수 이름도 조금은 더 직관적으로 만들고, 인구 수에 따라 적절히 스케일링할 수 있는 장치를 추가합니다.</p></li><li><p>지역의 인구에 따라 <b>백만</b>말고 <b>십만</b>, <b>만</b>, <b>천</b>명이 더 유용할 때도 있겠죠.</p></li><li><p><code>fig</code>를 return해서 여차하면 추가 수정을 할 수 있도록 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_pop</span>(<span class="params">loc, popmax=<span class="number">6e6</span>, poptick=<span class="number">1e6</span></span>):</span></span><br><span class="line">    fig, axs = plt.subplots(ncols=<span class="number">2</span>, sharey=<span class="literal">True</span>, figsize=(<span class="number">10</span>, <span class="number">5</span>), gridspec_kw=&#123;<span class="string">&quot;wspace&quot;</span>:<span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line">    c_M = <span class="string">&quot;green&quot;</span></span><br><span class="line">    c_F = <span class="string">&quot;darkorange&quot;</span></span><br><span class="line">    axs[<span class="number">0</span>].barh(df_popkrMT[<span class="string">&quot;나이&quot;</span>], df_popkrMT[loc], color=c_M)</span><br><span class="line">    axs[<span class="number">1</span>].barh(df_popkrFT[<span class="string">&quot;나이&quot;</span>], df_popkrFT[loc], color=c_F)</span><br><span class="line"></span><br><span class="line">    axs[<span class="number">0</span>].set_xlim(popmax, <span class="number">0</span>)</span><br><span class="line">    axs[<span class="number">1</span>].set_xlim(<span class="number">0</span>, popmax)</span><br><span class="line"></span><br><span class="line">    xticks = np.arange(<span class="number">0</span>, popmax, poptick)</span><br><span class="line">    <span class="keyword">if</span> poptick &gt;= <span class="number">1e6</span>:</span><br><span class="line">        factor, unit = <span class="number">1e-6</span>, <span class="string">&quot;백만&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="number">1e5</span> &lt;= poptick &lt; <span class="number">1e6</span>:</span><br><span class="line">        factor, unit = <span class="number">1e-5</span>, <span class="string">&quot;십만&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="number">1e4</span> &lt;= poptick &lt; <span class="number">2e5</span>:</span><br><span class="line">        factor, unit = <span class="number">1e-4</span>, <span class="string">&quot;만&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="number">1e3</span> &lt;= poptick &lt; <span class="number">2e4</span>:</span><br><span class="line">        factor, unit = <span class="number">1e-3</span>, <span class="string">&quot;천&quot;</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [<span class="string">&quot;남성&quot;</span>, <span class="string">&quot;여성&quot;</span>]):</span><br><span class="line">        ax.set_xticks(xticks)</span><br><span class="line">        ax.set_xticklabels([<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">int</span>(x*factor)&#125;</span><span class="subst">&#123;unit&#125;</span>&quot;</span> <span class="keyword">if</span> x != <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;0&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> xticks])</span><br><span class="line">        ax.grid(axis=<span class="string">&quot;x&quot;</span>, c=<span class="string">&quot;lightgray&quot;</span>)</span><br><span class="line">        ax.set_title(title, color=<span class="string">&quot;gray&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>, pad=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ax <span class="keyword">in</span> axs:</span><br><span class="line">        <span class="keyword">for</span> i, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(ax.patches):</span><br><span class="line">            w = p.get_width()</span><br><span class="line">            <span class="keyword">if</span> ax == axs[<span class="number">0</span>]:</span><br><span class="line">                ha = <span class="string">&quot;right&quot;</span></span><br><span class="line">                c = c_M</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ha = <span class="string">&quot;left&quot;</span></span><br><span class="line">                c = c_F</span><br><span class="line"></span><br><span class="line">            ax.text(w, i, <span class="string">f&quot; <span class="subst">&#123;<span class="built_in">format</span>(w, <span class="string">&#x27;,&#x27;</span>)&#125;</span> &quot;</span>, </span><br><span class="line">                    c=c, fontsize=<span class="string">&quot;x-small&quot;</span>, va=<span class="string">&quot;center&quot;</span>, ha=ha, </span><br><span class="line">                    fontweight=<span class="string">&quot;bold&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    fig.suptitle(<span class="string">f&quot;                 <span class="subst">&#123;loc&#125;</span>&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">    fig.tight_layout()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fig</span><br></pre></td></tr></table></figure></li><li><p>이 함수로 전국 인구 분포를 그려봅시다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fig = plot_pop(<span class="string">&quot;전국&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="85_popkr_18.png"><br></p></li><li><p>똑같이 나왔습니다. :)</p></li><li><p>서울시를 해볼까요? 구간별 인구 단위가 <b>십만</b>으로 줄어듭니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fig = plot_pop(<span class="string">&quot;서울특별시&quot;</span>, popmax=<span class="number">1e6</span>, poptick=<span class="number">2e5</span>)</span><br></pre></td></tr></table></figure><p><img src="85_popkr_19.png"><br></p></li><li><p>이제는 세종시 차례입니다. 구간별 인구 단위가 <b>만</b>단위로 줄어듭니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fig = plot_pop(<span class="string">&quot;세종특별자치시&quot;</span>, popmax=<span class="number">1e6</span>, poptick=<span class="number">2e5</span>)</span><br></pre></td></tr></table></figure><p><img src="85_popkr_20.png"><br></p></li><li><p>같은 요령으로 영호남과 다른 광역시도 그릴 수 있습니다.<br><br><img src="85_popkr_26.png"><br></p></li></ul><h1 id="4-결론"><a href="#4-결론" class="headerlink" title="4. 결론"></a>4. 결론</h1><ul><li>수작업 대신 코딩을 왜 하냐는 질문에 가장 좋은 답변 중 하나는 <b>반복 작업 처리</b>일 것입니다.</li><li><b>수작업보다 체계적인 작업</b>도 답변이 될 수 있을 것입니다.</li><li>데이터 시각화 작업을 체계적으로, 그리고 반복에 대응하는 방법은 <b>객체지향 방식</b>입니다.</li><li>Matplotlib을 다루시는 많은 분들께 평안이 깃들기를 기원합니다. </li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/pandas/">pandas</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      
    </item>
    
    <item>
      <title>pytorch &amp; sklearn pipeline</title>
      <link>https://jehyunlee.github.io/2021/09/29/Python-DL-7-skorch_pipeline/</link>
      <guid>https://jehyunlee.github.io/2021/09/29/Python-DL-7-skorch_pipeline/</guid>
      <pubDate>Wed, 29 Sep 2021 02:57:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;저는 tabular data를 다룹니다.&lt;/li&gt;
&lt;li&gt;간혹 딥러닝을 하고 싶지만 표준화등 전처리도 해야 합니다.&lt;/li&gt;
&lt;li&gt;범주형 변수를 인코딩해서 feature importance도 보고 싶습니다.&lt;/li&gt;
&lt;li&gt;skorc</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>저는 tabular data를 다룹니다.</li><li>간혹 딥러닝을 하고 싶지만 표준화등 전처리도 해야 합니다.</li><li>범주형 변수를 인코딩해서 feature importance도 보고 싶습니다.</li><li>skorch(sklearn + pytorch)를 사용하면 가능합니다.</li></ul><h1 id="1-skorch-sklearn-pytorch"><a href="#1-skorch-sklearn-pytorch" class="headerlink" title="1. skorch = sklearn + pytorch"></a>1. skorch = sklearn + pytorch</h1><p><img src="7_skorch_pipeline.png"></p><blockquote><p><a href="https://skorch.readthedocs.io/en/stable/index.html">skorch documentation</a><br><a href="https://skorch.readthedocs.io/en/stable/user/tutorials.html">skorch tutorials</a></p></blockquote><ul><li>저같은 사람들을 위해 skorch라는 라이브러리가 있습니다.</li><li>scikit-learn의 장점인 <b>grid search 등을 딥러닝과 함께</b> 사용할 수 있고</li><li>tutorial에서 transfer learning, U-Net, Seq2Seq 등을 지원합니다.<br><br><img src="7_skorch_pipeline_9.png"><br></li></ul><h1 id="2-sklearn-pipeline"><a href="#2-sklearn-pipeline" class="headerlink" title="2. sklearn pipeline"></a>2. sklearn pipeline</h1><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html">scikit-learn.pipeline.Pipeline</a></p></blockquote><ul><li>scikit-learn의 파이프라인은 데이터 전처리에서 발생하는 불확실성을 줄여줍니다.</li><li>데이터가 거쳐갈 길을 단단하게 만들어줌으로써 실수를 사전에 예방할 수 있습니다.</li><li>특히 PCA나 One-hot encoding처럼 <b>trainset의 정보를 기억해서 testset에 적용해야 할 때 좋습니다</b>.</li></ul><h2 id="2-1-예제-데이터셋"><a href="#2-1-예제-데이터셋" class="headerlink" title="2.1. 예제 데이터셋"></a>2.1. 예제 데이터셋</h2><ul><li>펭귄 데이터셋을 사용해서 펭귄 체중 예측모델을 만들어 봅니다.</li><li>편의를 위해 결측치까지 싹 지운 채로 시작합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 시각화 설정</span></span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line">sns.set_style(<span class="string">&quot;white&quot;</span>)</span><br><span class="line">font_title = &#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux 한글 사용 설정</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>]=[<span class="string">&#x27;NanumGothic&#x27;</span>, <span class="string">&#x27;sans-serif&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 펭귄 데이터셋 불러오기</span></span><br><span class="line">df_peng = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)</span><br><span class="line">df_peng.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line">df_peng.isna().<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure></li><li>실행 결과: 결측치가 모두 제거되었습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">species              0</span><br><span class="line">island               0</span><br><span class="line">bill_length_mm       0</span><br><span class="line">bill_depth_mm        0</span><br><span class="line">flipper_length_mm    0</span><br><span class="line">body_mass_g          0</span><br><span class="line">sex                  0</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></li></ul><ul><li>데이터셋을 준비합니다.</li><li>펭귄 체중만 y, 나머지는 모두 X입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y = df_peng[<span class="string">&quot;body_mass_g&quot;</span>]</span><br><span class="line">X = df_peng.drop(<span class="string">&quot;body_mass_g&quot;</span>, axis=<span class="number">1</span>)</span><br><span class="line">X.head(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><img src="7_skorch_pipeline_10.png"><br></li></ul><ul><li>trainset과 testset으로 나눕니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data split</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2-pipeline-구축"><a href="#2-2-pipeline-구축" class="headerlink" title="2.2. pipeline 구축"></a>2.2. pipeline 구축</h2><ul><li>scikit-learn으로 pipeline을 구축합니다.</li><li>numerical feature는 회귀모델 적용을 고려한 <code>PolynomialFeatures</code>와</li><li>데이터 정규화를 위한 <code>RobustScaler</code>를 거칩니다.</li><li>categorical feature는 <code>OneHotEncoder</code>를 거칩니다.</li></ul><ul><li><p>필요한 라이브러리를 불러옵니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoder</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> RobustScaler</span><br><span class="line"></span><br><span class="line"><span class="comment"># machine learning models</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"></span><br><span class="line"><span class="comment"># pipeline</span></span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.compose <span class="keyword">import</span> ColumnTransformer</span><br><span class="line"></span><br><span class="line"><span class="comment"># metrics</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br></pre></td></tr></table></figure></li><li><p>pipeline을 구축하는 함수를 만듭니다.</p></li><li><p><code>get_model_0()</code>을 실행하면 파이프라인이 만들어질 것입니다.</p></li><li><p>전처리 후 머신러닝 모델로는 선형회귀와 랜덤포레스트를 선택할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_model_0</span>(<span class="params">X_cols, degree=<span class="number">1</span>, method=<span class="string">&quot;lr&quot;</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    X_cols_ = deepcopy(X_cols)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1-1.categorical feature에 one-hot encoding 적용</span></span><br><span class="line">    cat_features = <span class="built_in">list</span>(<span class="built_in">set</span>(X_cols) &amp; <span class="built_in">set</span>([<span class="string">&quot;species&quot;</span>, <span class="string">&quot;island&quot;</span>, <span class="string">&quot;sex&quot;</span>]))</span><br><span class="line">    cat_transformer = OneHotEncoder(sparse=<span class="literal">False</span>, handle_unknown=<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1-2.numerical feature는 Power Transform과 Scaler를 거침</span></span><br><span class="line">    num_features = <span class="built_in">list</span>(<span class="built_in">set</span>(X_cols) - <span class="built_in">set</span>(cat_features))</span><br><span class="line">    num_features.sort()</span><br><span class="line">    num_transformer = Pipeline(steps=[(<span class="string">&quot;polynomial&quot;</span>, PolynomialFeatures(degree=degree)), </span><br><span class="line">                                      (<span class="string">&quot;scaler&quot;</span>, RobustScaler())</span><br><span class="line">                                     ])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 인자 종류별 전처리 적용</span></span><br><span class="line">    preprocessor = ColumnTransformer(transformers=[(<span class="string">&quot;num&quot;</span>, num_transformer, num_features), </span><br><span class="line">                                                   (<span class="string">&quot;cat&quot;</span>, cat_transformer, cat_features)])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 전처리 후 머신러닝 모델 적용</span></span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">&quot;lr&quot;</span>:</span><br><span class="line">        ml = LinearRegression(fit_intercept=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&quot;rf&quot;</span>:</span><br><span class="line">        ml = RandomForestRegressor()</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 3. Pipeline</span></span><br><span class="line">    model = Pipeline(steps=[(<span class="string">&quot;preprocessor&quot;</span>, preprocessor), </span><br><span class="line">                            (<span class="string">&quot;ml&quot;</span>, ml)])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure></li><li><p>6번째, 10번째 행을 보시면 조금 특이한 처리가 들어가 있습니다.</p></li><li><p><b>feature selection에 사용되는 장치</b>입니다.</p></li><li><p>feature 이름들을 하드코딩하면 feature selection이 불가능하기 때문에 이렇게 합니다.</p></li></ul><ul><li>만들어진 구조를 확인합니다.</li><li>일단 모든 인자를 모두 입력합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> set_config</span><br><span class="line">set_config(display=<span class="string">&#x27;diagram&#x27;</span>)</span><br><span class="line">model_0 = get_model_0(<span class="built_in">list</span>(X_train.columns), degree=<span class="number">1</span>, method=<span class="string">&quot;lr&quot;</span>)</span><br><span class="line">model_0</span><br></pre></td></tr></table></figure><img src="7_skorch_pipeline_11.png"><br></li></ul><h2 id="2-3-pipeline-전처리-확인"><a href="#2-3-pipeline-전처리-확인" class="headerlink" title="2.3. pipeline 전처리 확인"></a>2.3. pipeline 전처리 확인</h2><ul><li>pipeline에서 전처리 모듈만 떼어서 실행합니다.</li><li>pipeline의 모듈을 호출하는 방법은 <b>모델이름[“모듈이름”]</b>입니다.</li><li>따라서 우리의 전처리 모듈은 <b>model_0[“preprocessor”]</b>입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X_train_pp = model_0[<span class="string">&quot;preprocessor&quot;</span>].fit_transform(X_train)</span><br><span class="line"><span class="built_in">print</span>(X_train_pp.shape)</span><br><span class="line">X_train_pp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li><li>실행 결과: 첫 행만 찍어봤습니다. <b>숫자가 많습니다</b><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">266</span>, <span class="number">12</span>)</span><br><span class="line">array([ <span class="number">0.</span>        , -<span class="number">0.80645161</span>,  <span class="number">0.08579088</span>,  <span class="number">1.</span>        ,  <span class="number">1.</span>        ,</span><br><span class="line">        <span class="number">0.</span>        ,  <span class="number">0.</span>        ,  <span class="number">0.</span>        ,  <span class="number">0.</span>        ,  <span class="number">1.</span>        ,</span><br><span class="line">        <span class="number">0.</span>        ,  <span class="number">1.</span>        ])</span><br></pre></td></tr></table></figure></li></ul><ul><li>6개의 인자를 넣었는데 12개가 나왔습니다.</li><li>처음의 0은 LinearRegression에서 만든 intercept 항입니다.</li><li>네번째 1부터는 species, island, sex의 one-hot encoding 결과물입니다.</li></ul><ul><li>전처리 이후 데이터 분포도 확인합니다.</li><li>시각화 코드는 다소 길고, 여기선 중요하지 않아서 접었습니다.<details>  <summary><b>코드 보기/접기</b></summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Figure 생성</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>, <span class="number">8</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Subfigures 생성</span></span><br><span class="line">subfigs = fig.subfigures(nrows=<span class="number">2</span>, wspace=<span class="number">0.05</span>)</span><br><span class="line">subfigs[<span class="number">0</span>].set_facecolor(<span class="string">&quot;lightgray&quot;</span>)</span><br><span class="line">subfigs[<span class="number">1</span>].set_facecolor(<span class="string">&quot;beige&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># subfigs[0]: raw data</span></span><br><span class="line">axs0 = subfigs[<span class="number">0</span>].subplots(ncols=<span class="number">3</span>, nrows=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sns.kdeplot(X_train[<span class="string">&quot;bill_depth_mm&quot;</span>], cut=<span class="number">0</span>, fill=<span class="literal">True</span>, ax=axs0[<span class="number">0</span>])</span><br><span class="line">sns.kdeplot(X_train[<span class="string">&quot;bill_length_mm&quot;</span>], cut=<span class="number">0</span>, fill=<span class="literal">True</span>, ax=axs0[<span class="number">1</span>])</span><br><span class="line">sns.kdeplot(X_train[<span class="string">&quot;flipper_length_mm&quot;</span>], cut=<span class="number">0</span>, fill=<span class="literal">True</span>, ax=axs0[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># subfigs[1]: preprocessed data</span></span><br><span class="line">axs1 = subfigs[<span class="number">1</span>].subplots(ncols=<span class="number">3</span>, nrows=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sns.kdeplot(X_train_pp[:,<span class="number">1</span>], cut=<span class="number">0</span>, fill=<span class="literal">True</span>, ax=axs1[<span class="number">0</span>])</span><br><span class="line">sns.kdeplot(X_train_pp[:,<span class="number">2</span>], cut=<span class="number">0</span>, fill=<span class="literal">True</span>, ax=axs1[<span class="number">1</span>])</span><br><span class="line">sns.kdeplot(X_train_pp[:,<span class="number">3</span>], cut=<span class="number">0</span>, fill=<span class="literal">True</span>, ax=axs1[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax <span class="keyword">in</span> axs1:</span><br><span class="line">    ax.axvline(<span class="number">0</span>, c=<span class="string">&quot;gray&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> axs <span class="keyword">in</span> [axs0, axs1]:</span><br><span class="line">    <span class="keyword">for</span> i, (ax, title) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(axs, [<span class="string">&#x27;bill_depth_mm&#x27;</span>, <span class="string">&#x27;bill_length_mm&#x27;</span>, <span class="string">&#x27;flipper_length_mm&#x27;</span>])):</span><br><span class="line">        ax.set_xlabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        ax.set_title(<span class="string">f&quot;<span class="subst">&#123;title&#125;</span>&quot;</span>, fontdict=font_title, pad=<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            ax.set_ylabel(<span class="string">&quot; \n&quot;</span>)</span><br><span class="line"></span><br><span class="line">subfigs[<span class="number">0</span>].suptitle(<span class="string">&quot;raw data\n&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">subfigs[<span class="number">1</span>].suptitle(<span class="string">&quot;preprocessed data\n&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">fig.suptitle(<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><p><img src="7_skorch_pipeline_1.png"><br></p><ul><li>RobustScaler의 효과가 잘 보입니다.</li></ul><h2 id="2-3-pipeline-학습"><a href="#2-3-pipeline-학습" class="headerlink" title="2.3. pipeline 학습"></a>2.3. pipeline 학습</h2><ul><li><p><b>pipeline 전체를 사용해서 학습</b>시킵니다.</p></li><li><p>명령은 scikit-learn 스타일 그대로 <code>.fit()</code>입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model_0.fit(X_train, y_train)</span><br></pre></td></tr></table></figure></li><li><p>학습이 잘 되었는지 결과를 확인합니다.</p></li><li><p>parity plot 시각화 코드는 접어두었습니다.</p><details>  <summary><b>코드 보기/접기</b></summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parity plot</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_parity</span>(<span class="params">model, y_true, y_pred=<span class="literal">None</span>, X_to_pred=<span class="literal">None</span>, ax=<span class="literal">None</span>, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ax:</span><br><span class="line">        fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> y_pred <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        y_pred = model.predict(X_to_pred)</span><br><span class="line">    ax.scatter(y_true, y_pred, **kwargs)</span><br><span class="line">    xbound = ax.get_xbound()</span><br><span class="line">    xticks = [x <span class="keyword">for</span> x <span class="keyword">in</span> ax.get_xticks() <span class="keyword">if</span> xbound[<span class="number">0</span>] &lt;= x &lt;= xbound[<span class="number">1</span>]]</span><br><span class="line">    ax.set_xticks(xticks)</span><br><span class="line">    ax.set_xticklabels([<span class="string">f&quot;<span class="subst">&#123;x:<span class="number">.0</span>f&#125;</span>&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> xticks])</span><br><span class="line">    ax.set_yticks(xticks)</span><br><span class="line">    ax.set_yticklabels([<span class="string">f&quot;<span class="subst">&#123;x:<span class="number">.0</span>f&#125;</span>&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> xticks])</span><br><span class="line">    dxbound = <span class="number">0.05</span>*(xbound[<span class="number">1</span>]-xbound[<span class="number">0</span>])</span><br><span class="line">    ax.set_xlim(xbound[<span class="number">0</span>]-dxbound, xbound[<span class="number">1</span>]+dxbound)</span><br><span class="line">    ax.set_ylim(xbound[<span class="number">0</span>]-dxbound, xbound[<span class="number">1</span>]+dxbound)</span><br><span class="line">    </span><br><span class="line">    rmse = mean_squared_error(y_true, y_pred, squared=<span class="literal">False</span>)</span><br><span class="line">    r2 = r2_score(y_true, y_pred)</span><br><span class="line">    ax.text(<span class="number">0.95</span>, <span class="number">0.1</span>, <span class="string">f&quot;RMSE = <span class="subst">&#123;rmse:<span class="number">.2</span>f&#125;</span>\nR2 = <span class="subst">&#123;r2:<span class="number">.2</span>f&#125;</span>&quot;</span>, transform=ax.transAxes, </span><br><span class="line">            fontsize=<span class="number">14</span>, ha=<span class="string">&quot;right&quot;</span>, va=<span class="string">&quot;bottom&quot;</span>, bbox=&#123;<span class="string">&quot;boxstyle&quot;</span>:<span class="string">&quot;round&quot;</span>, <span class="string">&quot;fc&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;pad&quot;</span>:<span class="number">0.3</span>&#125;)</span><br><span class="line">    </span><br><span class="line">    ax.grid(<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ax</span><br><span class="line">    </span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">8</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line">plot_parity(model_0, y_train, X_to_pred=X_train, ax=axs[<span class="number">0</span>], c=<span class="string">&quot;g&quot;</span>, s=<span class="number">10</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plot_parity(model_0, y_test, X_to_pred=X_test, ax=axs[<span class="number">1</span>], c=<span class="string">&quot;m&quot;</span>, s=<span class="number">10</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [<span class="string">&quot;train&quot;</span>, <span class="string">&quot;test&quot;</span>]):</span><br><span class="line">    ax.set_title(title, fontdict=font_title, pad=<span class="number">16</span>)</span><br></pre></td></tr></table></figure></li></ul><p><img src="7_skorch_pipeline_2.png"><br></p><ul><li><p>단순 선형 회귀 모델인데 제법 쓸만합니다.</p></li><li><p>이제 pipeline에 랜덤포레스트 모델을 탑재해서 돌려봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model_1 = get_model_0(<span class="built_in">list</span>(X_train.columns), degree=<span class="number">1</span>, method=<span class="string">&quot;rf&quot;</span>)</span><br><span class="line">model_1.fit(X_train, y_train)</span><br><span class="line">model_1</span><br></pre></td></tr></table></figure><p><img src="7_skorch_pipeline_3.png"><br></p></li><li><p>과적합이 의심되긴 하지만 랜덤포레스트도 잘 나오네요.</p></li></ul><ul><li><p>이번에는 <b>feature selection</b>도 되는지 확인합니다.</p></li><li><p>부리 길이<code>bill_length_mm</code>와 종<code>species</code>만 가지고 결과를 예측해봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model_2 = get_model_0([<span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;species&quot;</span>], degree=<span class="number">1</span>, method=<span class="string">&quot;rf&quot;</span>)</span><br><span class="line">model_2.fit(X_train, y_train)</span><br></pre></td></tr></table></figure><p><img src="7_skorch_pipeline_4.png"><br></p></li><li><p>멀쩡한 인자들을 제외했으니 성능이 떨어지는 건 정상입니다.</p></li><li><p><b>pipeline을 작성하기에 따라 feature 중 일부만 넣어도 동작한다</b>는 것이 중요합니다.</p></li></ul><h1 id="3-pytorch-deep-learning"><a href="#3-pytorch-deep-learning" class="headerlink" title="3. pytorch deep learning"></a>3. pytorch deep learning</h1><ul><li>딥러닝은 다른 방법에 비해 복잡하고 연산자원이 많이 들지만 장점이 많습니다.</li><li>이미지나 시계열을 다룰 때 큰 힘을 발휘하는데, 간혹 tabular data에도 필요합니다.</li><li>pytorch만을 사용해서 모델을 만들어보고 pipeline에 탑재해서도 결과를 얻어봅니다.</li></ul><h2 id="3-1-pytorch-only"><a href="#3-1-pytorch-only" class="headerlink" title="3.1. pytorch only"></a>3.1. pytorch only</h2><ul><li><p>파이토치로 신경망 모델을 만들고 같은 데이터로 같은 문제를 풀어봅니다.</p></li><li><p>간단한 신경망 모델을 만듭니다. 나중에 pipeline 안에 넣을 겁니다. </p></li><li><p>feature selection을 대비해서 input dimension을 가변적으로 만듭니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim</span><br><span class="line"><span class="keyword">from</span> torch.optim.lr_scheduler <span class="keyword">import</span> CyclicLR</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegressorModule</span>(<span class="params">nn.Module</span>):</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ninput=<span class="number">11</span>, init_weights=<span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(RegressorModule, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self.model = nn.Sequential(nn.Linear(ninput, <span class="number">16</span>),</span><br><span class="line">                                   nn.ReLU(),</span><br><span class="line">                                   nn.Linear(<span class="number">16</span>, <span class="number">16</span>),</span><br><span class="line">                                   nn.ReLU(),</span><br><span class="line">                                   nn.Linear(<span class="number">16</span>, <span class="number">12</span>),</span><br><span class="line">                                   nn.ReLU(),</span><br><span class="line">                                   nn.Linear(<span class="number">12</span>, <span class="number">8</span>),</span><br><span class="line">                                   nn.ReLU(),</span><br><span class="line">                                   nn.Linear(<span class="number">8</span>, <span class="number">1</span>),</span><br><span class="line">                                   )</span><br><span class="line">        <span class="keyword">if</span> init_weights:</span><br><span class="line">            self._initialize_weights()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.model(X)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_initialize_weights</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> self.modules():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Linear):</span><br><span class="line">                nn.init.normal_(m.weight, <span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line">                nn.init.constant_(m.bias, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li><li><p>pytorch에 데이터를 넣으려면 tensor로 만들어야 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X_train_tensor = torch.Tensor(pd.get_dummies(X_train).astype(np.float32).values)</span><br><span class="line">y_train_tensor = torch.Tensor(y_train.astype(np.float32).values)</span><br></pre></td></tr></table></figure></li><li><p>지금 만든 모델에 학습을 시킬 수 있는 코드를 구현합니다.</p></li><li><p>1만 epoch동안 충분히 데이터를 넣어봅니다.</p></li><li><p>loss function으로는 RMSELoss를 구현해서 사용했습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">net = RegressorModule()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RMSELoss</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, eps=<span class="number">1e-6</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.mse = nn.MSELoss()</span><br><span class="line">        self.eps = eps</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,yhat,y</span>):</span></span><br><span class="line">        loss = torch.sqrt(self.mse(yhat,y) + self.eps)</span><br><span class="line">        <span class="keyword">return</span> loss</span><br><span class="line">    </span><br><span class="line">loss_func = RMSELoss()</span><br><span class="line">optimizer = optim.Adam(net.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">losses = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    output = net.forward(X_train_tensor)</span><br><span class="line">    loss = loss_func(output, y_train_tensor.view(-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line">    </span><br><span class="line">    losses.append(loss)</span><br><span class="line">    </span><br><span class="line">plt.plot(losses)</span><br></pre></td></tr></table></figure><p><img src="7_skorch_pipeline_5.png"><br></p></li></ul><ul><li><p>제법 학습이 잘 된 것 같습니다.</p></li><li><p>예측 성능을 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># numpy array를 pytorch tensor로 변환</span></span><br><span class="line">X_test_tensor = torch.Tensor(pd.get_dummies(X_test).astype(np.float32).values)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 예측값</span></span><br><span class="line">y_pred_train_tensor = net.forward(X_train_tensor)</span><br><span class="line">y_pred_test_tensor = net.forward(X_test_tensor)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pytorch tensor를 다시 numpy array로 변환</span></span><br><span class="line">y_pred_train = y_pred_train_tensor.detach().numpy()</span><br><span class="line">y_pred_test = y_pred_test_tensor.detach().numpy()</span><br></pre></td></tr></table></figure><p><img src="7_skorch_pipeline_6.png"><br></p></li><li><p><b>딥러닝으로도 제법 괜찮은 성능이 나오는 것</b>을 확인했습니다.</p></li></ul><h2 id="3-2-pytorch-pipeline"><a href="#3-2-pytorch-pipeline" class="headerlink" title="3.2. pytorch @pipeline"></a>3.2. pytorch @pipeline</h2><ul><li><b>skorch를 이용해서 pytorch를 pipeline 안에 탑재합니다.</b></li><li><b>skorch은 pytorch를 scikit-learn 객체처럼 만들어주는 일</b>을 합니다.</li><li>그래서 skorch로 감싼 pytorch 객체의 학습은 <b><code>fit()</code></b>이고,</li><li>예측은 <b><code>.forward()&lt;/b&gt;가 아니라 &lt;b&gt;</code>.predict()</b>입니다.</li></ul><ul><li>skorch의 <code>NeuralNetRegressor()</code>로 딥러닝 모듈 전체를 감싸고,</li><li>학습에 필요한 인자를 매개변수로 전달합니다.</li></ul><ul><li>그리고 중요한 사항이 하나 있습니다.</li><li><b>scikit-learn이 뱉는 <code>np.float64</code>를 <code>np.float32</code>로 변환</b>해야 합니다.</li><li>이를 위해 custom transformer를 만들어 적용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skorch <span class="keyword">import</span> NeuralNetRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.base <span class="keyword">import</span> BaseEstimator, TransformerMixin</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_model_T</span>(<span class="params">X_cols, degree=<span class="number">1</span>, method=<span class="string">&quot;lr&quot;</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    X_cols_ = deepcopy(X_cols)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1-1.categorical feature에 one-hot encoding 적용</span></span><br><span class="line">    cat_features = <span class="built_in">list</span>(<span class="built_in">set</span>(X_cols) &amp; <span class="built_in">set</span>([<span class="string">&quot;species&quot;</span>, <span class="string">&quot;island&quot;</span>, <span class="string">&quot;sex&quot;</span>]))</span><br><span class="line">    cat_transformer = OneHotEncoder(sparse=<span class="literal">False</span>, handle_unknown=<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1-2.numerical feature는 Power Transform과 Scaler를 거침</span></span><br><span class="line">    num_features = <span class="built_in">list</span>(<span class="built_in">set</span>(X_cols) - <span class="built_in">set</span>(cat_features))</span><br><span class="line">    num_features.sort()</span><br><span class="line">    num_transformer = Pipeline(steps=[(<span class="string">&quot;polynomial&quot;</span>, PolynomialFeatures(degree=degree)), </span><br><span class="line">                                      (<span class="string">&quot;scaler&quot;</span>, RobustScaler())</span><br><span class="line">                                     ])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 인자 종류별 전처리 적용</span></span><br><span class="line">    preprocessor = ColumnTransformer(transformers=[(<span class="string">&quot;num&quot;</span>, num_transformer, num_features), </span><br><span class="line">                                                   (<span class="string">&quot;cat&quot;</span>, cat_transformer, cat_features)])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. float64를 float32로 변환</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FloatTransformer</span>(<span class="params">BaseEstimator, TransformerMixin</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fit</span>(<span class="params">self, X, y=<span class="literal">None</span></span>):</span></span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">transform</span>(<span class="params">self, x</span>):</span></span><br><span class="line">            <span class="keyword">return</span> np.array(x, dtype=np.float32)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 전처리 후 머신러닝 모델 적용</span></span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">&quot;lr&quot;</span>:</span><br><span class="line">        ml = LinearRegression(fit_intercept=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&quot;rf&quot;</span>:</span><br><span class="line">        ml = RandomForestRegressor()</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&quot;torch&quot;</span>:</span><br><span class="line">        ninput = <span class="built_in">len</span>(num_features) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;species&quot;</span> <span class="keyword">in</span> cat_features:</span><br><span class="line">            ninput += <span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;island&quot;</span> <span class="keyword">in</span> cat_features:</span><br><span class="line">            ninput += <span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;sex&quot;</span> <span class="keyword">in</span> cat_features:</span><br><span class="line">            ninput += <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">        net = NeuralNetRegressor(RegressorModule(ninput=ninput, init_weights=<span class="literal">False</span>),</span><br><span class="line">                         max_epochs=<span class="number">1000</span>, verbose=<span class="number">0</span>,</span><br><span class="line">                         warm_start=<span class="literal">True</span>,</span><br><span class="line"><span class="comment">#                          device=&#x27;cuda&#x27;,</span></span><br><span class="line">                         criterion=RMSELoss,</span><br><span class="line">                         optimizer = optim.Adam,</span><br><span class="line">                         optimizer__lr = <span class="number">0.01</span></span><br><span class="line">                        )</span><br><span class="line">        ml = net</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 3. Pipeline</span></span><br><span class="line">    model = Pipeline(steps=[(<span class="string">&quot;preprocessor&quot;</span>, preprocessor), </span><br><span class="line">                            (<span class="string">&quot;float64to32&quot;</span>, FloatTransformer()),</span><br><span class="line">                            (<span class="string">&quot;ml&quot;</span>, ml)])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>모델을 만들고 확인합니다.</p></li><li><p>앞서 pytorch로 구현한 뉴럴넷 구조가 그대로 들어가 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model_T = get_model_T(<span class="built_in">list</span>(X_train.columns), degree=<span class="number">1</span>, method=<span class="string">&quot;torch&quot;</span>)</span><br><span class="line">model_T.fit(X_train, y_train.astype(np.float32).values.reshape(-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">model_T</span><br></pre></td></tr></table></figure><p><img src="7_skorch_pipeline_13.png"><br></p></li><li><p><b>성능을 확인합니다.</b> 준수하네요.<br><img src="7_skorch_pipeline_7.png"><br></p></li></ul><h1 id="4-permutation-feature-importance"><a href="#4-permutation-feature-importance" class="headerlink" title="4. permutation feature importance"></a>4. permutation feature importance</h1><ul><li>같은 파이프라인에서 선형, 트리, 딥러닝이 모두 구현되었습니다.</li><li>각각의 인자 중요도를 한번 확인해보겠습니다.</li><li>permutation importance를 사용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.inspection <span class="keyword">import</span> permutation_importance</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linear Regression</span></span><br><span class="line">pi_0 = permutation_importance(model_0, X_test, y_test, n_repeats=<span class="number">30</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Random Forest</span></span><br><span class="line">pi_1 = permutation_importance(model_1, X_test, y_test, n_repeats=<span class="number">30</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Neural Network</span></span><br><span class="line">pi_T = permutation_importance(model_T, X_test, y_test, n_repeats=<span class="number">30</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 시각화</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">15</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, pi, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [pi_0, pi_1, pi_T], [<span class="string">&quot;Linear Reg.&quot;</span>, <span class="string">&quot;Random Forest&quot;</span>, <span class="string">&quot;Neural Net&quot;</span>]):</span><br><span class="line">    ax.barh(X_test.columns, pi.importances_mean, xerr=pi.importances_std, color=<span class="string">&quot;orange&quot;</span>)</span><br><span class="line">    ax.invert_yaxis()</span><br><span class="line">    ax.set_xlim(<span class="number">0</span>, )</span><br><span class="line">    ax.set_title(title, fontdict=font_title, pad=<span class="number">16</span>)</span><br></pre></td></tr></table></figure><img src="7_skorch_pipeline_8.png"><br></li></ul><ul><li><b>입력 feature별 인자 중요도가 깔끔하게 정리되었습니다.</b></li><li>양상도 전반적으로 비슷하게 나오네요.</li><li>사소한 기능같지만 <b>tabular data를 딥러닝으로 돌렸을 때 이 그림을 그리기가 어려웠습니다.</b></li><li>이 글과 코드가 비슷한 어려움을 겪는 여러분께 도움이 되면 좋겠습니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Deep-Learning/">Deep Learning</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/pytorch/">pytorch</category>
      
      <category domain="https://jehyunlee.github.io/tags/sklearn/">sklearn</category>
      
      <category domain="https://jehyunlee.github.io/tags/pipeline/">pipeline</category>
      
      <category domain="https://jehyunlee.github.io/tags/neural-network/">neural network</category>
      
      
    </item>
    
    <item>
      <title>Full moon</title>
      <link>https://jehyunlee.github.io/2021/09/26/Python-General-9-fullmoon/</link>
      <guid>https://jehyunlee.github.io/2021/09/26/Python-General-9-fullmoon/</guid>
      <pubDate>Sat, 25 Sep 2021 23:52:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;지난 추석, 간만에 긴장을 풀었습니다.&lt;/li&gt;
&lt;li&gt;가끔 취미로 그림을 그리고는 하는데 python으로는 안그렸네요.&lt;/li&gt;
&lt;li&gt;자다가 문득 코드가 떠올라 보름달을 그렸습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-보름달은&quot;&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>지난 추석, 간만에 긴장을 풀었습니다.</li><li>가끔 취미로 그림을 그리고는 하는데 python으로는 안그렸네요.</li><li>자다가 문득 코드가 떠올라 보름달을 그렸습니다.</li></ul><h1 id="1-보름달은"><a href="#1-보름달은" class="headerlink" title="1. 보름달은?"></a>1. 보름달은?</h1><ul><li><p><b>보름달</b>이 어떻게 생겼는지 모르는 사람은 없을 겁니다.<br><br><img src="9_fullmoon_01.jpg"><br></p></li><li><p><b>검은 밤 하늘에 떠 있는 하얀 동그라미</b>로 단순화할 수 있습니다.</p></li><li><p>토끼가 방아를 찧고 있는 듯한 모양이 있지만 잠시 잊기로 합니다.</p></li><li><p>하지만 그냥 동그라미를 그리기엔 심심합니다. 작은 동그라미를 여럿 겹칩니다.</p></li></ul><h1 id="2-코드로-그리는-보름달"><a href="#2-코드로-그리는-보름달" class="headerlink" title="2. 코드로 그리는 보름달"></a>2. 코드로 그리는 보름달</h1><h2 id="2-1-코드로-그리는-그림"><a href="#2-1-코드로-그리는-그림" class="headerlink" title="2.1. 코드로 그리는 그림"></a>2.1. 코드로 그리는 그림</h2><blockquote><p><a href="http://www.genmedia.co.kr/news/articleView.html?idxno=12738">젠미디어: 이주행 ETRI 연구원 인터뷰</a><br><a href="https://techcrunch.com/2016/05/08/the-digital-age-of-data-art/">Techcrunch: The digital age of data art</a></p></blockquote><ul><li>무미건조한 코드나 데이터로 아름다움을 만들어내는 분들이 있으십니다.</li><li>데이터 시각화의 심미적 요소를 한껏 활용하는 것으로 볼 수도 있고</li><li>그림을 그리는 도구가 바뀌었을 뿐 데이터와 무관한 아름다움을 추구하기도 합니다.</li><li>이런 분들을 따라해 보기로 합니다<br><br><img src="9_fullmoon_08.png" alt="(좌) 이주행, &quot;Pixel Stack&quot;, (우) Mark Napier &quot;Black and White&quot;"><br></li></ul><h2 id="2-2-약간의-기하학"><a href="#2-2-약간의-기하학" class="headerlink" title="2.2. 약간의 기하학"></a>2.2. 약간의 기하학</h2><ul><li><p>중심을 (0,0)으로 하는 극좌표계 공간을 만듭니다.</p></li><li><p>반지름이 1인 공간 안에 랜덤하게 한 점을 골라 원의 중심을 잡습니다.</p></li><li><p>극좌표계를 사용하여 원점으로부터의 거리과 방위각으로 좌표를 잡으면 편리합니다.</p></li><li><p>matplotlib의 Circle을 이용해서 원을 생성합니다.</p></li><li><p>원의 반지름을 <code>1-원점으로부터의 거리</code>로 설정하면 원의 윤곽선에 항상 맞닿습니다.</p></li><li><p>10개만 그려봅시다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Circle</span><br><span class="line"></span><br><span class="line">num = <span class="number">10</span>    <span class="comment"># 원의 수</span></span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), </span><br><span class="line">                       constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 극좌표계에서 원 생성</span></span><br><span class="line">R = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)                   <span class="comment"># 반지름의 범위: 0~1</span></span><br><span class="line">pos_r = np.random.choice(R, size=num)        <span class="comment"># 랜덤 위치 (반지름)</span></span><br><span class="line">pos_a = <span class="number">2</span>*np.pi*np.random.uniform(size=num)  <span class="comment"># 랜덤 위치 (방위각)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 직교좌표계 변환</span></span><br><span class="line">pos_x = pos_r * np.cos(pos_a)         <span class="comment"># 직교좌표계 x</span></span><br><span class="line">pos_y = pos_r * np.sin(pos_a)         <span class="comment"># 직교좌표계 y</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x, y, r <span class="keyword">in</span> <span class="built_in">zip</span>(pos_x, pos_y, pos_r):</span><br><span class="line">    r_circle = <span class="number">1</span>-r  <span class="comment"># 원의 반지름</span></span><br><span class="line">    o = Circle((x, y), r_circle, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, alpha=<span class="number">1</span>)</span><br><span class="line">    ax.add_patch(o)</span><br><span class="line">    </span><br><span class="line">ax.set_xlim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">ax.set_ylim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">ax.axvline(<span class="number">0</span>, c=<span class="string">&quot;g&quot;</span>)</span><br><span class="line">ax.axhline(<span class="number">0</span>, c=<span class="string">&quot;g&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="9_fullmoon_02.png"><br></p></li></ul><h2 id="2-3-확률-제어"><a href="#2-3-확률-제어" class="headerlink" title="2.3. 확률 제어"></a>2.3. 확률 제어</h2><ul><li><p>100개를 그리면 이렇습니다.<br><img src="9_fullmoon_03.png"><br></p></li><li><p>뭔가 특이한 점을 느끼셨을까요?</p></li></ul><ul><li><p>원의 중심점 분포를 그리면 이렇습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 점들 사이 최단거리 계산</span></span><br><span class="line">pos_xy = np.array(<span class="built_in">list</span>(<span class="built_in">zip</span>(pos_x, pos_y)))</span><br><span class="line">d_shortests = []</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> pos_xy:</span><br><span class="line">    dp = pos_xy-p</span><br><span class="line">    d_shortest = np.inf</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> dp:</span><br><span class="line">        sd = np.sqrt(d[<span class="number">0</span>]**<span class="number">2</span> + d[<span class="number">1</span>]**<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt; sd &lt; d_shortest:</span><br><span class="line">            d_shortest = sd</span><br><span class="line">    d_shortests.append(d_shortest)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 시각화</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">8</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">0</span>].scatter(pos_x, pos_y)</span><br><span class="line">axs[<span class="number">0</span>].axvline(<span class="number">0</span>, c=<span class="string">&quot;g&quot;</span>)</span><br><span class="line">axs[<span class="number">0</span>].axhline(<span class="number">0</span>, c=<span class="string">&quot;g&quot;</span>)</span><br><span class="line">sns.kdeplot(d_shortests, cut=<span class="number">0</span>, ax=axs[<span class="number">1</span>], fill=<span class="literal">True</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_xlim(<span class="number">0</span>, <span class="built_in">max</span>(d_shortests))</span><br></pre></td></tr></table></figure><p><img src="9_fullmoon_04.png"><br></p></li><li><p>원점 부근을 중심으로 하는 점들이 월등히 많습니다.</p></li><li><p>앞서 그림을 그릴 때 원의 반지름을 <code>1-원점으로부터의 거리</code>로 설정했지요.</p></li><li><p><b>큰 원과 작은 원의 수는 비슷하더라도 작은 원은 여기저기 퍼져있고 큰 원은 뭉쳐있다</b>는 의미입니다.</p></li></ul><ul><li>나쁘다는 것은 아닙니다.</li><li>전체 원의 가운데보다 바깥 부분에 많은 선이 그려진다는 뜻이고,</li><li>원의 갯수를 키우는 것 만으로도 뭔가 3D 느낌이 납니다.</li><li>500개를 그리면 이렇게 됩니다.<br><img src="9_fullmoon_05.png"><br></li></ul><ul><li><p>다만, <b>약간의 확률 조작을 통해 연출이 가능하다</b>는 의미입니다.</p></li><li><p>예를 들어 이런 확률분포를 사용하면,<br><img src="9_fullmoon_06.png"><br></p></li><li><p>그림은 이렇게 바뀝니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), </span><br><span class="line">                       constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 극좌표계에서 원 생성</span></span><br><span class="line">R = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)                   <span class="comment"># 반지름의 범위: 0~1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># np.random.choice에 매개변수 p 적용, 확률 제어</span></span><br><span class="line">f = np.float_power(np.sin(R), <span class="number">10</span>)</span><br><span class="line">p = (f/<span class="built_in">max</span>(f))/<span class="built_in">sum</span>(f/<span class="built_in">max</span>(f))</span><br><span class="line">pos_r = np.random.choice(R, size=num, p=p)   <span class="comment"># 랜덤 위치 (반지름)</span></span><br><span class="line">pos_a = <span class="number">2</span>*np.pi*np.random.uniform(size=num)  <span class="comment"># 랜덤 위치 (방위각)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 직교좌표계 변환</span></span><br><span class="line">pos_x = pos_r * np.cos(pos_a)         <span class="comment"># 직교좌표계 x</span></span><br><span class="line">pos_y = pos_r * np.sin(pos_a)         <span class="comment"># 직교좌표계 y</span></span><br><span class="line"></span><br><span class="line">r_circles = []</span><br><span class="line"><span class="keyword">for</span> x, y, r <span class="keyword">in</span> <span class="built_in">zip</span>(pos_x, pos_y, pos_r):</span><br><span class="line">    r_circle = <span class="number">1</span>-r  <span class="comment"># 원의 반지름</span></span><br><span class="line">    r_circles.append(r_circle)</span><br><span class="line">    o = Circle((x, y), r_circle, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, alpha=<span class="number">1</span>, lw=<span class="number">0.1</span>)</span><br><span class="line">    ax.add_patch(o)</span><br><span class="line">    </span><br><span class="line">ax.set_xlim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">ax.set_ylim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">ax.axvline(<span class="number">0</span>, c=<span class="string">&quot;g&quot;</span>)</span><br><span class="line">ax.axhline(<span class="number">0</span>, c=<span class="string">&quot;g&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="9_fullmoon_07.png"><br></p></li></ul><h2 id="2-4-달-띄우기"><a href="#2-4-달-띄우기" class="headerlink" title="2.4. 달 띄우기"></a>2.4. 달 띄우기</h2><ul><li><p>달을 그리는 함수를 만들어봅니다.</p></li><li><p>앞에서 만든 함수에 딱 하나, <code>faceccolor</code>와 ‘edgecolor`를 제어하는 매개변수를 추가했습니다.</p></li><li><p>facecolor에 numpy array를 넣으면 랜덤하게 색을 입히는 기능을 추가했고요.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_fullmoon</span>(<span class="params">size, scale=<span class="number">5</span>, fc=<span class="string">&quot;w&quot;</span>, ec=<span class="string">&quot;none&quot;</span>, filename=<span class="string">&quot;fullmoon&quot;</span>, **kwargs</span>):</span></span><br><span class="line">    scale = np.<span class="built_in">float</span>(scale)</span><br><span class="line">    fig, ax = plt.subplots(figsize=(<span class="number">20</span>, <span class="number">20</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">    ax.set_facecolor(<span class="string">&quot;k&quot;</span>)</span><br><span class="line">    ax.spines[[<span class="string">&quot;top&quot;</span>, <span class="string">&quot;left&quot;</span>, <span class="string">&quot;bottom&quot;</span>, <span class="string">&quot;right&quot;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.set_xticks([])</span><br><span class="line">    ax.set_yticks([])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># random circle</span></span><br><span class="line">    R = np.linspace(<span class="number">0</span>, <span class="number">1</span>, size)</span><br><span class="line">    F = np.float_power(np.sin(R), <span class="number">10</span>)</span><br><span class="line">    P = (<span class="number">1</span>-F/<span class="built_in">max</span>(F))/<span class="built_in">sum</span>(<span class="number">1</span>-F/<span class="built_in">max</span>(F))</span><br><span class="line"></span><br><span class="line">    pos_r = np.random.choice(R, size=size, p=P)</span><br><span class="line">    pos_a = <span class="number">2</span>*np.pi*np.random.uniform(size=size)</span><br><span class="line">    pos_x = pos_r * np.cos(pos_a)</span><br><span class="line">    pos_y = pos_r * np.sin(pos_a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x, y, r <span class="keyword">in</span> <span class="built_in">zip</span>(pos_x, pos_y, pos_r):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(fc, np.ndarray):</span><br><span class="line">            fc = np.array([<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.8</span>]) + np.array([np.random.normal(loc=<span class="number">0.1</span>, scale=<span class="number">0.05</span>), np.random.normal(loc=<span class="number">0.1</span>, scale=<span class="number">0.05</span>), np.random.normal(loc=<span class="number">0.1</span>, scale=<span class="number">0.05</span>)])</span><br><span class="line">            fc[<span class="number">0</span>] = <span class="built_in">min</span>(fc[<span class="number">0</span>], <span class="number">1</span>)</span><br><span class="line">            fc[<span class="number">1</span>] = <span class="built_in">min</span>(fc[<span class="number">1</span>], <span class="number">1</span>)</span><br><span class="line">            fc[<span class="number">2</span>] = <span class="built_in">min</span>(fc[<span class="number">2</span>], <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        o = Circle((x, y), <span class="number">1</span>-r, fc=fc, ec=ec, alpha=scale/size, **kwargs)</span><br><span class="line">            </span><br><span class="line">        ax.add_patch(o)</span><br><span class="line"></span><br><span class="line">    ax.set_xlim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    ax.set_ylim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    fig.set_facecolor(<span class="string">&quot;k&quot;</span>)</span><br><span class="line">    fig.savefig(<span class="string">f&quot;<span class="subst">&#123;filename&#125;</span>.png&quot;</span>, dpi=<span class="number">300</span>)</span><br><span class="line">    </span><br><span class="line">plot_fullmoon(<span class="number">10</span>, fc=np.array([<span class="number">0.6</span>, <span class="number">0.6</span>, <span class="number">0.6</span>]), filename=<span class="string">&quot;fmc_10&quot;</span>, ec=<span class="string">&quot;w&quot;</span>, lw=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><img src="fmc_10.png"><br></p></li><li><p>원 10개로 그리면 이런 달이 떠오릅니다.</p></li></ul><ul><li>원 20개, 50개, 100개로도 그려볼 수 있겠죠.<br><br><img src="fmc_10-100.png"><br></li></ul><ul><li>꼭 추석이 아니더라도 모두들 둥근 달처럼 행복하시기 바랍니다.<br><br><img src="fmc_200.png"><br></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/art/">art</category>
      
      
    </item>
    
    <item>
      <title>3D curved surfaces</title>
      <link>https://jehyunlee.github.io/2021/09/03/Python-DS-84-sphere/</link>
      <guid>https://jehyunlee.github.io/2021/09/03/Python-DS-84-sphere/</guid>
      <pubDate>Fri, 03 Sep 2021 08:42:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;자주 있는 일은 아니지만 3차원 곡면을 그릴 때가 있습니다.&lt;/li&gt;
&lt;li&gt;어떤 분은 원자를 표현하느라, 또는 쇠구슬을 표현하느라 구가 필요할지도 모릅니다.&lt;/li&gt;
&lt;li&gt;저는 업무상 태양이 하늘에 떠 있는 지점을 고민할 때가 많아</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>자주 있는 일은 아니지만 3차원 곡면을 그릴 때가 있습니다.</li><li>어떤 분은 원자를 표현하느라, 또는 쇠구슬을 표현하느라 구가 필요할지도 모릅니다.</li><li>저는 업무상 태양이 하늘에 떠 있는 지점을 고민할 때가 많아서 반구가 필요합니다.</li><li>과거에는 원자의 3차원 에너지를 표현하느라 이런 그림이 필요했습니다.</li></ul><h1 id="1-데이터-준비"><a href="#1-데이터-준비" class="headerlink" title="1. 데이터 준비"></a>1. 데이터 준비</h1><blockquote><p><a href="https://en.wikipedia.org/wiki/Spherical_coordinate_system">wikipedia: Spherical coordinate system</a></p></blockquote><p><img src="84_sphere_00.png" alt="wikipedia: 구면 좌표계"><br></p><ul><li>구나 반구를 그리려면 구면 좌표계로 정의된 데이터가 필요합니다.</li><li>간단한 삼각함수를 사용해서 구면 데이터를 만듭니다.</li><li><b>방위각</b>(azimuthal angle, $\theta$)과 <b>극고도각</b>(polar angle, $\varphi$)을 나열한 뒤 여기에 아래 수식을 적용합니다.</li></ul><p>$$<br>\begin{aligned}<br>x &amp;= r \cos{\varphi} \sin{\theta}\\<br>y &amp;= r \sin{\varphi} \sin{\theta}\\<br>z &amp;= r \cos{\theta}<br>\end{aligned}$$</p><ul><li>코드로는 이렇게 정리됩니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># angles</span></span><br><span class="line">polars = np.linspace(<span class="number">0</span>, <span class="number">180</span>, <span class="number">19</span>)</span><br><span class="line">azimuths = np.linspace(<span class="number">0</span>, <span class="number">360</span>, <span class="number">37</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># points</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(product(polars, azimuths), columns=[<span class="string">&quot;azi&quot;</span>, <span class="string">&quot;polar&quot;</span>])</span><br><span class="line">df[<span class="string">&quot;x&quot;</span>] = df.apply(<span class="keyword">lambda</span> x: np.cos(np.deg2rad(x[<span class="number">1</span>]))*np.sin(np.deg2rad(x[<span class="number">0</span>])), axis=<span class="number">1</span>)</span><br><span class="line">df[<span class="string">&quot;y&quot;</span>] = df.apply(<span class="keyword">lambda</span> x: np.sin(np.deg2rad(x[<span class="number">1</span>]))*np.sin(np.deg2rad(x[<span class="number">0</span>])), axis=<span class="number">1</span>)</span><br><span class="line">df[<span class="string">&quot;z&quot;</span>] = df.apply(<span class="keyword">lambda</span> x: np.cos(np.deg2rad(x[<span class="number">0</span>])), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">df</span><br></pre></td></tr></table></figure><ul><li>실행 결과<br><img src="84_sphere_05.png"><br></li></ul></li></ul><h1 id="2-3D-곡면-도형-그리기"><a href="#2-3D-곡면-도형-그리기" class="headerlink" title="2. 3D 곡면 도형 그리기"></a>2. 3D 곡면 도형 그리기</h1><blockquote><p><a href="https://matplotlib.org/stable/gallery/mplot3d/surface3d.html">matplotlib: 3D surface (colormap)</a><br><a href="https://matplotlib.org/stable/api/_as_gen/mpl_toolkits.mplot3d.axes3d.Axes3D.html?highlight=plot_surface#mpl_toolkits.mplot3d.axes3d.Axes3D.plot_surface">matplotlib: mpl_toolkits.mplot3d.axes3d.Axes3D</a></p></blockquote><ul><li>주어진 데이터로 만들어지는 3D 표면 형상을 만드는데는 <code>.plot_surface()</code>가 적격입니다.</li><li>앞서 만든 데이터로 구(sphere)와 반구(hemisphere)를 만들어봅시다.</li></ul><h2 id="2-1-sphere"><a href="#2-1-sphere" class="headerlink" title="2.1. sphere"></a>2.1. sphere</h2><ul><li><p>우리가 만든 좌표가 이미 구의 좌표입니다.</p></li><li><p>방위각 $\varphi$를 0도에서 360도, 극고도각 $\theta$를 0도에서 180도까지 변화시켰고, 이는 3차원 공간의 모든 방향에 해당되기 때문입니다.</p></li><li><p>그렇다면 남은 일은, DataFrame에 1차원으로 들어있는 각각의 좌표를 차원에 맞게 2차원으로 바꿔주는 것 뿐입니다.</p></li><li><p>극고도각과 방위각의 경우의 수가 각각 19가지, 37가지이므로 <code>.reshape((19, 37)</code>을 적용합니다.</p></li><li><p>matplotlib은 구면좌표계가 아니라 직교좌표계를 사용합니다. x, y, z로 변환합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), </span><br><span class="line">                       subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line">ax.plot_surface(df[<span class="string">&quot;x&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>)), </span><br><span class="line">                df[<span class="string">&quot;y&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>)), </span><br><span class="line">                df[<span class="string">&quot;z&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>)), </span><br><span class="line">                alpha=<span class="number">0.3</span>)</span><br></pre></td></tr></table></figure><p><img src="84_sphere_06.png"><br></p></li><li><p>구가 그려졌습니다.</p></li><li><p>그런데 z축 방향으로 조금 찌그러져서 납작한 느낌이 나네요.</p></li><li><p><b>aspect ratio를 1:1:1로 맞춰줍시다.</b></p></li><li><p>matplotlib 3차원 Axes(<code>Axes3D</code>)에서 aspect ratio를 지정하는 명령은 <code>.set_box_aspect()</code>입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), </span><br><span class="line">                       subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line">ax.plot_surface(df[<span class="string">&quot;x&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>)), </span><br><span class="line">                df[<span class="string">&quot;y&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>)), </span><br><span class="line">                df[<span class="string">&quot;z&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>)), </span><br><span class="line">                alpha=<span class="number">0.3</span>)</span><br><span class="line">ax.set_box_aspect((<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p><img src="84_sphere_07.png"><br></p></li></ul><h2 id="2-2-partial-sphere"><a href="#2-2-partial-sphere" class="headerlink" title="2.2. partial sphere"></a>2.2. partial sphere</h2><ul><li>극좌표계를 사용해서 구의 일부를 쪼개볼 수도 있습니다.</li><li><code>plot_surface()</code>안에 넣는 x, y, z에다 slicing을 추가하면 됩니다.</li><li><b>극고도각은 전체 범위를 사용하고 방위각은 마지막 9개를 사용하지 않겠다</b>고 하면 이런 그림이 그려집니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), </span><br><span class="line">                       subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line">ax.plot_surface(df[<span class="string">&quot;x&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>))[:,:-<span class="number">9</span>], </span><br><span class="line">                df[<span class="string">&quot;y&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>))[:,:-<span class="number">9</span>], </span><br><span class="line">                df[<span class="string">&quot;z&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>))[:,:-<span class="number">9</span>], </span><br><span class="line">                alpha=<span class="number">0.3</span>)</span><br><span class="line">ax.set_box_aspect((<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><img src="84_sphere_08.png"><br></li></ul><h2 id="2-3-선-색깔-조정"><a href="#2-3-선-색깔-조정" class="headerlink" title="2.3. 선 색깔 조정"></a>2.3. 선 색깔 조정</h2><ul><li><p>우리는 지금 <b>면</b>을 그리고 있습니다.</p></li><li><p>따라서 <b><code>edgecolor</code> (<code>ec</code>)</b>, <b><code>linestyle</code> (<code>ls</code>)</b>, <b><code>linewidth</code> (<code>lw</code>)</b>가 적용됩니다.</p></li><li><p>불필요한 axis도 지워버립시다. 명령은 똑같이 <code>ax.axis(False)</code>입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), </span><br><span class="line">                       constrained_layout=<span class="literal">True</span>,</span><br><span class="line">                       subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line">ax.plot_surface(df[<span class="string">&quot;x&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>))[:,:-<span class="number">9</span>], </span><br><span class="line">                df[<span class="string">&quot;y&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>))[:,:-<span class="number">9</span>], </span><br><span class="line">                df[<span class="string">&quot;z&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>))[:,:-<span class="number">9</span>], </span><br><span class="line">                ec=<span class="string">&quot;k&quot;</span>, lw=<span class="number">0.2</span>, ls=<span class="string">&quot;:&quot;</span>,</span><br><span class="line">                alpha=<span class="number">0.3</span>)</span><br><span class="line">ax.set_box_aspect((<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">ax.axis(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="84_sphere_09.png"><br></p></li><li><p>아까보다 한결 깔끔해 보입니다.</p></li></ul><h2 id="2-4-면-색깔-조정"><a href="#2-4-면-색깔-조정" class="headerlink" title="2.4. 면 색깔 조정"></a>2.4. 면 색깔 조정</h2><ul><li><p>면 색깔을 지정하는 매개변수는 <code>color</code>입니다.</p></li><li><p><code>colors=&quot;g&quot;</code>처럼 색상을 의미하는 약어나 숫자를 넣으면 적용됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), </span><br><span class="line">                       constrained_layout=<span class="literal">True</span>,</span><br><span class="line">                       subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line">ax.plot_surface(df[<span class="string">&quot;x&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>))[:,:-<span class="number">9</span>], </span><br><span class="line">                df[<span class="string">&quot;y&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>))[:,:-<span class="number">9</span>], </span><br><span class="line">                df[<span class="string">&quot;z&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>))[:,:-<span class="number">9</span>], </span><br><span class="line">                ec=<span class="string">&quot;k&quot;</span>, lw=<span class="number">0.2</span>, ls=<span class="string">&quot;:&quot;</span>,</span><br><span class="line">                color=<span class="string">&quot;g&quot;</span>,</span><br><span class="line">                alpha=<span class="number">0.3</span>)</span><br><span class="line">ax.set_box_aspect((<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">ax.axis(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="84_sphere_10.png"><br></p></li><li><p>조명 방향도 바꿀 수 있습니다.</p></li><li><p><code>matplotlib.colors</code>의 <code>LightSource</code> 클래스를 사용해 조명 방향을 지정합니다.</p></li><li><p>두 개의 인자로 방위각과 극고도각을 도(degree) 단위로 입력합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> LightSource</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>,</span><br><span class="line">                        figsize=(<span class="number">15</span>, <span class="number">5</span>), </span><br><span class="line">                        constrained_layout=<span class="literal">True</span>,</span><br><span class="line">                        subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">lightsources = [LightSource(<span class="number">30</span>, <span class="number">30</span>), LightSource(-<span class="number">30</span>, <span class="number">60</span>), LightSource(<span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line">titles = [<span class="string">&quot;azi: 30, polar: 30&quot;</span>, <span class="string">&quot;azi: -30, polar: 60&quot;</span>, <span class="string">&quot;azi: 0, polar: 0&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> ax, ls, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, lightsources, titles):</span><br><span class="line">    ax.plot_surface(df[<span class="string">&quot;x&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>))[:,:-<span class="number">9</span>], </span><br><span class="line">                    df[<span class="string">&quot;y&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>))[:,:-<span class="number">9</span>], </span><br><span class="line">                    df[<span class="string">&quot;z&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>))[:,:-<span class="number">9</span>], </span><br><span class="line">                    ec=<span class="string">&quot;none&quot;</span>, lw=<span class="number">0</span>, ls=<span class="string">&quot;-&quot;</span>,</span><br><span class="line">                    color=<span class="string">&quot;w&quot;</span>, lightsource=ls,</span><br><span class="line">                    alpha=<span class="number">1</span>)</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;large&quot;</span>)</span><br><span class="line">    ax.set_box_aspect((<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    ax.axis(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="84_sphere_12.png"><br></p></li><li><p>멋진 그라데이션을 입히고 싶다면 <code>cmap</code> 매개변수를 사용할 수 있습니다.</p></li><li><p>z축 방향 값에 따른 그라데이션이 매겨집니다.</p></li><li><p>Matplotlib이 제공하는 gradation 이름을 집어넣습니다.</p></li><li><p>다만 <b><code>cmap</code></b>과 <b><code>lightsource</code></b>는 <b>함께 쓰일 수 없으니</b> 유의해야 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), </span><br><span class="line">                       constrained_layout=<span class="literal">True</span>,</span><br><span class="line">                       subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line">ax.plot_surface(df[<span class="string">&quot;x&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>))[:,:-<span class="number">9</span>], </span><br><span class="line">                df[<span class="string">&quot;y&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>))[:,:-<span class="number">9</span>], </span><br><span class="line">                df[<span class="string">&quot;z&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>))[:,:-<span class="number">9</span>], </span><br><span class="line">                ec=<span class="string">&quot;k&quot;</span>, lw=<span class="number">0.2</span>, ls=<span class="string">&quot;:&quot;</span>,</span><br><span class="line">                cmap=<span class="string">&quot;inferno&quot;</span>,</span><br><span class="line">                alpha=<span class="number">0.3</span>)</span><br><span class="line">ax.set_box_aspect((<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">ax.axis(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="84_sphere_11.png"><br></p></li></ul><h1 id="3-응용"><a href="#3-응용" class="headerlink" title="3. 응용"></a>3. 응용</h1><h2 id="3-1-구와-반구"><a href="#3-1-구와-반구" class="headerlink" title="3.1. 구와 반구"></a>3.1. 구와 반구</h2><blockquote><p><a href="https://stackoverflow.com/questions/16488182/removing-axes-margins-in-3d-plot">stackoverflow: Axes3D 여백 없애기</a></p></blockquote><ul><li><p>구와 반구를 동시에 그려봅니다.</p></li><li><p>구는 위에서 만든 코드를 그대로 사용하면 되고, </p></li><li><p>반구는 극고도각을 절반만 사용하면 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, </span><br><span class="line">                        figsize=(<span class="number">10</span>, <span class="number">5</span>), </span><br><span class="line">                        constrained_layout=<span class="literal">True</span>, </span><br><span class="line">                        subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sphere</span></span><br><span class="line">axs[<span class="number">0</span>].plot_surface(df[<span class="string">&quot;x&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>)), </span><br><span class="line">                    df[<span class="string">&quot;y&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>)), </span><br><span class="line">                    df[<span class="string">&quot;z&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>)), </span><br><span class="line">                    cmap=<span class="string">&quot;viridis&quot;</span>, </span><br><span class="line">                    alpha=<span class="number">0.3</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_box_aspect((<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">axs[<span class="number">0</span>].set_title(<span class="string">&quot;sphere&quot;</span>, pad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># hemisphere</span></span><br><span class="line">axs[<span class="number">1</span>].plot_surface(df[<span class="string">&quot;x&quot;</span>].iloc[:<span class="number">370</span>].values.reshape((<span class="number">10</span>, <span class="number">37</span>)), </span><br><span class="line">                    df[<span class="string">&quot;y&quot;</span>].iloc[:<span class="number">370</span>].values.reshape((<span class="number">10</span>, <span class="number">37</span>)), </span><br><span class="line">                    df[<span class="string">&quot;z&quot;</span>].iloc[:<span class="number">370</span>].values.reshape((<span class="number">10</span>, <span class="number">37</span>)), </span><br><span class="line">                    cmap=<span class="string">&quot;viridis&quot;</span>, </span><br><span class="line">                    alpha=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">1</span>].set_box_aspect((<span class="number">1</span>, <span class="number">1</span>, <span class="number">0.5</span>))</span><br><span class="line">axs[<span class="number">1</span>].set_title(<span class="string">&quot;hemisphere&quot;</span>, pad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax <span class="keyword">in</span> axs:</span><br><span class="line">    ax.set_xlabel(<span class="string">&quot;X&quot;</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">&quot;Y&quot;</span>)</span><br><span class="line">    ax.set_zlabel(<span class="string">&quot;Z&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="84_sphere_01.png"><br></p></li><li><p>X, Y, Z축 범위가 -1~1을 약간 벗어나 있습니다.</p></li><li><p>matplotlib 기본 설정 문제입니다.</p></li><li><p>이를 해결하려면 위 코드에서 fig, axs를 생성한 뒤에 짧은 코드를 추가합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d.axis3d <span class="keyword">import</span> Axis</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(Axis, <span class="string">&quot;_get_coord_info_old&quot;</span>):</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_coord_info_new</span>(<span class="params">self, renderer</span>):</span></span><br><span class="line">        mins, maxs, centers, deltas, tc, highs = self._get_coord_info_old(renderer)</span><br><span class="line">        mins += deltas / <span class="number">4</span></span><br><span class="line">        maxs -= deltas / <span class="number">4</span></span><br><span class="line">        <span class="keyword">return</span> mins, maxs, centers, deltas, tc, highs</span><br><span class="line">    Axis._get_coord_info_old = Axis._get_coord_info  </span><br><span class="line">    Axis._get_coord_info = _get_coord_info_new</span><br></pre></td></tr></table></figure><p><img src="84_sphere_02.png"><br></p></li><li><p>동서남북, 그리고 상하를 잇는 수직선을 그립니다.</p></li><li><p>좌표 원점이라고 봐도 됩니다.</p></li><li><p>여기서 한 가지 주의할 점이 있습니다.</p></li><li><p><b>matplotlib이 3D 도형과 2D 도형의 위치관계를 깔끔하기 처리하지 못합니다.</b></p></li><li><p>3D 도형에 가려질 부분과 가려지지 않을 부분을 따로 그리고 표현해줘야 합니다.</p></li><li><p>동서남북을 나타내는 N, E, W, S도 적당한 위치에 넣어줍니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, </span><br><span class="line">                        figsize=(<span class="number">10</span>, <span class="number">5</span>), </span><br><span class="line">                        subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Axes3D 딱 붙이기</span></span><br><span class="line"><span class="comment"># https://stackoverflow.com/questions/16488182/removing-axes-margins-in-3d-plot</span></span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d.axis3d <span class="keyword">import</span> Axis</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(Axis, <span class="string">&quot;_get_coord_info_old&quot;</span>):</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_coord_info_new</span>(<span class="params">self, renderer</span>):</span></span><br><span class="line">        mins, maxs, centers, deltas, tc, highs = self._get_coord_info_old(renderer)</span><br><span class="line">        mins += deltas / <span class="number">4</span></span><br><span class="line">        maxs -= deltas / <span class="number">4</span></span><br><span class="line">        <span class="keyword">return</span> mins, maxs, centers, deltas, tc, highs</span><br><span class="line">    Axis._get_coord_info_old = Axis._get_coord_info  </span><br><span class="line">    Axis._get_coord_info = _get_coord_info_new</span><br><span class="line"></span><br><span class="line"><span class="comment"># sphere</span></span><br><span class="line">axs[<span class="number">0</span>].plot_surface(df[<span class="string">&quot;x&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>)), </span><br><span class="line">                    df[<span class="string">&quot;y&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>)), </span><br><span class="line">                    df[<span class="string">&quot;z&quot;</span>].values.reshape((<span class="number">19</span>, <span class="number">37</span>)), </span><br><span class="line">                    cmap=<span class="string">&quot;viridis&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, lw=<span class="number">0.1</span>, </span><br><span class="line">                    alpha=<span class="number">0.3</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_box_aspect((<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">axs[<span class="number">0</span>].set_title(<span class="string">&quot;sphere&quot;</span>, pad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># hemisphere</span></span><br><span class="line">axs[<span class="number">1</span>].plot_surface(df[<span class="string">&quot;x&quot;</span>].iloc[:<span class="number">370</span>].values.reshape((<span class="number">10</span>, <span class="number">37</span>)), </span><br><span class="line">                    df[<span class="string">&quot;y&quot;</span>].iloc[:<span class="number">370</span>].values.reshape((<span class="number">10</span>, <span class="number">37</span>)), </span><br><span class="line">                    df[<span class="string">&quot;z&quot;</span>].iloc[:<span class="number">370</span>].values.reshape((<span class="number">10</span>, <span class="number">37</span>)), </span><br><span class="line">                    cmap=<span class="string">&quot;viridis&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, lw=<span class="number">0.1</span>, </span><br><span class="line">                    alpha=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">1</span>].set_box_aspect((<span class="number">1</span>, <span class="number">1</span>, <span class="number">0.5</span>))</span><br><span class="line">axs[<span class="number">1</span>].set_title(<span class="string">&quot;hemisphere&quot;</span>, pad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax <span class="keyword">in</span> axs:</span><br><span class="line">    ax.set_xlabel(<span class="string">&quot;X&quot;</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">&quot;Y&quot;</span>)</span><br><span class="line">    ax.set_zlabel(<span class="string">&quot;Z&quot;</span>)</span><br><span class="line">    ax.view_init(azim=<span class="number">235</span>)</span><br><span class="line">    <span class="comment"># make margins</span></span><br><span class="line">    ax.margins(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># center axis</span></span><br><span class="line">    zmin = -<span class="number">1</span> <span class="keyword">if</span> ax == axs[<span class="number">0</span>] <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    ax.plot([-<span class="number">1.1</span>, <span class="number">1.1</span>], [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>], c=<span class="string">&quot;k&quot;</span>, zorder=-<span class="number">10</span>)</span><br><span class="line">    ax.plot([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [-<span class="number">1.1</span>, <span class="number">1.1</span>, <span class="number">0</span>], c=<span class="string">&quot;k&quot;</span>, zorder=-<span class="number">10</span>)</span><br><span class="line">    ax.plot([<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>], [zmin, <span class="number">1</span>], c=<span class="string">&quot;k&quot;</span>, zorder=-<span class="number">10</span>)</span><br><span class="line">    ax.plot([<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1.1</span>], c=<span class="string">&quot;k&quot;</span>, zorder=<span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ax == axs[<span class="number">0</span>]:</span><br><span class="line">        ax.plot([-<span class="number">1</span>, -<span class="number">1.1</span>], [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>], c=<span class="string">&quot;k&quot;</span>, zorder=<span class="number">3</span>)</span><br><span class="line">        ax.plot([<span class="number">0</span>, <span class="number">0</span>], [-<span class="number">1</span>, -<span class="number">1.1</span>], [<span class="number">0</span>, <span class="number">0</span>], c=<span class="string">&quot;k&quot;</span>, zorder=<span class="number">3</span>)</span><br><span class="line">     </span><br><span class="line">    <span class="comment"># 동서남북 표시</span></span><br><span class="line">    font_text = &#123;<span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>, <span class="string">&quot;fontsize&quot;</span>:<span class="number">15</span>, <span class="string">&quot;ha&quot;</span>:<span class="string">&quot;center&quot;</span>, <span class="string">&quot;va&quot;</span>:<span class="string">&quot;center&quot;</span>&#125;</span><br><span class="line">    ax.text(-<span class="number">1.4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;W&quot;</span>, transform=ax.transData, fontdict=font_text)</span><br><span class="line">    ax.text(<span class="number">1.4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;E&quot;</span>, transform=ax.transData, fontdict=font_text)</span><br><span class="line">    ax.text(<span class="number">0</span>, <span class="number">1.4</span>, <span class="number">0</span>, <span class="string">&quot;N&quot;</span>, transform=ax.transData, fontdict=font_text, zorder=-<span class="number">10</span>)</span><br><span class="line">    ax.text(<span class="number">0</span>, -<span class="number">1.4</span>, <span class="number">0</span>, <span class="string">&quot;S&quot;</span>, transform=ax.transData, fontdict=font_text)</span><br><span class="line">    ax.axis(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="84_sphere_04.png"><br></p></li></ul><h2 id="3-2-magnetocrystalline-anisotropy"><a href="#3-2-magnetocrystalline-anisotropy" class="headerlink" title="3.2. magnetocrystalline anisotropy"></a>3.2. magnetocrystalline anisotropy</h2><blockquote><p><a href="https://en.wikipedia.org/wiki/Magnetocrystalline_anisotropy">wikipedia: magnetocrystalline anisotropy</a></p></blockquote><ul><li>결정자기이방성(magnetocrystalline anisotropy)이라는 말을 들어보신 분은 거의 없으실 겁니다.</li><li>자성(magnetism)을 공부할 때 나오는 용어인데, <b>방위에 따라 다른 에너지</b>라고 대충 넘어가셔도 좋습니다.</li><li>중요한 것은 이번엔 <b>구나 반구가 아니라 울퉁불퉁한 모양</b>을 만들 것이라는 점입니다.</li></ul><ul><li>원리는 간단합니다.</li><li>이 글의 처음에서 구면좌표계는 다음과 같은 식으로 표현된다고 했습니다.</li></ul><p>$$<br>\begin{aligned}<br>x &amp;= r \cos{\varphi} \sin{\theta}\\<br>y &amp;= r \sin{\varphi} \sin{\theta}\\<br>z &amp;= r \cos{\theta}<br>\end{aligned}$$</p><ul><li>앞에서는 $r = 1$로 두었지만, 여기서는 $r = f(\varphi, \theta)$입니다.</li><li>방위각과 극고도각을 이용해서 물질마다 다르게 r을 정의합니다.</li><li>모양이 울퉁불퉁한만큼 아까 10도 단위로 쪼갠 공간을 이번엔 5도 단위로 쪼갭니다.</li><li>자세한 설명은 생략하고 결과 그림과 코드만 간략히 보여드리겠습니다.</li></ul><ul><li><p>5도 단위로 공간 분할</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># angles</span></span><br><span class="line">polars = np.linspace(<span class="number">0</span>, <span class="number">179</span>, <span class="number">37</span>)</span><br><span class="line">azimuths = np.linspace(<span class="number">0</span>, <span class="number">360</span>, <span class="number">73</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># points</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(product(polars, azimuths), columns=[<span class="string">&quot;azi&quot;</span>, <span class="string">&quot;polar&quot;</span>])</span><br><span class="line">df[<span class="string">&quot;x&quot;</span>] = df.apply(<span class="keyword">lambda</span> x: np.cos(np.deg2rad(x[<span class="number">1</span>]))*np.sin(np.deg2rad(x[<span class="number">0</span>])), axis=<span class="number">1</span>)</span><br><span class="line">df[<span class="string">&quot;y&quot;</span>] = df.apply(<span class="keyword">lambda</span> x: np.sin(np.deg2rad(x[<span class="number">1</span>]))*np.sin(np.deg2rad(x[<span class="number">0</span>])), axis=<span class="number">1</span>)</span><br><span class="line">df[<span class="string">&quot;z&quot;</span>] = df.apply(<span class="keyword">lambda</span> x: np.cos(np.deg2rad(x[<span class="number">0</span>])), axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>방향에 따른 $r$ 계산: 자기이방성 에너지</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 자기이방성 계수 K1, K2</span></span><br><span class="line">K1_Co = <span class="number">45</span></span><br><span class="line">K2_Co = <span class="number">15</span></span><br><span class="line"></span><br><span class="line">K1_Fe = <span class="number">4.8</span></span><br><span class="line">K2_Fe = <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">K1_Ni = -<span class="number">0.5</span> </span><br><span class="line">K2_Ni = -<span class="number">0.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 방향에 따른 자기이방성 에너지 계산.</span></span><br><span class="line"><span class="comment"># 그림을 그리는 것이 목적이므로 보기 좋도록 적절히 스케일링</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_uni</span>(<span class="params">K1, K2, df</span>):</span></span><br><span class="line">    <span class="keyword">return</span> K1*(df[<span class="string">&quot;x&quot;</span>]**<span class="number">2</span> + df[<span class="string">&quot;y&quot;</span>]**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_cubic</span>(<span class="params">K1, K2, df</span>):</span></span><br><span class="line">    <span class="keyword">return</span> K1*(df[<span class="string">&quot;x&quot;</span>]**<span class="number">2</span> * df[<span class="string">&quot;y&quot;</span>]**<span class="number">2</span> + \</span><br><span class="line">               df[<span class="string">&quot;y&quot;</span>]**<span class="number">2</span> * df[<span class="string">&quot;z&quot;</span>]**<span class="number">2</span> + \</span><br><span class="line">               df[<span class="string">&quot;z&quot;</span>]**<span class="number">2</span> * df[<span class="string">&quot;x&quot;</span>]**<span class="number">2</span>) + \</span><br><span class="line">           K2*(df[<span class="string">&quot;x&quot;</span>]**<span class="number">2</span> * df[<span class="string">&quot;y&quot;</span>]**<span class="number">2</span> * df[<span class="string">&quot;z&quot;</span>]**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">df[<span class="string">&quot;E_Co&quot;</span>] = df.apply(<span class="keyword">lambda</span> x: calc_uni(K1_Co, K2_Co, x), axis=<span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">df[<span class="string">&quot;E_Fe&quot;</span>] = df.apply(<span class="keyword">lambda</span> x: calc_cubic(K1_Fe, K2_Fe, x), axis=<span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">df[<span class="string">&quot;E_Ni&quot;</span>] = df.apply(<span class="keyword">lambda</span> x: calc_cubic(K1_Ni, K2_Ni, x), axis=<span class="number">1</span>)*<span class="number">3</span> +<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 극좌표계를 직교좌표계로 변환</span></span><br><span class="line">df[<span class="string">&quot;x_Co&quot;</span>] = df[<span class="string">&quot;E_Co&quot;</span>] * df[<span class="string">&quot;x&quot;</span>]</span><br><span class="line">df[<span class="string">&quot;y_Co&quot;</span>] = df[<span class="string">&quot;E_Co&quot;</span>] * df[<span class="string">&quot;y&quot;</span>]</span><br><span class="line">df[<span class="string">&quot;z_Co&quot;</span>] = df[<span class="string">&quot;E_Co&quot;</span>] * df[<span class="string">&quot;z&quot;</span>]</span><br><span class="line"></span><br><span class="line">df[<span class="string">&quot;x_Fe&quot;</span>] = df[<span class="string">&quot;E_Fe&quot;</span>] * df[<span class="string">&quot;x&quot;</span>]</span><br><span class="line">df[<span class="string">&quot;y_Fe&quot;</span>] = df[<span class="string">&quot;E_Fe&quot;</span>] * df[<span class="string">&quot;y&quot;</span>]</span><br><span class="line">df[<span class="string">&quot;z_Fe&quot;</span>] = df[<span class="string">&quot;E_Fe&quot;</span>] * df[<span class="string">&quot;z&quot;</span>]</span><br><span class="line"></span><br><span class="line">df[<span class="string">&quot;x_Ni&quot;</span>] = df[<span class="string">&quot;E_Ni&quot;</span>] * df[<span class="string">&quot;x&quot;</span>]</span><br><span class="line">df[<span class="string">&quot;y_Ni&quot;</span>] = df[<span class="string">&quot;E_Ni&quot;</span>] * df[<span class="string">&quot;y&quot;</span>]</span><br><span class="line">df[<span class="string">&quot;z_Ni&quot;</span>] = df[<span class="string">&quot;E_Ni&quot;</span>] * df[<span class="string">&quot;z&quot;</span>]</span><br></pre></td></tr></table></figure></li><li><p>세 가지 물질(Co, Fe, Ni)의 자기이방성 에너지 시각화</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, </span><br><span class="line">                        figsize=(<span class="number">15</span>, <span class="number">6</span>), </span><br><span class="line">                       constrained_layout=<span class="literal">True</span>,</span><br><span class="line">                        subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>:<span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> ax, mat <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [<span class="string">&quot;Co&quot;</span>, <span class="string">&quot;Fe&quot;</span>, <span class="string">&quot;Ni&quot;</span>]):</span><br><span class="line">    ax.plot_surface(df[<span class="string">f&quot;x_<span class="subst">&#123;mat&#125;</span>&quot;</span>].values.reshape((<span class="number">37</span>, <span class="number">73</span>))[:,:-<span class="number">19</span>], </span><br><span class="line">                    df[<span class="string">f&quot;y_<span class="subst">&#123;mat&#125;</span>&quot;</span>].values.reshape((<span class="number">37</span>, <span class="number">73</span>))[:,:-<span class="number">19</span>], </span><br><span class="line">                    df[<span class="string">f&quot;z_<span class="subst">&#123;mat&#125;</span>&quot;</span>].values.reshape((<span class="number">37</span>, <span class="number">73</span>))[:,:-<span class="number">19</span>], </span><br><span class="line">                    ec=<span class="string">&quot;k&quot;</span>, lw=<span class="number">0.2</span>,</span><br><span class="line">                    color=<span class="string">&quot;w&quot;</span>, lightsource=LightSource(<span class="number">0</span>, <span class="number">10</span>),</span><br><span class="line">                    alpha=<span class="number">1</span>)</span><br><span class="line">    ax.plot(df[<span class="string">f&quot;x_<span class="subst">&#123;mat&#125;</span>&quot;</span>].values.reshape((<span class="number">37</span>, <span class="number">73</span>))[:,-<span class="number">20</span>], </span><br><span class="line">            df[<span class="string">f&quot;y_<span class="subst">&#123;mat&#125;</span>&quot;</span>].values.reshape((<span class="number">37</span>, <span class="number">73</span>))[:,-<span class="number">20</span>], </span><br><span class="line">            df[<span class="string">f&quot;z_<span class="subst">&#123;mat&#125;</span>&quot;</span>].values.reshape((<span class="number">37</span>, <span class="number">73</span>))[:,-<span class="number">20</span>], </span><br><span class="line">            c=<span class="string">&quot;k&quot;</span>, alpha=<span class="number">1</span>)</span><br><span class="line">    ax.plot(df[<span class="string">f&quot;x_<span class="subst">&#123;mat&#125;</span>&quot;</span>].values.reshape((<span class="number">37</span>, <span class="number">73</span>))[:,<span class="number">0</span>], </span><br><span class="line">            df[<span class="string">f&quot;y_<span class="subst">&#123;mat&#125;</span>&quot;</span>].values.reshape((<span class="number">37</span>, <span class="number">73</span>))[:,<span class="number">0</span>], </span><br><span class="line">            df[<span class="string">f&quot;z_<span class="subst">&#123;mat&#125;</span>&quot;</span>].values.reshape((<span class="number">37</span>, <span class="number">73</span>))[:,<span class="number">0</span>], </span><br><span class="line">            c=<span class="string">&quot;k&quot;</span>, alpha=<span class="number">1</span>)</span><br><span class="line">    ax.set_box_aspect((<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    ax.axis(<span class="literal">False</span>)</span><br><span class="line">    ax.set_title(mat, fontsize=<span class="string">&quot;xx-large&quot;</span>)</span><br><span class="line">    </span><br><span class="line">fig.suptitle(<span class="string">&quot;crystalline anisotropy energy surface\n&quot;</span>, </span><br><span class="line">             color=<span class="string">&quot;blue&quot;</span>, fontsize=<span class="string">&quot;xx-large&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="84_sphere_13.png"><br></p></li><li><p>제 박사학위 주제와 밀접한 그림입니다. </p></li><li><p>교과서 그림을 모방해 학위논문(2011)에도 같은 그림을 그려서 넣었습니다.</p></li><li><p>mathematica를 사용해서 그린 그림입니다.<br><br><img src="84_sphere_14.png"><br></p></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/3D/">3D</category>
      
      
    </item>
    
    <item>
      <title>머신러닝 모델링의 흔한 실수들 (2)</title>
      <link>https://jehyunlee.github.io/2021/09/02/Python-DS-83-aifestival2021/</link>
      <guid>https://jehyunlee.github.io/2021/09/02/Python-DS-83-aifestival2021/</guid>
      <pubDate>Thu, 02 Sep 2021 04:00:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;많은 분들께서 모아주신 &lt;b&gt;&lt;a href=&quot;https://bit.ly/3j3vnYL&quot;&gt;머신러닝, 딥러닝 실수 사례&lt;/a&gt;&lt;/b&gt; 두번째 이야기를 2021 AI Festival에서 발표했습니다.&lt;ul&gt;
&lt;li&gt;사례를 모아주신 분들께 깊</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>많은 분들께서 모아주신 <b><a href="https://bit.ly/3j3vnYL">머신러닝, 딥러닝 실수 사례</a></b> 두번째 이야기를 2021 AI Festival에서 발표했습니다.<ul><li>사례를 모아주신 분들께 깊은 감사 말씀을 드립니다.</li><li>60여건의 사례 중 데이터 관련 사례를 일부 모아 발표했습니다.</li><li><b><a href="210902_%EC%9D%B4%EC%A0%9C%ED%98%84_%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D%EB%AA%A8%EB%8D%B8%EB%A7%81%ED%9D%94%ED%95%9C%EC%8B%A4%EC%88%982.pdf">발표자료는 여기에서 다운로드</a></b> 받으실 수 있습니다.</li></ul></li></ul><blockquote><p><a href="https://aifesta.co.kr/">2021 AI Festival</a></p></blockquote><ul><li>제 발표는 44분 30초부터 시작합니다 (<a href="https://youtu.be/keXrv3D2m8k?t=2671">Link</a>)<br></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/keXrv3D2m8k" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p><img src="83_aifestival_02.jpg" alt="AI 프렌즈 공지"></p><p><img src="83_aifestival_01.png" alt="행사 프로그램"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/AI-festival/">AI festival</category>
      
      <category domain="https://jehyunlee.github.io/tags/AI-Frenz/">AI Frenz</category>
      
      
    </item>
    
  </channel>
</rss>
