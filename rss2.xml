<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Pega Devlog</title>
    <link>https://jehyunlee.github.io/</link>
    
    <atom:link href="https://jehyunlee.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Pega&#39;s Development log for myself and others</description>
    <pubDate>Thu, 30 Sep 2021 03:43:16 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>pytorch &amp; sklearn pipeline</title>
      <link>https://jehyunlee.github.io/2021/09/29/Python-DL-7-skorch_pipeline/</link>
      <guid>https://jehyunlee.github.io/2021/09/29/Python-DL-7-skorch_pipeline/</guid>
      <pubDate>Wed, 29 Sep 2021 02:57:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;저는 tabular data를 다룹니다.&lt;/li&gt;
&lt;li&gt;간혹 딥러닝을 하고 싶지만 표준화등 전처리도 해야 합니다.&lt;/li&gt;
&lt;li&gt;범주형 변수를 인코딩해서 feature importance도 보고 싶습니다.&lt;/li&gt;
&lt;li&gt;skorc</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>저는 tabular data를 다룹니다.</li><li>간혹 딥러닝을 하고 싶지만 표준화등 전처리도 해야 합니다.</li><li>범주형 변수를 인코딩해서 feature importance도 보고 싶습니다.</li><li>skorch(sklearn + pytorch)를 사용하면 가능합니다.</li></ul><h1 id="1-skorch-sklearn-pytorch"><a href="#1-skorch-sklearn-pytorch" class="headerlink" title="1. skorch = sklearn + pytorch"></a>1. skorch = sklearn + pytorch</h1><p><img src="7_skorch_pipeline.png"></p><blockquote><p><a href="https://skorch.readthedocs.io/en/stable/index.html">skorch documentation</a><br><a href="https://skorch.readthedocs.io/en/stable/user/tutorials.html">skorch tutorials</a></p></blockquote><ul><li>저같은 사람들을 위해 skorch라는 라이브러리가 있습니다.</li><li>scikit-learn의 장점인 <b>grid search 등을 딥러닝과 함께</b> 사용할 수 있고</li><li>tutorial에서 transfer learning, U-Net, Seq2Seq 등을 지원합니다.<br><br><img src="7_skorch_pipeline_9.png"><br></li></ul><h1 id="2-sklearn-pipeline"><a href="#2-sklearn-pipeline" class="headerlink" title="2. sklearn pipeline"></a>2. sklearn pipeline</h1><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html">scikit-learn.pipeline.Pipeline</a></p></blockquote><ul><li>scikit-learn의 파이프라인은 데이터 전처리에서 발생하는 불확실성을 줄여줍니다.</li><li>데이터가 거쳐갈 길을 단단하게 만들어줌으로써 실수를 사전에 예방할 수 있습니다.</li><li>특히 PCA나 One-hot encoding처럼 <b>trainset의 정보를 기억해서 testset에 적용해야 할 때 좋습니다</b>.</li></ul><h2 id="2-1-예제-데이터셋"><a href="#2-1-예제-데이터셋" class="headerlink" title="2.1. 예제 데이터셋"></a>2.1. 예제 데이터셋</h2><ul><li>펭귄 데이터셋을 사용해서 펭귄 체중 예측모델을 만들어 봅니다.</li><li>편의를 위해 결측치까지 싹 지운 채로 시작합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 시각화 설정</span></span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line">sns.set_style(<span class="string">&quot;white&quot;</span>)</span><br><span class="line">font_title = &#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux 한글 사용 설정</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>]=[<span class="string">&#x27;NanumGothic&#x27;</span>, <span class="string">&#x27;sans-serif&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 펭귄 데이터셋 불러오기</span></span><br><span class="line">df_peng = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)</span><br><span class="line">df_peng.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line">df_peng.isna().<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure></li><li>실행 결과: 결측치가 모두 제거되었습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">species              0</span><br><span class="line">island               0</span><br><span class="line">bill_length_mm       0</span><br><span class="line">bill_depth_mm        0</span><br><span class="line">flipper_length_mm    0</span><br><span class="line">body_mass_g          0</span><br><span class="line">sex                  0</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></li></ul><ul><li>데이터셋을 준비합니다.</li><li>펭귄 체중만 y, 나머지는 모두 X입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y = df_peng[<span class="string">&quot;body_mass_g&quot;</span>]</span><br><span class="line">X = df_peng.drop(<span class="string">&quot;body_mass_g&quot;</span>, axis=<span class="number">1</span>)</span><br><span class="line">X.head(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><img src="7_skorch_pipeline_10.png"><br></li></ul><ul><li>trainset과 testset으로 나눕니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data split</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2-pipeline-구축"><a href="#2-2-pipeline-구축" class="headerlink" title="2.2. pipeline 구축"></a>2.2. pipeline 구축</h2><ul><li>scikit-learn으로 pipeline을 구축합니다.</li><li>numerical feature는 회귀모델 적용을 고려한 <code>PolynomialFeatures</code>와</li><li>데이터 정규화를 위한 <code>RobustScaler</code>를 거칩니다.</li><li>categorical feature는 <code>OneHotEncoder</code>를 거칩니다.</li></ul><ul><li><p>필요한 라이브러리를 불러옵니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoder</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> RobustScaler</span><br><span class="line"></span><br><span class="line"><span class="comment"># machine learning models</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"></span><br><span class="line"><span class="comment"># pipeline</span></span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.compose <span class="keyword">import</span> ColumnTransformer</span><br><span class="line"></span><br><span class="line"><span class="comment"># metrics</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br></pre></td></tr></table></figure></li><li><p>pipeline을 구축하는 함수를 만듭니다.</p></li><li><p><code>get_model_0()</code>을 실행하면 파이프라인이 만들어질 것입니다.</p></li><li><p>전처리 후 머신러닝 모델로는 선형회귀와 랜덤포레스트를 선택할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_model_0</span>(<span class="params">X_cols, degree=<span class="number">1</span>, method=<span class="string">&quot;lr&quot;</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    X_cols_ = deepcopy(X_cols)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1-1.categorical feature에 one-hot encoding 적용</span></span><br><span class="line">    cat_features = <span class="built_in">list</span>(<span class="built_in">set</span>(X_cols) &amp; <span class="built_in">set</span>([<span class="string">&quot;species&quot;</span>, <span class="string">&quot;island&quot;</span>, <span class="string">&quot;sex&quot;</span>]))</span><br><span class="line">    cat_transformer = OneHotEncoder(sparse=<span class="literal">False</span>, handle_unknown=<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1-2.numerical feature는 Power Transform과 Scaler를 거침</span></span><br><span class="line">    num_features = <span class="built_in">list</span>(<span class="built_in">set</span>(X_cols) - <span class="built_in">set</span>(cat_features))</span><br><span class="line">    num_features.sort()</span><br><span class="line">    num_transformer = Pipeline(steps=[(<span class="string">&quot;polynomial&quot;</span>, PolynomialFeatures(degree=degree)), </span><br><span class="line">                                      (<span class="string">&quot;scaler&quot;</span>, RobustScaler())</span><br><span class="line">                                     ])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 인자 종류별 전처리 적용</span></span><br><span class="line">    preprocessor = ColumnTransformer(transformers=[(<span class="string">&quot;num&quot;</span>, num_transformer, num_features), </span><br><span class="line">                                                   (<span class="string">&quot;cat&quot;</span>, cat_transformer, cat_features)])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 전처리 후 머신러닝 모델 적용</span></span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">&quot;lr&quot;</span>:</span><br><span class="line">        ml = LinearRegression(fit_intercept=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&quot;rf&quot;</span>:</span><br><span class="line">        ml = RandomForestRegressor()</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 3. Pipeline</span></span><br><span class="line">    model = Pipeline(steps=[(<span class="string">&quot;preprocessor&quot;</span>, preprocessor), </span><br><span class="line">                            (<span class="string">&quot;ml&quot;</span>, ml)])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure></li><li><p>6번째, 10번째 행을 보시면 조금 특이한 처리가 들어가 있습니다.</p></li><li><p><b>feature selection에 사용되는 장치</b>입니다.</p></li><li><p>feature 이름들을 하드코딩하면 feature selection이 불가능하기 때문에 이렇게 합니다.</p></li></ul><ul><li>만들어진 구조를 확인합니다.</li><li>일단 모든 인자를 모두 입력합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> set_config</span><br><span class="line">set_config(display=<span class="string">&#x27;diagram&#x27;</span>)</span><br><span class="line">model_0 = get_model_0(<span class="built_in">list</span>(X_train.columns), degree=<span class="number">1</span>, method=<span class="string">&quot;lr&quot;</span>)</span><br><span class="line">model_0</span><br></pre></td></tr></table></figure><img src="7_skorch_pipeline_11.png"><br></li></ul><h2 id="2-3-pipeline-전처리-확인"><a href="#2-3-pipeline-전처리-확인" class="headerlink" title="2.3. pipeline 전처리 확인"></a>2.3. pipeline 전처리 확인</h2><ul><li>pipeline에서 전처리 모듈만 떼어서 실행합니다.</li><li>pipeline의 모듈을 호출하는 방법은 <b>모델이름[“모듈이름”]</b>입니다.</li><li>따라서 우리의 전처리 모듈은 <b>model_0[“preprocessor”]</b>입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X_train_pp = model_0[<span class="string">&quot;preprocessor&quot;</span>].fit_transform(X_train)</span><br><span class="line"><span class="built_in">print</span>(X_train_pp.shape)</span><br><span class="line">X_train_pp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li><li>실행 결과: 첫 행만 찍어봤습니다. <b>숫자가 많습니다</b><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">266</span>, <span class="number">12</span>)</span><br><span class="line">array([ <span class="number">0.</span>        , -<span class="number">0.80645161</span>,  <span class="number">0.08579088</span>,  <span class="number">1.</span>        ,  <span class="number">1.</span>        ,</span><br><span class="line">        <span class="number">0.</span>        ,  <span class="number">0.</span>        ,  <span class="number">0.</span>        ,  <span class="number">0.</span>        ,  <span class="number">1.</span>        ,</span><br><span class="line">        <span class="number">0.</span>        ,  <span class="number">1.</span>        ])</span><br></pre></td></tr></table></figure></li></ul><ul><li>6개의 인자를 넣었는데 12개가 나왔습니다.</li><li>처음의 0은 LinearRegression에서 만든 intercept 항입니다.</li><li>네번째 1부터는 species, island, sex의 one-hot encoding 결과물입니다.</li></ul><ul><li>전처리 이후 데이터 분포도 확인합니다.</li><li>시각화 코드는 다소 길고, 여기선 중요하지 않아서 접었습니다.<details>  <summary><b>코드 보기/접기</b></summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Figure 생성</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>, <span class="number">8</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Subfigures 생성</span></span><br><span class="line">subfigs = fig.subfigures(nrows=<span class="number">2</span>, wspace=<span class="number">0.05</span>)</span><br><span class="line">subfigs[<span class="number">0</span>].set_facecolor(<span class="string">&quot;lightgray&quot;</span>)</span><br><span class="line">subfigs[<span class="number">1</span>].set_facecolor(<span class="string">&quot;beige&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># subfigs[0]: raw data</span></span><br><span class="line">axs0 = subfigs[<span class="number">0</span>].subplots(ncols=<span class="number">3</span>, nrows=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sns.kdeplot(X_train[<span class="string">&quot;bill_depth_mm&quot;</span>], cut=<span class="number">0</span>, fill=<span class="literal">True</span>, ax=axs0[<span class="number">0</span>])</span><br><span class="line">sns.kdeplot(X_train[<span class="string">&quot;bill_length_mm&quot;</span>], cut=<span class="number">0</span>, fill=<span class="literal">True</span>, ax=axs0[<span class="number">1</span>])</span><br><span class="line">sns.kdeplot(X_train[<span class="string">&quot;flipper_length_mm&quot;</span>], cut=<span class="number">0</span>, fill=<span class="literal">True</span>, ax=axs0[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># subfigs[1]: preprocessed data</span></span><br><span class="line">axs1 = subfigs[<span class="number">1</span>].subplots(ncols=<span class="number">3</span>, nrows=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sns.kdeplot(X_train_pp[:,<span class="number">1</span>], cut=<span class="number">0</span>, fill=<span class="literal">True</span>, ax=axs1[<span class="number">0</span>])</span><br><span class="line">sns.kdeplot(X_train_pp[:,<span class="number">2</span>], cut=<span class="number">0</span>, fill=<span class="literal">True</span>, ax=axs1[<span class="number">1</span>])</span><br><span class="line">sns.kdeplot(X_train_pp[:,<span class="number">3</span>], cut=<span class="number">0</span>, fill=<span class="literal">True</span>, ax=axs1[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax <span class="keyword">in</span> axs1:</span><br><span class="line">    ax.axvline(<span class="number">0</span>, c=<span class="string">&quot;gray&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> axs <span class="keyword">in</span> [axs0, axs1]:</span><br><span class="line">    <span class="keyword">for</span> i, (ax, title) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(axs, [<span class="string">&#x27;bill_depth_mm&#x27;</span>, <span class="string">&#x27;bill_length_mm&#x27;</span>, <span class="string">&#x27;flipper_length_mm&#x27;</span>])):</span><br><span class="line">        ax.set_xlabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        ax.set_title(<span class="string">f&quot;<span class="subst">&#123;title&#125;</span>&quot;</span>, fontdict=font_title, pad=<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            ax.set_ylabel(<span class="string">&quot; \n&quot;</span>)</span><br><span class="line"></span><br><span class="line">subfigs[<span class="number">0</span>].suptitle(<span class="string">&quot;raw data\n&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">subfigs[<span class="number">1</span>].suptitle(<span class="string">&quot;preprocessed data\n&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">fig.suptitle(<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><p><img src="7_skorch_pipeline_1.png"><br></p><ul><li>RobustScaler의 효과가 잘 보입니다.</li></ul><h2 id="2-3-pipeline-학습"><a href="#2-3-pipeline-학습" class="headerlink" title="2.3. pipeline 학습"></a>2.3. pipeline 학습</h2><ul><li><p><b>pipeline 전체를 사용해서 학습</b>시킵니다.</p></li><li><p>명령은 scikit-learn 스타일 그대로 <code>.fit()</code>입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model_0.fit(X_train, y_train)</span><br></pre></td></tr></table></figure></li><li><p>학습이 잘 되었는지 결과를 확인합니다.</p></li><li><p>parity plot 시각화 코드는 접어두었습니다.</p><details>  <summary><b>코드 보기/접기</b></summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parity plot</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_parity</span>(<span class="params">model, y_true, y_pred=<span class="literal">None</span>, X_to_pred=<span class="literal">None</span>, ax=<span class="literal">None</span>, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ax:</span><br><span class="line">        fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> y_pred <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        y_pred = model.predict(X_to_pred)</span><br><span class="line">    ax.scatter(y_true, y_pred, **kwargs)</span><br><span class="line">    xbound = ax.get_xbound()</span><br><span class="line">    xticks = [x <span class="keyword">for</span> x <span class="keyword">in</span> ax.get_xticks() <span class="keyword">if</span> xbound[<span class="number">0</span>] &lt;= x &lt;= xbound[<span class="number">1</span>]]</span><br><span class="line">    ax.set_xticks(xticks)</span><br><span class="line">    ax.set_xticklabels([<span class="string">f&quot;<span class="subst">&#123;x:<span class="number">.0</span>f&#125;</span>&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> xticks])</span><br><span class="line">    ax.set_yticks(xticks)</span><br><span class="line">    ax.set_yticklabels([<span class="string">f&quot;<span class="subst">&#123;x:<span class="number">.0</span>f&#125;</span>&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> xticks])</span><br><span class="line">    dxbound = <span class="number">0.05</span>*(xbound[<span class="number">1</span>]-xbound[<span class="number">0</span>])</span><br><span class="line">    ax.set_xlim(xbound[<span class="number">0</span>]-dxbound, xbound[<span class="number">1</span>]+dxbound)</span><br><span class="line">    ax.set_ylim(xbound[<span class="number">0</span>]-dxbound, xbound[<span class="number">1</span>]+dxbound)</span><br><span class="line">    </span><br><span class="line">    rmse = mean_squared_error(y_true, y_pred, squared=<span class="literal">False</span>)</span><br><span class="line">    r2 = r2_score(y_true, y_pred)</span><br><span class="line">    ax.text(<span class="number">0.95</span>, <span class="number">0.1</span>, <span class="string">f&quot;RMSE = <span class="subst">&#123;rmse:<span class="number">.2</span>f&#125;</span>\nR2 = <span class="subst">&#123;r2:<span class="number">.2</span>f&#125;</span>&quot;</span>, transform=ax.transAxes, </span><br><span class="line">            fontsize=<span class="number">14</span>, ha=<span class="string">&quot;right&quot;</span>, va=<span class="string">&quot;bottom&quot;</span>, bbox=&#123;<span class="string">&quot;boxstyle&quot;</span>:<span class="string">&quot;round&quot;</span>, <span class="string">&quot;fc&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;pad&quot;</span>:<span class="number">0.3</span>&#125;)</span><br><span class="line">    </span><br><span class="line">    ax.grid(<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ax</span><br><span class="line">    </span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">8</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line">plot_parity(model_0, y_train, X_to_pred=X_train, ax=axs[<span class="number">0</span>], c=<span class="string">&quot;g&quot;</span>, s=<span class="number">10</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plot_parity(model_0, y_test, X_to_pred=X_test, ax=axs[<span class="number">1</span>], c=<span class="string">&quot;m&quot;</span>, s=<span class="number">10</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [<span class="string">&quot;train&quot;</span>, <span class="string">&quot;test&quot;</span>]):</span><br><span class="line">    ax.set_title(title, fontdict=font_title, pad=<span class="number">16</span>)</span><br></pre></td></tr></table></figure></li></ul><p><img src="7_skorch_pipeline_2.png"><br></p><ul><li><p>단순 선형 회귀 모델인데 제법 쓸만합니다.</p></li><li><p>이제 pipeline에 랜덤포레스트 모델을 탑재해서 돌려봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model_1 = get_model_0(<span class="built_in">list</span>(X_train.columns), degree=<span class="number">1</span>, method=<span class="string">&quot;rf&quot;</span>)</span><br><span class="line">model_1.fit(X_train, y_train)</span><br><span class="line">model_1</span><br></pre></td></tr></table></figure><p><img src="7_skorch_pipeline_3.png"><br></p></li><li><p>과적합이 의심되긴 하지만 랜덤포레스트도 잘 나오네요.</p></li></ul><ul><li><p>이번에는 <b>feature selection</b>도 되는지 확인합니다.</p></li><li><p>부리 길이<code>bill_length_mm</code>와 종<code>species</code>만 가지고 결과를 예측해봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model_2 = get_model_0([<span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;species&quot;</span>], degree=<span class="number">1</span>, method=<span class="string">&quot;rf&quot;</span>)</span><br><span class="line">model_2.fit(X_train, y_train)</span><br></pre></td></tr></table></figure><p><img src="7_skorch_pipeline_4.png"><br></p></li><li><p>멀쩡한 인자들을 제외했으니 성능이 떨어지는 건 정상입니다.</p></li><li><p><b>pipeline을 작성하기에 따라 feature 중 일부만 넣어도 동작한다</b>는 것이 중요합니다.</p></li></ul><h1 id="3-pytorch-deep-learning"><a href="#3-pytorch-deep-learning" class="headerlink" title="3. pytorch deep learning"></a>3. pytorch deep learning</h1><ul><li>딥러닝은 다른 방법에 비해 복잡하고 연산자원이 많이 들지만 장점이 많습니다.</li><li>이미지나 시계열을 다룰 때 큰 힘을 발휘하는데, 간혹 tabular data에도 필요합니다.</li><li>pytorch만을 사용해서 모델을 만들어보고 pipeline에 탑재해서도 결과를 얻어봅니다.</li></ul><h2 id="3-1-pytorch-only"><a href="#3-1-pytorch-only" class="headerlink" title="3.1. pytorch only"></a>3.1. pytorch only</h2><ul><li><p>파이토치로 신경망 모델을 만들고 같은 데이터로 같은 문제를 풀어봅니다.</p></li><li><p>간단한 신경망 모델을 만듭니다. 나중에 pipeline 안에 넣을 겁니다. </p></li><li><p>feature selection을 대비해서 input dimension을 가변적으로 만듭니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim</span><br><span class="line"><span class="keyword">from</span> torch.optim.lr_scheduler <span class="keyword">import</span> CyclicLR</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegressorModule</span>(<span class="params">nn.Module</span>):</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ninput=<span class="number">11</span>, init_weights=<span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(RegressorModule, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self.model = nn.Sequential(nn.Linear(ninput, <span class="number">16</span>),</span><br><span class="line">                                   nn.ReLU(),</span><br><span class="line">                                   nn.Linear(<span class="number">16</span>, <span class="number">16</span>),</span><br><span class="line">                                   nn.ReLU(),</span><br><span class="line">                                   nn.Linear(<span class="number">16</span>, <span class="number">12</span>),</span><br><span class="line">                                   nn.ReLU(),</span><br><span class="line">                                   nn.Linear(<span class="number">12</span>, <span class="number">8</span>),</span><br><span class="line">                                   nn.ReLU(),</span><br><span class="line">                                   nn.Linear(<span class="number">8</span>, <span class="number">1</span>),</span><br><span class="line">                                   )</span><br><span class="line">        <span class="keyword">if</span> init_weights:</span><br><span class="line">            self._initialize_weights()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.model(X)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_initialize_weights</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> self.modules():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Linear):</span><br><span class="line">                nn.init.normal_(m.weight, <span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line">                nn.init.constant_(m.bias, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li><li><p>pytorch에 데이터를 넣으려면 tensor로 만들어야 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X_train_tensor = torch.Tensor(pd.get_dummies(X_train).astype(np.float32).values)</span><br><span class="line">y_train_tensor = torch.Tensor(y_train.astype(np.float32).values)</span><br></pre></td></tr></table></figure></li><li><p>지금 만든 모델에 학습을 시킬 수 있는 코드를 구현합니다.</p></li><li><p>1만 epoch동안 충분히 데이터를 넣어봅니다.</p></li><li><p>loss function으로는 RMSELoss를 구현해서 사용했습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">net = RegressorModule()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RMSELoss</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, eps=<span class="number">1e-6</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.mse = nn.MSELoss()</span><br><span class="line">        self.eps = eps</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,yhat,y</span>):</span></span><br><span class="line">        loss = torch.sqrt(self.mse(yhat,y) + self.eps)</span><br><span class="line">        <span class="keyword">return</span> loss</span><br><span class="line">    </span><br><span class="line">loss_func = RMSELoss()</span><br><span class="line">optimizer = optim.Adam(net.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">losses = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    output = net.forward(X_train_tensor)</span><br><span class="line">    loss = loss_func(output, y_train_tensor.view(-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line">    </span><br><span class="line">    losses.append(loss)</span><br><span class="line">    </span><br><span class="line">plt.plot(losses)</span><br></pre></td></tr></table></figure><p><img src="7_skorch_pipeline_5.png"><br></p></li></ul><ul><li><p>제법 학습이 잘 된 것 같습니다.</p></li><li><p>예측 성능을 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># numpy array를 pytorch tensor로 변환</span></span><br><span class="line">X_test_tensor = torch.Tensor(pd.get_dummies(X_test).astype(np.float32).values)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 예측값</span></span><br><span class="line">y_pred_train_tensor = net.forward(X_train_tensor)</span><br><span class="line">y_pred_test_tensor = net.forward(X_test_tensor)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pytorch tensor를 다시 numpy array로 변환</span></span><br><span class="line">y_pred_train = y_pred_train_tensor.detach().numpy()</span><br><span class="line">y_pred_test = y_pred_test_tensor.detach().numpy()</span><br></pre></td></tr></table></figure><p><img src="7_skorch_pipeline_6.png"><br></p></li><li><p><b>딥러닝으로도 제법 괜찮은 성능이 나오는 것</b>을 확인했습니다.</p></li></ul><h2 id="3-2-pytorch-pipeline"><a href="#3-2-pytorch-pipeline" class="headerlink" title="3.2. pytorch @pipeline"></a>3.2. pytorch @pipeline</h2><ul><li><b>skorch를 이용해서 pytorch를 pipeline 안에 탑재합니다.</b></li><li><b>skorch은 pytorch를 scikit-learn 객체처럼 만들어주는 일</b>을 합니다.</li><li>그래서 skorch로 감싼 pytorch 객체의 학습은 <b><code>fit()</code></b>이고,</li><li>예측은 <b><code>.forward()&lt;/b&gt;가 아니라 &lt;b&gt;</code>.predict()</b>입니다.</li></ul><ul><li>skorch의 <code>NeuralNetRegressor()</code>로 딥러닝 모듈 전체를 감싸고,</li><li>학습에 필요한 인자를 매개변수로 전달합니다.</li></ul><ul><li>그리고 중요한 사항이 하나 있습니다.</li><li><b>scikit-learn이 뱉는 <code>np.float64</code>를 <code>np.float32</code>로 변환</b>해야 합니다.</li><li>이를 위해 custom transformer를 만들어 적용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skorch <span class="keyword">import</span> NeuralNetRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.base <span class="keyword">import</span> BaseEstimator, TransformerMixin</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_model_T</span>(<span class="params">X_cols, degree=<span class="number">1</span>, method=<span class="string">&quot;lr&quot;</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    X_cols_ = deepcopy(X_cols)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1-1.categorical feature에 one-hot encoding 적용</span></span><br><span class="line">    cat_features = <span class="built_in">list</span>(<span class="built_in">set</span>(X_cols) &amp; <span class="built_in">set</span>([<span class="string">&quot;species&quot;</span>, <span class="string">&quot;island&quot;</span>, <span class="string">&quot;sex&quot;</span>]))</span><br><span class="line">    cat_transformer = OneHotEncoder(sparse=<span class="literal">False</span>, handle_unknown=<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1-2.numerical feature는 Power Transform과 Scaler를 거침</span></span><br><span class="line">    num_features = <span class="built_in">list</span>(<span class="built_in">set</span>(X_cols) - <span class="built_in">set</span>(cat_features))</span><br><span class="line">    num_features.sort()</span><br><span class="line">    num_transformer = Pipeline(steps=[(<span class="string">&quot;polynomial&quot;</span>, PolynomialFeatures(degree=degree)), </span><br><span class="line">                                      (<span class="string">&quot;scaler&quot;</span>, RobustScaler())</span><br><span class="line">                                     ])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 인자 종류별 전처리 적용</span></span><br><span class="line">    preprocessor = ColumnTransformer(transformers=[(<span class="string">&quot;num&quot;</span>, num_transformer, num_features), </span><br><span class="line">                                                   (<span class="string">&quot;cat&quot;</span>, cat_transformer, cat_features)])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. float64를 float32로 변환</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FloatTransformer</span>(<span class="params">BaseEstimator, TransformerMixin</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fit</span>(<span class="params">self, X, y=<span class="literal">None</span></span>):</span></span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">transform</span>(<span class="params">self, x</span>):</span></span><br><span class="line">            <span class="keyword">return</span> np.array(x, dtype=np.float32)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 전처리 후 머신러닝 모델 적용</span></span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">&quot;lr&quot;</span>:</span><br><span class="line">        ml = LinearRegression(fit_intercept=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&quot;rf&quot;</span>:</span><br><span class="line">        ml = RandomForestRegressor()</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&quot;torch&quot;</span>:</span><br><span class="line">        ninput = <span class="built_in">len</span>(num_features) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;species&quot;</span> <span class="keyword">in</span> cat_features:</span><br><span class="line">            ninput += <span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;island&quot;</span> <span class="keyword">in</span> cat_features:</span><br><span class="line">            ninput += <span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;sex&quot;</span> <span class="keyword">in</span> cat_features:</span><br><span class="line">            ninput += <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">        net = NeuralNetRegressor(RegressorModule(ninput=ninput, init_weights=<span class="literal">False</span>),</span><br><span class="line">                         max_epochs=<span class="number">1000</span>, verbose=<span class="number">0</span>,</span><br><span class="line">                         warm_start=<span class="literal">True</span>,</span><br><span class="line"><span class="comment">#                          device=&#x27;cuda&#x27;,</span></span><br><span class="line">                         criterion=RMSELoss,</span><br><span class="line">                         optimizer = optim.Adam,</span><br><span class="line">                         optimizer__lr = <span class="number">0.01</span></span><br><span class="line">                        )</span><br><span class="line">        ml = net</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 3. Pipeline</span></span><br><span class="line">    model = Pipeline(steps=[(<span class="string">&quot;preprocessor&quot;</span>, preprocessor), </span><br><span class="line">                            (<span class="string">&quot;float64to32&quot;</span>, FloatTransformer()),</span><br><span class="line">                            (<span class="string">&quot;ml&quot;</span>, ml)])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>모델을 만들고 확인합니다.</p></li><li><p>앞서 pytorch로 구현한 뉴럴넷 구조가 그대로 들어가 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model_T = get_model_T(<span class="built_in">list</span>(X_train.columns), degree=<span class="number">1</span>, method=<span class="string">&quot;torch&quot;</span>)</span><br><span class="line">model_T.fit(X_train, y_train.astype(np.float32).values.reshape(-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">model_T</span><br></pre></td></tr></table></figure><p><img src="7_skorch_pipeline_13.png"><br></p></li><li><p><b>성능을 확인합니다.</b> 준수하네요.<br><img src="7_skorch_pipeline_7.png"><br></p></li></ul><h1 id="4-permutation-feature-importance"><a href="#4-permutation-feature-importance" class="headerlink" title="4. permutation feature importance"></a>4. permutation feature importance</h1><ul><li>같은 파이프라인에서 선형, 트리, 딥러닝이 모두 구현되었습니다.</li><li>각각의 인자 중요도를 한번 확인해보겠습니다.</li><li>permutation importance를 사용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.inspection <span class="keyword">import</span> permutation_importance</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linear Regression</span></span><br><span class="line">pi_0 = permutation_importance(model_0, X_test, y_test, n_repeats=<span class="number">30</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Random Forest</span></span><br><span class="line">pi_1 = permutation_importance(model_1, X_test, y_test, n_repeats=<span class="number">30</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Neural Network</span></span><br><span class="line">pi_T = permutation_importance(model_T, X_test, y_test, n_repeats=<span class="number">30</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 시각화</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">15</span>, <span class="number">5</span>), constrained_layout=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, pi, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [pi_0, pi_1, pi_T], [<span class="string">&quot;Linear Reg.&quot;</span>, <span class="string">&quot;Random Forest&quot;</span>, <span class="string">&quot;Neural Net&quot;</span>]):</span><br><span class="line">    ax.barh(X_test.columns, pi.importances_mean, xerr=pi.importances_std, color=<span class="string">&quot;orange&quot;</span>)</span><br><span class="line">    ax.invert_yaxis()</span><br><span class="line">    ax.set_xlim(<span class="number">0</span>, )</span><br><span class="line">    ax.set_title(title, fontdict=font_title, pad=<span class="number">16</span>)</span><br></pre></td></tr></table></figure><img src="7_skorch_pipeline_8.png"><br></li></ul><ul><li><b>입력 feature별 인자 중요도가 깔끔하게 정리되었습니다.</b></li><li>양상도 전반적으로 비슷하게 나오네요.</li><li>사소한 기능같지만 <b>tabular data를 딥러닝으로 돌렸을 때 이 그림을 그리기가 어려웠습니다.</b></li><li>이 글과 코드가 비슷한 어려움을 겪는 여러분께 도움이 되면 좋겠습니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Deep-Learning/">Deep Learning</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/pytorch/">pytorch</category>
      
      <category domain="https://jehyunlee.github.io/tags/sklearn/">sklearn</category>
      
      <category domain="https://jehyunlee.github.io/tags/pipeline/">pipeline</category>
      
      <category domain="https://jehyunlee.github.io/tags/neural-network/">neural network</category>
      
      
    </item>
    
    <item>
      <title>Full moon</title>
      <link>https://jehyunlee.github.io/2021/09/26/Python-General-9-fullmoon/</link>
      <guid>https://jehyunlee.github.io/2021/09/26/Python-General-9-fullmoon/</guid>
      <pubDate>Sat, 25 Sep 2021 23:52:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;지난 추석, 간만에 긴장을 풀었습니다.&lt;/li&gt;
&lt;li&gt;가끔 취미로 그림을 그리고는 하는데 python으로는 안그렸네요.&lt;/li&gt;
&lt;li&gt;자다가 문득 코드가 떠올라 보름달을 그렸습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-보름달은&quot;&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>지난 추석, 간만에 긴장을 풀었습니다.</li><li>가끔 취미로 그림을 그리고는 하는데 python으로는 안그렸네요.</li><li>자다가 문득 코드가 떠올라 보름달을 그렸습니다.</li></ul><h1 id="1-보름달은"><a href="#1-보름달은" class="headerlink" title="1. 보름달은?"></a>1. 보름달은?</h1><ul><li><p><b>보름달</b>이 어떻게 생겼는지 모르는 사람은 없을 겁니다.<br><br><img src="9_fullmoon_01.jpg"><br></p></li><li><p><b>검은 밤 하늘에 떠 있는 하얀 동그라미</b>로 단순화할 수 있습니다.</p></li><li><p>토끼가 방아를 찧고 있는 듯한 모양이 있지만 잠시 잊기로 합니다.</p></li><li><p>하지만 그냥 동그라미를 그리기엔 심심합니다. 작은 동그라미를 여럿 겹칩니다.</p></li></ul><h1 id="2-코드로-그리는-보름달"><a href="#2-코드로-그리는-보름달" class="headerlink" title="2. 코드로 그리는 보름달"></a>2. 코드로 그리는 보름달</h1><h2 id="2-1-코드로-그리는-그림"><a href="#2-1-코드로-그리는-그림" class="headerlink" title="2.1. 코드로 그리는 그림"></a>2.1. 코드로 그리는 그림</h2><blockquote><p><a href="http://www.genmedia.co.kr/news/articleView.html?idxno=12738">젠미디어: 이주행 ETRI 연구원 인터뷰</a><br><a href="https://techcrunch.com/2016/05/08/the-digital-age-of-data-art/">Techcrunch: The digital age of data art</a></p></blockquote><ul><li>무미건조한 코드나 데이터로 아름다움을 만들어내는 분들이 있으십니다.</li><li>데이터 시각화의 심미적 요소를 한껏 활용하는 것으로 볼 수도 있고</li><li>그림을 그리는 도구가 바뀌었을 뿐 데이터와 무관한 아름다움을 추구하기도 합니다.</li><li>이런 분들을 따라해 보기로 합니다<br><br><img src="9_fullmoon_08.png" alt="(좌) 이주행, &quot;Pixel Stack&quot;, (우) Mark Napier &quot;Black and White&quot;"><br></li></ul><h2 id="2-2-약간의-기하학"><a href="#2-2-약간의-기하학" class="headerlink" title="2.2. 약간의 기하학"></a>2.2. 약간의 기하학</h2><ul><li><p>중심을 (0,0)으로 하는 극좌표계 공간을 만듭니다.</p></li><li><p>반지름이 1인 공간 안에 랜덤하게 한 점을 골라 원의 중심을 잡습니다.</p></li><li><p>극좌표계를 사용하여 원점으로부터의 거리과 방위각으로 좌표를 잡으면 편리합니다.</p></li><li><p>matplotlib의 Circle을 이용해서 원을 생성합니다.</p></li><li><p>원의 반지름을 <code>1-원점으로부터의 거리</code>로 설정하면 원의 윤곽선에 항상 맞닿습니다.</p></li><li><p>10개만 그려봅시다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Circle</span><br><span class="line"></span><br><span class="line">num = <span class="number">10</span>    <span class="comment"># 원의 수</span></span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), </span><br><span class="line">                       constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 극좌표계에서 원 생성</span></span><br><span class="line">R = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)                   <span class="comment"># 반지름의 범위: 0~1</span></span><br><span class="line">pos_r = np.random.choice(R, size=num)        <span class="comment"># 랜덤 위치 (반지름)</span></span><br><span class="line">pos_a = <span class="number">2</span>*np.pi*np.random.uniform(size=num)  <span class="comment"># 랜덤 위치 (방위각)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 직교좌표계 변환</span></span><br><span class="line">pos_x = pos_r * np.cos(pos_a)         <span class="comment"># 직교좌표계 x</span></span><br><span class="line">pos_y = pos_r * np.sin(pos_a)         <span class="comment"># 직교좌표계 y</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x, y, r <span class="keyword">in</span> <span class="built_in">zip</span>(pos_x, pos_y, pos_r):</span><br><span class="line">    r_circle = <span class="number">1</span>-r  <span class="comment"># 원의 반지름</span></span><br><span class="line">    o = Circle((x, y), r_circle, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, alpha=<span class="number">1</span>)</span><br><span class="line">    ax.add_patch(o)</span><br><span class="line">    </span><br><span class="line">ax.set_xlim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">ax.set_ylim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">ax.axvline(<span class="number">0</span>, c=<span class="string">&quot;g&quot;</span>)</span><br><span class="line">ax.axhline(<span class="number">0</span>, c=<span class="string">&quot;g&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="9_fullmoon_02.png"><br></p></li></ul><h2 id="2-3-확률-제어"><a href="#2-3-확률-제어" class="headerlink" title="2.3. 확률 제어"></a>2.3. 확률 제어</h2><ul><li><p>100개를 그리면 이렇습니다.<br><img src="9_fullmoon_03.png"><br></p></li><li><p>뭔가 특이한 점을 느끼셨을까요?</p></li></ul><ul><li><p>원의 중심점 분포를 그리면 이렇습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 점들 사이 최단거리 계산</span></span><br><span class="line">pos_xy = np.array(<span class="built_in">list</span>(<span class="built_in">zip</span>(pos_x, pos_y)))</span><br><span class="line">d_shortests = []</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> pos_xy:</span><br><span class="line">    dp = pos_xy-p</span><br><span class="line">    d_shortest = np.inf</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> dp:</span><br><span class="line">        sd = np.sqrt(d[<span class="number">0</span>]**<span class="number">2</span> + d[<span class="number">1</span>]**<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt; sd &lt; d_shortest:</span><br><span class="line">            d_shortest = sd</span><br><span class="line">    d_shortests.append(d_shortest)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 시각화</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">8</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">0</span>].scatter(pos_x, pos_y)</span><br><span class="line">axs[<span class="number">0</span>].axvline(<span class="number">0</span>, c=<span class="string">&quot;g&quot;</span>)</span><br><span class="line">axs[<span class="number">0</span>].axhline(<span class="number">0</span>, c=<span class="string">&quot;g&quot;</span>)</span><br><span class="line">sns.kdeplot(d_shortests, cut=<span class="number">0</span>, ax=axs[<span class="number">1</span>], fill=<span class="literal">True</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_xlim(<span class="number">0</span>, <span class="built_in">max</span>(d_shortests))</span><br></pre></td></tr></table></figure><p><img src="9_fullmoon_04.png"><br></p></li><li><p>원점 부근을 중심으로 하는 점들이 월등히 많습니다.</p></li><li><p>앞서 그림을 그릴 때 원의 반지름을 <code>1-원점으로부터의 거리</code>로 설정했지요.</p></li><li><p><b>큰 원과 작은 원의 수는 비슷하더라도 작은 원은 여기저기 퍼져있고 큰 원은 뭉쳐있다</b>는 의미입니다.</p></li></ul><ul><li>나쁘다는 것은 아닙니다.</li><li>전체 원의 가운데보다 바깥 부분에 많은 선이 그려진다는 뜻이고,</li><li>원의 갯수를 키우는 것 만으로도 뭔가 3D 느낌이 납니다.</li><li>500개를 그리면 이렇게 됩니다.<br><img src="9_fullmoon_05.png"><br></li></ul><ul><li><p>다만, <b>약간의 확률 조작을 통해 연출이 가능하다</b>는 의미입니다.</p></li><li><p>예를 들어 이런 확률분포를 사용하면,<br><img src="9_fullmoon_06.png"><br></p></li><li><p>그림은 이렇게 바뀝니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>), </span><br><span class="line">                       constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 극좌표계에서 원 생성</span></span><br><span class="line">R = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)                   <span class="comment"># 반지름의 범위: 0~1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># np.random.choice에 매개변수 p 적용, 확률 제어</span></span><br><span class="line">f = np.float_power(np.sin(R), <span class="number">10</span>)</span><br><span class="line">p = (f/<span class="built_in">max</span>(f))/<span class="built_in">sum</span>(f/<span class="built_in">max</span>(f))</span><br><span class="line">pos_r = np.random.choice(R, size=num, p=p)   <span class="comment"># 랜덤 위치 (반지름)</span></span><br><span class="line">pos_a = <span class="number">2</span>*np.pi*np.random.uniform(size=num)  <span class="comment"># 랜덤 위치 (방위각)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 직교좌표계 변환</span></span><br><span class="line">pos_x = pos_r * np.cos(pos_a)         <span class="comment"># 직교좌표계 x</span></span><br><span class="line">pos_y = pos_r * np.sin(pos_a)         <span class="comment"># 직교좌표계 y</span></span><br><span class="line"></span><br><span class="line">r_circles = []</span><br><span class="line"><span class="keyword">for</span> x, y, r <span class="keyword">in</span> <span class="built_in">zip</span>(pos_x, pos_y, pos_r):</span><br><span class="line">    r_circle = <span class="number">1</span>-r  <span class="comment"># 원의 반지름</span></span><br><span class="line">    r_circles.append(r_circle)</span><br><span class="line">    o = Circle((x, y), r_circle, fc=<span class="string">&quot;none&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, alpha=<span class="number">1</span>, lw=<span class="number">0.1</span>)</span><br><span class="line">    ax.add_patch(o)</span><br><span class="line">    </span><br><span class="line">ax.set_xlim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">ax.set_ylim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">ax.axvline(<span class="number">0</span>, c=<span class="string">&quot;g&quot;</span>)</span><br><span class="line">ax.axhline(<span class="number">0</span>, c=<span class="string">&quot;g&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="9_fullmoon_07.png"><br></p></li></ul><h2 id="2-4-달-띄우기"><a href="#2-4-달-띄우기" class="headerlink" title="2.4. 달 띄우기"></a>2.4. 달 띄우기</h2><ul><li><p>달을 그리는 함수를 만들어봅니다.</p></li><li><p>앞에서 만든 함수에 딱 하나, <code>faceccolor</code>와 ‘edgecolor`를 제어하는 매개변수를 추가했습니다.</p></li><li><p>facecolor에 numpy array를 넣으면 랜덤하게 색을 입히는 기능을 추가했고요.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_fullmoon</span>(<span class="params">size, scale=<span class="number">5</span>, fc=<span class="string">&quot;w&quot;</span>, ec=<span class="string">&quot;none&quot;</span>, filename=<span class="string">&quot;fullmoon&quot;</span>, **kwargs</span>):</span></span><br><span class="line">    scale = np.<span class="built_in">float</span>(scale)</span><br><span class="line">    fig, ax = plt.subplots(figsize=(<span class="number">20</span>, <span class="number">20</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">    ax.set_facecolor(<span class="string">&quot;k&quot;</span>)</span><br><span class="line">    ax.spines[[<span class="string">&quot;top&quot;</span>, <span class="string">&quot;left&quot;</span>, <span class="string">&quot;bottom&quot;</span>, <span class="string">&quot;right&quot;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.set_xticks([])</span><br><span class="line">    ax.set_yticks([])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># random circle</span></span><br><span class="line">    R = np.linspace(<span class="number">0</span>, <span class="number">1</span>, size)</span><br><span class="line">    F = np.float_power(np.sin(R), <span class="number">10</span>)</span><br><span class="line">    P = (<span class="number">1</span>-F/<span class="built_in">max</span>(F))/<span class="built_in">sum</span>(<span class="number">1</span>-F/<span class="built_in">max</span>(F))</span><br><span class="line"></span><br><span class="line">    pos_r = np.random.choice(R, size=size, p=P)</span><br><span class="line">    pos_a = <span class="number">2</span>*np.pi*np.random.uniform(size=size)</span><br><span class="line">    pos_x = pos_r * np.cos(pos_a)</span><br><span class="line">    pos_y = pos_r * np.sin(pos_a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x, y, r <span class="keyword">in</span> <span class="built_in">zip</span>(pos_x, pos_y, pos_r):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(fc, np.ndarray):</span><br><span class="line">            fc = np.array([<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.8</span>]) + np.array([np.random.normal(loc=<span class="number">0.1</span>, scale=<span class="number">0.05</span>), np.random.normal(loc=<span class="number">0.1</span>, scale=<span class="number">0.05</span>), np.random.normal(loc=<span class="number">0.1</span>, scale=<span class="number">0.05</span>)])</span><br><span class="line">            fc[<span class="number">0</span>] = <span class="built_in">min</span>(fc[<span class="number">0</span>], <span class="number">1</span>)</span><br><span class="line">            fc[<span class="number">1</span>] = <span class="built_in">min</span>(fc[<span class="number">1</span>], <span class="number">1</span>)</span><br><span class="line">            fc[<span class="number">2</span>] = <span class="built_in">min</span>(fc[<span class="number">2</span>], <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        o = Circle((x, y), <span class="number">1</span>-r, fc=fc, ec=ec, alpha=scale/size, **kwargs)</span><br><span class="line">            </span><br><span class="line">        ax.add_patch(o)</span><br><span class="line"></span><br><span class="line">    ax.set_xlim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    ax.set_ylim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    fig.set_facecolor(<span class="string">&quot;k&quot;</span>)</span><br><span class="line">    fig.savefig(<span class="string">f&quot;<span class="subst">&#123;filename&#125;</span>.png&quot;</span>, dpi=<span class="number">300</span>)</span><br><span class="line">    </span><br><span class="line">plot_fullmoon(<span class="number">10</span>, fc=np.array([<span class="number">0.6</span>, <span class="number">0.6</span>, <span class="number">0.6</span>]), filename=<span class="string">&quot;fmc_10&quot;</span>, ec=<span class="string">&quot;w&quot;</span>, lw=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><img src="fmc_10.png"><br></p></li><li><p>원 10개로 그리면 이런 달이 떠오릅니다.</p></li></ul><ul><li>원 20개, 50개, 100개로도 그려볼 수 있겠죠.<br><br><img src="fmc_10-100.png"><br></li></ul><ul><li>꼭 추석이 아니더라도 모두들 둥근 달처럼 행복하시기 바랍니다.<br><br><img src="fmc_200.png"><br></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/art/">art</category>
      
      
    </item>
    
    <item>
      <title>PyTorch GPU setting</title>
      <link>https://jehyunlee.github.io/2021/06/06/Python-DL-6-pytorchGPU/</link>
      <guid>https://jehyunlee.github.io/2021/06/06/Python-DL-6-pytorchGPU/</guid>
      <pubDate>Sun, 06 Jun 2021 03:01:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;PyTorch GPU 버전을 설치한다고 GPU를 사용하지 않습니다.&lt;/li&gt;
&lt;li&gt;GPU가 여럿이라면 어떤 GPU가 사용 가능한지 확인하고,&lt;/li&gt;
&lt;li&gt;변수와 모델에 GPU 사용 설정을 해야 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 </description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>PyTorch GPU 버전을 설치한다고 GPU를 사용하지 않습니다.</li><li>GPU가 여럿이라면 어떤 GPU가 사용 가능한지 확인하고,</li><li>변수와 모델에 GPU 사용 설정을 해야 합니다.</li></ul><h1 id="1-PyTorch-버전-확인"><a href="#1-PyTorch-버전-확인" class="headerlink" title="1. PyTorch 버전 확인"></a>1. PyTorch 버전 확인</h1><ul><li>현재 버전을 확인합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch, torchvision</span><br><span class="line"><span class="built_in">print</span>(torch.__version__)</span><br><span class="line"><span class="built_in">print</span>(torchvision.__version__)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.7.1+cu101</span><br><span class="line">0.8.2+cu101</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="2-GPU-현황-확인"><a href="#2-GPU-현황-확인" class="headerlink" title="2. GPU 현황 확인"></a>2. GPU 현황 확인</h1><ul><li>GPU가 사용 가능한지 확인합니다.</li><li>사용 가능하다면, 메모리 점유 현황을 출력합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(torch.cuda.device_count()):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;# DEVICE <span class="subst">&#123;i&#125;</span>: <span class="subst">&#123;torch.cuda.get_device_name(i)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;- Memory Usage:&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  Allocated: <span class="subst">&#123;<span class="built_in">round</span>(torch.cuda.memory_allocated(i)/<span class="number">1024</span>**<span class="number">3</span>,<span class="number">1</span>)&#125;</span> GB&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  Cached:    <span class="subst">&#123;<span class="built_in">round</span>(torch.cuda.memory_cached(i)/<span class="number">1024</span>**<span class="number">3</span>,<span class="number">1</span>)&#125;</span> GB\n&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;# GPU is not available&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DEVICE 0: Tesla V100-PCIE-32GB</span></span><br><span class="line">- Memory Usage:</span><br><span class="line">  Allocated: 0.0 GB</span><br><span class="line">  Cached:    0.0 GB</span><br><span class="line"></span><br><span class="line"><span class="comment"># DEVICE 1: Tesla V100-PCIE-32GB</span></span><br><span class="line">- Memory Usage:</span><br><span class="line">  Allocated: 0.0 GB</span><br><span class="line">  Cached:    0.0 GB</span><br><span class="line"></span><br><span class="line"><span class="comment"># DEVICE 2: Tesla V100-PCIE-32GB</span></span><br><span class="line">- Memory Usage:</span><br><span class="line">  Allocated: 0.0 GB</span><br><span class="line">  Cached:    0.0 GB</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="3-GPU-할당-변경"><a href="#3-GPU-할당-변경" class="headerlink" title="3. GPU 할당 변경"></a>3. GPU 할당 변경</h1><ul><li>작업할 GPU를 선정합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GPU 할당 변경하기</span></span><br><span class="line">GPU_NUM = <span class="number">2</span> <span class="comment"># 원하는 GPU 번호 입력</span></span><br><span class="line">device = torch.device(<span class="string">f&#x27;cuda:<span class="subst">&#123;GPU_NUM&#125;</span>&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line">torch.cuda.set_device(device) <span class="comment"># change allocation of current GPU</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;# Current cuda device: &#x27;</span>, torch.cuda.current_device()) <span class="comment"># check</span></span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Current cuda device:  2</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="4-GPU-사용을-기본값으로-설정"><a href="#4-GPU-사용을-기본값으로-설정" class="headerlink" title="4. GPU 사용을 기본값으로 설정"></a>4. GPU 사용을 기본값으로 설정</h1><ul><li>변수를 만들때 자동으로 GPU를 사용하게 설정합니다.</li><li>앞서 <code>GPU_NUM</code>으로 지정한 GPU에 할당됩니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    torch.set_default_tensor_type(torch.cuda.FloatTensor)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;using cuda: <span class="subst">&#123;GPU_NUM&#125;</span>, <span class="subst">&#123;torch.cuda.get_device_name(GPU_NUM)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using cuda: 2, Tesla V100-PCIE-32GB</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>변수를 만들어 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = torch.FloatTensor([<span class="number">1.0</span>])</span><br><span class="line">x.<span class="built_in">type</span>()</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;torch.FloatTensor&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>GPU 사용을 기본값으로 명시했는데 안올라갑니다.</p></li><li><p>강제로 올려봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = x.cuda()</span><br><span class="line">x.<span class="built_in">type</span>()</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;torch.cuda.FloatTensor&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>그냥 <b><code>torch.Tensor()</code></b>를 해야 GPU에 올라갑니다.</li><li>자료형도 내가 원하는 <code>torch.cuda.FloatTensor</code>입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = torch.Tensor([<span class="number">1.0</span>])</span><br><span class="line">x.<span class="built_in">type</span>()</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;torch.cuda.FloatTensor&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Deep-Learning/">Deep Learning</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/pytorch/">pytorch</category>
      
      <category domain="https://jehyunlee.github.io/tags/GPU/">GPU</category>
      
      
    </item>
    
    <item>
      <title>Keras Code Examples - Image segmentation with a U-Net-like architecture</title>
      <link>https://jehyunlee.github.io/2020/12/24/Python-DL-5_kerasleraningday/</link>
      <guid>https://jehyunlee.github.io/2020/12/24/Python-DL-5_kerasleraningday/</guid>
      <pubDate>Thu, 24 Dec 2020 11:15:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://aifactory.space/kld&quot;&gt;Keras Learning Day&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.codestates.com/&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><a href="http://aifactory.space/kld">Keras Learning Day</a></p></blockquote><ul><li><a href="https://www.codestates.com/">AI Factory</a>에서 진행한 <b>케라스 러닝 데이</b> 발표입니다.</li><li>2020.12.23 발표영상입니다.  </li><li>Xception 논문의 저자이자 Keras의 창시자인 프랑스와 숄레님의 코드입니다.</li><li>제목에는 U-Net이라는 이름이 있지만 내용은 Xception입니다.</li><li>다만, classification이 아니라 segmentation을 합니다.</li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/3oFR7ajzAZs" frameborder="0" loading="lazy" allowfullscreen></iframe></div><ul><li>Xception 논문에 대한 설명을 위해 Inception, Batch Normalization을 같이 보았습니다.</li><li>miniature model을 만들어 layer별로 feature map을 그려봤습니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Deep-Learning/">Deep Learning</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/keras-learing-day/">keras learing day</category>
      
      <category domain="https://jehyunlee.github.io/tags/xception/">xception</category>
      
      <category domain="https://jehyunlee.github.io/tags/segmentation/">segmentation</category>
      
      
    </item>
    
    <item>
      <title>keras BatchNormalization</title>
      <link>https://jehyunlee.github.io/2020/12/01/Python-DL-4-bn/</link>
      <guid>https://jehyunlee.github.io/2020/12/01/Python-DL-4-bn/</guid>
      <pubDate>Tue, 01 Dec 2020 13:21:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;b&gt;Contributors&lt;/b&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hihunjin&quot;&gt;하헌진&lt;/a&gt;님, 흑염룡님, 머린이왕자님&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;CNN에서 bat</description>
        
      
      
      
      <content:encoded><![CDATA[<p><b>Contributors</b></p><blockquote><p><a href="https://github.com/hihunjin">하헌진</a>님, 흑염룡님, 머린이왕자님</p></blockquote><ul><li>CNN에서 batch normalization은 Convolution layer를 따라다닙니다.</li><li>배치 정규화<code>batch normalization</code>는 그레이디언트 소실<code>gradient vanishing</code>과 폭주<code>exploding</code> 문제를 해결하기 위해 제안되었습니다.</li><li>본 글에서는 배치 정규화의 이론적 내용을 다루지 않습니다.</li><li>tensorflow에 탑재된 keras의 <code>BatchNormalization()</code>이 어떤 결과를 만들어내는지에 집중합니다.</li></ul><blockquote><p><a href="https://arxiv.org/abs/1502.03167">Sergey Ioffe, Christian Szegedy, “Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift”, ICML2015</a><br><a href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/BatchNormalization">tf.keras.layers.BatchNormalization</a></p></blockquote><h3 id="1-예제-데이터-가져오기"><a href="#1-예제-데이터-가져오기" class="headerlink" title="1. 예제 데이터 가져오기"></a>1. 예제 데이터 가져오기</h3><ul><li>실제 상황에서는 많은 이미지를 학습시키겠지만, 3장으로 테스트해봅니다.</li><li>입력 이미지와 히스토그램의 분포 변화를 그려봅니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">img0 = plt.imread(<span class="string">&quot;./4-bn_0.jpg&quot;</span>)</span><br><span class="line">img1 = plt.imread(<span class="string">&quot;./4-bn_1.jpg&quot;</span>)</span><br><span class="line">img2 = plt.imread(<span class="string">&quot;./4-bn_2.jpg&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li>불러온 이미지를 numpy vector로 만들어 줍니다.</li><li>하나의 numpy array에 이미지를 모두 탑재합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">imgs = np.zeros((<span class="number">3</span>, ) + img0.shape)</span><br><span class="line">imgs[<span class="number">0</span>] = img0/<span class="number">255.0</span></span><br><span class="line">imgs[<span class="number">1</span>] = img1/<span class="number">255.0</span></span><br><span class="line">imgs[<span class="number">2</span>] = img2/<span class="number">255.0</span></span><br><span class="line"><span class="built_in">print</span>(img0.shape)</span><br></pre></td></tr></table></figure><ul><li>실행결과 : 256 x 256 크기의 3 channel image입니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(256, 256, 3)</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>이미지를 눈으로 확인합니다.</li><li>앞으로 자주 사용할 기능이니 figure를 리턴하는 함수로 만듭니다.</li><li>연산을 거친 이미지가 <b>그림으로 출력되기 어려운 범위로 환산될 것을 대비</b>하여 이미지 minmax scaling을 미리 수행합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_img</span>(<span class="params">imgs</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 이미지 minmax scaling</span></span><br><span class="line">    <span class="keyword">if</span> imgs.<span class="built_in">min</span>() &lt; <span class="number">0</span>:</span><br><span class="line">        imgs = imgs - imgs.<span class="built_in">min</span>()</span><br><span class="line">    <span class="keyword">if</span> imgs.<span class="built_in">max</span>() &gt; <span class="number">1</span>:</span><br><span class="line">        imgs = imgs/imgs.<span class="built_in">max</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 시각화</span></span><br><span class="line">    fig, axs = plt.subplots(ncols=<span class="built_in">len</span>(imgs), figsize=(<span class="number">3</span>*<span class="built_in">len</span>(imgs), <span class="number">3</span>))</span><br><span class="line">    <span class="keyword">for</span> img, ax <span class="keyword">in</span> <span class="built_in">zip</span>(imgs, axs):</span><br><span class="line">        ax.imshow(img)</span><br><span class="line"></span><br><span class="line">    fig.tight_layout()    </span><br><span class="line">    <span class="keyword">return</span> fig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 데이터 시각화</span></span><br><span class="line">fig = plot_img(imgs)</span><br></pre></td></tr></table></figure><img src="4-bn_3.png"><br></li></ul><h3 id="2-데이터-분포-확인하기"><a href="#2-데이터-분포-확인하기" class="headerlink" title="2. 데이터 분포 확인하기"></a>2. 데이터 분포 확인하기</h3><ul><li>데이터의 분포를 그림으로 그려서 확인합니다.</li><li>컬러 이미지이므로 <b>R, G, B</b> 세 개의 채널이 있습니다.</li><li>세 채널을 각기 <b>빨강, 녹색, 파랑</b>의 밀도함수로 표현합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_kde</span>(<span class="params">imgs, symmetry=<span class="literal">False</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 시각화</span></span><br><span class="line">    fig, axs = plt.subplots(ncols=<span class="built_in">len</span>(imgs), figsize=(<span class="number">3</span>*<span class="built_in">len</span>(imgs), <span class="number">3</span>), sharex=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> img, ax <span class="keyword">in</span> <span class="built_in">zip</span>(imgs, axs):</span><br><span class="line">        channel = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">        color = [<span class="string">&quot;r&quot;</span>, <span class="string">&quot;g&quot;</span>, <span class="string">&quot;b&quot;</span>]</span><br><span class="line">        <span class="comment"># R, G, B 채널 분포 시각화. </span></span><br><span class="line">        <span class="comment"># 오해가 발생하지 않도록 실제 데이터 범위에만 분포 시각화</span></span><br><span class="line">        [sns.kdeplot(img[:,:,ch].flatten(), color=c, fill=<span class="literal">True</span>, ax=ax, cut=<span class="number">0</span>) <span class="keyword">for</span> ch, c <span class="keyword">in</span> <span class="built_in">zip</span>(channel, color)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># x축 범위 설정. </span></span><br><span class="line">    <span class="comment"># 필요시 x축을 0 중심으로 대칭이 되도록 설정할 수 있도록.</span></span><br><span class="line">    xlim = ax.get_xlim()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> symmetry==<span class="literal">True</span>:</span><br><span class="line">        xlim = [-<span class="built_in">max</span>(<span class="built_in">abs</span>(xlim)), <span class="built_in">max</span>(<span class="built_in">abs</span>(xlim))]</span><br><span class="line">        axs[<span class="number">0</span>].set_xlim(xlim)</span><br><span class="line">    </span><br><span class="line">    fig.tight_layout()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 나중에 분포를 겹쳐 그리기 위해 fig 외에도 axes를 함께 리턴합니다.</span></span><br><span class="line">    <span class="keyword">return</span> fig, axs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 데이터 분포 시각화</span></span><br><span class="line">fig, axs = plot_kde(imgs)</span><br></pre></td></tr></table></figure><img src="4-bn_4.png"><br></li></ul><h3 id="3-Batch-Normalization-적용-1-직접"><a href="#3-Batch-Normalization-적용-1-직접" class="headerlink" title="3. Batch Normalization 적용 (1) 직접"></a>3. Batch Normalization 적용 (1) 직접</h3><ul><li><a href="https://jehyunlee.github.io/2020/11/29/Python-DL-1-conv2d/">앞선 글</a>에서 Conv2D만 따로 적용했습니다.</li><li>이번에도 학습과정 없이 <code>BatchNormalization()</code>만 적용해 보겠습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">imgs_tensor = tf.convert_to_tensor(imgs, dtype=<span class="string">&quot;float32&quot;</span>)</span><br><span class="line">bn0 = layers.BatchNormalization(trainable=<span class="literal">True</span>)(imgs_tensor)</span><br><span class="line">bn0_numpy = bn0.numpy()</span><br><span class="line"></span><br><span class="line">fig1 = plot_img(bn0_numpy)</span><br><span class="line">fig2, _ = plot_kde(bn0_numpy)</span><br></pre></td></tr></table></figure><img src="4-bn_5.png"><br><img src="4-bn_6.png"><br></li></ul><ul><li>바뀐 것이 없습니다.</li><li>Batch Normalization은 Conv2D와 달리 <b>학습 과정에서 데이터의 분포를 파악하여 적용</b>하도록 설계되어 있기 때문에 이런 방식으로는 작동하지 않습니다.</li></ul><h3 id="4-Batch-Normalization-적용-2-학습"><a href="#4-Batch-Normalization-적용-2-학습" class="headerlink" title="4. Batch Normalization 적용 (2) 학습"></a>4. Batch Normalization 적용 (2) 학습</h3><ul><li>학습을 위한 최소한의 모델을 만듭니다.</li><li>BatchNormalization 레이어 외에는 아무것도 없습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"></span><br><span class="line">model = Sequential([</span><br><span class="line">    layers.BatchNormalization()</span><br><span class="line">])</span><br><span class="line">model.<span class="built_in">compile</span>()</span><br></pre></td></tr></table></figure></li></ul><ul><li>모델에 데이터를 투입하여 학습을 시킵니다.</li><li>이 때, numpy array를 텐서로 변환하여 입력해야 합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bn1 = model(imgs_tensor, training=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li>잘 적용되었을까요? 확인합시다.</li><li>다시 numpy array로 바꾸어서 이미지와 분포를 그려봅니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bn1_numpy = bn1.numpy()</span><br><span class="line"></span><br><span class="line">fig1 = plot_img(bn1_numpy)</span><br><span class="line">fig2, _ = plot_kde(bn1_numpy)</span><br></pre></td></tr></table></figure><img src="4-bn_7.png"><br><img src="4-bn_8.png"><br></li></ul><ul><li><p>Batch Normalization 이전과 이후를 나란히 놓아봅시다.<br><br><img src="4-bn_13.png" alt="Batch Normalization 이전과 이후 비교"><br></p></li><li><p><b>원본에 비해 색이 흐려진 것</b>이 느껴집니다.</p></li><li><p>이미지는 데이터를 그림으로 표현하기 위해 minmax scaling이 된 것입니다.</p></li></ul><ul><li>실제 데이터의 분포는 아래에 있는 밀도함수를 통해 알 수 있습니다.</li><li>원본에서 0<del>1 사이에 있던 값의 분포가 -2</del>2 사이로 변환되었습니다.</li><li><b>RGB 채널이 각기 독립적으로 normalization</b> 되었습니다.</li></ul><p><b>※ CNN에서 Batch Normalization은 대개 Convolution layer와 activation layer 사이에 위치합니다</b></p><ul><li>Convolution을 거친 이미지는 Batch Normalization에 의해 고르게 분포됩니다.</li><li>잘못된 초기화로 인해 학습이 어려워지는 문제를 해결할 수 있습니다.</li><li>결과적으로 <b>학습이 안정적으로 빠르게 이루어집니다.</b><br></li></ul><p><b>※(추가) 위 그림이 BN효과를 오해할 소지가 있다고 생각되어 수정했습니다.</b></p><ul><li>자세한 고민은 다음 글을 읽어보세요: <a href="https://jehyunlee.github.io/2020/12/03/Python-DS-46-bnvis/">Visualization of Image Exceeding Limitation</a></li><li>기록 차원에서 본 글의 미리보기는 수정하지 않았습니다.<br><br><img src="46-bnvis_10.png"><br></li></ul><h3 id="4-보너스-toy-model"><a href="#4-보너스-toy-model" class="headerlink" title="4. 보너스 - toy model"></a>4. 보너스 - toy model</h3><ul><li>Batch Normalization은 <b>데이터의 평균을 0, 분산을 1로 조정합니다.</b></li><li>간단한 예제 데이터를 통해서 정말 그런지 살펴봅니다.</li><li>numpy array 형태의 예제 데이터를 만듭니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 예제 데이터 생성</span></span><br><span class="line">ex_img0 = np.random.normal(loc=-<span class="number">0.5</span>, scale=<span class="number">0.01</span>, size=<span class="number">256</span>*<span class="number">256</span>*<span class="number">3</span>).reshape((<span class="number">256</span>, <span class="number">256</span>, <span class="number">3</span>))</span><br><span class="line">ex_img1 = np.random.normal(loc=<span class="number">0.5</span>, scale=<span class="number">0.01</span>, size=<span class="number">256</span>*<span class="number">256</span>*<span class="number">3</span>).reshape((<span class="number">256</span>, <span class="number">256</span>, <span class="number">3</span>))</span><br><span class="line">ex_img2 = np.random.normal(loc=-<span class="number">0.5</span>, scale=<span class="number">0.01</span>, size=<span class="number">256</span>*<span class="number">256</span>*<span class="number">3</span>).reshape((<span class="number">256</span>, <span class="number">256</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 예제 데이터 vectorization</span></span><br><span class="line">ex_imgs = np.zeros((<span class="number">3</span>, ) + ex_img0.shape)</span><br><span class="line">ex_imgs[<span class="number">0</span>] = ex_img0</span><br><span class="line">ex_imgs[<span class="number">1</span>] = ex_img1</span><br><span class="line">ex_imgs[<span class="number">2</span>] = ex_img2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 데이터 시각화</span></span><br><span class="line">fig1 = plot_img(ex_imgs)</span><br><span class="line">fig2, _ = plot_kde(ex_imgs)</span><br></pre></td></tr></table></figure><img src="4-bn_9.png"><br><img src="4-bn_10.png"><br></li></ul><ul><li>평균이 각기 -0.5, 0.5, -0.5이고 표준편차가 0.01인 데이터가 만들어졌습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(ex_img0.var())</span><br></pre></td></tr></table></figure><ul><li>실행결과 : 분산이 0.0001, 즉 표준편차는 0.01 맞습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.00010004582097558264</span><br></pre></td></tr></table></figure></li></ul></li><li>Batch Normalization을 적용합니다.</li><li>데이터를 텐서로 만들어 적용하고, 시각화를 위해 다시 numpy로 변환합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ex_imgs_tensor = tf.convert_to_tensor(ex_imgs, dtype=<span class="string">&quot;float32&quot;</span>)</span><br><span class="line">ex_bn1 = model(ex_imgs_tensor, training=<span class="literal">True</span>)</span><br><span class="line">ex_bn1_numpy = ex_bn1.numpy()</span><br></pre></td></tr></table></figure></li></ul><ul><li>변환 결과를 그림으로 확인합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> patches</span><br><span class="line"></span><br><span class="line">fig1 = plot_img(ex_bn1_numpy)</span><br><span class="line"></span><br><span class="line">fig2, axs = plot_kde(ex_bn1_numpy, symmetry=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> ax, ex_img <span class="keyword">in</span> <span class="built_in">zip</span>(axs, ex_imgs):</span><br><span class="line">    sns.kdeplot(ex_img.flatten(), ax=ax, color=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line"></span><br><span class="line">Rectangle0 = patches.Rectangle((<span class="number">0.45</span>, <span class="number">0.9</span>), <span class="number">0.12</span>, <span class="number">0.05</span>, color=<span class="string">&quot;lightgray&quot;</span>, transform=axs[<span class="number">0</span>].transAxes)</span><br><span class="line">axs[<span class="number">0</span>].add_patch(Rectangle0)</span><br><span class="line">axs[<span class="number">0</span>].text(<span class="number">0.6</span>, <span class="number">0.9</span>, <span class="string">&quot;before BN&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">12</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;k&quot;</span>&#125;, transform=axs[<span class="number">0</span>].transAxes)</span><br><span class="line">Rectangle1 = patches.Rectangle((<span class="number">0.45</span>, <span class="number">0.8</span>), <span class="number">0.12</span>, <span class="number">0.05</span>, color=<span class="string">&quot;navy&quot;</span>, transform=axs[<span class="number">0</span>].transAxes)</span><br><span class="line">axs[<span class="number">0</span>].add_patch(Rectangle1)</span><br><span class="line">axs[<span class="number">0</span>].text(<span class="number">0.6</span>, <span class="number">0.8</span>, <span class="string">&quot;after BN&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">12</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;k&quot;</span>&#125;, transform=axs[<span class="number">0</span>].transAxes)</span><br></pre></td></tr></table></figure><img src="4-bn_11.png"><br><img src="4-bn_12.png"><br></li></ul><ul><li>그림으로 봐서는 모르겠습니다. minmax scaling이 적용되었기 때문입니다.</li><li>그러나 분포를 보면, -0.5와 0.5에 분포했던 데이터가 각기 -1과 1 방향으로 이동한 것을 알 수 있습니다.</li><li>정확한 값을 추측해봅시다.<ul><li>-0.5, 0.5, -0.5의 평균은 $$\frac{-1}{6}$$, 표준편차는 $$\frac{\sqrt{2}}{3}$$입니다.</li><li>따라서 -0.5, 0.5, -0.5의 Batch Normalization 결과는 $$\frac{-1}{\sqrt{2}}, \frac{2}{\sqrt{2}}, \frac{-1}{\sqrt{2}}$$가 될 것입니다.</li><li>정말 그런지 확인해봅시다.</li></ul></li></ul><ul><li>평균값을 확인합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>([ex_bn1_numpy[i].mean() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)])</span><br></pre></td></tr></table></figure><ul><li>실행결과 : $$\frac{-1}{\sqrt{2}}, \frac{2}{\sqrt{2}}, \frac{-1}{\sqrt{2}}$$입니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-0.7053814, 1.4107242, -0.70534563]</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>mini-batch의 평균과 variance를 구합니다.</li><li>model의 layer에 데이터가 저장되어 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mean = model.layers[<span class="number">0</span>].variables[<span class="number">2</span>].numpy()</span><br><span class="line">var  = model.layers[<span class="number">0</span>].variables[<span class="number">3</span>].numpy()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mean, mean.mean())</span><br><span class="line"><span class="built_in">print</span>(var, var.mean())</span><br></pre></td></tr></table></figure><ul><li>실행결과 : 0에 가까운 평균과 1에 가까운 분산이 출력되었습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0.00435958 0.00288465 0.00303697] 0.0034270668</span><br><span class="line">[0.9828158 0.983015  0.9831719] 0.98300093</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Deep-Learning/">Deep Learning</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/tensorflow/">tensorflow</category>
      
      <category domain="https://jehyunlee.github.io/tags/keras/">keras</category>
      
      <category domain="https://jehyunlee.github.io/tags/batch-normalization/">batch normalization</category>
      
      
    </item>
    
    <item>
      <title>keras Conv2D</title>
      <link>https://jehyunlee.github.io/2020/11/29/Python-DL-1-conv2d/</link>
      <guid>https://jehyunlee.github.io/2020/11/29/Python-DL-1-conv2d/</guid>
      <pubDate>Sat, 28 Nov 2020 20:21:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;Convolution의 기초 명령어 Conv2D 예시입니다.&lt;/li&gt;
&lt;li&gt;딥러닝의 일부로서가 아닌 명령어 자체 기능을 봅니다.&lt;/li&gt;
&lt;li&gt;무엇을 받아서 무엇으로 바꾸는지 살펴봅니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2D-</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>Convolution의 기초 명령어 Conv2D 예시입니다.</li><li>딥러닝의 일부로서가 아닌 명령어 자체 기능을 봅니다.</li><li>무엇을 받아서 무엇으로 바꾸는지 살펴봅니다.</li></ul><h2 id="1-2D-Convolution"><a href="#1-2D-Convolution" class="headerlink" title="1. 2D Convolution"></a>1. 2D Convolution</h2><blockquote><p><a href="https://www.pyimagesearch.com/2018/12/31/keras-conv2d-and-convolutional-layers/">pyimagesearch: Keras Conv2D and Convolutional Layers</a></p></blockquote><ul><li>convolution, 또는 합성곱 연산은 CNN(Convolution Neural Network)이라는 이름으로 접하신 분이 많을테지만 image processing을 비롯한 signal processing에서 사용되어 온 연산 기법입니다.</li></ul><ul><li>다음 두 가지 특징이 있습니다.<ol><li><b>인접 데이터</b>끼리 연산 (localization)</li><li><b>동일 연산</b>을 전체 데이터에 적용 (weight sharing)<br><br><img src="keras_conv2d_padding.gif" alt="convolution 연산 과정. 출처=pyimagesearch"><br></li></ol></li></ul><h2 id="2-Keras의-Conv2D"><a href="#2-Keras의-Conv2D" class="headerlink" title="2. Keras의 Conv2D"></a>2. Keras의 Conv2D</h2><h3 id="2-1-기본-문법"><a href="#2-1-기본-문법" class="headerlink" title="2.1. 기본 문법"></a>2.1. 기본 문법</h3><blockquote><p><a href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/Conv2D">tf.keras.layers.Conv2D</a></p></blockquote><ul><li>공식 홈페이지에 따르면 입출력은 다음과 같습니다.<ul><li><b>입력 형식</b> : 4차원 이상의 텐서.<br><code>data_format=&#39;channel_first&#39;</code>일 때: <b>batch_shape + (channels, rows, cols)</b>,<br><code>data_format=&#39;channel_last&#39;</code>일 때: <b>batch_shape + (rows, cols, channels)</b>,</li><li><b>출력 형식</b> : 4차원 이상의 텐서.<br><code>data_format=&#39;channel_first&#39;</code>일 때: <b>batch_shape + (filters, rows, cols)</b>,<br><code>data_format=&#39;channel_last&#39;</code>일 때: <b>batch_shape + (rows, cols, filters)</b>,</li></ul></li></ul><ul><li>텐서를 받아 텐서를 출력합니다.</li><li>입력의 channel 자리가 출력의 filter 자리로 바뀝니다.</li><li>또한, rows와 columns는 padding, strides 등에 따라 달라질 수 있습니다.</li></ul><ul><li>텐서를 입력으로 받기 때문에 일반 이미지는 텐서로 변환하여 넣어야 합니다.</li></ul><h3 id="2-2-이미지-입력"><a href="#2-2-이미지-입력" class="headerlink" title="2.2. 이미지 입력"></a>2.2. 이미지 입력</h3><ul><li>텐서플로와 케라스의 버전을 확인합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(tf.__version__)</span><br><span class="line"><span class="built_in">print</span>(tf.keras.__version__)</span><br></pre></td></tr></table></figure><ul><li>실행결과: tensorflow v2.3.1, tf.keras v2.4.0 입니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;2.3.1&#x27;</span></span><br><span class="line"><span class="string">&#x27;2.4.0&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>예제 이미지를 읽어옵니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = plt.imread(<span class="string">&quot;./1-conv2d_1.jpg&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(img))</span><br><span class="line"><span class="built_in">print</span>(img.shape)</span><br><span class="line">plt.imshow(img)</span><br></pre></td></tr></table></figure><ul><li>실행결과 : numpy array 형식, 1080 x 1080 3 channel(RGB) 이미지입니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;</span><br><span class="line">(1080, 1080, 3)</span><br></pre></td></tr></table></figure><img src="1-conv2d_6.png"></li></ul></li></ul><h3 id="2-3-Conv2D-적용-1-1-filter"><a href="#2-3-Conv2D-적용-1-1-filter" class="headerlink" title="2.3. Conv2D 적용 (1) 1 filter"></a>2.3. Conv2D 적용 (1) 1 filter</h3><blockquote><p><a href="https://www.tensorflow.org/api_docs/python/tf/convert_to_tensor">tf.convert_to_tensor</a></p></blockquote><ul><li><p>이미지를 텐서로 변환합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img_tf = tf.convert_to_tensor([img], dtype=<span class="string">&quot;float32&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(img_tf))</span><br><span class="line"><span class="built_in">print</span>(img_tf.shape)</span><br><span class="line"><span class="built_in">print</span>(img_tf.dtype)</span><br></pre></td></tr></table></figure><ul><li>실행결과 : numpy array가 EagerTensor로 변환되었습니다.<pre><code>      3차원을 4차원으로 만들어주기 위해 []를 씌웠습니다.</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;class <span class="string">&#x27;tensorflow.python.framework.ops.EagerTensor&#x27;</span>&gt;</span><br><span class="line">(1, 1080, 1080, 3)</span><br><span class="line">&lt;dtype: <span class="string">&#x27;float32&#x27;</span>&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Convolution을 수행합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conv_1 = layers.Conv2D(<span class="number">1</span>, <span class="number">3</span>, padding=<span class="string">&quot;same&quot;</span>)(img_tf)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(conv_1))</span><br><span class="line"><span class="built_in">print</span>(conv_1.shape)</span><br><span class="line"><span class="built_in">print</span>(conv_1.dtype)</span><br></pre></td></tr></table></figure><ul><li>실행결과 : 1 channel EagerTensor가 출력되었습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;class <span class="string">&#x27;tensorflow.python.framework.ops.EagerTensor&#x27;</span>&gt;</span><br><span class="line">(1, 1080, 1080, 1)</span><br><span class="line">&lt;dtype: <span class="string">&#x27;float32&#x27;</span>&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>matplotlib에서 출력하기 위해 다시 numpy로 변환합니다.</p></li><li><p>연산 범위가 0~1을 넘어갈 수 있으므로 normalize 처리를 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conv_1_np = conv_1.numpy()</span><br><span class="line">plt.imshow((conv_1_np[<span class="number">0</span>]-conv_1_np[<span class="number">0</span>].<span class="built_in">min</span>())/(conv_1_np[<span class="number">0</span>].<span class="built_in">max</span>()-conv_1_np[<span class="number">0</span>].<span class="built_in">min</span>()), cmap=<span class="string">&quot;gist_gray&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행결과 : convolution이 적용되어 그림 모양이 바뀌었습니다.<br><img src="1-conv2d_2.png"></li></ul></li><li><p>그림이 어떻게 바뀔지는 예측할 수 없습니다.</p></li><li><p><code>kernel_initializer</code> 기본값이 <code>glorot_uniform</code>으로, 랜덤이기 때문입니다.</p></li></ul><h3 id="2-3-Conv2D-적용-2-1-filter-x-8회"><a href="#2-3-Conv2D-적용-2-1-filter-x-8회" class="headerlink" title="2.3. Conv2D 적용 (2) 1 filter x 8회"></a>2.3. Conv2D 적용 (2) 1 filter x 8회</h3><ul><li>랜덤한 커널의 영향을 확인해 보겠습니다.</li><li>Conv2D를 반복해서 실행하며 결과가 바뀌는지 확인합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(ncols=<span class="number">4</span>, nrows=<span class="number">2</span>, figsize=(<span class="number">13</span>, <span class="number">6</span>))</span><br><span class="line">axs = axes.ravel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, ax <span class="keyword">in</span> <span class="built_in">enumerate</span>(axs):</span><br><span class="line">    conv_1 = layers.Conv2D(<span class="number">1</span>, <span class="number">3</span>, padding=<span class="string">&quot;same&quot;</span>)(img_tf)</span><br><span class="line">    conv_1_np = conv_1.numpy()</span><br><span class="line">    ax.imshow(conv_1_np[<span class="number">0</span>], cmap=<span class="string">&quot;gist_gray&quot;</span>)</span><br><span class="line">    ax.set_title(<span class="string">f&quot;try <span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><ul><li>실행결과 : 실행할때마다 다른 그림이 나옵니다.<br><img src="1-conv2d_3.png"></li></ul></li></ul><h3 id="2-3-Conv2D-적용-3-16-filter"><a href="#2-3-Conv2D-적용-3-16-filter" class="headerlink" title="2.3. Conv2D 적용 (3) 16 filter"></a>2.3. Conv2D 적용 (3) 16 filter</h3><ul><li>필터의 수를 지정하면 반복된 결과물이 channel로 쌓입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conv_16 = layers.Conv2D(<span class="number">16</span>, <span class="number">3</span>, padding=<span class="string">&quot;same&quot;</span>)(img_tf)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(conv_16))</span><br><span class="line"><span class="built_in">print</span>(conv_16.shape)</span><br><span class="line"><span class="built_in">print</span>(conv_16.dtype)</span><br></pre></td></tr></table></figure><ul><li>실행결과 : 16 channel이 출력됩니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;class <span class="string">&#x27;tensorflow.python.framework.ops.EagerTensor&#x27;</span>&gt;</span><br><span class="line">(1, 1080, 1080, 16)</span><br><span class="line">&lt;dtype: <span class="string">&#x27;float32&#x27;</span>&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>각각의 채널을 출력합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">conv_16_np = conv_16.numpy()</span><br><span class="line">conv_16_norm = (conv_16_np[<span class="number">0</span>]-conv_16_np.<span class="built_in">min</span>())/(conv_16_np.<span class="built_in">max</span>()-conv_16_np.<span class="built_in">min</span>())</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(ncols=<span class="number">4</span>, nrows=<span class="number">4</span>, figsize=(<span class="number">13</span>, <span class="number">13</span>))</span><br><span class="line">axs = axes.ravel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, ax <span class="keyword">in</span> <span class="built_in">enumerate</span>(axs):</span><br><span class="line">    ax.imshow(conv_16_norm[:,:,i], cmap=<span class="string">&quot;gist_gray&quot;</span>)</span><br><span class="line">    ax.set_title(<span class="string">f&quot;Channel <span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><ul><li>실행결과 : 랜덤 커널 적용 결과 16개가 나왔습니다.<br><img src="1-conv2d_5.png"></li></ul></li><li>CNN 학습은 커널의 가중치를 목적에 맞도록 조정하는 과정입니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Deep-Learning/">Deep Learning</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/tensorflow/">tensorflow</category>
      
      <category domain="https://jehyunlee.github.io/tags/keras/">keras</category>
      
      <category domain="https://jehyunlee.github.io/tags/convolution/">convolution</category>
      
      
    </item>
    
    <item>
      <title>Since PyCon, 세상 밖으로</title>
      <link>https://jehyunlee.github.io/2020/11/12/Python-General-8-PyCon2020/</link>
      <guid>https://jehyunlee.github.io/2020/11/12/Python-General-8-PyCon2020/</guid>
      <pubDate>Thu, 12 Nov 2020 07:57:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;PyCon Korea 2020 에서 발표한 라이트닝토크 &lt;b&gt;“Since PyCon, 세상 밖으로”&lt;/b&gt; 영상입니다.&lt;/li&gt;
&lt;li&gt;PyCon Korea 2019에 참여한 이후 제 삶의 변화를 정리한 내용입니다.&lt;/li&gt;
&lt;li&gt;제</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>PyCon Korea 2020 에서 발표한 라이트닝토크 <b>“Since PyCon, 세상 밖으로”</b> 영상입니다.</li><li>PyCon Korea 2019에 참여한 이후 제 삶의 변화를 정리한 내용입니다.</li><li>제가 2019년에 다른 분들의 발표를 보고 큰 용기와 자극을 얻었듯 누군가에게 보탬이 되기를 바라며 올립니다.</li></ul><blockquote><p><a href="https://www.youtube.com/c/PyConKRtube">PyCon Korea 2020 발표 영상 모음</a></p></blockquote><ul><li>제 발표는 9분 28초부터 시작합니다 (<a href="https://youtu.be/s8yBnEcOYN8?t=568">Link</a>)<br></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/s8yBnEcOYN8" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/pycon/">pycon</category>
      
      
    </item>
    
    <item>
      <title>Automatic .gitignore generation</title>
      <link>https://jehyunlee.github.io/2020/11/07/Python-General-7-make_gitignore/</link>
      <guid>https://jehyunlee.github.io/2020/11/07/Python-General-7-make_gitignore/</guid>
      <pubDate>Sat, 07 Nov 2020 10:32:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.github.com/en/free-pro-team@latest/github/using-git/ignoring-files&quot;&gt;GitHub Docs: Ignoring files&lt;/a&gt;&lt;/p</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><a href="https://docs.github.com/en/free-pro-team@latest/github/using-git/ignoring-files">GitHub Docs: Ignoring files</a></p></blockquote><ul><li><b>.gitignore</b> 파일은 git add 할때 <b>이 파일들은 빼놓고 하라</b>는 뜻입니다.</li><li>보안상 민감한 파일일 수도 있고 github 용량제한을 넘어서는 대용량 파일일 수도 있습니다.</li><li>한참 일을 하다보니 발생한 대용량 파일을 잊고 커밋했다가 문제가 되었습니다.</li><li>이를 방지하고자 .gitignore 파일을 자동으로 생성하는 간단한 프로그램을 만들었습니다.</li></ul><h2 id="1-gitignore-파일-구조"><a href="#1-gitignore-파일-구조" class="headerlink" title="1. .gitignore 파일 구조"></a>1. .gitignore 파일 구조</h2><blockquote><p><a href="https://github.com/github/gitignore">github/gitignore</a></p></blockquote><ul><li><p>.gitignore는 아주 간단한 구조를 가지고 있습니다.</p></li><li><p>add하지 않을 파일의 목록을 상대경로로 적어주기만 하면 됩니다.</p></li><li><p>제 .gitignore 파일의 일부입니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data_ml/X_train_full.pkl</span><br><span class="line">data_ml/X3_test_full.pkl</span><br><span class="line">data_ml/X3_train_full.pkl</span><br><span class="line">data_ml/X3_full_poolconv.pkl</span><br></pre></td></tr></table></figure></li><li><p><a href="https://github.com/github/gitignore">더 좋은 구조를 갖춘 .gitignore 파일의 예시</a>를 모아둔 곳도 있습니다</p></li><li><p><a href="https://www.vim.org/">vim</a> 같은 텍스트 편집기로 열어서 항목을 추가하면 됩니다.</p></li></ul><h2 id="2-gitignore-파일-자동-생성-프로그램-제작"><a href="#2-gitignore-파일-자동-생성-프로그램-제작" class="headerlink" title="2. .gitignore 파일 자동 생성 프로그램 제작"></a>2. .gitignore 파일 자동 생성 프로그램 제작</h2><ul><li>용량이 50 MB를 넘어서는 파일을 자동으로 모아 <b>자동으로 .gitignore를 만들어 봅시다.</b></li><li>파일 생성이 귀찮은게 저만은 아니었는지, 이런 일을 하는 프로그램이 종종 보입니다.</li></ul><h3 id="2-1-파이썬-프로그램-제작"><a href="#2-1-파이썬-프로그램-제작" class="headerlink" title="2-1. 파이썬 프로그램 제작"></a>2-1. 파이썬 프로그램 제작</h3><ul><li>다음과 같이 짧은 프로그램을 만듭니다.</li><li><b>make_gitignore.py</b>라는 이름으로 저장했습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">files_50m = <span class="string">&quot;50m.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. find files larger than 50M</span></span><br><span class="line">cmd_50m = <span class="string">f&quot;find -size +50000k &gt; <span class="subst">&#123;files_50m&#125;</span>&quot;</span></span><br><span class="line">os.system(cmd_50m)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. edit lines and save</span></span><br><span class="line">items = []</span><br><span class="line">line = <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(files_50m, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> rf:</span><br><span class="line">    wf = <span class="built_in">open</span>(<span class="string">&quot;.gitignore&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(line):</span><br><span class="line">        line = rf.readline()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;.git&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> line.split(<span class="string">&quot;/&quot;</span>):</span><br><span class="line">            add_item = line.lstrip(<span class="string">&quot;./&quot;</span>)</span><br><span class="line">            items.append(add_item)</span><br><span class="line">            wf.write(add_item)</span><br><span class="line">    wf.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. verification</span></span><br><span class="line">[<span class="built_in">print</span>(item.rstrip(<span class="string">&quot;\n&quot;</span>)) <span class="keyword">for</span> item <span class="keyword">in</span> items]</span><br></pre></td></tr></table></figure></li></ul><ul><li>코드는 이런 작업을 합니다.<ol><li>50MB를 넘는 <b>파일 명단</b> 작성 (50m.txt)</li><li>파일을 열어서 한 줄 한 줄 보면서<br>2-1. <b>.git</b>이 포함된 파일은 무시하고<br>2-2. 상대경로 처음 부분 <b>./ 삭제</b><br>2-3. 바뀐 내용을 <b>.gitignore 파일에 저장</b></li><li><b>목록을 출력</b>합니다.</li></ol></li></ul><h3 id="2-2-alias-설정"><a href="#2-2-alias-설정" class="headerlink" title="2-2. alias 설정"></a>2-2. alias 설정</h3><ul><li>파이썬 프로그램을 만들었지만 이걸 실행하려고 <code>python make_gitignore.py</code>를 입력하기 번거롭습니다.</li><li>그냥 <code>mg</code>만 입력하면 되게 하고 싶네요.</li><li><b>.bashrc</b> 파일을 열고 한 줄 적어줍니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> mg=<span class="string">&#x27;python /workplace/utils/make_gitignore/make_gitignore.py&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>위 줄에서 <code>/workplace/utils/make_gitignore/</code>는 제가 파일을 저장한 경로입니다.</li><li>각자 자기 설정에 맞게 변경하시면 됩니다.</li></ul><h3 id="2-3-환경설정-적용"><a href="#2-3-환경설정-적용" class="headerlink" title="2-3. 환경설정 적용"></a>2-3. 환경설정 적용</h3><ul><li><code>source ~/.bashrc</code>를 해서 바뀐 설정을 적용합니다.</li></ul><h2 id="3-실행"><a href="#3-실행" class="headerlink" title="3. 실행"></a>3. 실행</h2><ul><li>이제 작업공간으로 가서 커밋하기 전에 명령어를 한 줄 실행합니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mg</span><br></pre></td></tr></table></figure><img src="7_mg_1.png"><br></li></ul><ul><li>git <b>add</b>, <b>commit</b>에 이어 <b>push</b>도 해봅니다.<br><br><img src="7_mg_2.png"></li></ul><ul><li>잘 됩니다.</li></ul><p><div style="text-align:center; margin:20px 0px 20px 0px">  <a href="https://donaricano.com/mypage/1543013959_CGtZmr" target="_blank">    <img     src="https://d1u4yishnma8v5.cloudfront.net/donarincano_gift.png"     alt="도움이 되셨나요? 카페인을 투입하시면 다음 포스팅으로 변환됩니다"     style="height:70px !important;width: 200px !important;"     /> </a></div>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/automation/">automation</category>
      
      <category domain="https://jehyunlee.github.io/tags/github/">github</category>
      
      <category domain="https://jehyunlee.github.io/tags/gitignore/">gitignore</category>
      
      
    </item>
    
    <item>
      <title>Google Trend Visualization</title>
      <link>https://jehyunlee.github.io/2020/10/25/Python-DS-40-googletrend/</link>
      <guid>https://jehyunlee.github.io/2020/10/25/Python-DS-40-googletrend/</guid>
      <pubDate>Sun, 25 Oct 2020 12:03:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;Google trend 분석 결과는 그 자체로 깔끔합니다.&lt;/li&gt;
&lt;li&gt;그러나 여러 항목을 개별적으로 분석하려면 데이터를 다운받아 분석하는 것이 좋습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-Google-Trends&quot;&gt;&lt;a hre</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>Google trend 분석 결과는 그 자체로 깔끔합니다.</li><li>그러나 여러 항목을 개별적으로 분석하려면 데이터를 다운받아 분석하는 것이 좋습니다.</li></ul><h3 id="1-Google-Trends"><a href="#1-Google-Trends" class="headerlink" title="1. Google Trends"></a>1. Google Trends</h3><blockquote><p><a href="https://trends.google.com/">Google trends</a></p></blockquote><ul><li>Google trends는 검색어를 입력하는 것 만으로 웹, 이미지, 또는 유튜브에서 해당 검색어가 얼마나 빈번하게 등장하는지 경향을 쉽게 알 수 있습니다.</li><li>절대값이 아니라 검색된 기간 내의 최대값을 100으로 표준화해서 보여준다는 점이 조금 아쉽기는 하지만 정성적인 경향 변화를 보기에 적절합니다.<br><br><img src="40_gt_1.png"></li></ul><ul><li><p>지난 10년간 인공지능 관련 키워드의 경향을 알아봤습니다.</p><ul><li>날짜에 Custom Range를 지정해서 넣고,</li><li>검색어에 artificial intelligence, big data 등 단어를 넣습니다.</li><li>오른쪽 위 다운로드 버튼을 누르면 .csv 파일 형식으로 다운로드 됩니다.</li></ul></li><li><p>파일을 열어보면 구조가 간단합니다.</p></li><li><p>시간에 따른 검색 빈도가 표준화되어 나타납니다.<br><br><img src="40_gt_5.png"></p></li></ul><ul><li>csv 다운로드시 파일명을 지정할 수 없습니다.</li><li>여러 검색어를 다운받으며 적절히 파일명을 바꿔줍니다.</li></ul><h3 id="2-Python에서-여러-데이터-비교하기"><a href="#2-Python에서-여러-데이터-비교하기" class="headerlink" title="2. Python에서 여러 데이터 비교하기"></a>2. Python에서 여러 데이터 비교하기</h3><ul><li>각자 다른 값이 최대값 100으로 표준화되어 있습니다.</li><li>따라서 이들을 겹쳐 그리는 것은 무의미한 교차점들을 만들기 때문에 적절치 않습니다.</li><li>여러 개의 공간을 만들고 별도로 그려줍니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Google Trends 파일명</span></span><br><span class="line">files = [<span class="string">&#x27;ai_time.csv&#x27;</span>, <span class="string">&#x27;bigdata_time.csv&#x27;</span>, <span class="string">&#x27;da_time.csv&#x27;</span>, <span class="string">&#x27;de_time.csv&#x27;</span>, <span class="string">&#x27;dl_time.csv&#x27;</span>, <span class="string">&#x27;ds_time.csv&#x27;</span>]</span><br><span class="line">nfiles = <span class="built_in">len</span>(files)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 시각화</span></span><br><span class="line">fig, axes = plt.subplots(ncols=<span class="number">2</span>, nrows=<span class="number">3</span>, figsize=(<span class="number">11</span>, <span class="number">5</span>), </span><br><span class="line">                        sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line">axs = axes.ravel()</span><br><span class="line"></span><br><span class="line">dfs = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, (ax, file) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(axs, files)):</span><br><span class="line">    dfs[file] = pd.read_csv(os.path.join(path, file), skiprows=<span class="number">2</span>)</span><br><span class="line">    dfs[file][<span class="string">&quot;year&quot;</span>] = dfs[file][<span class="string">&quot;Month&quot;</span>].apply(<span class="keyword">lambda</span> s: s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>])</span><br><span class="line">    cols = dfs[file].columns</span><br><span class="line">    cols_clear = cols[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    dfs[file].rename(columns=&#123;cols[<span class="number">1</span>]: cols_clear&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line">    region = cols[<span class="number">1</span>].split(<span class="string">&quot;: &quot;</span>)[<span class="number">1</span>][<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    df_idx = dfs[file].reset_index().groupby(<span class="string">&quot;year&quot;</span>).nth(<span class="number">0</span>)[<span class="string">&quot;index&quot;</span>].values</span><br><span class="line">    </span><br><span class="line">    ax.fill_between(dfs[file].index, <span class="number">0</span>, dfs[file][cols_clear], color=<span class="string">f&quot;C<span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">    ax.annotate(cols_clear, (dfs[file].shape[<span class="number">0</span>]-<span class="number">3</span>, <span class="number">10</span>), ha=<span class="string">&quot;right&quot;</span>, color=<span class="string">&quot;w&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.set_xlim(<span class="number">0</span>, dfs[file].shape[<span class="number">0</span>]-<span class="number">1</span>)</span><br><span class="line">    ax.set_ylim(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">    ax.set_yticks([])</span><br><span class="line">    ax.grid()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">3</span>:</span><br><span class="line">        ax.set_xticks(df_idx[::<span class="number">2</span>][<span class="number">1</span>:])</span><br><span class="line">        ax.set_xticklabels(dfs[file][<span class="string">&quot;year&quot;</span>].loc[df_idx].values[::<span class="number">2</span>][<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">axs[<span class="number">5</span>].text(dfs[file].shape[<span class="number">0</span>]-<span class="number">3</span>, -<span class="number">70</span>, <span class="string">&quot;*max. of each plot is scaled to 100&quot;</span>, </span><br><span class="line">            ha=<span class="string">&quot;right&quot;</span>, c=<span class="string">&quot;gray&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">fig.suptitle(<span class="string">&quot;Google Trends$^*$:&quot;</span> + <span class="string">f&quot; <span class="subst">&#123;region&#125;</span>, 24.Sep.2010 - 23.Oct.2020&quot;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">fig.tight_layout(rect=[<span class="number">0</span>,-<span class="number">0.05</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><img src="40_gt_2.png" alt="검색어별 지난 10년간 경향성"></li></ul><ul><li>data analysis에 반년 주기성이 보입니다.</li><li>big data는 2012년 이후 상승했네요.</li><li>deep learning은 2016년 이후 급격히 상승했습니다.</li><li>data science와 data engineering이 꾸준하게 상승중입니다.</li></ul><ul><li><p>이번에는 주요 라이브러리 경향성을 보겠습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">libs_time = [<span class="string">&#x27;numpy.csv&#x27;</span>, <span class="string">&#x27;keras.csv&#x27;</span>, <span class="string">&#x27;pandas.csv&#x27;</span>, <span class="string">&#x27;tensorflow.csv&#x27;</span>, <span class="string">&#x27;sklearn.csv&#x27;</span>, <span class="string">&#x27;pytorch.csv&#x27;</span>]</span><br><span class="line">nfiles = <span class="built_in">len</span>(lib_time)</span><br><span class="line">fig, axes = plt.subplots(ncols=<span class="number">2</span>, nrows=<span class="number">3</span>, figsize=(<span class="number">11</span>, <span class="number">5</span>), </span><br><span class="line">                        sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>) <span class="comment">#, gridspec_kw=&#123;&quot;hspace&quot;:0.1, &quot;wspace&quot;:0.05&#125;)</span></span><br><span class="line">axs = axes.ravel()</span><br><span class="line"></span><br><span class="line">dfs = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, (ax, file) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(axs, libs_time)):</span><br><span class="line">    dfs[file] = pd.read_csv(os.path.join(path, file), skiprows=<span class="number">2</span>, na_values=<span class="string">&quot;&lt;1&quot;</span>)</span><br><span class="line">    dfs[file][<span class="string">&quot;year&quot;</span>] = dfs[file][<span class="string">&quot;Month&quot;</span>].apply(<span class="keyword">lambda</span> s: s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>])</span><br><span class="line">    cols = dfs[file].columns</span><br><span class="line">    cols_clear = cols[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    dfs[file].rename(columns=&#123;cols[<span class="number">1</span>]: cols_clear&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line">    region = cols[<span class="number">1</span>].split(<span class="string">&quot;: &quot;</span>)[<span class="number">1</span>][<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    df_idx = dfs[file].reset_index().groupby(<span class="string">&quot;year&quot;</span>).nth(<span class="number">0</span>)[<span class="string">&quot;index&quot;</span>].values</span><br><span class="line">    </span><br><span class="line">    ax.fill_between(dfs[file].index, <span class="number">0</span>, dfs[file][cols_clear], color=<span class="string">&quot;forestgreen&quot;</span>)</span><br><span class="line">    ax.annotate(cols_clear, (dfs[file].shape[<span class="number">0</span>]-<span class="number">3</span>, <span class="number">10</span>), ha=<span class="string">&quot;right&quot;</span>, color=<span class="string">&quot;w&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.set_xlim(<span class="number">0</span>, dfs[file].shape[<span class="number">0</span>]-<span class="number">1</span>)</span><br><span class="line">    ax.set_ylim(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">    ax.set_yticks([])</span><br><span class="line">    ax.grid()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">3</span>:</span><br><span class="line">        ax.set_xticks(df_idx[::<span class="number">2</span>][<span class="number">1</span>:])</span><br><span class="line">        ax.set_xticklabels(dfs[file][<span class="string">&quot;year&quot;</span>].loc[df_idx].values[::<span class="number">2</span>][<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">axs[<span class="number">0</span>].annotate(<span class="string">&quot;(as numeric) 1995&quot;</span>, (<span class="number">0</span>, <span class="number">80</span>),ha=<span class="string">&quot;left&quot;</span>, fontsize=<span class="number">14</span>, backgroundcolor=<span class="string">&quot;w&quot;</span>)</span><br><span class="line">axs[<span class="number">0</span>].annotate(<span class="string">&quot;(as numpy) 24 Aug. 2006 &quot;</span>, (<span class="number">0</span>, <span class="number">50</span>),ha=<span class="string">&quot;left&quot;</span>, fontsize=<span class="number">14</span>, backgroundcolor=<span class="string">&quot;w&quot;</span>)        </span><br><span class="line">        </span><br><span class="line">axs[<span class="number">1</span>].axvline(<span class="number">53</span>, c=<span class="string">&quot;k&quot;</span>, linestyle=<span class="string">&quot;:&quot;</span>)</span><br><span class="line">axs[<span class="number">1</span>].annotate(<span class="string">&quot;27 Mar. 2015&quot;</span>, (<span class="number">53</span>-<span class="number">3</span>, <span class="number">80</span>),ha=<span class="string">&quot;right&quot;</span>, fontsize=<span class="number">14</span>, backgroundcolor=<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">2</span>].annotate(<span class="string">&quot;11 Jan. 2008 &quot;</span>, (<span class="number">0</span>, <span class="number">80</span>),ha=<span class="string">&quot;left&quot;</span>, fontsize=<span class="number">14</span>, backgroundcolor=<span class="string">&quot;w&quot;</span>)        </span><br><span class="line"></span><br><span class="line">axs[<span class="number">3</span>].axvline(<span class="number">61</span>, c=<span class="string">&quot;k&quot;</span>, linestyle=<span class="string">&quot;:&quot;</span>)</span><br><span class="line">axs[<span class="number">3</span>].annotate(<span class="string">&quot;9 Nov. 2015&quot;</span>, (<span class="number">61</span>-<span class="number">3</span>, <span class="number">80</span>),ha=<span class="string">&quot;right&quot;</span>, fontsize=<span class="number">14</span>, backgroundcolor=<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">4</span>].annotate(<span class="string">&quot;Jun. 2007 &quot;</span>, (<span class="number">0</span>, <span class="number">80</span>),ha=<span class="string">&quot;left&quot;</span>, fontsize=<span class="number">14</span>, backgroundcolor=<span class="string">&quot;w&quot;</span>)        </span><br><span class="line"></span><br><span class="line">axs[<span class="number">5</span>].axvline(<span class="number">71</span>, c=<span class="string">&quot;k&quot;</span>, linestyle=<span class="string">&quot;:&quot;</span>)</span><br><span class="line">axs[<span class="number">5</span>].annotate(<span class="string">&quot;1 Sep. 2016&quot;</span>, (<span class="number">71</span>-<span class="number">3</span>, <span class="number">80</span>),ha=<span class="string">&quot;right&quot;</span>, fontsize=<span class="number">14</span>, backgroundcolor=<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">axs[<span class="number">5</span>].text(dfs[file].shape[<span class="number">0</span>]-<span class="number">3</span>, -<span class="number">70</span>, <span class="string">&quot;*max. of each plot is scaled to 100&quot;</span>, </span><br><span class="line">            ha=<span class="string">&quot;right&quot;</span>, c=<span class="string">&quot;gray&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">fig.suptitle(<span class="string">&quot;Google Trends$^*$:&quot;</span> + <span class="string">f&quot; <span class="subst">&#123;region&#125;</span>, 24.Sep.2010 - 23.Oct.2020&quot;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">fig.tight_layout(rect=[<span class="number">0</span>,-<span class="number">0.05</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><img src="40_gt_3.png" alt="라이브러리별 지난 10년간 경향성"></p></li><li><p>라이브러리별 initial release date를 함께 표기했습니다.</p></li><li><p>tensorflow와 pytorch는 고유명사라서 initial release이후 등장합니다.</p></li><li><p>그러나 <b>뿔</b>이라는 뜻을 가진 보통명사인 keras는 initial release 한참 전부터 등장합니다.</p></li><li><p>맏형격인 scikit-learn은 2007년에 처음 나왔지만 유의미한 신호가 보이지 않다가 2012년 이후 쭉쭉 올라갔네요.</p></li></ul><ul><li>라이브러리별로 어느 나라에서 많이 찾았는지 보겠습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">6</span>, figsize=(<span class="number">11</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">libs_map_ = [<span class="string">&quot;numpy&quot;</span>, <span class="string">&quot;pandas&quot;</span>, <span class="string">&quot;sklearn&quot;</span>, <span class="string">&quot;keras&quot;</span>, <span class="string">&quot;tensorflow&quot;</span>, <span class="string">&quot;pytorch&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, l  <span class="keyword">in</span> <span class="built_in">zip</span>(axs, libs_map_):</span><br><span class="line">    lib = l.split(<span class="string">&quot;_&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    shares = dfs_map[l+<span class="string">&#x27;_map.csv&#x27;</span>].loc[:<span class="number">10</span>, lib]</span><br><span class="line">    countries = dfs_map[l+<span class="string">&#x27;_map.csv&#x27;</span>].loc[:<span class="number">10</span>, <span class="string">&quot;Country&quot;</span>]</span><br><span class="line">    ax.barh(countries, shares, fc=<span class="string">&quot;lightgray&quot;</span>)</span><br><span class="line">    ax.set_yticklabels([])</span><br><span class="line">    ax.invert_yaxis()</span><br><span class="line">    ax.set_xticks(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100</span>, <span class="number">20</span>)))</span><br><span class="line">    ax.set_xticklabels([])</span><br><span class="line">    ax.grid(axis=<span class="string">&quot;x&quot;</span>, c=<span class="string">&quot;lightgray&quot;</span>, lw=<span class="number">1</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> l == <span class="string">&quot;sklearn&quot;</span>:</span><br><span class="line">        title = <span class="string">&quot;scikit-learn&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        title = l</span><br><span class="line">    </span><br><span class="line">    ax.set_title(title, fontsize=<span class="number">16</span>, pad=<span class="number">12</span>)</span><br><span class="line">    </span><br><span class="line">    idx_korea = np.where(<span class="string">&quot;South Korea&quot;</span> == countries.values)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(idx_korea) &gt; <span class="number">0</span>:</span><br><span class="line">        ax.patches[idx_korea[<span class="number">0</span>]].set_facecolor(<span class="string">&quot;gold&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i, country <span class="keyword">in</span> <span class="built_in">enumerate</span>(countries):</span><br><span class="line">        ax.annotate(country, (<span class="number">10</span>, i), va=<span class="string">&quot;center&quot;</span>, fontsize=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">fig.text(<span class="number">0.98</span>, <span class="number">0.02</span>, <span class="string">&quot;*max. of each plot is scaled to 100&quot;</span>, </span><br><span class="line">            ha=<span class="string">&quot;right&quot;</span>, c=<span class="string">&quot;gray&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">fig.suptitle(<span class="string">&quot;Google Trends$^*$:&quot;</span> + <span class="string">f&quot; <span class="subst">&#123;region&#125;</span>, 24.Sep.2010 - 23.Oct.2020&quot;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">fig.tight_layout(rect=[<span class="number">0</span>,<span class="number">0.02</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><img src="40_gt_4.png" alt="라이브러리별 국가별 검색 지분"></li></ul><ul><li>대부분 중국이 1위, 한국이 2위입니다.</li><li>사실 의외입니다. 수위에 있을 것 같은 미국은 검색이 안 된 것이 아니라 한참 아래 순위에 있습니다.</li><li>미국 사람들은 검색어에 뭘 넣는 걸까요? 검색을 안하는 건 아닐텐데요.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/pandas/">pandas</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/subplots/">subplots</category>
      
      <category domain="https://jehyunlee.github.io/tags/text/">text</category>
      
      <category domain="https://jehyunlee.github.io/tags/google-trends/">google trends</category>
      
      
    </item>
    
    <item>
      <title>Random Generation Fitting to a Histogram</title>
      <link>https://jehyunlee.github.io/2020/10/15/Python-DS-39-randgen_dist/</link>
      <guid>https://jehyunlee.github.io/2020/10/15/Python-DS-39-randgen_dist/</guid>
      <pubDate>Thu, 15 Oct 2020 05:32:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;새로운 데이터는 &lt;code&gt;numpy.random&lt;/code&gt;함수로 만들 수 있습니다.&lt;/li&gt;
&lt;li&gt;정규분포나 균일하게 만드는 것은 많이들 합니다만,&lt;/li&gt;
&lt;li&gt;기존 데이터의 분포를 모방해 봅시다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blo</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>새로운 데이터는 <code>numpy.random</code>함수로 만들 수 있습니다.</li><li>정규분포나 균일하게 만드는 것은 많이들 합니다만,</li><li>기존 데이터의 분포를 모방해 봅시다.</li></ul><blockquote><p><a href="https://riptutorial.com/scipy/example/31081/fitting-a-function-to-data-from-a-histogram">RIP tutorial: Fitting a function to data from a histogram</a></p></blockquote><h3 id="1-기존-데이터"><a href="#1-기존-데이터" class="headerlink" title="1. 기존 데이터"></a>1. 기존 데이터</h3><ul><li><a href="randgen_dist.pkl">10만개가 조금 넘는 데이터</a>가 있습니다.</li><li>대강 이렇게 생겼습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_pickle(<span class="string">&quot;randgen_dist.pkl&quot;</span>)</span><br><span class="line">display(df.describe())</span><br></pre></td></tr></table></figure><img src="39_randgen_dist_6.png"></li></ul><blockquote><p><a href="https://seaborn.pydata.org/generated/seaborn.set_palette.html">seaborn.set_palette</a><br><a href="https://seaborn.pydata.org/generated/seaborn.set_context.html?highlight=set_context#seaborn.set_context">seaborn.set_context</a><br><a href="https://seaborn.pydata.org/generated/seaborn.set_style.html?highlight=set_style#seaborn.set_style">seaborn.set_style</a><br><a href="https://seaborn.pydata.org/generated/seaborn.histplot.html?highlight=histplot#seaborn.histplot">seaborn.histplot</a></p></blockquote><ul><li><b>분포</b>를 확인해보겠습니다.</li><li>보고용 그림이 아니므로 손을 많이 대고 싶지 않습니다.</li><li>스타일을 잡고 간단히 그립니다.</li><li>seaborn이 이럴 때 좋습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.set_palette(<span class="string">&quot;muted&quot;</span>)</span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line">sns.set_style(<span class="string">&quot;white&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">12</span>, <span class="number">4</span>))</span><br><span class="line">sns.histplot(df[<span class="string">&quot;A&quot;</span>], ax=axs[<span class="number">0</span>], kde=<span class="literal">True</span>, bins=<span class="number">100</span>)</span><br><span class="line">sns.histplot(df[<span class="string">&quot;B&quot;</span>], ax=axs[<span class="number">1</span>], kde=<span class="literal">True</span>, bins=<span class="number">100</span>)</span><br><span class="line">sns.histplot(df[<span class="string">&quot;C&quot;</span>], ax=axs[<span class="number">2</span>], kde=<span class="literal">True</span>, bins=<span class="number">100</span>, kde_kws=&#123;<span class="string">&quot;bw_adjust&quot;</span>:<span class="number">5</span>&#125;)</span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><img src="39_randgen_dist_1.png"></li></ul><blockquote><p><a href="https://seaborn.pydata.org/generated/seaborn.kdeplot.html?highlight=kdeplot#seaborn.kdeplot">seaborn.kdeplot</a><br><a href="https://seaborn.pydata.org/generated/seaborn.regplot.html?highlight=regplot#seaborn.regplot">seaborn.regplot</a><br><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.corr.html">pandas.DataFrame.corr</a></p></blockquote><ul><li><b>2변수 분포</b>를 확인해보겠습니다.</li><li>2차원 KDE plot을 그리고 pearson correlation coefficient를 봅니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PCC_AB = df.corr().loc[<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>]</span><br><span class="line">PCC_BC = df.corr().loc[<span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>]</span><br><span class="line">PCC_AC = df.corr().loc[<span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(PCC_AB, PCC_BC, PCC_AC)</span><br></pre></td></tr></table></figure>실행결과: 피어슨 계수가 모두 작네요.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.2813347529044316 0.025736569810035914 0.0011956781154378422</span><br></pre></td></tr></table></figure></li></ul><ul><li>2차원 분포에 같이 얹어봅니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">12</span>, <span class="number">4</span>))</span><br><span class="line">sns.kdeplot(x=df[<span class="string">&quot;A&quot;</span>], y=df[<span class="string">&quot;B&quot;</span>], cmap=<span class="string">&quot;Blues&quot;</span>, ax=axs[<span class="number">0</span>])</span><br><span class="line">sns.regplot(x=df[<span class="string">&quot;A&quot;</span>], y=df[<span class="string">&quot;B&quot;</span>], scatter=<span class="literal">False</span>, ax=axs[<span class="number">0</span>])</span><br><span class="line">axs[<span class="number">0</span>].annotate(<span class="string">f&quot;PCC = <span class="subst">&#123;PCC_AB:<span class="number">0.2</span>f&#125;</span>&quot;</span>, (<span class="number">0.5</span>, <span class="number">0.8</span>), xycoords=<span class="string">&#x27;axes fraction&#x27;</span>, ha=<span class="string">&quot;center&quot;</span>)</span><br><span class="line"></span><br><span class="line">sns.kdeplot(x=df[<span class="string">&quot;B&quot;</span>], y=df[<span class="string">&quot;C&quot;</span>], cmap=<span class="string">&quot;Blues&quot;</span>, ax=axs[<span class="number">1</span>])</span><br><span class="line">sns.regplot(x=df[<span class="string">&quot;B&quot;</span>], y=df[<span class="string">&quot;C&quot;</span>], scatter=<span class="literal">False</span>, ax=axs[<span class="number">1</span>])</span><br><span class="line">axs[<span class="number">1</span>].annotate(<span class="string">f&quot;PCC = <span class="subst">&#123;PCC_BC:<span class="number">0.2</span>f&#125;</span>&quot;</span>, (<span class="number">0.5</span>, <span class="number">0.8</span>), xycoords=<span class="string">&#x27;axes fraction&#x27;</span>, ha=<span class="string">&quot;center&quot;</span>)</span><br><span class="line"></span><br><span class="line">sns.kdeplot(x=df[<span class="string">&quot;A&quot;</span>], y=df[<span class="string">&quot;C&quot;</span>], cmap=<span class="string">&quot;Blues&quot;</span>, ax=axs[<span class="number">2</span>])</span><br><span class="line">sns.regplot(x=df[<span class="string">&quot;A&quot;</span>], y=df[<span class="string">&quot;C&quot;</span>], scatter=<span class="literal">False</span>, ax=axs[<span class="number">2</span>])</span><br><span class="line">axs[<span class="number">2</span>].annotate(<span class="string">f&quot;PCC = <span class="subst">&#123;PCC_AC:<span class="number">0.2</span>f&#125;</span>&quot;</span>, (<span class="number">0.5</span>, <span class="number">0.8</span>), xycoords=<span class="string">&#x27;axes fraction&#x27;</span>, ha=<span class="string">&quot;center&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><img src="39_randgen_dist_2.png"></li></ul><ul><li>A와 B 사이에 상관관계가 있지만 매우 약합니다.</li><li>C는 A, B와 전혀 관계가 없어보입니다.</li></ul><h3 id="2-histogram-fitting"><a href="#2-histogram-fitting" class="headerlink" title="2. histogram fitting"></a>2. histogram fitting</h3><ul><li><p>원 데이터의 분포를 재현하려면 <b>함수</b>로 모사해야 합니다.</p></li><li><p>히스토그램이 정규분포만으로는 설명이 되지 않습니다.</p></li><li><p><b>A</b>와 <b>B</b> : $$y = (ax + b) + e^{-\frac{1}{2} (\frac{x-\mu}{\sigma})^2}$$로,</p></li><li><p><b>C</b> : $$y = (ax + b) + Ae^{-\frac{1}{2} (\frac{x-\mu_A}{\sigma_A})^2} + Be^{-\frac{1}{2} (\frac{x-\mu_B}{\sigma_B})^2}$$로 가정합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> curve_fit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit_lingau</span>(<span class="params">x, a, b, B, mu, sigma</span>):</span></span><br><span class="line">    func_lin = a * x + b</span><br><span class="line">    func_gaussian = B * np.exp(-<span class="number">1.0</span> * (x - mu)**<span class="number">2</span> / (<span class="number">2</span> * sigma**<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> func_lin + func_gaussian</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit_lingaugau</span>(<span class="params">x, a, b, A, muA, sigmaA, B, muB, sigmaB</span>):</span></span><br><span class="line">    func_lin = a * x + b</span><br><span class="line">    func_gaussian1 = A * np.exp(-<span class="number">1.0</span> * (x - muA)**<span class="number">2</span> / (<span class="number">2</span> * sigmaA**<span class="number">2</span>))</span><br><span class="line">    func_gaussian2 = B * np.exp(-<span class="number">1.0</span> * (x - muB)**<span class="number">2</span> / (<span class="number">2</span> * sigmaB**<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> func_lin + func_gaussian1 + func_gaussian2</span><br></pre></td></tr></table></figure></li><li><p>데이터 A의 히스토그램 계급과 갯수를 추출합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># histogram of A</span></span><br><span class="line">counts_A, bins_A = np.histogram(df[<span class="string">&quot;A&quot;</span>], bins=<span class="number">100</span>)</span><br><span class="line">bins_Ac = np.array([bins_A[i]*<span class="number">0.5</span> + bins_A[i+<span class="number">1</span>]*<span class="number">0.5</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(counts_A))])</span><br><span class="line"></span><br><span class="line"><span class="comment"># fit for histogram of A</span></span><br><span class="line">popt_A, pcov_A = curve_fit(fit_lingau, xdata=bins_Ac, ydata=counts_A,</span><br><span class="line">                           p0=[-<span class="number">20.0</span>, <span class="number">500.0</span>, <span class="number">3000.0</span>, <span class="number">10.0</span>, <span class="number">3.0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># new x range</span></span><br><span class="line">xa_new = np.linspace(df[<span class="string">&quot;A&quot;</span>].<span class="built_in">min</span>(), df[<span class="string">&quot;A&quot;</span>].<span class="built_in">max</span>(), <span class="number">100</span>)</span><br><span class="line">ya_new = fit_lingau(xa_new, *popt_A)</span><br></pre></td></tr></table></figure></li><li><p>데이터 B와 C도 같은 요령으로 처리합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">12</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># A</span></span><br><span class="line">sns.histplot(df[<span class="string">&quot;A&quot;</span>], ax=axs[<span class="number">0</span>], kde=<span class="literal">True</span>, bins=<span class="number">100</span>)</span><br><span class="line">axs[<span class="number">0</span>].plot(xa_new, ya_new, c=<span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="comment"># B</span></span><br><span class="line">sns.histplot(df[<span class="string">&quot;B&quot;</span>], ax=axs[<span class="number">1</span>], kde=<span class="literal">True</span>, bins=<span class="number">100</span>)</span><br><span class="line">axs[<span class="number">1</span>].plot(xb_new, yb_new, c=<span class="string">&quot;r&quot;</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_ylabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_ylim(<span class="number">0</span>,)</span><br><span class="line"></span><br><span class="line"><span class="comment"># C</span></span><br><span class="line">sns.histplot(df[<span class="string">&quot;C&quot;</span>], ax=axs[<span class="number">2</span>], kde=<span class="literal">True</span>, bins=<span class="number">100</span>, kde_kws=&#123;<span class="string">&quot;bw_adjust&quot;</span>:<span class="number">5</span>&#125;, label=<span class="string">&quot;data&quot;</span>)</span><br><span class="line">axs[<span class="number">2</span>].plot(xc_new, yc_new, c=<span class="string">&quot;r&quot;</span>, label=<span class="string">&quot;fit&quot;</span>)</span><br><span class="line">axs[<span class="number">2</span>].set_ylabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line">axs[<span class="number">2</span>].set_ylim(<span class="number">0</span>,)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">2</span>].legend(bbox_to_anchor=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><p><img src="39_randgen_dist_3.png"></p></li></ul><ul><li>fitting된 함수가 데이터 분포와 잘 맞습니다.</li><li>C는 모양을 조금 더 잘 반영하고자 gaussian을 하나 더 추가해서 <b>의도적으로</b> 조금 복잡하게 만들었습니다.</li></ul><h3 id="3-데이터-생성"><a href="#3-데이터-생성" class="headerlink" title="3. 데이터 생성"></a>3. 데이터 생성</h3><blockquote><p><a href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.choice.html">numpy.random.choice</a></p></blockquote><ul><li><code>numpy.random</code>은 <code>choice</code>명령으로 샘플링을 할 수 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">np.random.choice(A, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>실행결과: 균일하게 뽑혀나옵니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([2, 1, 1, 3, 2, 2, 1, 2, 3, 2])</span><br></pre></td></tr></table></figure><img src=""></li></ul><ul><li><b>추출 확률</b>을 조정할 수 있습니다.</li><li>1, 2, 3 중 <b>3만 뽑히도록 조작합시다.</b><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">p = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">np.random.choice(A, <span class="number">10</span>, p=p)</span><br></pre></td></tr></table></figure>실행결과: p=1로 설정된 3만 반복해서 나옵니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([3, 3, 3, 3, 3, 3, 3, 3, 3, 3])</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><b>확률을 조정해 추출하는 함수</b>를 만듭니다.</p><ul><li>분포를 재현할 함수가 필요합니다.</li><li>fitting 함수 이름과 파라미터를 입력받도록 합니다.</li><li>함수에 맞춰 지정된 갯수의 데이터를 생성합니다.</li></ul></li><li><p><b>데이터 생성 및 추출 함수</b>입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_data</span>(<span class="params">x, fit_func, fit_param, number</span>):</span></span><br><span class="line">    prob_ = fit_func(x, *fit_param)</span><br><span class="line">    prob_ = np.array([p <span class="keyword">if</span> p&gt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> p <span class="keyword">in</span> prob_])</span><br><span class="line">    prob = prob_/prob_.<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> np.random.choice(x, number, p=prob)</span><br></pre></td></tr></table></figure></li></ul><ul><li>데이터를 10000개 생성합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen_A = gen_data(xa_new, fit_lingau, popt_A, <span class="number">10000</span>)</span><br><span class="line">gen_B = gen_data(xb_new, fit_lingau, popt_B, <span class="number">10000</span>)</span><br><span class="line">gen_C = gen_data(xc_new, fit_lingaugau, popt_C, <span class="number">10000</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li>생성된 데이터의 분포를 원본과 비교합니다.</li><li><b>원본의 빨간 선</b>과 <b>생성데이터의 녹색</b>이 <b>거의 일치</b>합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">12</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># A</span></span><br><span class="line">sns.histplot(gen_A, bins=<span class="number">100</span>, ax=axs[<span class="number">0</span>], color=<span class="string">&quot;green&quot;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">axs[<span class="number">0</span>].plot(xa_new, fit_lingau(xa_new, *popt_A)/df.shape[<span class="number">0</span>]*<span class="number">10000</span>, c=<span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="comment"># B</span></span><br><span class="line">sns.histplot(gen_B, bins=<span class="number">100</span>, ax=axs[<span class="number">1</span>], color=<span class="string">&quot;green&quot;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">axs[<span class="number">1</span>].plot(xb_new, fit_lingau(xb_new, *popt_B)/df.shape[<span class="number">0</span>]*<span class="number">10000</span>, c=<span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="comment"># C</span></span><br><span class="line">sns.histplot(gen_C, bins=<span class="number">100</span>, ax=axs[<span class="number">2</span>], color=<span class="string">&quot;green&quot;</span>, alpha=<span class="number">0.3</span>, label=<span class="string">&quot;generated&quot;</span>)</span><br><span class="line">axs[<span class="number">2</span>].plot(xc_new, fit_lingaugau(xc_new, *popt_C)/df.shape[<span class="number">0</span>]*<span class="number">10000</span>, c=<span class="string">&quot;r&quot;</span>, label=<span class="string">&quot;fit&quot;</span>)</span><br><span class="line"></span><br><span class="line">xlabels=[<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    axs[i].set_xlabel(xlabels[i])</span><br><span class="line">    axs[i].set_ylim(<span class="number">0</span>,)</span><br><span class="line">    <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">        axs[i].set_ylabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">2</span>].legend(bbox_to_anchor=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><img src="39_randgen_dist_4.png"></li></ul><ul><li>생성된 데이터간의 상관성을 확인합시다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df_gen = pd.DataFrame(&#123;<span class="string">&quot;A&quot;</span>:gen_A, <span class="string">&quot;B&quot;</span>:gen_B, <span class="string">&quot;C&quot;</span>: gen_C&#125;)</span><br><span class="line">gen_corr = df_gen.corr()</span><br><span class="line">gen_corr</span><br></pre></td></tr></table></figure><img src="39_randgen_dist_7.png"></li></ul><ul><li>독립적으로 생성되었기 때문에 <b>변수간 관계가 없습니다.</b></li><li>다시 <b>2변수 분포</b>를 확인합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">gen_PCC_AB = df_gen.corr().loc[<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>]</span><br><span class="line">gen_PCC_BC = df_gen.corr().loc[<span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>]</span><br><span class="line">gen_PCC_AC = df_gen.corr().loc[<span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>]</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">12</span>, <span class="number">4</span>))</span><br><span class="line">sns.kdeplot(x=df_gen[<span class="string">&quot;A&quot;</span>], y=df_gen[<span class="string">&quot;B&quot;</span>], cmap=<span class="string">&quot;Greens&quot;</span>, ax=axs[<span class="number">0</span>])</span><br><span class="line">sns.regplot(x=df_gen[<span class="string">&quot;A&quot;</span>], y=df_gen[<span class="string">&quot;B&quot;</span>], scatter=<span class="literal">False</span>, ax=axs[<span class="number">0</span>])</span><br><span class="line">axs[<span class="number">0</span>].annotate(<span class="string">f&quot;PCC = <span class="subst">&#123;gen_PCC_AB:<span class="number">0.2</span>f&#125;</span>&quot;</span>, (<span class="number">0.5</span>, <span class="number">0.8</span>), xycoords=<span class="string">&#x27;axes fraction&#x27;</span>, ha=<span class="string">&quot;center&quot;</span>)</span><br><span class="line"></span><br><span class="line">sns.kdeplot(x=df_gen[<span class="string">&quot;B&quot;</span>], y=df_gen[<span class="string">&quot;C&quot;</span>], cmap=<span class="string">&quot;Greens&quot;</span>, ax=axs[<span class="number">1</span>])</span><br><span class="line">sns.regplot(x=df_gen[<span class="string">&quot;B&quot;</span>], y=df_gen[<span class="string">&quot;C&quot;</span>], scatter=<span class="literal">False</span>, ax=axs[<span class="number">1</span>])</span><br><span class="line">axs[<span class="number">1</span>].annotate(<span class="string">f&quot;PCC = <span class="subst">&#123;gen_PCC_BC:<span class="number">0.2</span>f&#125;</span>&quot;</span>, (<span class="number">0.5</span>, <span class="number">0.8</span>), xycoords=<span class="string">&#x27;axes fraction&#x27;</span>, ha=<span class="string">&quot;center&quot;</span>)</span><br><span class="line"></span><br><span class="line">sns.kdeplot(x=df_gen[<span class="string">&quot;A&quot;</span>], y=df_gen[<span class="string">&quot;C&quot;</span>], cmap=<span class="string">&quot;Greens&quot;</span>, ax=axs[<span class="number">2</span>])</span><br><span class="line">sns.regplot(x=df_gen[<span class="string">&quot;A&quot;</span>], y=df_gen[<span class="string">&quot;C&quot;</span>], scatter=<span class="literal">False</span>, ax=axs[<span class="number">2</span>])</span><br><span class="line">axs[<span class="number">2</span>].annotate(<span class="string">f&quot;PCC = <span class="subst">&#123;gen_PCC_AC:<span class="number">0.2</span>f&#125;</span>&quot;</span>, (<span class="number">0.5</span>, <span class="number">0.8</span>), xycoords=<span class="string">&#x27;axes fraction&#x27;</span>, ha=<span class="string">&quot;center&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><img src="39_randgen_dist_5.png"></li></ul><ul><li><b>A와 B 사이의 상관관계가 소멸</b>되었습니다.</li><li>그러나 <b>B와 C</b>, <b>A와 C</b>는 <b>2차원 분포까지 재현</b>되었습니다.</li><li>약한 상관성을 어떻게 확보할지는 더 고민해보겠습니다. </li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/statistics/">statistics</category>
      
      <category domain="https://jehyunlee.github.io/tags/data-augmentation/">data augmentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/data-generation/">data generation</category>
      
      <category domain="https://jehyunlee.github.io/tags/probability/">probability</category>
      
      <category domain="https://jehyunlee.github.io/tags/scipy/">scipy</category>
      
      <category domain="https://jehyunlee.github.io/tags/numpy/">numpy</category>
      
      
    </item>
    
    <item>
      <title>Shadow Pattern Modeling</title>
      <link>https://jehyunlee.github.io/2020/10/14/GIS-Python-5-shadow/</link>
      <guid>https://jehyunlee.github.io/2020/10/14/GIS-Python-5-shadow/</guid>
      <pubDate>Wed, 14 Oct 2020 01:43:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;태양의 일주운동에 따른 건물 그림자 모델 논문을 구현했습니다.&lt;/li&gt;
&lt;li&gt;pysolar를 이용해 태양의 운동을 계산하고, geopandas를 이용해 그림자 형상을 계산했습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-논문-간단-요약</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>태양의 일주운동에 따른 건물 그림자 모델 논문을 구현했습니다.</li><li>pysolar를 이용해 태양의 운동을 계산하고, geopandas를 이용해 그림자 형상을 계산했습니다.</li></ul><h3 id="1-논문-간단-요약"><a href="#1-논문-간단-요약" class="headerlink" title="1. 논문 간단 요약"></a>1. 논문 간단 요약</h3><blockquote><p>R. Soler-Bientz et al., “Developing a computational tool to assess shadow pattern on a horizontal plane, preliminary results”, IEEE Photovoltaic Specialists Conference p.2312, 2010. doi:10.1109/PVSC.2010.5614490</p></blockquote><ul><li>태양은 아침에 동쪽에서 떠서 남쪽 하늘을 따라 움직이다 저녁이 되면 서쪽으로 넘어갑니다.</li><li>태양광은 아주 멀리서 직진하므로 건물이 만드는 그림자는 태양의 좌표와 건물의 형상으로 구할 수 있습니다.<br><br><img src="5_shadow_11.png"><br></li></ul><ul><li>이 둘을 조합하면 위도와 경도가 다른 지구상 여러 위치에서 건물 그림자를 계산할 수 있습니다.<br><br><img src="5_shadow_12.png"><br></li></ul><ul><li>거의 같은 경도 상에 있는 다섯 도시에서 같은 시간에 생기는 그림자를 그려봅니다.</li><li>위도에 따라 태양의 위치가 달라 다른 방향과 형태의 그림자가 생깁니다.<br><br><img src="5_shadow_13.png"><br></li></ul><h3 id="2-태양-일주운동"><a href="#2-태양-일주운동" class="headerlink" title="2. 태양 일주운동"></a>2. 태양 일주운동</h3><blockquote><p><a href="https://jehyunlee.github.io/2020/10/13/GIS-Python-4-pysolar/">Pega Devlog: pysolar</a><br><a href="https://github.com/pingswept/pysolar">pysolar github</a><br><a href="https://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/points-solar-radiation.htm">ArcGIS: Points Solar Radiation</a></p></blockquote><ul><li>위도와 시간에 따른 태양 고도 변화를 그려봅니다.</li><li>춘분(3월 21일) 06시 일출부터 18시 일몰까지 16등분한 태양의 위치입니다. <ul><li>arcgis에서 360도를 32등분 하더군요.</li></ul></li><li><b>방위각<code>azimuthal angle</code></b>과 <b>고도<code>altitude</code></b>로 그렸습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> pysolar.solar <span class="keyword">import</span> get_altitude, get_azimuth</span><br><span class="line"></span><br><span class="line">lats = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>))</span><br><span class="line">lon = <span class="number">127.3845</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Spring equinox</span></span><br><span class="line">KST = datetime.timezone(datetime.timedelta(hours=<span class="number">9</span>))</span><br><span class="line">date = datetime.datetime(<span class="number">2017</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">0</span>, tzinfo=KST)</span><br><span class="line"></span><br><span class="line"><span class="comment"># data</span></span><br><span class="line">nlats = <span class="built_in">len</span>(lats)</span><br><span class="line">alts_lat = &#123;&#125;</span><br><span class="line">azis_lat = &#123;&#125;</span><br><span class="line">date_hr_lat = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># altitudes and azimuthal angles</span></span><br><span class="line"><span class="keyword">for</span> i, lat <span class="keyword">in</span> <span class="built_in">enumerate</span>(lats):</span><br><span class="line">    alts, azis, dates_hr = [], [], []</span><br><span class="line">    <span class="keyword">for</span> hh <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">24</span>):</span><br><span class="line">        <span class="keyword">for</span> mm <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">60</span>, <span class="number">1</span>):</span><br><span class="line">            date_hr = datetime.datetime(<span class="number">2017</span>, <span class="number">3</span>, <span class="number">21</span>, hh, mm, <span class="number">0</span>, tzinfo=KST)</span><br><span class="line">            dates_hr.append(date_hr)</span><br><span class="line">            alt = get_altitude(lat, lon, date_hr)</span><br><span class="line">            azi = get_azimuth(lat, lon, date_hr)</span><br><span class="line">            alts.append(alt)</span><br><span class="line">            azis.append(azi)</span><br><span class="line"></span><br><span class="line">    date_hr_lat[i] = dates_hr</span><br><span class="line">    alts_lat[i] = np.array(alts)      </span><br><span class="line">    azis_lat[i] = np.array(azis)</span><br><span class="line"></span><br><span class="line">hhmm = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1440</span>))    </span><br><span class="line"></span><br><span class="line">df_azialt = &#123;&#125;</span><br><span class="line">select_values = np.linspace(<span class="number">90</span>, <span class="number">270</span>+<span class="number">11.25</span>, <span class="number">18</span>)</span><br><span class="line">azis_arcgis = &#123;&#125;</span><br><span class="line">alts_arcgis = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, lat <span class="keyword">in</span> <span class="built_in">enumerate</span>(lats):</span><br><span class="line">    df_azialt[i] = pd.DataFrame(&#123;<span class="string">&quot;date_hr&quot;</span>:hhmm, <span class="string">&quot;azimuth&quot;</span>:azis_lat[i], <span class="string">&quot;altitude&quot;</span>:alts_lat[i]&#125;)</span><br><span class="line">    pcut = pd.cut(df_azialt[i][<span class="string">&quot;azimuth&quot;</span>], select_values)</span><br><span class="line">    azis_arcgis[i] = df_azialt[i][<span class="string">&quot;azimuth&quot;</span>].groupby(pcut).nth(<span class="number">0</span>).values</span><br><span class="line">    alts_arcgis[i] = df_azialt[i][<span class="string">&quot;altitude&quot;</span>].groupby(pcut).nth(<span class="number">0</span>).values</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>삽입할 그림을 파워포인트에서 도형으로 그립니다.<br><img src="5_shadow_14.png"><br></p></li><li><p>matplotlib의 <code>.add_axes()</code>를 사용해 <b>그림을 넣을 위치를 지정</b>합니다.</p></li><li><p>그림 삽입 후 <code>.axis(&quot;off&quot;)</code>로 가로 세로 <b>눈금을 떼어버립니다.</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.ticker <span class="keyword">import</span> MultipleLocator</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">lines = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, nlats):</span><br><span class="line">    line = ax.plot(azis_lat[i], alts_lat[i], zorder=<span class="number">1</span>)</span><br><span class="line">    lines.append(line)</span><br><span class="line">    ax.scatter(azis_arcgis[i], alts_arcgis[i], zorder=<span class="number">1.1</span>)</span><br><span class="line">    </span><br><span class="line">ax.set_aspect(<span class="string">&quot;equal&quot;</span>)</span><br><span class="line">ax.set_xlim(<span class="number">90</span>, <span class="number">270</span>)  </span><br><span class="line">ax.set_ylim(<span class="number">0</span>, <span class="number">90</span>)</span><br><span class="line"></span><br><span class="line">xticklabels = [<span class="string">&quot;&quot;</span>]*<span class="built_in">len</span>(ax.get_xticks())</span><br><span class="line">xticklabels[<span class="number">0</span>] = <span class="string">&quot;East&quot;</span></span><br><span class="line">xticklabels[<span class="built_in">int</span>(<span class="built_in">len</span>(ax.get_xticks())/<span class="number">2</span>)] = <span class="string">&quot;South&quot;</span></span><br><span class="line">xticklabels[-<span class="number">1</span>] = <span class="string">&quot;West&quot;</span></span><br><span class="line">ax.set_xticklabels(xticklabels)</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Azimuthal angle&quot;</span>, fontdict=&#123;<span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, labelpad=<span class="number">12</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;Altitude angle (deg.)&quot;</span>, fontdict=&#123;<span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, pad=<span class="number">90</span>)</span><br><span class="line">ax.yaxis.set_major_locator(MultipleLocator(<span class="number">30</span>))</span><br><span class="line"></span><br><span class="line">plt.legend(lats[<span class="number">1</span>:], bbox_to_anchor=(<span class="number">1</span>,<span class="number">1</span>), frameon=<span class="literal">False</span>, title=<span class="string">&quot;Latitude (deg.)&quot;</span>)</span><br><span class="line"></span><br><span class="line">im_sunrise = plt.imread(<span class="string">&quot;sunrise.png&quot;</span>)</span><br><span class="line">ax_sunrise = fig.add_axes([<span class="number">0.06</span>, <span class="number">0.69</span>, <span class="number">0.1</span>, <span class="number">0.1</span>], anchor=<span class="string">&quot;NW&quot;</span>, zorder=<span class="number">2</span>)</span><br><span class="line">ax_sunrise.imshow(im_sunrise)</span><br><span class="line">ax_sunrise.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line"></span><br><span class="line">im_suntop = plt.imread(<span class="string">&quot;suntop.png&quot;</span>)</span><br><span class="line">ax_suntop = fig.add_axes([<span class="number">0.37</span>, <span class="number">0.69</span>, <span class="number">0.1</span>, <span class="number">0.1</span>], anchor=<span class="string">&quot;NW&quot;</span>, zorder=<span class="number">2</span>)</span><br><span class="line">ax_suntop.imshow(im_suntop)</span><br><span class="line">ax_suntop.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">im_sunset = plt.imread(<span class="string">&quot;sunset.png&quot;</span>)</span><br><span class="line">ax_sunset = fig.add_axes([<span class="number">0.68</span>, <span class="number">0.69</span>, <span class="number">0.1</span>, <span class="number">0.1</span>], anchor=<span class="string">&quot;NW&quot;</span>, zorder=<span class="number">2</span>)</span><br><span class="line">ax_sunset.imshow(im_sunset)</span><br><span class="line">ax_sunset.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><p><img src="5_shadow_3.png"><br></p></li></ul><h3 id="3-건물-그리기"><a href="#3-건물-그리기" class="headerlink" title="3. 건물 그리기"></a>3. 건물 그리기</h3><blockquote><p><a href="https://jehyunlee.github.io/2020/09/14/GIS-Python-2-PolygonShapefile/">Pega Devlog: Create Shapefile from Polygon Dots</a><br><a href="https://jehyunlee.github.io/2020/09/21/GIS-Python-3-raster_and_polygon/">Pega Devlog: Mapping Shapefile on Raster Map</a><br><a href="https://geopandas.org/reference/geopandas.GeoDataFrame.html">geopandas: GeoDataFrame</a></p></blockquote><ul><li>좌표로 사각형을 만드는 함수입니다.</li><li><a href="https://jehyunlee.github.io/2020/09/14/GIS-Python-2-PolygonShapefile/">지난 글</a>에서는 파일로 저장했지만 이번엔 <b>메모리</b>에 올려서 사용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> MultiPoint</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_rec</span>(<span class="params">x, y, width, length, angle</span>):</span></span><br><span class="line">    l_half = length/<span class="number">2</span></span><br><span class="line">    w_half = width/<span class="number">2</span></span><br><span class="line">    a_rad = np.deg2rad(angle)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_coord</span>(<span class="params">l_half, w_half, a_rad</span>):</span></span><br><span class="line">        X = x + l_half * np.sin(a_rad) - w_half * np.cos(a_rad)</span><br><span class="line">        Y = y + l_half * np.cos(a_rad) + w_half * np.sin(a_rad)</span><br><span class="line">        <span class="keyword">return</span> (X, Y)</span><br><span class="line">    </span><br><span class="line">    points = [get_coord(l_half, w_half, a_rad),</span><br><span class="line">              get_coord(-l_half, w_half, a_rad),</span><br><span class="line">              get_coord(-l_half, -w_half, a_rad),</span><br><span class="line">              get_coord(l_half, -w_half, a_rad)</span><br><span class="line">             ]</span><br><span class="line">    </span><br><span class="line">    rec = gpd.GeoDataFrame(&#123;<span class="string">&quot;points&quot;</span>:[points], <span class="string">&quot;geometry&quot;</span>:[MultiPoint(points).convex_hull]&#125;)</span><br><span class="line">    <span class="keyword">return</span> rec</span><br></pre></td></tr></table></figure></li></ul><ul><li>이렇게 만들어진 도형은 <code>geopandas</code>의 GeoDataFrame입니다.</li><li>GeoDataFrame은 <b><code>geometry</code></b>와 함께 <b>다른 데이터</b>를 담을 수 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rec = create_rec(<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">45</span>)</span><br><span class="line">rec</span><br></pre></td></tr></table></figure><img src="5_shadow_15.png"><br></li></ul><ul><li>그린 건물을 확인합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots()</span><br><span class="line">rec.plot(ax=ax)</span><br></pre></td></tr></table></figure><img src="5_shadow_2.png"><br></li></ul><h3 id="4-그림자-그리기"><a href="#4-그림자-그리기" class="headerlink" title="4. 그림자 그리기"></a>4. 그림자 그리기</h3><h4 id="4-1-도시별-시간별-태양-위치"><a href="#4-1-도시별-시간별-태양-위치" class="headerlink" title="4.1. 도시별, 시간별 태양 위치"></a>4.1. 도시별, 시간별 태양 위치</h4><blockquote><p><a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time">wikipedia: Coordinated Universal Time</a><br><a href="https://docs.python.org/3.7/library/datetime.html">python: datetime</a></p></blockquote><ul><li>그림자는 <b>태양 위치</b>와 <b>건물 모양</b>의 결과물입니다.<ul><li>태양의 위치는 <b>시간</b>에 대한 함수로 주어집니다.</li><li>그리고 시간은 <a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time">협정 세계시</a>에 따라 <b>위치</b>별로 다릅니다.<br></li></ul></li></ul><ul><li><p>논문에서 제시한 5개 도시는 거의 <b>동경 75도</b>상에 위치합니다.</p></li><li><p>그러나 적용 시간대가 다릅니다.</p></li><li><p>위의 세 도시는 <b>UTC-5</b>, 아래 두 도시는 <b>UTC-4</b>를 따릅니다.<br><br><img src="5_shadow_16.png"><br></p></li><li><p>도시별 데이터를 만들어 줍니다.</p></li><li><p>Antofagasta와 Los Lagos는 UTC-4입니다.</p></li><li><p>그러나 <b>논문 결과는 UTC-5</b>를 넣어야 구현됩니다.</p></li><li><p>저자의 실수로 생각됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cities = [<span class="string">&quot;Philadelphia&quot;</span>, <span class="string">&quot;Adderly&quot;</span>, <span class="string">&quot;Agua Blanca&quot;</span>, <span class="string">&quot;Antofagasta&quot;</span>, <span class="string">&quot;Los Lagos&quot;</span>]</span><br><span class="line">lats = [<span class="number">39</span>+<span class="number">57</span>/<span class="number">60</span>, <span class="number">23</span>+<span class="number">36</span>/<span class="number">60</span>, -<span class="number">2</span>/<span class="number">60</span>, -(<span class="number">23</span>+<span class="number">39</span>/<span class="number">60</span>), -(<span class="number">39</span>+<span class="number">51</span>/<span class="number">60</span>)]</span><br><span class="line">lons = [-(<span class="number">75</span>+<span class="number">9</span>/<span class="number">60</span>), -(<span class="number">75</span>+<span class="number">18</span>/<span class="number">60</span>), -(<span class="number">75</span>+<span class="number">12</span>/<span class="number">60</span>), -(<span class="number">72</span>+<span class="number">0</span>/<span class="number">60</span>), -(<span class="number">72</span>+<span class="number">50</span>/<span class="number">60</span>)]  <span class="comment"># negative for East Longitude</span></span><br><span class="line">TZs = [-<span class="number">5</span>, -<span class="number">5</span>, -<span class="number">5</span>, -<span class="number">5</span>, -<span class="number">5</span>]  <span class="comment"># &quot;Antofagasta&quot;, &quot;Los Lagos&quot; 데이터 오류?</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>각 <b>도시별, 시간대별 태양의 방위각과 고도</b>를 구합니다.</li><li>시간도 다르기 때문에 <b>도시별 timezone 설정</b>을 해 줍니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### data</span></span><br><span class="line">nlats = <span class="built_in">len</span>(lats)</span><br><span class="line">alts_lat = &#123;&#125;</span><br><span class="line">azis_lat = &#123;&#125;</span><br><span class="line">date_hr_lat = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### altitudes and azimuthal angles</span></span><br><span class="line"><span class="keyword">for</span> i, (lat, lon, TZ) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(lats, lons, TZs)):</span><br><span class="line">    <span class="comment"># timezone</span></span><br><span class="line">    tz = datetime.timezone(datetime.timedelta(hours=TZ))</span><br><span class="line">    </span><br><span class="line">    alts, azis, dates_hr = [], [], []</span><br><span class="line">    <span class="keyword">for</span> hh <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">24</span>):</span><br><span class="line">        <span class="keyword">for</span> mm <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">60</span>, <span class="number">30</span>):</span><br><span class="line">            date_hr = datetime.datetime(<span class="number">2008</span>, <span class="number">3</span>, <span class="number">21</span>, hh, mm, <span class="number">0</span>, tzinfo=tz)</span><br><span class="line">            dates_hr.append(date_hr)</span><br><span class="line">            alt = get_altitude(lat, lon, date_hr)</span><br><span class="line">            azi = get_azimuth(lat, lon, date_hr)</span><br><span class="line">            alts.append(alt)</span><br><span class="line">            azis.append(azi)</span><br><span class="line"></span><br><span class="line">    date_hr_lat[i] = dates_hr</span><br><span class="line">    alts = np.array(alts)      </span><br><span class="line">    alts_lat[i] = alts</span><br><span class="line">    azis = np.array(azis)</span><br><span class="line">    azis_lat[i] = azis</span><br></pre></td></tr></table></figure></li></ul><ul><li>결과를 dataframe으로 정리합니다.</li><li><code>datetime.strftime()</code>을 사용해 <b>시각</b>과 <b>분</b>을 추출하고</li><li>방위각과 고도를 이용해 <b>그림자 끝점</b>을 추출합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">df_solars = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, lat <span class="keyword">in</span> <span class="built_in">enumerate</span>(lats):</span><br><span class="line">    df_solar = pd.DataFrame(&#123;<span class="string">&quot;hh&quot;</span>:[date_hr_lat[i][j].strftime(<span class="string">&quot;%H&quot;</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span>)],</span><br><span class="line">                             <span class="string">&quot;mm&quot;</span>:[date_hr_lat[i][j].strftime(<span class="string">&quot;%M&quot;</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span>)],</span><br><span class="line">                             <span class="string">&quot;azimuth&quot;</span>: azis_lat[i],</span><br><span class="line">                             <span class="string">&quot;altitude&quot;</span>: alts_lat[i],</span><br><span class="line">                             <span class="string">&quot;projection&quot;</span>: np.sin(np.deg2rad(alts_lat[i]))</span><br><span class="line">                            &#125;)</span><br><span class="line">    df_solar[<span class="string">&quot;shadow_len&quot;</span>] = df_solar[<span class="string">&quot;altitude&quot;</span>].apply(<span class="keyword">lambda</span> x: <span class="number">1</span>/np.tan(np.deg2rad(x)) <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> np.nan)</span><br><span class="line">    df_solar[<span class="string">&quot;shadow_dx&quot;</span>] = -df_solar[<span class="string">&quot;shadow_len&quot;</span>] * np.sin(np.deg2rad(df_solar[<span class="string">&quot;azimuth&quot;</span>]))</span><br><span class="line">    df_solar[<span class="string">&quot;shadow_dy&quot;</span>] = -df_solar[<span class="string">&quot;shadow_len&quot;</span>] * np.cos(np.deg2rad(df_solar[<span class="string">&quot;azimuth&quot;</span>]))</span><br><span class="line">    </span><br><span class="line">    df_solars[i] = df_solar</span><br></pre></td></tr></table></figure></li></ul><ul><li>데이터를 확인해 봅니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_solars[<span class="number">0</span>].loc[<span class="number">10</span>:<span class="number">15</span>]</span><br></pre></td></tr></table></figure><img src="5_shadow_17.png"></li></ul><h4 id="4-2-그림자-그리기-함수"><a href="#4-2-그림자-그리기-함수" class="headerlink" title="4.2. 그림자 그리기 함수"></a>4.2. 그림자 그리기 함수</h4><blockquote><p><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/style.html">pandas: styling</a></p></blockquote><ul><li><p>상자 모양 건물의 그림자를 그립니다.</p><ul><li>네 꼭지점에서 각기 <b>그림자 포인트</b>를 찾고</li><li>건물 밑의 <b>네 꼭지점</b>을 연결합니다.</li></ul></li><li><p>앞에서 구해둔 데이터프레임을 이용합니다.</p></li><li><p><code>shadow_dx</code>, <code>shadow_dy</code>를 적용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shadows</span>(<span class="params">src_x, src_y, src_width, src_length, src_height, src_angle, df_solar</span>):</span></span><br><span class="line">    <span class="comment"># shadow points</span></span><br><span class="line">    s_points = []</span><br><span class="line">    rec = create_rec(src_x, src_y, src_width, src_length, src_angle)</span><br><span class="line">    points = rec.loc[<span class="number">0</span>, <span class="string">&quot;points&quot;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> px, py <span class="keyword">in</span> points:</span><br><span class="line">        sx = px + src_height * df_solar[<span class="string">&quot;shadow_dx&quot;</span>].values</span><br><span class="line">        sy = py + src_height * df_solar[<span class="string">&quot;shadow_dy&quot;</span>].values</span><br><span class="line">        s_points.append(<span class="built_in">list</span>(<span class="built_in">zip</span>(sx, sy)))</span><br><span class="line">    </span><br><span class="line">    shadows_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(df_solar.shape[<span class="number">0</span>]):</span><br><span class="line">        mpoints_i = MultiPoint(points + np.array(s_points)[:,i].tolist())</span><br><span class="line">        shadows_list.append(mpoints_i)</span><br><span class="line">    </span><br><span class="line">    shadows = gpd.GeoDataFrame(&#123;<span class="string">&quot;geometry&quot;</span>:shadows_list&#125;)</span><br><span class="line">    <span class="keyword">return</span> shadows</span><br></pre></td></tr></table></figure></li></ul><ul><li>테스트를 해 봅니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shadows_test1 = get_shadows(<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">45</span>, df_solars[<span class="number">0</span>])</span><br><span class="line">shadows_test1.head()</span><br></pre></td></tr></table></figure><img src="5_shadow_18.png"></li></ul><ul><li>그림으로 그려봅니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shadows_test1.loc[<span class="number">17</span>, <span class="string">&quot;geometry&quot;</span>]</span><br></pre></td></tr></table></figure><img src="5_shadow_19.png"></li></ul><ul><li>오른쪽 네 개의 점은 바닥면 점,</li><li>왼쪽 네 개의 점은 윗면이 만든 그림자 점입니다.</li><li>위 함수 15번째 줄에 <code>convex_hull</code>을 넣어 면을 만듭니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shadows_list.append(mpoints_i.convex_hull)</span><br></pre></td></tr></table></figure></li></ul><ul><li>다시 그려봅니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shadows_test2 = get_shadows(<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">45</span>, df_solars[<span class="number">0</span>])</span><br><span class="line">shadows_test2.loc[<span class="number">17</span>, <span class="string">&quot;geometry&quot;</span>]</span><br></pre></td></tr></table></figure><img src="5_shadow_20.png"></li></ul><ul><li>앞서 계산한 <b>태양의 이동</b>을 따라 그림자를 그립니다.</li><li>논문에서 제시한 <b>9:30 AM의 그림자</b>를 추가로 그립니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Circle</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(ncols=<span class="number">5</span>, nrows=<span class="number">2</span>, figsize=(<span class="number">15</span>, <span class="number">6</span>))</span><br><span class="line">axs = axes.ravel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    paper_im = plt.imread(<span class="string">f&quot;paper_<span class="subst">&#123;i&#125;</span>.png&quot;</span>)</span><br><span class="line">    axs[i].imshow(paper_im)</span><br><span class="line">    axs[i].set_xticks([])</span><br><span class="line">    axs[i].set_yticks([])</span><br><span class="line">    [axs[i].spines[k].set_edgecolor(<span class="string">&quot;lightgray&quot;</span>) <span class="keyword">for</span> k <span class="keyword">in</span> axs[i].spines.keys()]</span><br><span class="line">    </span><br><span class="line">    axs[i].set_title(cities[i], fontdict=&#123;<span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, pad=<span class="number">16</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        axs[i].set_ylabel(<span class="string">&quot;Soler-Bientz\net al.&quot;</span>, rotation=<span class="number">0</span>, labelpad=<span class="number">56</span>, </span><br><span class="line">                          fontdict=&#123;<span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>, <span class="string">&quot;ha&quot;</span>:<span class="string">&quot;center&quot;</span>, <span class="string">&quot;va&quot;</span>:<span class="string">&quot;center&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">10</span>):</span><br><span class="line">    shadow = get_shadows_2(<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">45</span>, df_solars[i-<span class="number">5</span>])</span><br><span class="line">    shadow.plot(ax=axs[i], facecolor=<span class="string">&quot;gray&quot;</span>, edgecolor=<span class="string">&quot;w&quot;</span>, alpha=<span class="number">0.1</span>, zorder=<span class="number">1</span>)</span><br><span class="line">    shadow_930.idx = df_solars[i-<span class="number">5</span>].loc[df_solars[i-<span class="number">5</span>][<span class="string">&quot;hh&quot;</span>] == <span class="string">&quot;09&quot;</span>].loc[df_solars[i-<span class="number">5</span>][<span class="string">&quot;mm&quot;</span>] == <span class="string">&quot;30&quot;</span>].index[<span class="number">0</span>]</span><br><span class="line">    shadow_930 = gpd.GeoDataFrame(&#123;<span class="string">&quot;geometry&quot;</span>:[shadow.loc[<span class="number">19</span>, <span class="string">&quot;geometry&quot;</span>]]&#125;)</span><br><span class="line">    shadow_930.plot(ax=axs[i], facecolor=<span class="string">&quot;gray&quot;</span>, edgecolor=<span class="string">&quot;k&quot;</span>, linewidth=<span class="number">1</span>, zorder=<span class="number">2</span>)</span><br><span class="line">    rec.plot(ax=axs[i], zorder=<span class="number">3</span>, facecolor=<span class="string">&quot;w&quot;</span>, edgecolor=<span class="string">&quot;k&quot;</span>, linewidth=<span class="number">1</span>)</span><br><span class="line">    axs[i].set_xlim(-<span class="number">21</span>, <span class="number">21</span>)</span><br><span class="line">    axs[i].set_ylim(-<span class="number">21</span>, <span class="number">21</span>)</span><br><span class="line">    axs[i].set_xticks([])</span><br><span class="line">    axs[i].set_yticks([])</span><br><span class="line">    [axs[i].spines[k].set_edgecolor(<span class="string">&quot;lightgray&quot;</span>) <span class="keyword">for</span> k <span class="keyword">in</span> axs[i].spines.keys()]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># patches</span></span><br><span class="line">    circle = Circle((<span class="number">0</span>, <span class="number">0</span>), <span class="number">15</span>, linewidth=<span class="number">0.5</span>, edgecolor=<span class="string">&quot;gray&quot;</span>, fill=<span class="literal">False</span>)</span><br><span class="line">    axs[i].add_patch(circle)</span><br><span class="line">    axs[i].plot([-<span class="number">15</span>, <span class="number">15</span>], [<span class="number">0</span>, <span class="number">0</span>], linewidth=<span class="number">0.5</span>, color=<span class="string">&quot;gray&quot;</span> )</span><br><span class="line">    axs[i].plot([<span class="number">0</span>, <span class="number">0</span>], [-<span class="number">15</span>, <span class="number">15</span>], linewidth=<span class="number">0.5</span>, color=<span class="string">&quot;gray&quot;</span> )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># annotates</span></span><br><span class="line">    axs[i].annotate(<span class="string">&quot;W&quot;</span>, (-<span class="number">17.5</span>, <span class="number">0</span>), ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;12&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">    axs[i].annotate(<span class="string">&quot;E&quot;</span>, (<span class="number">17.5</span>, <span class="number">0</span>), ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;12&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">    axs[i].annotate(<span class="string">&quot;S&quot;</span>, (<span class="number">0</span>, -<span class="number">17.5</span>), ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;12&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">    axs[i].annotate(<span class="string">&quot;N&quot;</span>, (<span class="number">0</span>, <span class="number">17.5</span>), ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;12&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span>:</span><br><span class="line">        axs[i].set_ylabel(<span class="string">&quot;Jehyun Lee\n(Pega)&quot;</span>, rotation=<span class="number">0</span>, labelpad=<span class="number">56</span>, </span><br><span class="line">                          fontdict=&#123;<span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>, <span class="string">&quot;ha&quot;</span>:<span class="string">&quot;center&quot;</span>, <span class="string">&quot;va&quot;</span>:<span class="string">&quot;center&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">fig.align_ylabels([axs[<span class="number">0</span>], axs[<span class="number">5</span>]])            </span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><img src="5_shadow_10.png"></li></ul><ul><li><b>논문 그림이 거의 똑같이 재현</b>되었습니다.</li><li>태양 <b>방위각</b>, <b>고도</b>와 <b>그림자 넓이</b>를 수치로 비교합시다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shadow area at 9:30</span></span><br><span class="line">azis_summary = []</span><br><span class="line">alts_summary = []</span><br><span class="line">areas_summary = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nlats):</span><br><span class="line">    azi = df_solars[i].loc[<span class="number">19</span>, <span class="string">&quot;azimuth&quot;</span>]</span><br><span class="line">    alt = df_solars[i].loc[<span class="number">19</span>, <span class="string">&quot;altitude&quot;</span>]</span><br><span class="line">    shadow = get_shadows_2(<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">45</span>, df_solars[i])</span><br><span class="line">    shadow_930 = gpd.GeoDataFrame(&#123;<span class="string">&quot;geometry&quot;</span>:[shadow.loc[<span class="number">19</span>, <span class="string">&quot;geometry&quot;</span>]]&#125;)</span><br><span class="line">    </span><br><span class="line">    azis_summary.append(azi-<span class="number">180</span>)</span><br><span class="line">    alts_summary.append(alt)</span><br><span class="line">    areas_summary.append(shadow_930.area.values[<span class="number">0</span>] - <span class="number">24</span>)</span><br><span class="line">    </span><br><span class="line">df_summary = pd.DataFrame(&#123;<span class="string">&quot;Cities&quot;</span>: cities, </span><br><span class="line">                           <span class="string">&quot;azimuth (deg.)&quot;</span>: azis_summary, </span><br><span class="line">                           <span class="string">&quot;altitude (deg.)&quot;</span>: alts_summary, </span><br><span class="line">                           <span class="string">&quot;area (m2)&quot;</span>: areas_summary&#125;)</span><br><span class="line"></span><br><span class="line">df_summary.style.<span class="built_in">format</span>(&#123;<span class="string">&quot;azimuth (deg.)&quot;</span>:<span class="string">&quot;&#123;:.1f&#125;&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;altitude (deg.)&quot;</span>:<span class="string">&quot;&#123;:.1f&#125;&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;area (m2)&quot;</span>:<span class="string">&quot;&#123;:.0f&#125;&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><img src="5_shadow_21.png"></li></ul><ul><li>수치적으로도 <b>거의 똑같이 재현되었습니다.</b></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/GIS/">GIS</category>
      
      <category domain="https://jehyunlee.github.io/categories/GIS/Python/">Python</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/gis/">gis</category>
      
      <category domain="https://jehyunlee.github.io/tags/pysolar/">pysolar</category>
      
      <category domain="https://jehyunlee.github.io/tags/shadow/">shadow</category>
      
      
    </item>
    
    <item>
      <title>pysolar</title>
      <link>https://jehyunlee.github.io/2020/10/13/GIS-Python-4-pysolar/</link>
      <guid>https://jehyunlee.github.io/2020/10/13/GIS-Python-4-pysolar/</guid>
      <pubDate>Mon, 12 Oct 2020 22:46:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;태양 위치 계산은 성가십니다.&lt;/li&gt;
&lt;li&gt;날짜별, 시간별, 위치별 태양의 위치를 알고싶다면 pysolar가 편리합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://pypi.org/project/</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>태양 위치 계산은 성가십니다.</li><li>날짜별, 시간별, 위치별 태양의 위치를 알고싶다면 pysolar가 편리합니다.</li></ul><blockquote><p><a href="https://pypi.org/project/Pysolar/">pysolar pypi</a><br><a href="https://github.com/pingswept/pysolar">pysolar github</a><br><a href="https://pysolar.readthedocs.io/en/latest/">pysolar documentation</a></p></blockquote><h3 id="1-pysolar-설치"><a href="#1-pysolar-설치" class="headerlink" title="1. pysolar 설치"></a>1. pysolar 설치</h3><ul><li>pip로 간단하게 설치할 수 있습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pysolar</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-pysolar-사용"><a href="#2-pysolar-사용" class="headerlink" title="2. pysolar 사용"></a>2. pysolar 사용</h3><ul><li>pysolar를 사용하려면 <code>import</code>를 해야 합니다.</li><li>pysolar를 import 하고 모듈을 확인해보면 뭔가 많습니다.</li><li>그런데 <a href="https://pysolar.readthedocs.io/en/latest/">공식문서</a>에 설명이 잘 나와 있지 않아 아쉽습니다.<br><br><img src="4_pysolar_3.png"></li></ul><ul><li>일시와 위치를 넣어주면 태양에 대한 정보를 알려줍니다.</li><li>일시는 <code>datetime</code>을 이용해 설정합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">KST = datetime.timezone(datetime.timedelta(hours=<span class="number">9</span>))</span><br><span class="line">date = datetime.datetime(<span class="number">2017</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">0</span>, tzinfo=KST)</span><br><span class="line">date</span><br></pre></td></tr></table></figure>실행결과: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datetime.datetime(2017, 3, 21, 13, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=32400)))</span><br></pre></td></tr></table></figure></li></ul><ul><li>그리고 태양을 관찰할 지점을 지정합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Daejeon</span></span><br><span class="line">lat = <span class="number">36.3504</span></span><br><span class="line">lon = <span class="number">127.3845</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-1-고도altitude"><a href="#2-1-고도altitude" class="headerlink" title="2.1. 고도altitude"></a>2.1. 고도<code>altitude</code></h4><ul><li>지표면으로부터의 각도입니다.</li><li><code>.get_altitude()</code>를 사용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pysolar.solar <span class="keyword">import</span> get_altitude</span><br><span class="line"></span><br><span class="line">alt = get_altitude(lat, lon, date)</span><br><span class="line">alt</span><br></pre></td></tr></table></figure>실행결과: 출력 단위는 degree 입니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">53.57702210048166</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-방위각azimuthal-angle"><a href="#2-2-방위각azimuthal-angle" class="headerlink" title="2.2. 방위각azimuthal angle"></a>2.2. 방위각<code>azimuthal angle</code></h4><ul><li>정북 기준 시계방향 각도입니다.</li><li><code>.get_azimuth()</code>를 사용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pysolar.solar <span class="keyword">import</span> get_azimuth</span><br><span class="line"></span><br><span class="line">azi = get_azimuth(lat, lon, date)</span><br><span class="line">azi</span><br></pre></td></tr></table></figure>실행결과: 출력 단위는 degree 입니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">189.44917229657798</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-일사량radiation"><a href="#2-3-일사량radiation" class="headerlink" title="2.3. 일사량radiation"></a>2.3. 일사량<code>radiation</code></h3><blockquote><p><a href="https://pysolar.readthedocs.io/en/latest/index.html?highlight=get_radiation_direct#">pysolar get_radiation_direct()</a></p></blockquote><ul><li>pysolar가 제공하는 일사량에는 <b>대기에 의한 산란</b>이 포함되어 있습니다.</li><li>이 때 <b>대기모델은 미국 기준</b>이기 때문에 데이터 활용에 주의해야 합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pysolar.radiation <span class="keyword">import</span> get_radiation_direct</span><br><span class="line"></span><br><span class="line">rad = get_radiation_direct(date, alt)</span><br><span class="line">rad</span><br></pre></td></tr></table></figure>실행결과: 단위는 <b>$W/m^2$</b> 입니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">961.3376847317991</span><br></pre></td></tr></table></figure></li></ul><ul><li>다음과 같은 수식으로 구성되어 있습니다.</li><li>일사량 $$\textrm{direct radiation} = flux \times exp(-1 \times od \times amr) \times daytime$$<ul><li>$$day$$ : <code>datetime.utctimetuple().tm_yday</code></li><li>$$daytime$$ : <code>1 if altitude &gt; 0 else 0</code></li><li>apparent extraterrestrial flux : $$flux = 1160+(75\sin( \frac{2 \pi}{365}(day-275)))$$</li><li>optical depth : $$od = 0.174+(0.035\sin(\frac{2 \pi}{365}(day-100))$$</li><li>air mass ratio : $$amr = 1/\sin(altitude)$$</li></ul></li></ul><h3 id="2-4-시각화"><a href="#2-4-시각화" class="headerlink" title="2.4. 시각화"></a>2.4. 시각화</h3><ul><li>2017년 춘분 다른 위도의 일주운동을 그려봅니다.<ol><li><b>방위각</b> vs <b>고도</b></li><li><b>시간</b> vs <b>고도</b></li><li><b>시간</b> vs <b>일사량</b> (pysolar 제공)</li><li><b>시간</b> vs <b>사상</b> (projection)</li></ol></li><li>극좌표와 직교좌표계를 동시에를 담습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> matplotlib.ticker <span class="keyword">import</span> MultipleLocator, AutoMinorLocator</span><br><span class="line"></span><br><span class="line">lats = [<span class="number">45</span>, <span class="number">23.5</span>, <span class="number">1</span>, -<span class="number">23.5</span>, -<span class="number">45</span>]</span><br><span class="line">lon = <span class="number">127.3845</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### data</span></span><br><span class="line">nlats = <span class="built_in">len</span>(lats)</span><br><span class="line">alts_lat = &#123;&#125;</span><br><span class="line">azis_lat = &#123;&#125;</span><br><span class="line">date_hr_lat = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### altitudes and azimuthal angles</span></span><br><span class="line"><span class="keyword">for</span> i, lat <span class="keyword">in</span> <span class="built_in">enumerate</span>(lats, <span class="number">1</span>):</span><br><span class="line">    alts, azis, dates_hr = [], [], []</span><br><span class="line">    <span class="keyword">for</span> hr <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">24</span>):</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">min</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">60</span>, <span class="number">1</span>):</span><br><span class="line">            date_hr = datetime.datetime(<span class="number">2017</span>, <span class="number">3</span>, <span class="number">20</span>, hr, <span class="built_in">min</span>, <span class="number">0</span>, tzinfo=KST)</span><br><span class="line">            dates_hr.append(date_hr)</span><br><span class="line">            alt = get_altitude(lat, lon, date_hr)</span><br><span class="line">            azi = get_azimuth(lat, lon, date_hr)</span><br><span class="line">            alts.append(alt)</span><br><span class="line">            azis.append(azi)</span><br><span class="line"></span><br><span class="line">    date_hr_lat[i] = dates_hr</span><br><span class="line">    alts = np.array(alts)      </span><br><span class="line">    alts_lat[i] = alts</span><br><span class="line">    azis = np.array(azis)</span><br><span class="line">    azis_lat[i] = azis</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">### Figure</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">30</span>,<span class="number">24</span>))</span><br><span class="line">axs = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, (lat) <span class="keyword">in</span> <span class="built_in">enumerate</span>(lats, <span class="number">1</span>):  </span><br><span class="line">    axs[i] = fig.add_subplot(<span class="number">5</span>, nlats, i, projection=<span class="string">&#x27;polar&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    axs[i].set_theta_zero_location(<span class="string">&quot;N&quot;</span>)</span><br><span class="line">    axs[i].set_theta_direction(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    axs[i].plot(np.deg2rad(azis_lat[i]), alts_lat[i], c=<span class="string">&quot;k&quot;</span>, zorder=<span class="number">1</span>)</span><br><span class="line">    axs[i].scatter(np.deg2rad(azis_lat[i]), alts_lat[i], c=alts_lat[i], </span><br><span class="line">                   cmap=<span class="string">&quot;inferno&quot;</span>, zorder=<span class="number">2</span>, vmin=<span class="number">0</span>, vmax=<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line">    axs[i].fill(np.deg2rad(azis_lat[i]), [<span class="number">0</span>]*<span class="built_in">len</span>(azis_lat[i]), <span class="string">&quot;gray&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">    axs[i].set_ylim(-<span class="number">80</span>, <span class="number">90</span>)</span><br><span class="line">    axs[i].set_title(<span class="string">f&quot;<span class="subst">&#123;lat&#125;</span>&quot;</span> + <span class="string">&quot; $^&#123;\circ&#125;$&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">32</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, pad=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># azimuth vs altitude</span></span><br><span class="line">hrs = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1440</span>))</span><br><span class="line"><span class="keyword">for</span> i, (lat) <span class="keyword">in</span> <span class="built_in">enumerate</span>(lats, nlats+<span class="number">1</span>):  </span><br><span class="line">    axs[i] = fig.add_subplot(<span class="number">5</span>, nlats, i)</span><br><span class="line">    axs[i].scatter(azis_lat[i-nlats], alts_lat[i-nlats], c=alts_lat[i-nlats], </span><br><span class="line">                   cmap=<span class="string">&quot;inferno&quot;</span>, zorder=<span class="number">2</span>, vmin=<span class="number">0</span>, vmax=<span class="number">90</span>)</span><br><span class="line">    </span><br><span class="line">    axs[i].xaxis.set_major_locator(MultipleLocator(<span class="number">180</span>))</span><br><span class="line">    axs[i].xaxis.set_minor_locator(MultipleLocator(<span class="number">60</span>))</span><br><span class="line">    </span><br><span class="line">    axs[i].set_xlim(<span class="number">0</span>, <span class="number">360</span>)</span><br><span class="line">    axs[i].set_ylim(-<span class="number">90</span>, <span class="number">100</span>)</span><br><span class="line">    yticks = [-<span class="number">90</span>, -<span class="number">60</span>, -<span class="number">30</span>, <span class="number">0</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">90</span>]</span><br><span class="line">    axs[i].set_yticks(yticks)</span><br><span class="line">    axs[i].set_yticklabels(yticks)</span><br><span class="line">    axs[i].tick_params(axis=<span class="string">&quot;both&quot;</span>, labelsize=<span class="number">20</span>)</span><br><span class="line">    axs[i].fill_between(hrs, -<span class="number">90</span>, <span class="number">0</span>, facecolor=<span class="string">&quot;gray&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">    axs[i].set_xlabel(<span class="string">&quot;azimuthal angle (deg.)&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">24</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, labelpad=<span class="number">12</span>)</span><br><span class="line">    <span class="keyword">if</span> i == nlats+<span class="number">1</span>:</span><br><span class="line">        axs[i].set_ylabel(<span class="string">&quot;altitude A (deg.)&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">24</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, labelpad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># time vs altitude</span></span><br><span class="line">hrs = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1440</span>))</span><br><span class="line"><span class="keyword">for</span> i, (lat) <span class="keyword">in</span> <span class="built_in">enumerate</span>(lats, <span class="number">2</span>*nlats+<span class="number">1</span>):  </span><br><span class="line">    axs[i] = fig.add_subplot(<span class="number">5</span>, nlats, i)</span><br><span class="line">    axs[i].scatter(hrs, alts_lat[i-<span class="number">2</span>*nlats], c=alts_lat[i-<span class="number">2</span>*nlats], </span><br><span class="line">                   cmap=<span class="string">&quot;inferno&quot;</span>, zorder=<span class="number">2</span>, vmin=<span class="number">0</span>, vmax=<span class="number">90</span>)</span><br><span class="line">    </span><br><span class="line">    axs[i].xaxis.set_major_locator(MultipleLocator(<span class="number">180</span>))</span><br><span class="line">    axs[i].xaxis.set_minor_locator(MultipleLocator(<span class="number">60</span>))</span><br><span class="line">    </span><br><span class="line">    axs[i].set_xlim(<span class="number">0</span>, <span class="number">1440</span>)</span><br><span class="line">    axs[i].set_ylim(-<span class="number">90</span>, <span class="number">100</span>)</span><br><span class="line">    xticks = [<span class="built_in">int</span>(x//<span class="number">60</span>) <span class="keyword">for</span> x <span class="keyword">in</span> axs[i].get_xticks()]</span><br><span class="line">    axs[i].set_xticklabels(xticks)</span><br><span class="line">    axs[i].set_xlabel(<span class="string">&quot;time (hour)&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">24</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, labelpad=<span class="number">12</span>)</span><br><span class="line">    yticks = [-<span class="number">90</span>, -<span class="number">60</span>, -<span class="number">30</span>, <span class="number">0</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">90</span>]</span><br><span class="line">    axs[i].set_yticks(yticks)</span><br><span class="line">    axs[i].set_yticklabels(yticks)</span><br><span class="line">    axs[i].tick_params(axis=<span class="string">&quot;both&quot;</span>, labelsize=<span class="number">20</span>)</span><br><span class="line">    axs[i].fill_between(hrs, -<span class="number">90</span>, <span class="number">0</span>, facecolor=<span class="string">&quot;gray&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">2</span>*nlats+<span class="number">1</span>:</span><br><span class="line">        axs[i].set_ylabel(<span class="string">&quot;altitude A (deg.)&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">24</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, labelpad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># irradiation accounting for the scattering of light (by US atmosphere model)     </span></span><br><span class="line"><span class="keyword">for</span> i, lat <span class="keyword">in</span> <span class="built_in">enumerate</span>(lats, <span class="number">3</span>*nlats+<span class="number">1</span>):</span><br><span class="line">    axs[i] = fig.add_subplot(<span class="number">5</span>, nlats, i)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># irradiation by pysolar</span></span><br><span class="line">    irrs_pysolar = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(date_hr_lat[i-(<span class="number">3</span>*nlats)])):</span><br><span class="line">        irr_pysolar = get_radiation_direct(date_hr_lat[i-(<span class="number">3</span>*nlats)][j], </span><br><span class="line">                                           alts_lat[i-(<span class="number">3</span>*nlats)][j])</span><br><span class="line">        irrs_pysolar.append(irr_pysolar)</span><br><span class="line">    </span><br><span class="line">    axs[i].scatter(hrs, irrs_pysolar, c=irrs_pysolar, </span><br><span class="line">                   cmap=<span class="string">&quot;copper&quot;</span>, zorder=<span class="number">2</span>, vmin=<span class="number">0</span>, vmax=<span class="number">1100</span>)</span><br><span class="line">    axs[i].xaxis.set_major_locator(MultipleLocator(<span class="number">180</span>))</span><br><span class="line">    axs[i].xaxis.set_minor_locator(MultipleLocator(<span class="number">60</span>))</span><br><span class="line">    axs[i].set_xlim(<span class="number">0</span>, <span class="number">1440</span>)</span><br><span class="line">    xticks = [<span class="built_in">int</span>(x//<span class="number">60</span>) <span class="keyword">for</span> x <span class="keyword">in</span> axs[i].get_xticks()]</span><br><span class="line">    axs[i].set_xticklabels(xticks)</span><br><span class="line">    axs[i].set_xlabel(<span class="string">&quot;time (hour)&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">24</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, labelpad=<span class="number">12</span>)</span><br><span class="line">    axs[i].tick_params(axis=<span class="string">&quot;both&quot;</span>, labelsize=<span class="number">20</span>)   </span><br><span class="line">    axs[i].set_ylim(<span class="number">0</span>, <span class="number">1100</span>)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">3</span>*nlats+<span class="number">1</span>:</span><br><span class="line">        axs[i].set_ylabel(<span class="string">&quot;solar irradiation (W/m2)\n incl. diffuse irradiation&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">24</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, labelpad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># direct irradiation, above the atmosphere </span></span><br><span class="line"><span class="keyword">for</span> i, lat <span class="keyword">in</span> <span class="built_in">enumerate</span>(lats, <span class="number">4</span>*nlats+<span class="number">1</span>):</span><br><span class="line">    axs[i] = fig.add_subplot(<span class="number">5</span>, nlats, i)</span><br><span class="line">    irradiation = np.sin(np.deg2rad(alts_lat[i-(<span class="number">4</span>*nlats)]))</span><br><span class="line">    axs[i].scatter(hrs, irradiation, c=irradiation, </span><br><span class="line">                   cmap=<span class="string">&quot;copper&quot;</span>, zorder=<span class="number">2</span>, vmin=<span class="number">0</span>, vmax=<span class="number">1</span>)</span><br><span class="line">    axs[i].xaxis.set_major_locator(MultipleLocator(<span class="number">180</span>))</span><br><span class="line">    axs[i].xaxis.set_minor_locator(MultipleLocator(<span class="number">60</span>))</span><br><span class="line">    axs[i].set_xlim(<span class="number">0</span>, <span class="number">1440</span>)</span><br><span class="line">    xticks = [<span class="built_in">int</span>(x//<span class="number">60</span>) <span class="keyword">for</span> x <span class="keyword">in</span> axs[i].get_xticks()]</span><br><span class="line">    axs[i].set_xticklabels(xticks)</span><br><span class="line">    axs[i].set_xlabel(<span class="string">&quot;time (hour)&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">24</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, labelpad=<span class="number">12</span>)</span><br><span class="line">    axs[i].tick_params(axis=<span class="string">&quot;both&quot;</span>, labelsize=<span class="number">20</span>)   </span><br><span class="line">    axs[i].set_ylim(<span class="number">0</span>, <span class="number">1.2</span>)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">4</span>*nlats+<span class="number">1</span>:</span><br><span class="line">        axs[i].set_ylabel(<span class="string">&quot;projection &quot;</span> + <span class="string">&quot;$cos(A)$&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">24</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, labelpad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">fig.align_ylabels([axs[<span class="number">1</span>], axs[<span class="number">6</span>], axs[<span class="number">11</span>], axs[<span class="number">16</span>], axs[<span class="number">21</span>]])    </span><br><span class="line">fig.tight_layout()      </span><br></pre></td></tr></table></figure><img src="4_pysolar_1.png" alt="위도에 따라 태양의 움직임이 다릅니다."><br></li></ul><ul><li>일주운동의 연중 변화를 살펴봅니다.</li><li>지역은 <b>대전</b>으로 고정하고 날짜만 <b>춘분</b>, <b>하지</b>, <b>추분</b>, <b>동지</b>로 나눕니다.<ol><li><b>방위각</b> vs <b>고도</b></li><li><b>시간</b> vs 높이가 1인 막대기의 <b>그림자 끝 위치</b></li></ol></li></ul><ul><li>시각화 코드입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Daejeon</span></span><br><span class="line">lat = <span class="number">36.3504</span></span><br><span class="line">lon = <span class="number">127.3845</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dates</span></span><br><span class="line">months = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>]</span><br><span class="line">dates = [<span class="number">21</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">22</span>]</span><br><span class="line">colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;purple&quot;</span>]</span><br><span class="line">markers = [<span class="string">&quot;x&quot;</span>, <span class="string">&quot;^&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;o&quot;</span>]</span><br><span class="line"></span><br><span class="line">alts, azis = &#123;&#125;, &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> month, date <span class="keyword">in</span> <span class="built_in">zip</span>(months, dates):</span><br><span class="line">    alts[month], azis[month] = [], []</span><br><span class="line">    <span class="keyword">for</span> hr <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">24</span>):</span><br><span class="line">        <span class="keyword">for</span> minu <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">60</span>, <span class="number">30</span>):</span><br><span class="line">            date_hr = datetime.datetime(<span class="number">2017</span>, month, date, hr, minu, <span class="number">0</span>, tzinfo=KST)</span><br><span class="line">            alt = get_altitude(lat, lon, date_hr)</span><br><span class="line">            azi = get_azimuth(lat, lon, date_hr)</span><br><span class="line">            alts[month].append(alt)</span><br><span class="line">            azis[month].append(azi)</span><br><span class="line">    </span><br><span class="line">    alts[month] = np.array(alts[month])        </span><br><span class="line">    azis[month] = np.array(azis[month])</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="comment">### visualziation</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># diurnal motion</span></span><br><span class="line">ax1 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, projection=<span class="string">&#x27;polar&#x27;</span>)</span><br><span class="line">ax1.set_theta_zero_location(<span class="string">&quot;N&quot;</span>)</span><br><span class="line">ax1.set_theta_direction(-<span class="number">1</span>)</span><br><span class="line">ax1.fill(np.deg2rad(azis[<span class="number">3</span>]), [<span class="number">0</span>]*<span class="built_in">len</span>(azis[<span class="number">3</span>]), <span class="string">&quot;gray&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> month, marker, color <span class="keyword">in</span> <span class="built_in">zip</span>(months, markers, colors):</span><br><span class="line">    ax1.plot(np.deg2rad(azis[month]), alts[month], c=color, zorder=<span class="number">1</span>)</span><br><span class="line">    im1 = ax1.scatter(np.deg2rad(azis[month]), alts[month], marker=marker,</span><br><span class="line">                      c=alts[month], ec=color, lw=<span class="number">1</span>, cmap=<span class="string">&quot;inferno&quot;</span>, </span><br><span class="line">                      vmin=<span class="number">0</span>, vmax=<span class="number">90</span>, zorder=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cbar1 = plt.colorbar(im1, ax=ax1, fraction=<span class="number">0.046</span>, pad=<span class="number">0.15</span>, ticks= [<span class="number">0</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">90</span>])</span><br><span class="line">cbar1.set_label(<span class="string">&quot;altitude (deg.)&quot;</span>, fontsize=<span class="number">20</span>, labelpad=<span class="number">12</span>)    </span><br><span class="line"></span><br><span class="line">ax1.set_title(<span class="string">&quot;diurnal motion&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">20</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, pad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># shadow</span></span><br><span class="line">ax2 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, projection=<span class="string">&#x27;polar&#x27;</span>)</span><br><span class="line">ax2.set_theta_zero_location(<span class="string">&quot;N&quot;</span>)</span><br><span class="line">ax2.set_theta_direction(-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># cmaps = [&quot;Reds_r&quot;, &quot;Greens_r&quot;, &quot;Blues_r&quot;, &quot;Purples_r&quot;]</span></span><br><span class="line">time_arr = np.linspace(<span class="number">0</span>, <span class="number">47</span>, <span class="number">48</span>)/<span class="number">2</span></span><br><span class="line">handles = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> month, color, marker <span class="keyword">in</span> <span class="built_in">zip</span>(months, colors, markers):</span><br><span class="line">    shadow_idx = np.where(alts[month]&gt;<span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">    shadow_azis_rad = np.deg2rad(azis[month][shadow_idx]+<span class="number">180</span>)</span><br><span class="line">    shadow_lengths = <span class="number">1</span>/np.tan(np.deg2rad(alts[month][shadow_idx]))</span><br><span class="line">    ax2.plot(shadow_azis_rad, shadow_lengths, c=color, zorder=<span class="number">1</span>)</span><br><span class="line">    im2 = ax2.scatter(shadow_azis_rad, shadow_lengths, marker=marker,</span><br><span class="line">                      c=time_arr[shadow_idx], ec=color, lw=<span class="number">1</span>, cmap=<span class="string">&quot;gist_gray&quot;</span>, </span><br><span class="line">                      vmin=<span class="number">0</span>, vmax=<span class="number">23.5</span>, zorder=<span class="number">2</span>)</span><br><span class="line">    handles.append(im2)</span><br><span class="line">    </span><br><span class="line">ax2.set_ylim(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">ax2.yaxis.set_major_locator(MultipleLocator(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">cbar2 = plt.colorbar(im2, ax=ax2, fraction=<span class="number">0.046</span>, pad=<span class="number">0.15</span>, ticks= <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">28</span>, <span class="number">4</span>)))</span><br><span class="line">cbar2.set_label(<span class="string">&quot;time (hour)&quot;</span>, fontsize=<span class="number">20</span>, labelpad=<span class="number">12</span>)    </span><br><span class="line"></span><br><span class="line">ax2.set_title(<span class="string">&quot;shadow motion&quot;</span>, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">20</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;, pad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">fig.legend(handles=handles, labels=[<span class="string">&quot;spring equinox&quot;</span>, <span class="string">&quot;summer soliste&quot;</span>, <span class="string">&quot;autumn equinox&quot;</span>, <span class="string">&quot;winter soliste&quot;</span>],</span><br><span class="line">           ncol=<span class="number">4</span>, bbox_to_anchor=(<span class="number">0.</span>, <span class="number">0.9</span>, <span class="number">1.</span>, <span class="number">.1</span>), mode=<span class="string">&quot;expand&quot;</span>)</span><br><span class="line">fig.tight_layout(rect=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.9</span>])   </span><br></pre></td></tr></table></figure><img src="4_pysolar_2.png" alt="계절에 따라 하루 중 태양과 그림자의 움직임이 다릅니다."><br></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/GIS/">GIS</category>
      
      <category domain="https://jehyunlee.github.io/categories/GIS/Python/">Python</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/gis/">gis</category>
      
      <category domain="https://jehyunlee.github.io/tags/pysolar/">pysolar</category>
      
      
    </item>
    
    <item>
      <title>데이터 과학자</title>
      <link>https://jehyunlee.github.io/2020/10/11/Python-DS-38-xstem_2020/</link>
      <guid>https://jehyunlee.github.io/2020/10/11/Python-DS-38-xstem_2020/</guid>
      <pubDate>Sun, 11 Oct 2020 07:06:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;2020 대전 사이언스 페스티벌에서 발표한 &lt;b&gt;“데이터 과학자”&lt;/b&gt; 영상입니다.&lt;/li&gt;
&lt;li&gt;데이터 과학자라는 직업에 대해 2020년 10월 시점에서 정리했습니다.&lt;/li&gt;
&lt;li&gt;30년 전의 저를 가상의 청중으로 생각했습니다</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>2020 대전 사이언스 페스티벌에서 발표한 <b>“데이터 과학자”</b> 영상입니다.</li><li>데이터 과학자라는 직업에 대해 2020년 10월 시점에서 정리했습니다.</li><li>30년 전의 저를 가상의 청중으로 생각했습니다.</li></ul><blockquote><p><a href="http://xstem.co.kr/Home/Index">2020 X-STEM 집콕 과학진로 온리인축제</a></p></blockquote><p><img src="38_xstem_2020_1.png"></p><div class="video-container"><iframe src="https://www.youtube.com/embed/2H0afV3a1vk" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p><a href="http://xstem.co.kr/home/quiz">강연 &amp; 퀴즈 홈페이지</a></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/HelloDD/">HelloDD</category>
      
      <category domain="https://jehyunlee.github.io/tags/X-STEM/">X-STEM</category>
      
      <category domain="https://jehyunlee.github.io/tags/Daejeon-Science-Festival/">Daejeon Science Festival</category>
      
      <category domain="https://jehyunlee.github.io/tags/Data-Scienctist/">Data Scienctist</category>
      
      
    </item>
    
    <item>
      <title>Seaborn with Matplotlib (4)</title>
      <link>https://jehyunlee.github.io/2020/10/10/Python-DS-37-seaborn_matplotlib4/</link>
      <guid>https://jehyunlee.github.io/2020/10/10/Python-DS-37-seaborn_matplotlib4/</guid>
      <pubDate>Fri, 09 Oct 2020 20:12:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;4-seaborn-figure-level-다듬기&quot;&gt;&lt;a href=&quot;#4-seaborn-figure-level-다듬기&quot; class=&quot;headerlink&quot; title=&quot;4. seaborn figure-level 다듬기&quot;&gt;&lt;/a&gt;4. seab</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="4-seaborn-figure-level-다듬기"><a href="#4-seaborn-figure-level-다듬기" class="headerlink" title="4. seaborn figure-level 다듬기"></a>4. seaborn <code>figure-level</code> 다듬기</h2><ul><li>seaborn + matplotlib 마지막 시간입니다.</li><li><code>figure-level</code> 그림을 그리고 다듬어 봅니다.</li><li>자체적으로 지원하는 명령어를 사용해보고,</li><li>개흉 심장마사지 방법을 알아보겠습니다.</li></ul><blockquote><p><a href="https://seaborn.pydata.org/api.html">seaborn API</a><br><a href="https://seaborn.pydata.org/tutorial.html">seaborn tutorial</a><br><a href="https://jehyunlee.github.io/2020/10/06/Python-DS-36-seaborn_matplotlib3/">seaborn with matplotlib (3)</a></p></blockquote><h3 id="4-1-figure-level으로-편리하게-그리기-pairplot"><a href="#4-1-figure-level으로-편리하게-그리기-pairplot" class="headerlink" title="4.1. figure-level으로 편리하게 그리기: pairplot()"></a>4.1. <code>figure-level</code>으로 편리하게 그리기: <code>pairplot()</code></h3><blockquote><p><a href="https://en.wikipedia.org/wiki/Exploratory_data_analysis">wikipedia: Exploratory data analysis</a><br><a href="https://en.wikipedia.org/wiki/Anscombe%27s_quartet">wikipedia: Anscombe’s quartet</a><br><a href="https://www.autodesk.com/research/publications/same-stats-different-graphs">autodesk: datasaurus</a><br><a href="https://seaborn.pydata.org/generated/seaborn.pairplot.html#seaborn.pairplot">seaborn.pairplot</a></p></blockquote><ul><li><a href="https://en.wikipedia.org/wiki/Exploratory_data_analysis">EDA</a>에서 피할 수 없는 과정이 상관도입니다.<ul><li>두 변수 사이의 관계를 그려 관계를 파악합니다.</li><li>대개 산점도<code>scatter plot</code>나 밀도 함수<code>density plot</code>를 쓰고,</li><li>추세선<code>regression</code>을 덧붙이는 경우도 있습니다.</li></ul></li></ul><ul><li>데이터 분포는 통계값으로만 확인하면 안됩니다.<ul><li><b>평균과 표준편차는 같은데 분포는 다른 경우</b>가 많습니다.</li><li><b>반드시 분포를 그려 봐야</b> 합니다.</li><li><a href="https://en.wikipedia.org/wiki/Anscombe%27s_quartet">Anscombe’s quartet</a>이 아주 좋은 예시입니다.<br><img src="37_s2m4_6.png" alt="Anscombe&#39;s quartet"></li></ul></li></ul><ul><li>N개의 인자 사이에는 $ \frac{N(N-1)}{2} $가지 관계가 있습니다.</li><li>seaborn의 <code>pairplot()</code>은 여러 인자 사이의 수많은 상관도를 쉽게 그려줍니다.</li></ul><ul><li><p>붓꽃<code>iris</code> 데이터셋으로 상관도를 그려봅니다.</p><ul><li>꽃받침<code>sepal</code>과 꽃잎<code>petal</code>,</li><li>길이<code>length</code>와 폭<code>width</code> 네 가지 인자로부터 </li><li>여섯 가지의 상관도, </li><li>네 가지의 히스토그램이 나옵니다.</li></ul></li><li><p>코드 한 줄로 그려봅시다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">iris = sns.load_dataset(<span class="string">&quot;iris&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="37_s2m4_1.png"></p></li></ul><ul><li>종<code>species</code>별 분포를 그려봅니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = sns.pairplot(iris, hue=<span class="string">&quot;species&quot;</span>)</span><br></pre></td></tr></table></figure><img src="37_s2m4_2.png"></li></ul><ul><li><code>hue=</code>라는 인자 하나만 추가했을 뿐입니다.<ul><li>그림이 갑자기 예뻐졌습니다.</li><li>히스토그램도 밀도함수로 바뀌어서 훨씬 보기 좋습니다.</li></ul></li></ul><ul><li>여기에 다른 그림을 겹쳐보겠습니다.<ul><li><b>대각선 위 :</b> 2차원 밀도함수 + 추세선</li><li><b>대각선 아래 :</b> 2차원 밀도함수 + 산포도</li></ul></li></ul><ul><li>seaborn <code>figure-level</code> 기능만으로 가능합니다.</li><li><code>.map_lower()</code>와 <code>.map_upper</code>를 사용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = sns.pairplot(iris, hue=<span class="string">&quot;species&quot;</span>, kind=<span class="string">&quot;kde&quot;</span>, plot_kws=&#123;<span class="string">&quot;alpha&quot;</span>:<span class="number">0.3</span>&#125;)</span><br><span class="line">g.map_lower(sns.scatterplot)</span><br><span class="line">g.map_upper(sns.regplot, scatter=<span class="literal">False</span>, truncate=<span class="literal">False</span>, ci=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><img src="37_s2m4_3.png"></li></ul><ul><li><code>map_lower()</code>와 <code>map_upper()</code>는 대각선의 위와 아래에 <b>그림을 덧씌우는<code>map</code> 함수</b>입니다.<ul><li>앞서 완성한 pairplot에 새로운 그림을 덧붙입니다.</li><li>인자로는 <b>함수 이름</b>과 <b>이 함수의 옵션들</b>을 연달아 넣어 줍니다.</li><li>함수에 맞는 인자를 넣어줘야 합니다.</li></ul></li></ul><h3 id="4-2-figure-level-그림-뼈대부터-세우기-PairGrid"><a href="#4-2-figure-level-그림-뼈대부터-세우기-PairGrid" class="headerlink" title="4.2. figure-level 그림 뼈대부터 세우기: PairGrid()"></a>4.2. <code>figure-level</code> 그림 뼈대부터 세우기: <code>PairGrid()</code></h3><blockquote><p><a href="https://seaborn.pydata.org/generated/seaborn.PairGrid.html">seaborn.PairGrid</a></p></blockquote><ul><li><p>pairplot을 단계별로 그리는 방법입니다.</p><ul><li>코드 양은 <code>pairplot()</code>한 줄보다 늘어납니다.</li><li>그러나 자유도가 늘어납니다.</li></ul></li><li><p><code>.pairplot()</code> 으로는 위 아래를 완전히 다르게 할 수 없습니다.</p></li><li><p>대각선의 아래엔 산점도와 추세선을 그리고</p></li><li><p>대각선 위에는 밀도함수만 그려보겠습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 틀 만들기</span></span><br><span class="line">g = sns.PairGrid(iris, hue=<span class="string">&quot;species&quot;</span>, diag_sharey=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># diagonal</span></span><br><span class="line">g.map_diag(sns.kdeplot, fill=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># lower</span></span><br><span class="line">g.map_lower(plt.scatter, s=<span class="number">30</span>, edgecolor=<span class="string">&quot;w&quot;</span>)</span><br><span class="line">g.map_lower(sns.regplot, scatter=<span class="literal">False</span>, truncate=<span class="literal">False</span>, ci=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># upper</span></span><br><span class="line">g.map_upper(sns.kdeplot, alpha=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># legend</span></span><br><span class="line">g.add_legend()</span><br></pre></td></tr></table></figure><p><img src="37_s2m4_4.png"></p></li></ul><ul><li><code>.pairplot()</code>과 같은 형식의 그림이 나왔습니다.</li><li>내 의도를 더 잘 반영할 수 있게 되었습니다.</li><li>8번째 줄에는 <code>plt.scatter</code>가 들어가 있습니다. </li><li><code>.pairplot()</code>도 마찬가지지만 <code>.map()</code>에는 seaborn대신 matplotlib 함수를 사용할 수 있습니다.</li></ul><ul><li>중복되는 오른쪽 윗부분을 생략할 수 있습니다.</li><li><code>corner=True</code>를 넣어줍니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">g = sns.PairGrid(iris, hue=<span class="string">&quot;species&quot;</span>, diag_sharey=<span class="literal">False</span>, corner=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># diagonal</span></span><br><span class="line">g.map_diag(sns.kdeplot, fill=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># lower</span></span><br><span class="line">g.map_lower(plt.scatter, s=<span class="number">30</span>, edgecolor=<span class="string">&quot;w&quot;</span>)</span><br><span class="line">g.map_lower(sns.regplot, scatter=<span class="literal">False</span>, truncate=<span class="literal">False</span>, ci=<span class="literal">False</span>)</span><br><span class="line">g.map_lower(sns.kdeplot, alpha=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># legend</span></span><br><span class="line">g.add_legend()</span><br></pre></td></tr></table></figure><img src="37_s2m4_5.png"></li></ul><ul><li>이제 작은 수정을 해봅니다.<ol><li>대각선에 <b>사각 테두리</b> 치기</li><li><b>범례를 그림 안으로</b> 가져오기</li></ol></li></ul><ul><li>가슴을 열고 심장마사지를 할 시간입니다.</li></ul><h3 id="4-3-figure-level-그림-객체-접근"><a href="#4-3-figure-level-그림-객체-접근" class="headerlink" title="4.3. figure-level 그림 객체 접근"></a>4.3. <code>figure-level</code> 그림 객체 접근</h3><blockquote><p><a href="https://seaborn.pydata.org/generated/seaborn.FacetGrid.html?highlight=facetgrid#seaborn.FacetGrid">seaborn.FacetGrid</a><br><a href="https://matplotlib.org/api/_as_gen/matplotlib.figure.Figure.html">matplotlib.figure.Figure</a><br><a href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes">matplotlib.axes.Axes</a></p></blockquote><ul><li>matplolib 그림은 <a href="https://matplotlib.org/api/_as_gen/matplotlib.figure.Figure.html"><b>figure</b></a>와 <a href="https://matplotlib.org/3.3.2/api/axes_api.html"><b>axes</b></a>로 나뉩니다.<ul><li>seaborn 그림도 결국 matplotlib 그림입니다.</li><li><b>seaborn의 figure와 axes</b>에 접근하면 됩니다.</li></ul></li></ul><h4 id="4-3-1-axes-axes"><a href="#4-3-1-axes-axes" class="headerlink" title="4.3.1. axes: .axes"></a>4.3.1. axes: <code>.axes</code></h4><ul><li><a href="https://jehyunlee.github.io/2020/10/03/Python-DS-35-seaborn_matplotlib2/">이전 글</a>에서 <code>axes</code>를 이용해 jointplot을 재현했습니다.</li><li>axes 객체는 <b><code>.axes</code></b>를 이용해 접근 가능합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.axes</span><br></pre></td></tr></table></figure><img src="37_s2m4_8.png"></li></ul><ul><li>확인 결과 <code>AxesSubplot</code>의 array입니다.</li></ul><h5 id="4-3-1-1-특정-axes-윤곽선-그리기"><a href="#4-3-1-1-특정-axes-윤곽선-그리기" class="headerlink" title="4.3.1.1. 특정 axes 윤곽선 그리기"></a>4.3.1.1. 특정 axes 윤곽선 그리기</h5><blockquote><p><a href="https://jehyunlee.github.io/2020/10/03/Python-DS-35-seaborn_matplotlib2/">Seaborn with Matplotlib (2)</a><br><a href="https://jehyunlee.github.io/2020/08/27/Python-DS-28-mpl_spines_grids/">Spines &amp; Grids</a></p></blockquote><ul><li>정체를 알았으니 <code>axes[i][j]</code>로 접근할 수 있습니다.</li><li><code>g.axes[i][j]</code>의 spine을 보이게 합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">g = sns.PairGrid(iris, hue=<span class="string">&quot;species&quot;</span>, diag_sharey=<span class="literal">False</span>, corner=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># diagonal</span></span><br><span class="line">g.map_diag(sns.kdeplot, fill=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    g.axes[i][i].spines[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">True</span>)</span><br><span class="line">    g.axes[i][i].spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">True</span>)</span><br><span class="line">    g.axes[i][i].spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># lower</span></span><br><span class="line">g.map_lower(plt.scatter, s=<span class="number">30</span>, edgecolor=<span class="string">&quot;w&quot;</span>)</span><br><span class="line">g.map_lower(sns.regplot, scatter=<span class="literal">False</span>, truncate=<span class="literal">False</span>, ci=<span class="literal">False</span>)</span><br><span class="line">g.map_lower(sns.kdeplot, alpha=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># legend</span></span><br><span class="line">g.add_legend()</span><br></pre></td></tr></table></figure><img src="37_s2m4_16.png"></li></ul><h5 id="4-3-1-2-범례-조정"><a href="#4-3-1-2-범례-조정" class="headerlink" title="4.3.1.2. 범례 조정"></a>4.3.1.2. 범례 조정</h5><blockquote><p><a href="https://github.com/mwaskom/seaborn/blob/master/seaborn/axisgrid.py">seaborn axisgrid.py 소스코드</a><br><a href="https://matplotlib.org/3.3.1/api/_as_gen/matplotlib.axes.Axes.get_legend_handles_labels.html">matplotlib.axes.Axes.get_legend_handles_labels</a><br><a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.legend.html?highlight=legend#matplotlib.axes.Axes.legend">matplotlib.axes.Axes.legend</a></p></blockquote><ul><li>legend 정보를 가져와서 legend로 삽입합니다.<ul><li>대개 legend에 필요한 handles와 labels는 <a href="https://matplotlib.org/3.3.1/api/_as_gen/matplotlib.axes.Axes.get_legend_handles_labels.html"><code>.get_legend_handles_labels()</code></a>로 가져옵니다.</li><li>하지만 seaborn <code>figure-level</code> 그림엔 이 명령이 통하지 않습니다.</li><li>private처럼 보이는 <b><code>._legend_data</code></b>를 사용합니다.</li><li><b>공식 문서에 없습니다. 소스 코드를 뒤적여야 합니다.</b></li></ul></li></ul><ul><li><code>._legend_data</code> 정체를 확인합니다.</li><li>범례가 <code>dict</code> 형식으로 들어 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g._legend_data</span><br></pre></td></tr></table></figure><img src="37_s2m4_10.png"></li></ul><ul><li>아래 코드를 추가하여 범례를 이동합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">handles = g._legend_data.values()</span><br><span class="line">labels = g._legend_data.keys()</span><br><span class="line"></span><br><span class="line"><span class="comment"># axes[1][0] 기준으로 오른쪽 멀리 범례 삽입</span></span><br><span class="line">g.axes[<span class="number">1</span>][<span class="number">0</span>].legend(handles=handles, labels=labels,</span><br><span class="line">                    bbox_to_anchor=(<span class="number">3.45</span>, <span class="number">1</span>),</span><br><span class="line">                    fontsize=<span class="string">&quot;large&quot;</span>, frameon=<span class="literal">False</span></span><br><span class="line">                   )</span><br></pre></td></tr></table></figure><img src="37_s2m4_9.png"></li></ul><ul><li>이런 방식으로 특정 axes만 제어할 수 있습니다.<ul><li><b>원하는 그림, 글자</b>을 넣을 수 있고</li><li><b>특정 데이터의 색상</b>을 변경할 수 있습니다.</li></ul></li></ul><h4 id="4-3-2-figure-fig"><a href="#4-3-2-figure-fig" class="headerlink" title="4.3.2. figure: .fig"></a>4.3.2. figure: <code>.fig</code></h4><ul><li>개별 공간은 axes로 제어하지만</li><li>여러 axes가 연관된 공간은 figure로 제어합니다.</li><li>figure 객체는 <b><code>.fig</code></b>를 이용해 접근 가능합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>(g.fig)</span><br></pre></td></tr></table></figure><img src="37_s2m4_11.png"></li></ul><ul><li><code>type()</code>으로 감싸주지 않으면 그림이 통으로 출력됩니다.</li></ul><h5 id="4-3-2-1-ylabel-alignment"><a href="#4-3-2-1-ylabel-alignment" class="headerlink" title="4.3.2.1. ylabel alignment"></a>4.3.2.1. ylabel alignment</h5><blockquote><p><a href="https://matplotlib.org/3.3.1/api/_as_gen/matplotlib.figure.Figure.html?highlight=align_ylabels#matplotlib.figure.Figure.align_ylabels">matplolib.figure.Figure #align_ylabels</a><br><a href="https://matplotlib.org/3.3.1/gallery/pyplots/align_ylabels.html">matplotlib Align y-labels</a></p></blockquote><ul><li>위 그림에서 ylabel 줄이 잘 맞지 않습니다.<ul><li>맨 왼쪽 아래 axes[3][0]의 label이 비죽 나왔네요.</li><li>다른 ylabel을 움직여서 열을 맞춰 봅시다.</li></ul></li></ul><ul><li>위 그림 코드의 맨 마지막 줄에 한 줄만 추가합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.fig.align_ylabels(g.axes[:,<span class="number">0</span>])</span><br></pre></td></tr></table></figure><img src="37_s2m4_12.png"></li></ul><h5 id="4-3-2-2-범례-조정"><a href="#4-3-2-2-범례-조정" class="headerlink" title="4.3.2.2. 범례 조정"></a>4.3.2.2. 범례 조정</h5><blockquote><p><a href="https://matplotlib.org/3.3.1/api/_as_gen/matplotlib.figure.Figure.html?highlight=legend#matplotlib.figure.Figure.legend">matplolib.figure.Figure #legend</a></p></blockquote><ul><li>범례는 figure 기준으로도 삽입 가능합니다.</li><li>아래 코드는 위의 <code>axes[1][0].legend()</code>와 동일합니다.</li><li>전체적인 그림의 위치를 잡을 수 있어 더 좋습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g.fig.legend(handles=handles, labels=labels,</span><br><span class="line">             bbox_to_anchor=(<span class="number">0.75</span>, <span class="number">0.75</span>),</span><br><span class="line">             fontsize=<span class="string">&quot;large&quot;</span>)</span><br></pre></td></tr></table></figure><img src="37_s2m4_13.png"></li></ul><h5 id="4-3-2-3-suptitle"><a href="#4-3-2-3-suptitle" class="headerlink" title="4.3.2.3. suptitle"></a>4.3.2.3. suptitle</h5><blockquote><p><a href="https://matplotlib.org/3.3.1/api/_as_gen/matplotlib.figure.Figure.html?highlight=suptitle#matplotlib.figure.Figure.suptitle">matplolib.figure.Figure #suptitle</a></p></blockquote><ul><li>그림 전체에 제목을 붙일 수 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g.fig.suptitle(<span class="string">&quot;iris dataset&quot;</span>, y=<span class="number">1.01</span>,</span><br><span class="line">               weight=<span class="string">&quot;bold&quot;</span>, fontsize=<span class="string">&quot;x-large&quot;</span></span><br><span class="line">              )</span><br><span class="line">g.fig.tight_layout()</span><br></pre></td></tr></table></figure><img src="37_s2m4_14.png"></li></ul><h5 id="4-3-2-4-facecolor-edgecolor"><a href="#4-3-2-4-facecolor-edgecolor" class="headerlink" title="4.3.2.4. facecolor, edgecolor"></a>4.3.2.4. facecolor, edgecolor</h5><blockquote><p><a href="https://matplotlib.org/3.3.1/api/_as_gen/matplotlib.figure.Figure.html?highlight=set_facecolor#matplotlib.figure.Figure.set_facecolor">matplolib.figure.Figure #set_facecolor</a></p></blockquote><ul><li>그림 바탕색을 칠합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.fig.set_facecolor(<span class="string">&quot;whitesmoke&quot;</span>)</span><br></pre></td></tr></table></figure><img src="37_s2m4_15.png"></li></ul><h4 id="4-3-3-최종"><a href="#4-3-3-최종" class="headerlink" title="4.3.3. 최종"></a>4.3.3. 최종</h4><ul><li>x, ylabel까지 정리하면 이렇습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">g = sns.PairGrid(iris, hue=<span class="string">&quot;species&quot;</span>, diag_sharey=<span class="literal">False</span>, corner=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># diagonal</span></span><br><span class="line">g.map_diag(sns.kdeplot, fill=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    g.axes[i][i].spines[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">True</span>)</span><br><span class="line">    g.axes[i][i].spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">True</span>)</span><br><span class="line">    g.axes[i][i].spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># lower</span></span><br><span class="line">g.map_lower(plt.scatter, s=<span class="number">30</span>, edgecolor=<span class="string">&quot;w&quot;</span>)</span><br><span class="line">g.map_lower(sns.regplot, scatter=<span class="literal">False</span>, truncate=<span class="literal">False</span>, ci=<span class="literal">False</span>)</span><br><span class="line">g.map_lower(sns.kdeplot, alpha=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># legend</span></span><br><span class="line">handles = g._legend_data.values()</span><br><span class="line">labels = g._legend_data.keys()</span><br><span class="line">g.fig.legend(handles=handles, labels=labels,</span><br><span class="line">             bbox_to_anchor=(<span class="number">0.75</span>, <span class="number">0.75</span>),</span><br><span class="line">             fontsize=<span class="string">&quot;large&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># x, y labels</span></span><br><span class="line">labels = [<span class="string">&quot;Sepal Length&quot;</span>, <span class="string">&quot;Sepal Width&quot;</span>, <span class="string">&quot;Petal Length&quot;</span>, <span class="string">&quot;Petal Width&quot;</span>]</span><br><span class="line">font_labels = &#123;<span class="string">&quot;fontsize&quot;</span>:<span class="string">&quot;large&quot;</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    g.axes[<span class="number">3</span>, i].set_xlabel(labels[i], fontdict=font_labels)</span><br><span class="line">    g.axes[i, <span class="number">0</span>].set_ylabel(labels[i], fontdict=font_labels)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ylabel alignment</span></span><br><span class="line">g.fig.align_ylabels(g.axes[:,<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># suptitle</span></span><br><span class="line">g.fig.suptitle(<span class="string">&quot;iris dataset&quot;</span>, y=<span class="number">1.01</span>,</span><br><span class="line">               weight=<span class="string">&quot;bold&quot;</span>, fontsize=<span class="string">&quot;x-large&quot;</span></span><br><span class="line">              )</span><br><span class="line">g.fig.tight_layout()</span><br><span class="line"></span><br><span class="line"><span class="comment"># facecolor</span></span><br><span class="line">g.fig.set_facecolor(<span class="string">&quot;whitesmoke&quot;</span>)</span><br></pre></td></tr></table></figure><img src="37_s2m4_17.png"></li></ul><h2 id="5-결론"><a href="#5-결론" class="headerlink" title="5. 결론"></a>5. 결론</h2><ul><li>네 편의 글에 걸쳐 matplotlib + seaborn 연계기를 정리했습니다.<ul><li>개별적인 코드와 기술보다는 <b>본질</b>에 집중합시다.</li><li><b>figure</b>와 <b>axes</b>를 통하면 <b>웬만한건 다 된다</b>는 겁니다.</li></ul></li><li>0.11에서 seaborn의 공식문서가 대폭 정리됐습니다.<ul><li>하지만 아직 부족한 점이 많습니다.</li><li>특히 많은 경우 matplotlib에 숙달되었다고 전제합니다.</li><li><b>일단 matplotlib</b>부터 제대로 익혀봅시다.</li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/pairplot/">pairplot</category>
      
      <category domain="https://jehyunlee.github.io/tags/PairGrid/">PairGrid</category>
      
      <category domain="https://jehyunlee.github.io/tags/align/">align</category>
      
      <category domain="https://jehyunlee.github.io/tags/legend/">legend</category>
      
      
    </item>
    
    <item>
      <title>Seaborn with Matplotlib (3)</title>
      <link>https://jehyunlee.github.io/2020/10/06/Python-DS-36-seaborn_matplotlib3/</link>
      <guid>https://jehyunlee.github.io/2020/10/06/Python-DS-36-seaborn_matplotlib3/</guid>
      <pubDate>Tue, 06 Oct 2020 04:28:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;3-seaborn-figure-level-function&quot;&gt;&lt;a href=&quot;#3-seaborn-figure-level-function&quot; class=&quot;headerlink&quot; title=&quot;3. seaborn figure-level functi</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="3-seaborn-figure-level-function"><a href="#3-seaborn-figure-level-function" class="headerlink" title="3. seaborn figure-level function"></a>3. seaborn <code>figure-level</code> function</h2><ul><li>seaborn의 핵심기능, 강력한 명령입니다.</li><li>4부 중 세 번째 시간입니다.</li><li>matplotlib으로는 매우 수고스러울 일을 줄여줍니다.</li><li>그러나 손대기 어렵기도 합니다. 이유와 해결방법을 알아봅시다.</li></ul><blockquote><p><a href="https://seaborn.pydata.org/api.html">seaborn API</a><br><a href="https://seaborn.pydata.org/tutorial.html">seaborn tutorial</a><br><a href="https://jehyunlee.github.io/2020/09/30/Python-DS-34-seaborn_matplotlib/">seaborn with matplotlib (1)</a></p></blockquote><ul><li><a href="https://jehyunlee.github.io/2020/09/30/Python-DS-34-seaborn_matplotlib/">지난 글</a>에서 matplotlib과 친한 함수를 알아봤습니다.<ul><li>이런 axex 반환 함수를 <b><code>axes-level</code> 함수</b>,</li><li>반대로 그림 전체를 반환하는 함수를 <b><code>figure-level</code> 함수</b>라고 합니다.</li></ul></li></ul><ul><li>아래 노란 부분이 <b><code>figure-level</code></b> 함수입니다.<br><br><img src="36_s2m3_3.png" alt="노랑색: figure-level functions"></li></ul><ul><li>반환 형식<code>return type</code>이 왜 이렇게 깔끔하지 않은지는 뒤에 보겠습니다.</li><li><code>figure-level</code> 함수는 복잡한 그림을 <b>한 번에 편하게</b> 그려줍니다.</li></ul><h3 id="3-1-figure-level-편리함-맛보기-FacetGrid"><a href="#3-1-figure-level-편리함-맛보기-FacetGrid" class="headerlink" title="3.1. figure-level 편리함 맛보기: FacetGrid()"></a>3.1. <code>figure-level</code> 편리함 맛보기: <code>FacetGrid()</code></h3><ul><li><p>seaborn에 내장된 penguins dataset에는 이런 데이터가 있습니다.</p><ul><li>bill_length_mm : 부리 길이</li><li>bill_depth_mm : 부리 위아래 두께</li><li>species : 펭귄 종</li><li>sex : 성별</li><li>island : 서식지</li></ul></li><li><p>이 데이터를 산점도로 한번에 나타내고자 합니다.</p><ul><li>X축 : bill_length_mm</li><li>Y축 : bill_depth_mm</li><li>색상 : species</li><li>X방향 axes : island</li><li>Y방향 axes : sex</li></ul></li></ul><ul><li>matplotlib 코드는 이렇습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(nrows=<span class="number">2</span>, ncols=<span class="number">3</span>, figsize=(<span class="number">12</span>, <span class="number">8</span>), sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 인자별 데이터 종 수 세기</span></span><br><span class="line">sex = penguins[<span class="string">&quot;sex&quot;</span>].dropna().unique()</span><br><span class="line">island = penguins[<span class="string">&quot;island&quot;</span>].dropna().unique()</span><br><span class="line">species = penguins[<span class="string">&quot;species&quot;</span>].dropna().unique()</span><br><span class="line"></span><br><span class="line"><span class="comment"># X방향 axes: sex</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sex)): </span><br><span class="line">    <span class="comment"># Y방향 axes: island</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(island)):</span><br><span class="line">        <span class="comment"># 색상 : species</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(species)):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                axes[i][j].scatter(penguins.loc[penguins[<span class="string">&quot;sex&quot;</span>] == sex[i]].loc[penguins[<span class="string">&quot;island&quot;</span>] == island[j]].loc[penguins[<span class="string">&quot;species&quot;</span>] == species[k]][<span class="string">&quot;bill_length_mm&quot;</span>], </span><br><span class="line">                                   penguins.loc[penguins[<span class="string">&quot;sex&quot;</span>] == sex[i]].loc[penguins[<span class="string">&quot;island&quot;</span>] == island[j]].loc[penguins[<span class="string">&quot;species&quot;</span>] == species[k]][<span class="string">&quot;bill_depth_mm&quot;</span>])</span><br><span class="line">                axes[i][j].set_title(<span class="string">f&quot;sex = <span class="subst">&#123;sex[i]&#125;</span> | island = <span class="subst">&#123;island[j]&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span>:  <span class="comment"># 결측치 예외처리</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 맨 아래줄에만 xlabel 추가</span></span><br><span class="line">        axes[<span class="built_in">len</span>(sex)-<span class="number">1</span>, j].set_xlabel(<span class="string">&quot;bill_length_mm&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 맨 왼쪽에만 ylabel 추가</span></span><br><span class="line">    axes[i, <span class="number">0</span>].set_ylabel(<span class="string">&quot;bill_depth_mm&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 그래프 우측에 범례 표시</span></span><br><span class="line">fig.legend(species,  title=<span class="string">&quot;species&quot;</span>, bbox_to_anchor=(<span class="number">0.95</span>, <span class="number">0.5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 그래프 간격 조정</span></span><br><span class="line">fig.tight_layout(rect=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.85</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><img src="36_s2m3_8.png"></li></ul><ul><li>따로 꾸민 것도 없는데 매우 번잡합니다.<ol><li><b>인자별로 몇가지인지</b>를 알아내야 합니다.</li><li><b>결측치 처리</b>가 필요합니다. 안하면 에러납니다.</li><li><b>색상별로 따로</b> 그려야 합니다.</li></ol></li></ul><ul><li>그런데 seaborn을 사용하면 <b>세 줄</b> 만에 끝납니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = sns.FacetGrid(penguins, row=<span class="string">&quot;sex&quot;</span>, col=<span class="string">&quot;island&quot;</span>, hue=<span class="string">&quot;species&quot;</span>)</span><br><span class="line">g.<span class="built_in">map</span>(sns.scatterplot, <span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>)</span><br><span class="line">g.add_legend()</span><br></pre></td></tr></table></figure><img src="36_s2m3_5.png"></li></ul><ul><li><p><code>FacetGrid()</code>로 만든 <b>공간</b>을 <code>.map()</code>으로 <b>채웁니다.</b></p><ul><li>데이터셋 이름, 변수 이름, 그리는 방식 외에 다른 내용이 없습니다.</li><li>인자가 여럿인 관계를 보기에 아주 좋습니다.</li></ul></li><li><p><b>밀도 함수<code>density plot</code></b>로 바꾸는 것도 간단합니다.</p></li><li><p>위 코드에서 <code>sns.scatterplot</code>만 <code>sns.kdeplot</code>으로 넣으면 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = sns.FacetGrid(penguins, row=<span class="string">&quot;sex&quot;</span>, col=<span class="string">&quot;island&quot;</span>, hue=<span class="string">&quot;species&quot;</span>)</span><br><span class="line">g.<span class="built_in">map</span>(sns.kdeplot, <span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>)</span><br><span class="line">g.add_legend()</span><br></pre></td></tr></table></figure><p><img src="36_s2m3_9.png"></p></li></ul><ul><li><code>figure-level</code> 함수는 <b>복잡한 그림을 간단히 그릴 때</b> 매우 강력합니다.<br></li><li>이 그림들을 matplotlib으로 그리려면 얼마나 막막할까요.<br><img src="36_s2m3_7.png" alt="이런 그림이 두 세 줄로 나옵니다."><br></li></ul><h3 id="3-2-figure-level-꾸미기-FacetGrid"><a href="#3-2-figure-level-꾸미기-FacetGrid" class="headerlink" title="3.2. figure-level 꾸미기: FacetGrid()"></a>3.2. <code>figure-level</code> 꾸미기: <code>FacetGrid()</code></h3><blockquote><p><a href="https://seaborn.pydata.org/generated/seaborn.FacetGrid.html">seaborn.FacetGrid</a><br><a href="https://seaborn.pydata.org/generated/seaborn.kdeplot.html?highlight=kdeplot#seaborn.kdeplot">seaborn.kdeplot</a><br><a href="https://seaborn.pydata.org/generated/seaborn.regplot.html">seaborn.regplot</a></p></blockquote><ul><li><b>이번엔 <code>figure-level</code> 그림을 꾸며 보겠습니다.</b><ol><li><code>kdeplot</code>위에 <b>추세선</b>을 겹쳐 그립니다.</li></ol><ul><li>추세선이 중간에 안끊기면 좋겠습니다.</li><li>신뢰구간은 80% 수준으로 그리고 싶습니다.</li></ul><ol start="2"><li><b>xlabel</b>을 “Bill Length (mm)”로 바꾸고</li><li><b>ylabel</b>을 “Bill Depth (mm)”로 바꿉니다.</li></ol></li></ul><ul><li>공식 홈페이지의 설명에 힘입어 해냈습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g = sns.FacetGrid(penguins, row=<span class="string">&quot;sex&quot;</span>, col=<span class="string">&quot;island&quot;</span>, hue=<span class="string">&quot;species&quot;</span>)</span><br><span class="line">g.<span class="built_in">map</span>(sns.kdeplot, <span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">g.<span class="built_in">map</span>(sns.regplot, <span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, truncate=<span class="literal">False</span>, ci=<span class="number">80</span>, scatter=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">g.set_axis_labels(<span class="string">&quot;Bill Length (mm)&quot;</span>, <span class="string">&quot;Bill Depth (mm)&quot;</span>)</span><br><span class="line">g.add_legend()</span><br></pre></td></tr></table></figure><img src="36_s2m3_10.png"></li></ul><ul><li><b>한 단계 더 꾸며보도록 합시다.</b><ol><li>xlabel, ylabel <b>글자를 키우고 싶습니다.</b></li><li>추세선의 <b>신뢰구간 80%를 적어두고</b> 싶습니다.</li><li>axes마다 붙어 있는 <b>title을 정리</b>하고 싶습니다.</li></ol></li></ul><ul><li>첫 단계에서 막혔습니다.<br><br><img src="36_s2m3_11.png" alt="검색 결과가 안나옵니다"></li></ul><ul><li>xlabel, ylabel을 수정할 때 <code>set_axis_labels()</code>를 사용했습니다.<ul><li>공식 홈페이지의 <code>FacetGrid()</code>부분 가이드를 따른 것입니다.</li><li>그런데 <code>set_axis_labels()</code>에 대한 <b>설명이 더 이상 없습니다.</b></li></ul></li></ul><ul><li>혹시나, matplotlib 명령어를 넣어봅니다.</li><li><code>fontdict=</code>를 적용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">g = sns.FacetGrid(penguins, row=<span class="string">&quot;sex&quot;</span>, col=<span class="string">&quot;island&quot;</span>, hue=<span class="string">&quot;species&quot;</span>)</span><br><span class="line">g.<span class="built_in">map</span>(sns.kdeplot, <span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">g.<span class="built_in">map</span>(sns.regplot, <span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, truncate=<span class="literal">False</span>, ci=<span class="number">80</span>, scatter=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">g.set_axis_labels(<span class="string">&quot;Bill Length (mm)&quot;</span>, <span class="string">&quot;Bill Depth (mm)&quot;</span>, </span><br><span class="line">                  fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="string">&quot;large&quot;</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;)</span><br><span class="line">g.add_legend()</span><br></pre></td></tr></table></figure><img src="36_s2m3_12.png" alt="적용되었습니다"></li></ul><ul><li><b><code>figure-level</code> 그림의 세부 설정은 도움말 찾기도 어렵습니다.</b></li><li>매뉴얼에 없는 내용을 상상해서 넣어야 합니다.<ul><li>아직은 공식 홈페이지가 충만하지 않습니다.</li><li>소스코드를 뜯어봐서 기능을 확인하거나</li><li><b>matplotlib 명령어를 숙지하고</b> 대응시켜 시도해야 합니다.</li></ul></li></ul><h3 id="3-3-figure-level의-장단점"><a href="#3-3-figure-level의-장단점" class="headerlink" title="3.3. figure-level의 장단점"></a>3.3. <code>figure-level</code>의 장단점</h3><ul><li><a href="https://seaborn.pydata.org/tutorial.html">공식 튜토리얼</a>에 정리된 장단점은 이렇습니다.<br><br><img src="36_s2m3_6.png" alt="figure-level function의 장단점"></li></ul><ul><li>하나씩 짚어보겠습니다.<br></li></ul><ul><li><b>(1) 데이터 변수에 따른 축공간 생성</b><ul><li>matplotlib에서 변수 갯수를 세어야 했던 것에 비해서 편리합니다.</li><li>seaborn에 구현된 그림을 제어하는 인자 수가 확실히 적습니다.</li><li>번거롭더라도 axes에 직접 접근해서 matplotlib 명령을 쓰는 게 낫습니다.</li></ul></li></ul><ul><li><b>(2) 그림 밖 범례 생성</b><ul><li>그림 밖에 붙는 것은 다행입니다.</li><li>그러나 통제가 안되어 심각한 갈증을 유발합니다.</li></ul></li></ul><ul><li><p><b>(3) figure-level 수정</b> &amp; <b>(4) figure size를 조정하는 인자가 다름</b></p><ul><li>장점보다 단점이 크다고 생각됩니다.</li><li>더 쉬운 명령어를 제공한다고 해도 결국은 또 다른 문법입니다.</li><li>matplotlib 명령어만 해도 정신이 없는데 말이죠.</li></ul></li><li><p>지금까지의 경험으로 이런 결론이 나옵니다.</p><ul><li><b>“figure-level의 가성비는 그리자마자, 손을 더 대기 전이 가장 높다.”</b></li><li>새로운 명령어는 새로운 혼돈입니다.</li><li>시각화만 붙잡고 있을 게 아니라 통계분석, 머신러닝도 해야 하거든요.</li></ul></li></ul><h3 id="3-4-figure-level그림이-손대기-어려운-이유"><a href="#3-4-figure-level그림이-손대기-어려운-이유" class="headerlink" title="3.4. figure-level그림이 손대기 어려운 이유"></a>3.4. <code>figure-level</code>그림이 손대기 어려운 이유</h3><blockquote><p><a href="https://github.com/mwaskom/seaborn">github: seaborn source code</a></p></blockquote><ul><li>seaborn 코드를 뜯어보면 클래스 구조는 이렇습니다.<br><br><img src="36_s2m3_2.png" alt="simplified UML of seaborn"></li></ul><ul><li>multi-plot grids는 Grid 클래스를 상속받는 가족입니다.<ul><li><code>FacetGrid()</code>, <code>PairGrid()</code>, <code>ClusterGrid</code> 입니다.</li><li><code>JointGrid()</code>는 Grid를 상속받지 않습니다.</li><li>Grid로 만든 공간에 목적에 맞는 그림을 채웁니다.</li><li><code>relplot()</code>, <code>displot()</code>, <code>catplot()</code>, <code>lmplot()</code>은 1x1 <code>FacetGrid()</code>로 출력됩니다.</li></ul></li><li>그리고 <b>Grid 클래스는 <code>figure</code>의 wrapper입니다.</b><ul><li>정확히는 <code>matplotlib.pyplot.subplots()</code>의 wrapper입니다.</li><li>따라서 <code>figure</code>, <code>axes</code>에 적용되는 matplotlib 명령이 안통합니다.</li><li>그래서 <code>set_axis_labels</code>같은 자체 명령어를 탑재하고 있습니다.</li><li>하지만 보셨다시피 도움말이 충분치 않습니다.</li></ul></li></ul><h3 id="3-5-figure-level-그림을-꾸미는-방법"><a href="#3-5-figure-level-그림을-꾸미는-방법" class="headerlink" title="3.5. figure-level 그림을 꾸미는 방법"></a>3.5. <code>figure-level</code> 그림을 꾸미는 방법</h3><blockquote><p><a href="http://blog.wellcomelibrary.org/2015/09/doctor-the-hearts-stopped/">Doctor! The heart’s stopped!</a></p></blockquote><ul><li><p>한마디로, <b>seaborn 제공 함수는 한계가 큽니다.</b></p><ul><li>기능 자체도 많이 빠져있고</li><li>있는 기능도 문서화가 덜 됐습니다.</li><li>이걸 믿고 쓰긴 어렵습니다.</li></ul></li><li><p>하지만 대안이 있습니다. </p><ul><li>seaborn 그림을 matplotlib 그림으로 간주합니다.</li><li><code>figure-level</code> 객체 안으로 <b>한 걸음 들어갑니다.</b></li><li>그리고 <b><code>figure</code>와 <code>axes</code>를 직접 건드립니다.</b></li></ul></li><li><p>개흉 심장마사지를 상상하시면 됩니다.</p></li><li><p>가슴을 열고 직접 심장을 마사지하는 겁니다.<br><br><img src="open-chest.jpg" alt="이미지 = Treatment of Cardiac Arrest"></p></li></ul><ul><li>그러면, 풀지 못했던 난제도 이렇게 풀립니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">g = sns.FacetGrid(penguins, row=<span class="string">&quot;sex&quot;</span>, col=<span class="string">&quot;island&quot;</span>, hue=<span class="string">&quot;species&quot;</span>, margin_titles=<span class="literal">True</span>, despine=<span class="literal">False</span>)</span><br><span class="line">g.<span class="built_in">map</span>(sns.kdeplot, <span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">g.<span class="built_in">map</span>(sns.regplot, <span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, truncate=<span class="literal">False</span>, ci=<span class="number">80</span>, scatter=<span class="literal">False</span>)</span><br><span class="line">g.add_legend()</span><br><span class="line"></span><br><span class="line"><span class="comment"># xlabel, ylabel 수정</span></span><br><span class="line">g.set_axis_labels(<span class="string">&quot;Bill Length (mm)&quot;</span>, <span class="string">&quot;Bill Depth (mm)&quot;</span>, </span><br><span class="line">                  fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="string">&quot;large&quot;</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># axes 직접 접근, 1차원 행렬로 표현</span></span><br><span class="line">axs = g.axes.ravel()</span><br><span class="line"><span class="keyword">for</span> i, ax <span class="keyword">in</span> <span class="built_in">enumerate</span>(axs):</span><br><span class="line">    <span class="comment"># 열 title 수정</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">3</span>:</span><br><span class="line">        ax.set_title(ax.get_title(), fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="string">&quot;x-large&quot;</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;k&quot;</span>&#125;, pad=<span class="number">12</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 행 title 수정</span></span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">3</span> == <span class="number">2</span>:</span><br><span class="line">        sex = <span class="string">&quot;Male&quot;</span> <span class="keyword">if</span> i == <span class="number">2</span> <span class="keyword">else</span> <span class="string">&quot;Female&quot;</span></span><br><span class="line">        ax.texts.clear()</span><br><span class="line">        text = ax.annotate(<span class="string">f&quot;sex = <span class="subst">&#123;sex&#125;</span>&quot;</span>, xy=(<span class="number">1.02</span>, <span class="number">.5</span>), xycoords=<span class="string">&quot;axes fraction&quot;</span>, rotation=<span class="number">270</span>, </span><br><span class="line">                           ha=<span class="string">&quot;left&quot;</span>, va=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;x-large&quot;</span>, color=<span class="string">&quot;k&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># suptitle 추가</span></span><br><span class="line">g.fig.suptitle(<span class="string">&quot;Penguins dataset summary (ci = 80%)        &quot;</span>, </span><br><span class="line">               fontsize=<span class="string">&quot;xx-large&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>, color=<span class="string">&quot;indigo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 전반적 크기 조정   </span></span><br><span class="line">g.fig.tight_layout(rect=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.88</span>,<span class="number">0.97</span>])</span><br></pre></td></tr></table></figure><img src="36_s2m3_13.png"></li><li><b>외웁시다.</b><ol><li><code>figure-level</code> 함수는 <b>matplotlib과 못 섞는다.</b></li><li><code>figure-level</code> 함수는 <code>figure</code>와 <code>axes</code>를 한번 더 감싸고 있다.</li><li><code>figure-level</code> 함수를 수정하려면 <b>후벼 파는</b> 과정이 필요하다.</li></ol></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/FacetGrid/">FacetGrid</category>
      
      
    </item>
    
    <item>
      <title>Seaborn with Matplotlib (2)</title>
      <link>https://jehyunlee.github.io/2020/10/03/Python-DS-35-seaborn_matplotlib2/</link>
      <guid>https://jehyunlee.github.io/2020/10/03/Python-DS-35-seaborn_matplotlib2/</guid>
      <pubDate>Sat, 03 Oct 2020 04:02:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;2-seaborn-matplotlib을-이용한-jointplot-보완&quot;&gt;&lt;a href=&quot;#2-seaborn-matplotlib을-이용한-jointplot-보완&quot; class=&quot;headerlink&quot; title=&quot;2. seaborn + mat</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="2-seaborn-matplotlib을-이용한-jointplot-보완"><a href="#2-seaborn-matplotlib을-이용한-jointplot-보완" class="headerlink" title="2. seaborn + matplotlib을 이용한 jointplot 보완"></a>2. seaborn + matplotlib을 이용한 jointplot 보완</h2><ul><li>seaborn을 matplotlib과 섞어쓰는 방법입니다.</li><li>4부 중 두 번째 시간입니다.</li><li>seaborn jointplot의 단점을 보완합니다.</li></ul><h3 id="2-1-seaborn-jointplot"><a href="#2-1-seaborn-jointplot" class="headerlink" title="2.1. seaborn jointplot"></a>2.1. seaborn jointplot</h3><blockquote><p><a href="https://seaborn.pydata.org/generated/seaborn.jointplot.html">seaborn jointplot</a></p></blockquote><ul><li>seaborn의 <code>jointplot</code>은 매력적인 기능입니다.<ul><li>두 변수 <b>각각의 분포</b>와 <b>2차원 분포</b>를 함께 보여줍니다.</li><li>각각의 분포는 <b><code>histogram</code>과 <code>kdeplot</code></b>으로 표현할 수 있고</li><li>2차원 분포는 <b><code>scatterplot</code>, <code>regression</code>, <code>kdeplot</code>, <code>hexbin</code></b>등으로 표현할 수 있습니다.</li></ul></li></ul><ul><li>만약 matplotlib에서 일일이 만들어야 한다면 눈물이 앞을 가릴 일입니다.</li><li>seaborn에서는 <b>단 한 줄</b>로 이런 그림들이 탄생합니다.<br><br><img src="35_s2m2_14.png" alt="jointplot 예제"></li></ul><h3 id="2-2-multiple-jointplot"><a href="#2-2-multiple-jointplot" class="headerlink" title="2.2. multiple jointplot"></a>2.2. multiple jointplot</h3><ul><li>그러나 seaborn 만으로는 여러 jointplot이 합쳐진 그림을 <b>표현할 수 없습니다.</b></li><li>y축을 공유시키는 것 만으로도 훨씬 기능이 강력해질텐데요.<br><br><img src="35_s2m2_15.png" alt="multiple jointplot"></li></ul><ul><li>현실적으로 가장 빠른 방법은 <b>파워포인트</b>입니다.</li><li>같은 y축 범위로 그림을 여러 개 그린 후 붙이면 됩니다.<br><br><img src="35_s2m2_16.png" alt="파워포인트 작업"></li></ul><ul><li>그러나 수작업이 동반되고, 오류 가능성이 커집니다.</li><li>seaborn과 matplotlib의 힘을 합해서 그려봅시다.</li></ul><h3 id="2-3-matplotlib-seaborn"><a href="#2-3-matplotlib-seaborn" class="headerlink" title="2.3. matplotlib + seaborn"></a>2.3. matplotlib + seaborn</h3><ul><li><p><a href="https://jehyunlee.github.io/2020/09/30/Python-DS-34-seaborn_matplotlib/">지난 글</a>에서 <b>seaborn과 matplotlib이 섞일 수 있음</b>을 보였습니다.</p></li><li><p><b>matplotlib으로 틀을 만들고 여기에 seaborn을 삽입</b>합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">penguins = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)  <span class="comment"># 펭귄 데이터셋으로 시작합니다.</span></span><br><span class="line">penguins.head()</span><br></pre></td></tr></table></figure></li><li><p>가로축에 두 개의 데이터 : <code>bill_length_mm</code>, <code>flipper_length_mm</code>,</p></li><li><p>세로축에 한 개의 데이터 : <code>bill_depth_mm</code>를 놓아보겠습니다.</p></li></ul><h4 id="2-3-1-축공간-배열-gridspec"><a href="#2-3-1-축공간-배열-gridspec" class="headerlink" title="2.3.1. 축공간 배열 : gridspec"></a>2.3.1. 축공간 배열 : gridspec</h4><blockquote><p><a href="https://matplotlib.org/3.3.2/api/_as_gen/matplotlib.pyplot.subplots.html">matplotlib.pyplot.subplots</a><br><a href="https://matplotlib.org/api/_as_gen/matplotlib.gridspec.GridSpec.html#matplotlib.gridspec.GridSpec">matplotlib.gridspec.GridSpec</a></p></blockquote><ul><li>저는 matplotlib을 객체지향 방식으로 사용할 때 이렇게 합니다.<ul><li><code>fig, ax = plt.subplots()</code> 명령으로 <code>figure</code>와 <code>axes</code>를 만드는데</li><li>가로세로 여러 axes를 만들 때는 <code>ncols</code>, <code>nrows</code> 인자를 사용합니다.</li><li>그러나 이렇게 하면 <b>모든 축공간의 크기가 같아집니다.</b></li></ul></li></ul><ul><li><code>jointplot</code>은 축공간의 크기가 일정하지 않습니다.</li><li><b><code>gridspec</code></b>을 이용해서 비대칭 축공간을 만듭니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>,<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line">widths = [<span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">heights = [<span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">### 1. gridspec preparation</span></span><br><span class="line">spec = fig.add_gridspec(ncols=<span class="number">3</span>, nrows=<span class="number">2</span>, width_ratios=widths, height_ratios=heights)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 2. setting axes</span></span><br><span class="line">axs = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights)*<span class="built_in">len</span>(widths)):</span><br><span class="line">    axs[i] = fig.add_subplot(spec[i//<span class="built_in">len</span>(widths), i%<span class="built_in">len</span>(widths)])</span><br><span class="line">    axs[i].text(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="string">f&quot;axs[<span class="subst">&#123;i&#125;</span>]&quot;</span>, fontdict=&#123;<span class="string">&quot;horizontalalignment&quot;</span>:<span class="string">&quot;center&quot;</span>, <span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><img src="35_s2m2_3.png"></li></ul><ul><li>축공간은 원래 2차원 배열입니다.</li><li>하지만 이를 별로 좋아하지 않아서, <code>dictionary</code>를 사용해 1차원으로 취급합니다.</li><li>개인적인 취향입니다. 꼭 따르지 않아도 좋습니다.</li></ul><h4 id="2-3-2-첫-번째-jointplot-scatterplot-kdeplot"><a href="#2-3-2-첫-번째-jointplot-scatterplot-kdeplot" class="headerlink" title="2.3.2. 첫 번째 jointplot : scatterplot + kdeplot"></a>2.3.2. 첫 번째 jointplot : scatterplot + kdeplot</h4><blockquote><p><a href="https://seaborn.pydata.org/generated/seaborn.scatterplot.html">seaborn.scatterplot</a><br><a href="https://seaborn.pydata.org/generated/seaborn.kdeplot.html">seaborn.kdeplot</a></p></blockquote><ul><li>좌측 하단에 첫 번째 2차원 분포도를 그립니다.</li><li>x축 변수는 <code>bill_length_nm</code>, y축 변수는 <code>bill_depth_mm</code>로 지정합니다.</li><li>seaborn 명령의 <code>ax=</code> 인자를 사용해 축공간을 지정합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>,<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line">widths = [<span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">heights = [<span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. gridspec preparation</span></span><br><span class="line">spec = fig.add_gridspec(ncols=<span class="number">3</span>, nrows=<span class="number">2</span>, width_ratios=widths, height_ratios=heights)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. setting axes</span></span><br><span class="line">axs = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights)*<span class="built_in">len</span>(widths)):</span><br><span class="line">    axs[i] = fig.add_subplot(spec[i//<span class="built_in">len</span>(widths), i%<span class="built_in">len</span>(widths)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. bill_length_mm vs bill_depth_mm</span></span><br><span class="line"><span class="comment"># 3.1. kdeplot</span></span><br><span class="line">sns.kdeplot(<span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, alpha=<span class="number">0.3</span>, ax=axs[<span class="number">3</span>])</span><br><span class="line"><span class="comment"># 3.2. scatterplot</span></span><br><span class="line">sns.scatterplot(<span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, ax=axs[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><img src="35_s2m2_4.png"></li></ul><h4 id="2-3-3-첫-번째-jointplot-1차원-kdeplot"><a href="#2-3-3-첫-번째-jointplot-1차원-kdeplot" class="headerlink" title="2.3.3. 첫 번째 jointplot : 1차원 kdeplot"></a>2.3.3. 첫 번째 jointplot : 1차원 kdeplot</h4><ul><li>첫 번째 jointplot의 상단과 우측에 1차원 분포도를 그립니다.</li></ul><ul><li>두 가지를 주의해야 합니다.</li></ul><ol><li>중심이 되는 jointplot과 <b>가로세로 범위를 일치</b>시켜야 합니다.</li><li>1차원 분포도의 <b>눈금과 수치는 필요없으니 제거</b>합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>,<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line">widths = [<span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">heights = [<span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">### 1. gridspec preparation</span></span><br><span class="line">spec = fig.add_gridspec(ncols=<span class="number">3</span>, nrows=<span class="number">2</span>, width_ratios=widths, height_ratios=heights)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 2. setting axes</span></span><br><span class="line">axs = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights)*<span class="built_in">len</span>(widths)):</span><br><span class="line">    axs[i] = fig.add_subplot(spec[i//<span class="built_in">len</span>(widths), i%<span class="built_in">len</span>(widths)])</span><br><span class="line"></span><br><span class="line"><span class="comment">### 3. bill_length_mm vs bill_depth_mm</span></span><br><span class="line"><span class="comment"># 3.1. kdeplot</span></span><br><span class="line">sns.kdeplot(<span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, alpha=<span class="number">0.3</span>, ax=axs[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.2. scatterplot</span></span><br><span class="line">sns.scatterplot(<span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, ax=axs[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.3. histogram (bill_length_mm)</span></span><br><span class="line">sns.kdeplot(<span class="string">&quot;bill_length_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, ax=axs[<span class="number">0</span>], legend=<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_xlim(axs[<span class="number">3</span>].get_xlim())</span><br><span class="line">axs[<span class="number">0</span>].set_xlabel(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_xticklabels([])</span><br><span class="line">axs[<span class="number">0</span>].spines[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">0</span>].spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">0</span>].spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.3. histogram (bill_depth_mm)</span></span><br><span class="line">sns.kdeplot(y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, ax=axs[<span class="number">5</span>], legend=<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">5</span>].set_ylim(axs[<span class="number">3</span>].get_ylim())</span><br><span class="line">axs[<span class="number">5</span>].set_ylabel(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">axs[<span class="number">5</span>].set_yticklabels([])</span><br><span class="line">axs[<span class="number">5</span>].spines[<span class="string">&quot;bottom&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">5</span>].spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">5</span>].spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><img src="35_s2m2_6.png"></li></ol><h4 id="2-3-4-두-번째-jointplot"><a href="#2-3-4-두-번째-jointplot" class="headerlink" title="2.3.4. 두 번째 jointplot"></a>2.3.4. 두 번째 jointplot</h4><ul><li>같은 요령으로 두 번째 분포도 도시합니다.</li><li>첫 번째 jointplot에서 x 변수만 바꿔주면 됩니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>,<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line">widths = [<span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">heights = [<span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">### 1. gridspec preparation</span></span><br><span class="line">spec = fig.add_gridspec(ncols=<span class="number">3</span>, nrows=<span class="number">2</span>, width_ratios=widths, height_ratios=heights)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 2. setting axes</span></span><br><span class="line">axs = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights)*<span class="built_in">len</span>(widths)):</span><br><span class="line">    axs[i] = fig.add_subplot(spec[i//<span class="built_in">len</span>(widths), i%<span class="built_in">len</span>(widths)])</span><br><span class="line"></span><br><span class="line"><span class="comment">### 3. bill_length_mm vs bill_depth_mm</span></span><br><span class="line"><span class="comment"># 3.1. kdeplot</span></span><br><span class="line">sns.kdeplot(<span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, alpha=<span class="number">0.3</span>, ax=axs[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.2. scatterplot</span></span><br><span class="line">sns.scatterplot(<span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, ax=axs[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.3. histogram (bill_length_mm)</span></span><br><span class="line">sns.kdeplot(<span class="string">&quot;bill_length_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, ax=axs[<span class="number">0</span>], legend=<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_xlim(axs[<span class="number">3</span>].get_xlim())</span><br><span class="line">axs[<span class="number">0</span>].set_xlabel(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_xticklabels([])</span><br><span class="line">axs[<span class="number">0</span>].spines[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">0</span>].spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">0</span>].spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.3. histogram (bill_depth_mm)</span></span><br><span class="line">sns.kdeplot(y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, ax=axs[<span class="number">5</span>], legend=<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">5</span>].set_ylim(axs[<span class="number">3</span>].get_ylim())</span><br><span class="line">axs[<span class="number">5</span>].set_ylabel(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">axs[<span class="number">5</span>].set_yticklabels([])</span><br><span class="line">axs[<span class="number">5</span>].spines[<span class="string">&quot;bottom&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">5</span>].spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">5</span>].spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 4. flipper_length_mm vs bill_depth_mm</span></span><br><span class="line"><span class="comment"># 3.1. kdeplot</span></span><br><span class="line">sns.kdeplot(<span class="string">&quot;flipper_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, alpha=<span class="number">0.3</span>, ax=axs[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.2. scatterplot</span></span><br><span class="line">sns.scatterplot(<span class="string">&quot;flipper_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, ax=axs[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.3. histogram (bill_length_mm)</span></span><br><span class="line">sns.kdeplot(<span class="string">&quot;flipper_length_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, ax=axs[<span class="number">1</span>], legend=<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_xlim(axs[<span class="number">4</span>].get_xlim())</span><br><span class="line">axs[<span class="number">1</span>].set_xlabel(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_xticklabels([])</span><br><span class="line">axs[<span class="number">1</span>].spines[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">1</span>].spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">1</span>].spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><img src="35_s2m2_7.png"></li></ul><h4 id="2-3-5-부대효과-조정-spines-grids-간격"><a href="#2-3-5-부대효과-조정-spines-grids-간격" class="headerlink" title="2.3.5. 부대효과 조정 : spines, grids, 간격"></a>2.3.5. 부대효과 조정 : spines, grids, 간격</h4><ul><li>데이터는 모두 올라갔으니 부대 효과를 조정합니다.</li><li>불필요한 요소(ex. <code>spines</code>)는 제거하고, 애매한 요소(ex. 위치)는 <code>grid</code>로 명확히 합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>,<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line">widths = [<span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">heights = [<span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">### 1. gridspec preparation</span></span><br><span class="line">spec = fig.add_gridspec(ncols=<span class="number">3</span>, nrows=<span class="number">2</span>, width_ratios=widths, height_ratios=heights, </span><br><span class="line">                        wspace=<span class="number">0.03</span>, hspace=<span class="number">0.03</span>)  <span class="comment"># setting spaces</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 2. setting axes</span></span><br><span class="line">axs = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights)*<span class="built_in">len</span>(widths)):</span><br><span class="line">    axs[i] = fig.add_subplot(spec[i//<span class="built_in">len</span>(widths), i%<span class="built_in">len</span>(widths)])</span><br><span class="line"></span><br><span class="line"><span class="comment">### 3. bill_length_mm vs bill_depth_mm</span></span><br><span class="line"><span class="comment"># 3.1. kdeplot</span></span><br><span class="line">sns.kdeplot(<span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, alpha=<span class="number">0.3</span>, ax=axs[<span class="number">3</span>], zorder=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.2. scatterplot</span></span><br><span class="line">sns.scatterplot(<span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, ax=axs[<span class="number">3</span>], zorder=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.3. histogram (bill_length_mm)</span></span><br><span class="line">sns.kdeplot(<span class="string">&quot;bill_length_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, ax=axs[<span class="number">0</span>], legend=<span class="literal">False</span>, zorder=<span class="number">1</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_xlim(axs[<span class="number">3</span>].get_xlim())</span><br><span class="line">axs[<span class="number">0</span>].set_xlabel(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_xticklabels([])</span><br><span class="line">axs[<span class="number">0</span>].spines[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">0</span>].spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">0</span>].spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.3. histogram (bill_depth_mm)</span></span><br><span class="line">sns.kdeplot(y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, ax=axs[<span class="number">5</span>], legend=<span class="literal">False</span>, zorder=<span class="number">1</span>)</span><br><span class="line">axs[<span class="number">5</span>].set_ylim(axs[<span class="number">3</span>].get_ylim())</span><br><span class="line">axs[<span class="number">5</span>].set_ylabel(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">axs[<span class="number">5</span>].set_yticklabels([])</span><br><span class="line">axs[<span class="number">5</span>].spines[<span class="string">&quot;bottom&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">5</span>].spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">5</span>].spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 4. flipper_length_mm vs bill_depth_mm</span></span><br><span class="line"><span class="comment"># 4.1. kdeplot</span></span><br><span class="line">sns.kdeplot(<span class="string">&quot;flipper_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, alpha=<span class="number">0.3</span>, ax=axs[<span class="number">4</span>], zorder=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.2. scatterplot</span></span><br><span class="line">sns.scatterplot(<span class="string">&quot;flipper_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, ax=axs[<span class="number">4</span>], zorder=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.3. histogram (flipper_length_mm)</span></span><br><span class="line">sns.kdeplot(<span class="string">&quot;flipper_length_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, ax=axs[<span class="number">1</span>], legend=<span class="literal">False</span>, zorder=<span class="number">1</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_xlim(axs[<span class="number">4</span>].get_xlim())</span><br><span class="line">axs[<span class="number">1</span>].set_xlabel(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_xticklabels([])</span><br><span class="line">axs[<span class="number">1</span>].spines[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">1</span>].spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">1</span>].spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 5. unnecessary elements removal</span></span><br><span class="line"><span class="comment"># 5.1. upper-right axes</span></span><br><span class="line">axs[<span class="number">2</span>].axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.2. margin kdeplot scale unification</span></span><br><span class="line">hist_range_max = <span class="built_in">max</span>(axs[<span class="number">0</span>].get_ylim()[-<span class="number">1</span>], axs[<span class="number">1</span>].get_ylim()[-<span class="number">1</span>], axs[<span class="number">5</span>].get_xlim()[-<span class="number">1</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(widths)-<span class="number">1</span>):</span><br><span class="line">    axs[i].set_ylim(<span class="number">0</span>, hist_range_max)</span><br><span class="line">axs[<span class="number">5</span>].set_xlim(<span class="number">0</span>, hist_range_max)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.3. redundent labels and titles removal</span></span><br><span class="line">axs[<span class="number">1</span>].set_yticklabels([])</span><br><span class="line">axs[<span class="number">1</span>].set_ylabel(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">axs[<span class="number">4</span>].set_yticklabels([])</span><br><span class="line">axs[<span class="number">4</span>].set_ylabel(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.4. grids</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights)*<span class="built_in">len</span>(widths)):</span><br><span class="line">    axs[i].grid(<span class="string">&quot;on&quot;</span>, color=<span class="string">&quot;lightgray&quot;</span>, zorder=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><img src="35_s2m2_9.png"></li></ul><ul><li>1차원 분포의 스케일도 맞춰주었습니다.<ul><li>그러나 꼭 필요한 작업인지는 의구심이 듭니다.</li><li><b>‘밀도’</b>라는 정의에 맞게 넓이를 1로 만드는 과정이 포함되어 있는데, 이로 인해 <b>x축 스케일이 크면 높이가 낮아지는 경향</b>이 있기 때문입니다.</li><li>데이터의 범위에 집중하고 싶다면 스케일을 맞추지 않는 것이 나을지도 모릅니다.</li></ul></li></ul><h4 id="2-3-6-마무리-작업"><a href="#2-3-6-마무리-작업" class="headerlink" title="2.3.6. 마무리 작업"></a>2.3.6. 마무리 작업</h4><blockquote><p><a href="https://seaborn.pydata.org/tutorial/aesthetics.html">seaborn tutorial: controlling figure aesthetics</a></p></blockquote><ul><li>데이터를 표현하는 작업은 사실상 완료되었습니다.</li><li>폰트의 크기, 색상 등 가독성을 높입니다.</li><li>이 때도 seaborn의 <code>set_style()</code>과 <code>set_context()</code>를 사용하면 편리합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">sns.set_style(<span class="string">&quot;white&quot;</span>)</span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">14</span>,<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">widths = [<span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">heights = [<span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">### 1. gridspec preparation</span></span><br><span class="line">spec = fig.add_gridspec(ncols=<span class="number">3</span>, nrows=<span class="number">2</span>, width_ratios=widths, height_ratios=heights, </span><br><span class="line">                        wspace=<span class="number">0.03</span>, hspace=<span class="number">0.03</span>)  <span class="comment"># setting spaces</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 2. setting axes</span></span><br><span class="line">axs = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights)*<span class="built_in">len</span>(widths)):</span><br><span class="line">    axs[i] = fig.add_subplot(spec[i//<span class="built_in">len</span>(widths), i%<span class="built_in">len</span>(widths)])</span><br><span class="line"></span><br><span class="line"><span class="comment">### 3. bill_length_mm vs bill_depth_mm</span></span><br><span class="line"><span class="comment"># 3.1. kdeplot</span></span><br><span class="line">sns.kdeplot(<span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, alpha=<span class="number">0.3</span>, ax=axs[<span class="number">3</span>], zorder=<span class="number">1</span>, legend=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.2. scatterplot</span></span><br><span class="line">sns.scatterplot(<span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, ax=axs[<span class="number">3</span>], zorder=<span class="number">2</span>, legend=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.3. histogram (bill_length_mm)</span></span><br><span class="line">sns.kdeplot(<span class="string">&quot;bill_length_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, ax=axs[<span class="number">0</span>], legend=<span class="literal">False</span>, zorder=<span class="number">1</span>, fill=<span class="literal">True</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_xlim(axs[<span class="number">3</span>].get_xlim())</span><br><span class="line">axs[<span class="number">0</span>].set_xlabel(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_xticklabels([])</span><br><span class="line">axs[<span class="number">0</span>].spines[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">0</span>].spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">0</span>].spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.3. histogram (bill_depth_mm)</span></span><br><span class="line">sns.kdeplot(y=<span class="string">&quot;bill_depth_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, ax=axs[<span class="number">5</span>], legend=<span class="literal">False</span>, zorder=<span class="number">1</span>, fill=<span class="literal">True</span>)</span><br><span class="line">axs[<span class="number">5</span>].set_ylim(axs[<span class="number">3</span>].get_ylim())</span><br><span class="line">axs[<span class="number">5</span>].set_ylabel(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">axs[<span class="number">5</span>].set_yticklabels([])</span><br><span class="line">axs[<span class="number">5</span>].spines[<span class="string">&quot;bottom&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">5</span>].spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">5</span>].spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 4. flipper_length_mm vs bill_depth_mm</span></span><br><span class="line"><span class="comment"># 4.1. kdeplot</span></span><br><span class="line">sns.kdeplot(<span class="string">&quot;flipper_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, alpha=<span class="number">0.3</span>, ax=axs[<span class="number">4</span>], zorder=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.2. scatterplot</span></span><br><span class="line">sns.scatterplot(<span class="string">&quot;flipper_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, ax=axs[<span class="number">4</span>], zorder=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.3. histogram (flipper_length_mm)</span></span><br><span class="line">sns.kdeplot(<span class="string">&quot;flipper_length_mm&quot;</span>, data=penguins, hue=<span class="string">&quot;species&quot;</span>, ax=axs[<span class="number">1</span>], legend=<span class="literal">False</span>, zorder=<span class="number">1</span>, fill=<span class="literal">True</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_xlim(axs[<span class="number">4</span>].get_xlim())</span><br><span class="line">axs[<span class="number">1</span>].set_xlabel(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_xticklabels([])</span><br><span class="line">axs[<span class="number">1</span>].spines[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">1</span>].spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">1</span>].spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 5. unnecessary elements removal</span></span><br><span class="line"><span class="comment"># 5.1. upper-right axes</span></span><br><span class="line">axs[<span class="number">2</span>].axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.2. margin kdeplot scale unification</span></span><br><span class="line">hist_range_max = <span class="built_in">max</span>(axs[<span class="number">0</span>].get_ylim()[-<span class="number">1</span>], axs[<span class="number">1</span>].get_ylim()[-<span class="number">1</span>], axs[<span class="number">5</span>].get_xlim()[-<span class="number">1</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(widths)-<span class="number">1</span>):</span><br><span class="line">    axs[i].set_ylim(<span class="number">0</span>, hist_range_max)</span><br><span class="line">axs[<span class="number">5</span>].set_xlim(<span class="number">0</span>, hist_range_max)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.3. redundent labels and titles removal</span></span><br><span class="line">axs[<span class="number">1</span>].set_yticklabels([])</span><br><span class="line">axs[<span class="number">1</span>].set_ylabel(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">axs[<span class="number">4</span>].set_yticklabels([])</span><br><span class="line">axs[<span class="number">4</span>].set_ylabel(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.4. grids</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights)*<span class="built_in">len</span>(widths)):</span><br><span class="line">    axs[i].grid(<span class="string">&quot;on&quot;</span>, color=<span class="string">&quot;lightgray&quot;</span>, zorder=<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 5.5. labels</span></span><br><span class="line">font_label = &#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>&#125;</span><br><span class="line">axs[<span class="number">3</span>].set_xlabel(<span class="string">&quot;Bill Legnth (mm)&quot;</span>, fontdict=font_label, labelpad=<span class="number">12</span>)</span><br><span class="line">axs[<span class="number">3</span>].set_ylabel(<span class="string">&quot;Bill Depth (mm)&quot;</span>, fontdict=font_label, labelpad=<span class="number">12</span>)</span><br><span class="line">axs[<span class="number">4</span>].set_xlabel(<span class="string">&quot;Flipper Legnth (mm)&quot;</span>, fontdict=font_label, labelpad=<span class="number">12</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_ylabel(<span class="string">&quot;Density&quot;</span>, fontdict=font_label, labelpad=<span class="number">12</span>)</span><br><span class="line">axs[<span class="number">5</span>].set_xlabel(<span class="string">&quot;Density&quot;</span>, fontdict=font_label, labelpad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><img src="35_s2m2_10.png"></li></ul><ul><li><code>jointplot</code>의 한계인 <b>2중 jointplot이 구현되었습니다.</b></li></ul><h4 id="2-3-7-generalize-함수로-만들기"><a href="#2-3-7-generalize-함수로-만들기" class="headerlink" title="2.3.7. generalize : 함수로 만들기"></a>2.3.7. generalize : 함수로 만들기</h4><ul><li>하는 김에, 기능을 일반화합시다.</li><li>다중 jointplot 제작 기능을 함수로 만들고, </li><li>x 변수의 수와 그림 크기, 1차원 분포 스케일 통일 등을 인자로 만듭니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jointplots</span>(<span class="params">xs, y, data, hue=<span class="literal">None</span>, height=<span class="number">6</span>, ratio=<span class="number">5</span>, space=<span class="number">0.2</span>, xlabels=<span class="literal">None</span>, ylabel=<span class="literal">None</span>, margin_norm=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    -------------------</span></span><br><span class="line"><span class="string">    Input Parameters</span></span><br><span class="line"><span class="string">    -------------------</span></span><br><span class="line"><span class="string">    xs      : (list or str) feature name(s) of data</span></span><br><span class="line"><span class="string">    y       : (str) feature name of data</span></span><br><span class="line"><span class="string">    data    : (pandas.DataFrame)</span></span><br><span class="line"><span class="string">    hue     : (str) semantic variable that is mapped to determine the color of plot elements. Semantic variable that is mapped to determine the color of plot elements.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    height  : (float) size of the figure</span></span><br><span class="line"><span class="string">    ratio   : (float) ratio of the joint axes height to marginal axes height.</span></span><br><span class="line"><span class="string">    space   : (float) space between the joint and marginal axes</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    xlabels : (list or str) xlabels</span></span><br><span class="line"><span class="string">    ylabel  : (str) ylabel</span></span><br><span class="line"><span class="string">    margin_norm : (boolean) if True, kdeplots at marginal axes have same scale.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">### 1. input check</span></span><br><span class="line">    <span class="comment"># input type</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(xs, <span class="built_in">list</span>) <span class="keyword">or</span> <span class="built_in">isinstance</span>(xs, <span class="built_in">str</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(xs, <span class="built_in">list</span>):</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">all</span>([<span class="built_in">isinstance</span>(x, <span class="built_in">str</span>) <span class="keyword">for</span> x <span class="keyword">in</span> xs])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        xs = [xs]</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> xlabels != <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(xlabels, <span class="built_in">list</span>) <span class="keyword">or</span> <span class="built_in">isinstance</span>(xlabels, <span class="built_in">str</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(xlabels, <span class="built_in">list</span>):</span><br><span class="line">            <span class="keyword">assert</span> <span class="built_in">all</span>([<span class="built_in">isinstance</span>(xlabel, <span class="built_in">str</span>) <span class="keyword">for</span> xlabel <span class="keyword">in</span> xlabels])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            xlabels = [xlabels]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ylabel != <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(ylabel, <span class="built_in">str</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> hue != <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(hue, <span class="built_in">str</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># input data</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">all</span>([x <span class="keyword">in</span> data.columns <span class="keyword">for</span> x <span class="keyword">in</span> xs])</span><br><span class="line">    <span class="keyword">assert</span> y <span class="keyword">in</span> data.columns</span><br><span class="line">    <span class="keyword">if</span> hue != <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">assert</span> hue <span class="keyword">in</span> data.columns</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">### 2. figure</span></span><br><span class="line">    h_margin = height / (ratio + <span class="number">1</span>)</span><br><span class="line">    h_joint = height - h_margin</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(xs, <span class="built_in">list</span>):</span><br><span class="line">        n_x = <span class="built_in">len</span>(xs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        n_x = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    widths = [h_joint] * n_x + [h_margin]</span><br><span class="line">    heights = [h_margin, h_joint]</span><br><span class="line">    ncols = <span class="built_in">len</span>(widths)</span><br><span class="line">    nrows = <span class="built_in">len</span>(heights)</span><br><span class="line">    </span><br><span class="line">    fig = plt.figure(figsize=(<span class="built_in">sum</span>(widths), <span class="built_in">sum</span>(heights)))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">### 3. gridspec preparation</span></span><br><span class="line">    spec = fig.add_gridspec(ncols=ncols, nrows=nrows, </span><br><span class="line">                            width_ratios = widths, height_ratios = heights,</span><br><span class="line">                            wspace=space, hspace=space</span><br><span class="line">                           )</span><br><span class="line">    </span><br><span class="line">    <span class="comment">### 4. setting axes</span></span><br><span class="line">    axs = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ncols * nrows):</span><br><span class="line">        axs[i] = fig.add_subplot(spec[i//ncols, i%ncols])</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">### 5. jointplots (scatterplot + kdeplot)</span></span><br><span class="line">    <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(xs, ncols):</span><br><span class="line">        <span class="keyword">if</span> i == ncols:</span><br><span class="line">            legend=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            legend=<span class="literal">False</span></span><br><span class="line">        sns.kdeplot(x=x, y=y, data=data, hue=hue, alpha=<span class="number">0.3</span>, ax=axs[i], zorder=<span class="number">2</span>, legend=<span class="literal">False</span>)</span><br><span class="line">        sns.scatterplot(x=x, y=y, data=data, hue=hue, alpha=<span class="number">0.8</span>, ax=axs[i], zorder=<span class="number">3</span>, legend=legend)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">### 6. kdeplots at marginal axes</span></span><br><span class="line">    axs[ncols-<span class="number">1</span>].axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    axes_mx = <span class="built_in">list</span>(<span class="built_in">range</span>(ncols-<span class="number">1</span>))</span><br><span class="line">    axes_my = <span class="number">2</span>*ncols - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">zip</span>(axes_mx, xs):</span><br><span class="line">        sns.kdeplot(x=x, data=data, hue=hue, fill=<span class="literal">True</span>, ax=axs[i], zorder=<span class="number">2</span>, legend=<span class="literal">False</span>)</span><br><span class="line">        axs[i].set_xlim(axs[i+ncols].get_xlim())</span><br><span class="line">        axs[i].set_xlabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        axs[i].set_xticklabels([])</span><br><span class="line">        axs[i].spines[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">        axs[i].spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">        axs[i].spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    sns.kdeplot(y=y, data=data, hue=hue, fill=<span class="literal">True</span>, ax=axs[axes_my], zorder=<span class="number">2</span>, legend=<span class="literal">False</span>)</span><br><span class="line">    axs[axes_my].set_ylim(axs[ncols].get_ylim())</span><br><span class="line">    axs[axes_my].set_ylabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    axs[axes_my].set_yticklabels([])</span><br><span class="line">    axs[axes_my].spines[<span class="string">&quot;bottom&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    axs[axes_my].spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    axs[axes_my].spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> margin_norm == <span class="literal">True</span>:</span><br><span class="line">        hist_range_max = <span class="built_in">max</span>([axs[m].get_ylim()[-<span class="number">1</span>] <span class="keyword">for</span> m <span class="keyword">in</span> axes_mx] + [axs[axes_my].get_xlim()[-<span class="number">1</span>]])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> axes_mx:</span><br><span class="line">            axs[i].set_ylim(<span class="number">0</span>, hist_range_max)</span><br><span class="line">        axs[axes_my].set_xlim(<span class="number">0</span>, hist_range_max)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">### 7. unnecessary elements removal</span></span><br><span class="line">    <span class="comment"># 7.1. labels and ticklabels</span></span><br><span class="line">    axes_j = <span class="built_in">list</span>(<span class="built_in">range</span>(ncols, <span class="number">2</span>*ncols-<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> axes_j:</span><br><span class="line">        <span class="keyword">if</span> i != ncols:</span><br><span class="line">            axs[i].set_ylabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line">            axs[i].set_yticklabels([])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 7.2. marginal axes</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> axes_mx:</span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">            axs[i].set_ylabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        axs[i].grid(<span class="string">&quot;on&quot;</span>, color=<span class="string">&quot;lightgray&quot;</span>, zorder=<span class="number">0</span>)</span><br><span class="line">        axs[i].set_yticklabels([])</span><br><span class="line">        </span><br><span class="line">        yticks = axs[i].get_yticks()</span><br><span class="line">        ylim = axs[i].get_ylim()</span><br><span class="line">        <span class="keyword">for</span> ytick <span class="keyword">in</span> yticks:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt; ytick &lt; ylim[-<span class="number">1</span>]:</span><br><span class="line">                axs[i].text(axs[i].get_xlim()[<span class="number">0</span>], ytick, <span class="built_in">str</span>(ytick), </span><br><span class="line">                            fontdict=&#123;<span class="string">&quot;verticalalignment&quot;</span>:<span class="string">&quot;center&quot;</span>&#125;)</span><br><span class="line">        </span><br><span class="line">    axs[axes_my].grid(<span class="string">&quot;on&quot;</span>, color=<span class="string">&quot;lightgray&quot;</span>, zorder=<span class="number">0</span>)</span><br><span class="line">    axs[axes_my].set_xticklabels([])</span><br><span class="line">    axes_my_xticks = axs[axes_my].get_xticks()</span><br><span class="line">    axes_my_xlim = axs[axes_my].get_xlim()</span><br><span class="line">    <span class="keyword">for</span> xtick <span class="keyword">in</span> axes_my_xticks:</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt; xtick &lt; axes_my_xlim[-<span class="number">1</span>]:</span><br><span class="line">            axs[axes_my].text(xtick, axs[axes_my].get_ylim()[<span class="number">0</span>], <span class="built_in">str</span>(xtick), </span><br><span class="line">                              rotation=<span class="number">270</span>, fontdict=&#123;<span class="string">&quot;horizontalalignment&quot;</span>:<span class="string">&quot;center&quot;</span>&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 7.3. labels</span></span><br><span class="line">    font_label = &#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;gray&quot;</span>, <span class="string">&quot;fontsize&quot;</span>:<span class="string">&quot;large&quot;</span>&#125;</span><br><span class="line">    labelpad = <span class="number">12</span></span><br><span class="line">    <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">zip</span>(axes_j, xlabels):</span><br><span class="line">        axs[i].set_xlabel(x, fontdict=font_label, labelpad=labelpad)</span><br><span class="line">        <span class="keyword">if</span> i == ncols:</span><br><span class="line">            axs[i].set_ylabel(ylabel, fontdict=font_label, labelpad=labelpad)</span><br><span class="line">    </span><br><span class="line">    axs[<span class="number">0</span>].set_ylabel(<span class="string">&quot;Density&quot;</span>, fontdict=font_label, labelpad=labelpad)</span><br><span class="line">    axs[<span class="number">2</span>*ncols-<span class="number">1</span>].set_xlabel(<span class="string">&quot;Density&quot;</span>, fontdict=font_label, labelpad=labelpad)</span><br><span class="line">    </span><br><span class="line">    fig.align_ylabels([axs[<span class="number">0</span>], axs[ncols]])</span><br><span class="line">    fig.align_xlabels([axs[x] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(ncols, <span class="number">2</span>*ncols)])</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fig, axs</span><br></pre></td></tr></table></figure></li></ul><ul><li><b>X인자의 수가 바뀌어도</b> jointplot이 안정적으로 그려집니다.</li><li>1차원 분포도 <b>표현 방식을 바꾸어</b> 전보다 깔끔해졌습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jointplots([<span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, <span class="string">&quot;flipper_length_mm&quot;</span>], <span class="string">&quot;body_mass_g&quot;</span>, penguins, hue=<span class="string">&quot;species&quot;</span>, </span><br><span class="line">            height=<span class="number">8</span>, ratio=<span class="number">5</span>, space=<span class="number">0.03</span>, </span><br><span class="line">            xlabels=[<span class="string">&quot;Bill Length (mm)&quot;</span>, <span class="string">&quot;Bill Depth (mm)&quot;</span>, <span class="string">&quot;Flipper Length (mm)&quot;</span>], ylabel=<span class="string">&quot;Body Mass (g)&quot;</span>)</span><br></pre></td></tr></table></figure><img src="35_s2m2_11.png"></li></ul><h3 id="2-4-결론"><a href="#2-4-결론" class="headerlink" title="2.4. 결론"></a>2.4. 결론</h3><ul><li>seaborn의 jointplot을 가져다 쓰는 데 그치지 않았습니다.</li><li><b>matplotlib의 객체지향 방식을 이용해 seaborn의 한계를 벗어날 수 있었습니다.</b></li></ul><ul><li>본 예제에서는 <code>scatterplot</code>과 2차원 <code>kdeplot</code>만 결합했습니다.</li><li>그러나 이 외에도 seaborn과 matplotlib이 제공하는 거의 모든 기능을 결합할 수 있습니다.</li><li>매뉴얼의 한계에 얽매이지 말고 상상력을 동원해 보시면 어떨까요.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/jointplot/">jointplot</category>
      
      <category domain="https://jehyunlee.github.io/tags/gridspec/">gridspec</category>
      
      
    </item>
    
    <item>
      <title>Seaborn with Matplotlib (1)</title>
      <link>https://jehyunlee.github.io/2020/09/30/Python-DS-34-seaborn_matplotlib/</link>
      <guid>https://jehyunlee.github.io/2020/09/30/Python-DS-34-seaborn_matplotlib/</guid>
      <pubDate>Wed, 30 Sep 2020 11:58:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;1-seaborn-matplotlib&quot;&gt;&lt;a href=&quot;#1-seaborn-matplotlib&quot; class=&quot;headerlink&quot; title=&quot;1. seaborn + matplotlib&quot;&gt;&lt;/a&gt;1. seaborn + matplotlib</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1-seaborn-matplotlib"><a href="#1-seaborn-matplotlib" class="headerlink" title="1. seaborn + matplotlib"></a>1. seaborn + matplotlib</h2><ul><li>seaborn을 matplotlib과 섞어쓰는 방법입니다.</li><li>4부 중 첫 번째 시간입니다.</li><li>seaborn 함수 중 matplotlib axes를 반환하는 함수들에 관한 내용입니다.</li></ul><blockquote><p><a href="https://seaborn.pydata.org/api.html">seaborn API</a></p></blockquote><ul><li><p>seaborn은 matplotlib을 쉽고 아름답게 쓰고자 만들어졌습니다.</p><ul><li>따라서 seaborn의 결과물은 당연히 matplotlib의 결과물입니다.</li><li>그러나 간혹 seaborn이 그린 그림의 폰트, 색상에 접근이 되지 않아 난처합니다.</li><li>seaborn의 구조를 잘 이해하지 못하면 해결도 어렵습니다.</li></ul></li><li><p>v0.11 기준으로 seaborn에는 다음 함수들이 있습니다. <br><br><img src="34_s2m_1.png" alt="seaborn functions"></p></li></ul><ul><li>matplotlib의 출력물은 <code>figure</code>와 <code>axes</code>만을 반환합니다.<ul><li>seaborn의 명령어 중 <code>axes</code>를 반환하는 것들은 matplotlib과 섞어 쓰기 좋습니다.</li><li>먼저 matplotlib의 <b>객체 지향<code>object oriented</code> interface</b>를 사용해서 그림의 틀을 만든 뒤, </li><li>특정 <code>axes</code>에 seaborn을 삽입하면 됩니다.</li><li><b>결론적으로, 하고 싶은 거 다 됩니다.</b></li></ul></li></ul><h3 id="1-1-Load-data"><a href="#1-1-Load-data" class="headerlink" title="1.1. Load data"></a>1.1. Load data</h3><ul><li>예제로 사용할 펭귄 데이터를 불러옵니다.</li><li>seaborn에 내장되어 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">penguins = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)</span><br><span class="line">penguins.head()</span><br></pre></td></tr></table></figure><img src="34_s2m_3.png"></li></ul><h3 id="1-2-figure-and-axes"><a href="#1-2-figure-and-axes" class="headerlink" title="1.2. figure and axes"></a>1.2. <b><code>figure</code></b> and <b><code>axes</code></b></h3><ul><li>matplotlib으로 도화지<code>figure</code>를 깔고 축공간<code>axes</code>를 만듭니다.</li><li>1 x 2 축공간을 구성합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><img src="34_s2m_2.png"></li></ul><h3 id="1-3-plot-with-matplotlib"><a href="#1-3-plot-with-matplotlib" class="headerlink" title="1.3. plot with matplotlib"></a>1.3. plot with matplotlib</h3><ul><li>matplotlib 기능을 이용해서 산점도를 그립니다.<ul><li>x축은 부리 길이 <code>bill length</code></li><li>y축은 부리 위 아래 두께 <code>bill depth</code></li><li>색상은 종<code>species</code>로 합니다.<br>Adelie, Chinstrap, Gentoo이 있습니다.</li></ul></li></ul><ul><li>두 축공간 중 왼쪽에만 그립니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">species_u = penguins[<span class="string">&quot;species&quot;</span>].unique()</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot 0 : matplotlib</span></span><br><span class="line"><span class="keyword">for</span> i, s <span class="keyword">in</span> <span class="built_in">enumerate</span>(species_u):</span><br><span class="line">    axes[<span class="number">0</span>].scatter(penguins[<span class="string">&quot;bill_length_mm&quot;</span>].loc[penguins[<span class="string">&quot;species&quot;</span>]==s],</span><br><span class="line">                   penguins[<span class="string">&quot;bill_depth_mm&quot;</span>].loc[penguins[<span class="string">&quot;species&quot;</span>]==s],</span><br><span class="line">                   c=<span class="string">f&quot;C<span class="subst">&#123;i&#125;</span>&quot;</span>, label=s, alpha=<span class="number">0.3</span></span><br><span class="line">                  )</span><br><span class="line">axes[<span class="number">0</span>].legend(species_u, title=<span class="string">&quot;species&quot;</span>)</span><br><span class="line">axes[<span class="number">0</span>].set_xlabel(<span class="string">&quot;Bill Length (mm)&quot;</span>)</span><br><span class="line">axes[<span class="number">0</span>].set_ylabel(<span class="string">&quot;Bill Depth (mm)&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><img src="34_s2m_4.png"></li></ul><h3 id="1-4-plot-with-seaborn"><a href="#1-4-plot-with-seaborn" class="headerlink" title="1.4. plot with seaborn"></a>1.4. plot with seaborn</h3><blockquote><p><a href="https://seaborn.pydata.org/generated/seaborn.scatterplot.html">seaborn scatterplot</a></p></blockquote><ul><li>이번엔 같은 plot을 seaborn으로 그려봅니다.</li><li>위 코드에 아래 세 줄만 추가합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plot 1 : seaborn</span></span><br><span class="line">sns.scatterplot(<span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, hue=<span class="string">&quot;species&quot;</span>, data=penguins, alpha=<span class="number">0.3</span>, ax=axes[<span class="number">1</span>])</span><br><span class="line">axes[<span class="number">1</span>].set_xlabel(<span class="string">&quot;Bill Length (mm)&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>].set_ylabel(<span class="string">&quot;Bill Depth (mm)&quot;</span>)</span><br></pre></td></tr></table></figure><img src="34_s2m_5.png"></li></ul><ul><li>단 세 줄로 거의 동일한 그림이 나왔습니다.<ul><li>scatter plot의 점 크기만 살짝 작습니다.</li><li>label의 투명도만 살짝 다릅니다.</li></ul></li></ul><ul><li>seaborn 명령 <code>scatterplot()</code>을 그대로 사용했습니다.</li><li>x축과 y축 label도 바꾸었습니다.<ul><li><code>ax=axes[1]</code> 인자에서 볼 수 있듯, 존재하는 <code>axes</code>에 그림만 얹었습니다.</li><li><b>matplotlib 틀 + seaborn 그림</b> 이므로, matplotlib 명령이 모두 통합니다.</li></ul></li></ul><h4 id="1-5-matplotlib-seaborn-amp-seaborn-matplotlib"><a href="#1-5-matplotlib-seaborn-amp-seaborn-matplotlib" class="headerlink" title="1.5. matplotlib + seaborn &amp; seaborn + matplotlib"></a>1.5. matplotlib + seaborn &amp; seaborn + matplotlib</h4><ul><li><p>matplotlib과 seaborn이 자유롭게 섞일 수 있습니다.</p><ul><li><b>matplotlib 산점도 위에 seaborn 추세선</b>을 얹을 수 있고,</li><li><b>seaborn 산점도 위에 matplotlib 중심점</b>을 얹을 수 있습니다.</li></ul></li><li><p>파이썬 코드는 다음과 같습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">species_u = penguins[<span class="string">&quot;species&quot;</span>].unique()</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot 0 : matplotlib + seaborn</span></span><br><span class="line"><span class="keyword">for</span> i, s <span class="keyword">in</span> <span class="built_in">enumerate</span>(species_u):</span><br><span class="line">    <span class="comment"># matplotlib 산점도</span></span><br><span class="line">    axes[<span class="number">0</span>].scatter(penguins[<span class="string">&quot;bill_length_mm&quot;</span>].loc[penguins[<span class="string">&quot;species&quot;</span>]==s],</span><br><span class="line">                   penguins[<span class="string">&quot;bill_depth_mm&quot;</span>].loc[penguins[<span class="string">&quot;species&quot;</span>]==s],</span><br><span class="line">                   c=<span class="string">f&quot;C<span class="subst">&#123;i&#125;</span>&quot;</span>, label=s, alpha=<span class="number">0.3</span></span><br><span class="line">                  )</span><br><span class="line">                  </span><br><span class="line">    <span class="comment"># seaborn 추세선</span></span><br><span class="line">    sns.regplot(<span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, data=penguins.loc[penguins[<span class="string">&quot;species&quot;</span>]==s], </span><br><span class="line">                scatter=<span class="literal">False</span>, ax=axes[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">axes[<span class="number">0</span>].legend(species_u, title=<span class="string">&quot;species&quot;</span>)</span><br><span class="line">axes[<span class="number">0</span>].set_xlabel(<span class="string">&quot;Bill Length (mm)&quot;</span>)</span><br><span class="line">axes[<span class="number">0</span>].set_ylabel(<span class="string">&quot;Bill Depth (mm)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot 1 : seaborn + matplotlib</span></span><br><span class="line"><span class="comment"># seaborn 산점도</span></span><br><span class="line">sns.scatterplot(<span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, hue=<span class="string">&quot;species&quot;</span>, data=penguins, alpha=<span class="number">0.3</span>, ax=axes[<span class="number">1</span>])</span><br><span class="line">axes[<span class="number">1</span>].set_xlabel(<span class="string">&quot;Bill Length (mm)&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>].set_ylabel(<span class="string">&quot;Bill Depth (mm)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, s <span class="keyword">in</span> <span class="built_in">enumerate</span>(species_u):</span><br><span class="line">    <span class="comment"># matplotlib 중심점</span></span><br><span class="line">    axes[<span class="number">1</span>].scatter(penguins[<span class="string">&quot;bill_length_mm&quot;</span>].loc[penguins[<span class="string">&quot;species&quot;</span>]==s].mean(),</span><br><span class="line">                   penguins[<span class="string">&quot;bill_depth_mm&quot;</span>].loc[penguins[<span class="string">&quot;species&quot;</span>]==s].mean(),</span><br><span class="line">                   c=<span class="string">f&quot;C<span class="subst">&#123;i&#125;</span>&quot;</span>, alpha=<span class="number">1</span>, marker=<span class="string">&quot;x&quot;</span>, s=<span class="number">100</span></span><br><span class="line">                  )</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><p><img src="34_s2m_6.png"></p></li></ul><h4 id="1-6-seaborn-seaborn-matplotlib"><a href="#1-6-seaborn-seaborn-matplotlib" class="headerlink" title="1.6. seaborn + seaborn + matplotlib"></a>1.6. seaborn + seaborn + matplotlib</h4><ul><li>안 될 이유가 없습니다. </li><li>seaborn <code>scatterplot</code> + seaborn <code>kdeplot</code> + matplotlib <code>text</code>입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot 0: scatter plot</span></span><br><span class="line">sns.scatterplot(<span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, color=<span class="string">&quot;k&quot;</span>, data=penguins, alpha=<span class="number">0.3</span>, ax=ax, legend=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot 1: kde plot</span></span><br><span class="line">sns.kdeplot(<span class="string">&quot;bill_length_mm&quot;</span>, <span class="string">&quot;bill_depth_mm&quot;</span>, hue=<span class="string">&quot;species&quot;</span>, data=penguins, alpha=<span class="number">0.5</span>, ax=ax, legend=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># text:</span></span><br><span class="line">species_u = penguins[<span class="string">&quot;species&quot;</span>].unique()</span><br><span class="line"><span class="keyword">for</span> i, s <span class="keyword">in</span> <span class="built_in">enumerate</span>(species_u):</span><br><span class="line">    ax.text(penguins[<span class="string">&quot;bill_length_mm&quot;</span>].loc[penguins[<span class="string">&quot;species&quot;</span>]==s].mean(),</span><br><span class="line">            penguins[<span class="string">&quot;bill_depth_mm&quot;</span>].loc[penguins[<span class="string">&quot;species&quot;</span>]==s].mean(),</span><br><span class="line">            s = s, fontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">14</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>,<span class="string">&quot;color&quot;</span>:<span class="string">&quot;k&quot;</span>&#125;</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Bill Length (mm)&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Bill Depth (mm)&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><img src="34_s2m_7.png"></li></ul><h4 id="1-7-결론"><a href="#1-7-결론" class="headerlink" title="1.7. 결론"></a>1.7. 결론</h4><ul><li><b>seaborn을 matplotlib과 마음껏 섞어쓰세요</b></li><li><b>단, <code>axes</code>를 반환하는 명령어에 한해서 말입니다.</b></li><li>이런 명령어를 <b><code>axes-level function</code></b> 이라고 합니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/axes/">axes</category>
      
      
    </item>
    
    <item>
      <title>Mapping Shapefile on Raster Map</title>
      <link>https://jehyunlee.github.io/2020/09/21/GIS-Python-3-raster_and_polygon/</link>
      <guid>https://jehyunlee.github.io/2020/09/21/GIS-Python-3-raster_and_polygon/</guid>
      <pubDate>Mon, 21 Sep 2020 00:46:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;raster map 위에 polygon을 생성하는 과정을 정리했습니다.&lt;/li&gt;
&lt;li&gt;간단한 작업이지만 4 GB 용량의 raster file을 불러오는 과정과 좌표를 맞추는 과정이 중요합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-g</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>raster map 위에 polygon을 생성하는 과정을 정리했습니다.</li><li>간단한 작업이지만 4 GB 용량의 raster file을 불러오는 과정과 좌표를 맞추는 과정이 중요합니다.</li></ul><h3 id="1-geotiff-읽기"><a href="#1-geotiff-읽기" class="headerlink" title="1. geotiff 읽기"></a>1. <code>geotiff</code> 읽기</h3><ul><li><code>geotiff</code>는 지형과 건물 등 여러 정보를 담은 raster image입니다.</li><li>건물 그림자가 담긴 geotiff 파일을 읽고 그 위에 polygon을 그리고자 합니다.</li></ul><h4 id="1-1-matplotlib"><a href="#1-1-matplotlib" class="headerlink" title="1.1. matplotlib"></a>1.1. <code>matplotlib</code></h4><ul><li><code>geotiff</code>는 이미지파일이기 때문에 <code>imagej</code>에서 읽을 수도 있습니다.</li><li><code>matplotlib</code>에서도 이미지를 다룰 수 있습니다.</li><li><code>plt.imread()</code>기능을 이용해 읽을 수 있지만 문제가 있습니다.<br><br><img src="3_rasterpoly_1.png"></li></ul><ul><li>너무 큰 그림은 읽어들이지 못합니다.</li><li>심지어 DOS 공격이라고까지 의심합니다.</li></ul><h4 id="1-2-gdal"><a href="#1-2-gdal" class="headerlink" title="1.2. gdal"></a>1.2. <code>gdal</code></h4><blockquote><p><a href="https://en.wikipedia.org/wiki/GeoTIFF">wikipedia:GeoTIFF</a><br><a href="https://gdal.org/">GDAL</a><br><a href="https://ljvmiranda921.github.io/notebook/2019/04/13/install-gdal/">GDAL install on ubuntu</a></p></blockquote><p><img src="3_rasterpoly_2.png"></p><ul><li><p><b>GDAL</b>은 래스터와 벡터 데이터를 상호 교환하는 translator library입니다.</p><ul><li>ArcGIS, PostGIS를 비롯해 상당히 많은 프로그램에서 사용하는 de-facto 표준입니다.</li><li>그러나 왜인지 설치가 만만치 않습니다.</li></ul></li><li><p>전에는 <code>geopandas</code>설치 과정에서 잘 됐던 것 같은데 새 서버에서 말썽입니다.</p><ul><li>윈도에서는 <a href="https://codedragon.tistory.com/9556">이런 순서</a>로 설치하면 된다고 하고,</li><li>리눅스에서는 <a href="https://ljvmiranda921.github.io/notebook/2019/04/13/install-gdal/">이렇게</a> 하라고 합니다.</li><li>하루 오전을 희생한 끝에 겨우 설치했습니다.</li></ul></li><li><p>파일을 엽니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> osgeo <span class="keyword">import</span> gdal</span><br><span class="line">gdal.UseExceptions()</span><br><span class="line"></span><br><span class="line">ds = gdal.Open(<span class="string">&quot;파일명&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-raster-data-접근"><a href="#2-raster-data-접근" class="headerlink" title="2. raster data 접근"></a>2. raster data 접근</h3><blockquote><p><a href="https://gdal.org/tutorials/raster_api_tut.html">GDAL: Raster API Tutorial</a></p></blockquote><ul><li>Raster API로 파일의 데이터에 접근할 수 있습니다.</li><li><code>.GetDriver()</code>로 파일의 형태를 알 수 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Driver: <span class="subst">&#123;ds.GetDriver().ShortName&#125;</span>/<span class="subst">&#123;ds.GetDriver().LongName&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>Driver: GTiff/GeoTIFF</li></ul><ul><li><code>.RasterXSize</code>와 <code>.RasterYSize</code>로 그림의 크기를 알 수 있습니다.</li><li><code>.RasterCount</code>로 파일에 담긴 raster band의 수를 알 수 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Size is <span class="subst">&#123;ds.RasterXSize&#125;</span> x <span class="subst">&#123;ds.RasterYSize&#125;</span> x <span class="subst">&#123;ds.RasterCount&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>Size is 27001 x 36000 x 1</li></ul><ul><li><code>.GetProjection()</code>으로 사용된 좌표계를 확인할 수 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Projection is <span class="subst">&#123;ds.GetProjection()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>Projection is PROJCS[“Korea 2000 / Central Belt 2010”,GEOGCS[“Korea 2000”,DATUM[“Geocentric_datum_of_Korea”,SPHEROID[“GRS 1980”,6378137,298.257222101,AUTHORITY[“EPSG”,”7019”]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[“EPSG”,”6737”]],PRIMEM[“Greenwich”,0,AUTHORITY[“EPSG”,”8901”]],UNIT[“degree”,0.0174532925199433,AUTHORITY[“EPSG”,”9122”]],AUTHORITY[“EPSG”,”4737”]],PROJECTION[“Transverse_Mercator”],PARAMETER[“latitude_of_origin”,38],PARAMETER[“central_meridian”,127],PARAMETER[“scale_factor”,1],PARAMETER[“false_easting”,200000],PARAMETER[“false_northing”,600000],UNIT[“metre”,1,AUTHORITY[“EPSG”,”9001”]],AUTHORITY[“EPSG”,”5186”]]</li></ul><h3 id="3-raster-data-가져오기"><a href="#3-raster-data-가져오기" class="headerlink" title="3. raster data 가져오기"></a>3. raster data 가져오기</h3><ul><li><code>.GetRasterBand()</code>를 사용해 raster data를 가져옵니다.</li><li>제 데이터에서는 <code>.RasterCount</code>에서 band가 1개라고 했으니 괄호 안에 1을 넣어줘야 합니다.</li><li>분명 파이썬 코드이지만 <b><code>GDAL</code>은 숫자를 1부터 셉니다.</b><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">band = ds.GetRasterBand(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li>band에 저장된 raster band data를 <code>numpy</code> array로 가져옵니다.</li><li>제가 익숙한 방식이고, 다른 데이터와 결합해야 하기 때문입니다.</li><li>가져온 데이터의 차원을 출력해 잘 읽혔는지 확인합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">irrad = band.ReadAsArray()</span><br><span class="line">nrows, ncols = irrad.shape</span><br><span class="line"><span class="built_in">print</span>(nrows, ncols)</span><br></pre></td></tr></table></figure>36000 27001</li></ul><h3 id="4-좌표-매핑"><a href="#4-좌표-매핑" class="headerlink" title="4. 좌표 매핑"></a>4. 좌표 매핑</h3><blockquote><p><a href="https://matplotlib.org/3.3.1/tutorials/intermediate/imshow_extent.html?highlight=origin%20extent%20imshow">matplotlib: origin and extent in imshow</a></p></blockquote><ul><li><code>numpy</code> array의 index가 0이라고 Korea Belt 2000의 좌표도 0은 아닙니다.</li><li>2차원 배열의 좌표와 실제 지점의 좌표를 매핑해야 합니다.</li></ul><ul><li><code>.GetGeoTransform()</code> 명령으로 변환 인자들을 추출합니다.</li><li>raster band에서 가져오는 것이 아닙니다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x0, dx, dxdy, y0, dydx, dy = ds.GetGeoTransform()</span><br><span class="line"><span class="built_in">print</span>(x0, dx, dxdy, y0, dydx, dy)</span><br><span class="line"></span><br><span class="line">x1 = x0 + dx * ncols  <span class="comment"># x limit</span></span><br><span class="line">y1 = y0 + dy * nrows  <span class="comment"># y limit</span></span><br></pre></td></tr></table></figure></li></ul><p>222100.0 1.0 0.0 434400.0 0.0 -1.0</p><ul><li>이제 raster data를 화면에 그려봅시다.</li><li><code>matplotlib</code>의 <code>extent</code>는 가로세로축에 실제 데이터값을 찍어줍니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">20</span>, <span class="number">20</span>))</span><br><span class="line">ax.imshow(irrad, cmap=<span class="string">&quot;gist_gray&quot;</span>, extent=[x0, x1, y1, y0])</span><br><span class="line">ax.set_aspect(<span class="string">&quot;equal&quot;</span>, <span class="string">&quot;box&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="3_rasterpoly_3.png"></li></ul><ul><li>위 정보를 이용해 position을 index로 변환하는 함수를 만들 수 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># position to index</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pos2idx</span>(<span class="params">X, Y, ds=ds</span>):</span></span><br><span class="line">    x0, dx, dxdy, y0, dydx, dy = ds.GetGeoTransform()</span><br><span class="line">    X_idx = <span class="built_in">int</span>((X-x0)/dx)  <span class="comment"># x index of X coordinate</span></span><br><span class="line">    Y_idx = <span class="built_in">int</span>((Y-y0)/dy)  <span class="comment"># y index of Y coordinate</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> X_idx, Y_idx</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-Polygon-얹기"><a href="#5-Polygon-얹기" class="headerlink" title="5. Polygon 얹기"></a>5. Polygon 얹기</h3><blockquote><p><a href="https://jehyunlee.github.io/2020/09/14/GIS-Python-2-PolygonShapefile/">Create Shapefile from Polygon</a><br><a href="https://geopandas.org/reference/geopandas.read_file.html">geopandas.read_file</a></p></blockquote><ul><li>살펴볼 지점을 확대해서 그립니다.</li><li>건물들 데이터가 담긴 데이터로부터 목표 건물의 좌표를 추출하고,</li><li>이 건물을 중심으로 가로세로 100 pixel 범위의 그림을 그립니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">idx_range = <span class="number">100</span> <span class="comment">#pixel</span></span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">ax.imshow(irrad[Y_idx-idx_range: Y_idx+idx_range, X_idx-idx_range:X_idx+idx_range], </span><br><span class="line">          cmap=<span class="string">&quot;gist_gray&quot;</span>, </span><br><span class="line">          extent=[idx_x-idx_range, idx_x+idx_range, idx_y-idx_range, idx_y+idx_range])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="3_rasterpoly_5.png"></li></ul><ul><li>여기에 건물을 하나 얹어봅니다.</li><li><a href="https://jehyunlee.github.io/2020/09/14/GIS-Python-2-PolygonShapefile/">중심점과 가로세로 길이, 각도를 이용해서 도형을 생성하는 기술</a>을 사용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> mapping, Polygon</span><br><span class="line"><span class="keyword">import</span> fiona</span><br><span class="line"></span><br><span class="line">shppath = <span class="string">&quot;파일 저장 경로&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_mor</span>(<span class="params">x, y, width, height, angle, filename, shppath=shppath</span>):</span></span><br><span class="line">    h_half = height/<span class="number">2</span></span><br><span class="line">    w_half = width/<span class="number">2</span></span><br><span class="line">    a_rad = np.deg2rad(angle)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_coord</span>(<span class="params">h_half, w_half, a_rad</span>):</span></span><br><span class="line">        X = x + h_half * np.sin(a_rad) - w_half * np.cos(a_rad)</span><br><span class="line">        Y = y + h_half * np.cos(a_rad) + w_half * np.sin(a_rad)</span><br><span class="line">        <span class="keyword">return</span> (X, Y)</span><br><span class="line">    </span><br><span class="line">    points = [get_coord(h_half, w_half, a_rad), </span><br><span class="line">              get_coord(-h_half, w_half, a_rad), </span><br><span class="line">              get_coord(-h_half, -w_half, a_rad), </span><br><span class="line">              get_coord(h_half, -w_half, a_rad), </span><br><span class="line">              get_coord(h_half, w_half, a_rad), </span><br><span class="line">              ]</span><br><span class="line">    </span><br><span class="line">    schema = &#123;<span class="string">&quot;geometry&quot;</span>: <span class="string">&quot;Polygon&quot;</span>, <span class="string">&quot;properties&quot;</span>: &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;int&quot;</span>&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    savefile = os.path.join(shppath, filename)</span><br><span class="line">    <span class="keyword">with</span> fiona.<span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;savefile&#125;</span>&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="string">&quot;ESRI Shapefile&quot;</span>, schema) <span class="keyword">as</span> c:</span><br><span class="line">        c.write(&#123;</span><br><span class="line">            <span class="string">&quot;geometry&quot;</span>: mapping(Polygon(points)),</span><br><span class="line">            <span class="string">&quot;properties&quot;</span>: &#123;<span class="string">&quot;id&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure></li></ul><ul><li>목표 건물 데이터를 읽고 사각형을 형성합니다.</li><li>geopandas로 그린 건물은 실제 지도에 들어갈 좌표를 갖고 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"></span><br><span class="line">idx_width = df_dir[<span class="string">&quot;OMBB_WIDTH&quot;</span>].loc[idx]</span><br><span class="line">idx_height = df_dir[<span class="string">&quot;OMBB_HEIGHT&quot;</span>].loc[idx]</span><br><span class="line">idx_angle = df_dir[<span class="string">&quot;OMBB_ANGLE&quot;</span>].loc[idx]</span><br><span class="line"></span><br><span class="line">create_mor(idx_x, idx_y, idx_width, idx_height, idx_angle, <span class="string">&quot;idx_100&quot;</span>)</span><br><span class="line"></span><br><span class="line">idx100 = gpd.read_file(<span class="string">&#x27;./data/200917_shadow/idx_100/idx_100.shp&#x27;</span>)</span><br><span class="line">idx100.plot()</span><br></pre></td></tr></table></figure><img src="3_rasterpoly_4.png"></li></ul><ul><li>이렇게 도형을 shapefile로 만들어주고 <code>geopandas</code>로 읽어옵니다.</li><li>예쁘게 겹쳐져 있습니다.<br><br><img src="3_rasterpoly_6.png"></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/GIS/">GIS</category>
      
      <category domain="https://jehyunlee.github.io/categories/GIS/Python/">Python</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/gis/">gis</category>
      
      <category domain="https://jehyunlee.github.io/tags/polygon/">polygon</category>
      
      <category domain="https://jehyunlee.github.io/tags/shapefile/">shapefile</category>
      
      <category domain="https://jehyunlee.github.io/tags/raster/">raster</category>
      
      
    </item>
    
    <item>
      <title>Seaborn Distribution Plot</title>
      <link>https://jehyunlee.github.io/2020/09/16/Python-DS-32-seaborn_displot/</link>
      <guid>https://jehyunlee.github.io/2020/09/16/Python-DS-32-seaborn_displot/</guid>
      <pubDate>Wed, 16 Sep 2020 00:58:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;seaborn 0.11에서 업데이트된 distribution plot을 살펴봅니다.&lt;/li&gt;
&lt;li&gt;distplot()이 없어진 대신 displot()이 들어왔습니다.&lt;/li&gt;
&lt;li&gt;matplotlib으로 만든 틀 안에 seaborn</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>seaborn 0.11에서 업데이트된 distribution plot을 살펴봅니다.</li><li>distplot()이 없어진 대신 displot()이 들어왔습니다.</li><li>matplotlib으로 만든 틀 안에 seaborn을 넣어봅니다.</li></ul><h2 id="1-displot"><a href="#1-displot" class="headerlink" title="1. displot()"></a>1. <code>displot()</code></h2><blockquote><p><a href="https://seaborn.pydata.org/generated/seaborn.displot.html#seaborn.displot">seaborn.displot</a></p></blockquote><p><img src="32_displots_7.png"></p><ul><li><b><code>displot()</code></b>은 <code>histplot()</code>, <code>kdeplot()</code>, <code>ecdfplot()</code>, <code>rugplot()</code>을 편하게 그리는 방법입니다<ul><li><b>편하게</b>라는 말은 하나의 명령어(<code>displot()</code>)로 여러 형태를 그릴 수 있다는 뜻입니다.</li><li>장점은 <b>하나의 인자 <code>kind</code> 를 바꿔주는 것 만</b>으로 그래프의 형태를 바꿀 수 있다는 것,</li><li>단점은 그림의 인자들이 그래프 종류마다 다르다는 점입니다. </li><li>그 바람에 <code>kind</code> 외에도 <b>다른 인자들을 많이 바꾸게 된다는 것</b>입니다.</li></ul></li></ul><ul><li>인자만 바꿔도 되는데 다른 인자도 많이 바꿔야 한다니 모순입니다.<ul><li>조금 풀어서 설명하면,</li><li><b>기본 세팅된 그림을 그리려면 인자만 바꾸면 된다</b></li><li>그러나 <b>여기저기 수정하려면 여러 인자를 바꿔야 한다</b> 입니다.</li></ul></li></ul><ul><li><code>displot()</code>을 알아보는 과정은 세부 기능들을 알아보는 기능과 거의 동일합니다.</li><li>세부 기능들을 먼저 알아보겠습니다.</li></ul><h2 id="2-histplot-kdeplot-ecdfplot"><a href="#2-histplot-kdeplot-ecdfplot" class="headerlink" title="2. histplot(), kdeplot(), ecdfplot()"></a>2. <code>histplot()</code>, <code>kdeplot()</code>, <code>ecdfplot()</code></h2><blockquote><p><a href="https://seaborn.pydata.org/generated/seaborn.histplot.html?highlight=histplot#seaborn.histplot">seaborn.histplot</a><br><a href="https://seaborn.pydata.org/generated/seaborn.kdeplot.html?highlight=kdeplot#seaborn.kdeplot">seaborn.kdeplot</a><br><a href="https://seaborn.pydata.org/generated/seaborn.ecdfplot.html?highlight=ecdfplot#seaborn.ecdfplot">seaborn.ecdfplot</a><br><a href="https://seaborn.pydata.org/generated/seaborn.rugplot.html?highlight=rugplot#seaborn.rugplot">seaborn.rugplot</a></p></blockquote><h3 id="2-1-plots"><a href="#2-1-plots" class="headerlink" title="2.1. plots"></a>2.1. plots</h3><ul><li><p><b><code>rugplot()</code></b>은 단독으로 사용하기 어렵습니다.</p></li><li><p>다른 세 plot을 하나의 figure에 담아보겠습니다.</p><ul><li><code>plt.subplots()</code>명령으로 <code>Figure</code>와 <code>Axes</code>를 생성하고,</li><li>seaborn plot 함수에 <code>ax=</code> 인자를 삽입하여 그려질 <code>axes</code>를 지정합니다.</li></ul></li><li><p>동일 x값을 쌓아주도록 <code>multiple=&quot;stack&quot;</code>을 지정합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the diamonds dataset</span></span><br><span class="line">diamonds = sns.load_dataset(<span class="string">&quot;diamonds&quot;</span>)</span><br><span class="line">diamonds.head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">fig, axes = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">12</span>,<span class="number">4</span>))</span><br><span class="line">sns.histplot(data=diamonds, x=<span class="string">&quot;carat&quot;</span>, hue=<span class="string">&quot;cut&quot;</span>, multiple=<span class="string">&quot;stack&quot;</span>, ax=axes[<span class="number">0</span>], legend=<span class="literal">True</span>)</span><br><span class="line">sns.kdeplot(data=diamonds, x=<span class="string">&quot;carat&quot;</span>, hue=<span class="string">&quot;cut&quot;</span>, multiple=<span class="string">&quot;stack&quot;</span>, ax=axes[<span class="number">1</span>], legend=<span class="literal">True</span>)</span><br><span class="line">sns.ecdfplot(data=diamonds, x=<span class="string">&quot;carat&quot;</span>, hue=<span class="string">&quot;cut&quot;</span>, ax=axes[<span class="number">2</span>], legend=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">&quot;histplot&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>].set_title(<span class="string">&quot;kdeplot&quot;</span>)</span><br><span class="line">axes[<span class="number">2</span>].set_title(<span class="string">&quot;ecdfplot&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><p><img src="32_displots_1.png"></p></li></ul><h3 id="2-2-proportion"><a href="#2-2-proportion" class="headerlink" title="2.2. proportion"></a>2.2. proportion</h3><ul><li>별도의 설정을 하지 않았는데도 <b>y축 label이 그래프마다 다릅니다</b>.<ul><li><b><code>histplot()</code></b>은 <code>Count</code></li><li><b><code>kdeplot()</code></b>은 <code>Density</code></li><li><b><code>ecdfplot()</code></b>은 <code>Proportion</code>으로 되어 있습니다.</li><li><code>ecdfplot()</code>의 뜻은 empirical cumulative distribution functions 입니다.</li></ul></li></ul><ul><li>위 코드에서 <code>multiple</code> 부분을 <code>&quot;fill&quot;</code>로 변경하면 비율을 그립니다.</li><li>단위가 바뀌었지만 <b>y축 label은 변하지 않았습니다.</b> 주의해야 합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">12</span>,<span class="number">4</span>))</span><br><span class="line">sns.histplot(data=diamonds, x=<span class="string">&quot;carat&quot;</span>, hue=<span class="string">&quot;cut&quot;</span>, multiple=<span class="string">&quot;fill&quot;</span>, ax=axes[<span class="number">0</span>], legend=<span class="literal">False</span>)</span><br><span class="line">sns.kdeplot(data=diamonds, x=<span class="string">&quot;carat&quot;</span>, hue=<span class="string">&quot;cut&quot;</span>, multiple=<span class="string">&quot;fill&quot;</span>, ax=axes[<span class="number">1</span>], legend=<span class="literal">False</span>)</span><br><span class="line">sns.ecdfplot(data=diamonds, x=<span class="string">&quot;carat&quot;</span>, hue=<span class="string">&quot;cut&quot;</span>, ax=axes[<span class="number">2</span>], legend=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">&quot;histplot&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>].set_title(<span class="string">&quot;kdeplot&quot;</span>)</span><br><span class="line">axes[<span class="number">2</span>].set_title(<span class="string">&quot;ecdfplot&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><img src="32_displots_2.png"></li></ul><h3 id="2-3-bivariate-distribution"><a href="#2-3-bivariate-distribution" class="headerlink" title="2.3. bivariate distribution"></a>2.3. bivariate distribution</h3><ul><li>x와 y축에 다른 변수를 지정하면 <b>2변수 분포도</b>를 그릴 수 있습니다.</li><li><code>ecdfplot()</code>에는 적용되지 않습니다.</li><li>범주형(categorical) 변수에는 적용되지 않으니 주의합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load the penguins dataset</span></span><br><span class="line">penguins = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)</span><br><span class="line">penguins.head()</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line">sns.histplot(data=penguins, x=<span class="string">&quot;bill_depth_mm&quot;</span>, y=<span class="string">&quot;body_mass_g&quot;</span>, hue=<span class="string">&quot;species&quot;</span>, </span><br><span class="line">             bins=<span class="number">20</span>, ax=axes[<span class="number">0</span>], legend=<span class="literal">False</span>)</span><br><span class="line">sns.kdeplot(data=penguins, x=<span class="string">&quot;bill_depth_mm&quot;</span>, y=<span class="string">&quot;body_mass_g&quot;</span>, hue=<span class="string">&quot;species&quot;</span>, </span><br><span class="line">            fill=<span class="literal">True</span>, levels=<span class="number">5</span>, alpha=<span class="number">0.5</span>,</span><br><span class="line">            ax=axes[<span class="number">1</span>], legend=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">&quot;histplot&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>].set_title(<span class="string">&quot;kdeplot&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><img src="32_displots_6.png"></li></ul><h2 id="3-displot-vs-kdeplot"><a href="#3-displot-vs-kdeplot" class="headerlink" title="3. displot() vs kdeplot()"></a>3. <code>displot()</code> vs <code>kdeplot()</code></h2><blockquote><p><a href="https://seaborn.pydata.org/examples/multiple_conditional_kde.html">seaborn Gallery</a><br><a href="https://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid">seaborn.FacetGrid</a></p></blockquote><ul><li>diamond 데이터셋을 <code>displot()</code>과 <code>kdeplot()</code>으로 그려 비교해 보겠습니다.</li><li><code>displot()</code>은 <b><code>FacetGrid</code>를 생성</b>합니다.<ul><li>matplotlib이 생성하는 <code>Figure</code>와 <code>Axes</code>를 포함하는 객체입니다.</li><li>따라서 matplot이 <code>subplot</code>으로 생성하는 <b><code>Axes</code>에 담길 수 없습니다</b>.</li></ul></li></ul><ul><li><code>displot()</code>은 matplotlib의 <code>pyplot</code>방식으로 사용해야 합니다.</li><li>그림 크기는 <code>height</code>와 <code>aspect</code>로 제어합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sns.displot(</span><br><span class="line">    data=diamonds,</span><br><span class="line">    x=<span class="string">&quot;carat&quot;</span>, hue=<span class="string">&quot;cut&quot;</span>,</span><br><span class="line">    kind=<span class="string">&quot;kde&quot;</span>, </span><br><span class="line">    multiple=<span class="string">&quot;fill&quot;</span>, clip=(<span class="number">0</span>, <span class="literal">None</span>),</span><br><span class="line">    palette=<span class="string">&quot;ch:rot=-.25,hue=1,light=.75&quot;</span>,</span><br><span class="line">    height=<span class="number">5</span>, aspect=<span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><img src="32_displots_3.png"></li></ul><ul><li>반면 <code>kdeplot()</code>은 <code>Axes</code>를 생성합니다.</li><li><code>ax</code> 인자를 사용해 <code>subplot</code>으로 미리 생성한 <code>Axes</code>에 담을 수 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">sns.kdeplot(</span><br><span class="line">    data=diamonds,</span><br><span class="line">    x=<span class="string">&quot;carat&quot;</span>, hue=<span class="string">&quot;cut&quot;</span>,</span><br><span class="line">    multiple=<span class="string">&quot;fill&quot;</span>, clip=(<span class="number">0</span>, <span class="literal">None</span>),</span><br><span class="line">    palette=<span class="string">&quot;ch:rot=-.25,hue=1,light=.75&quot;</span>,</span><br><span class="line">    ax=ax</span><br><span class="line">)</span><br></pre></td></tr></table></figure><img src="32_displots_4.png"></li></ul><ul><li>두 그림의 legend가 묘하게 다릅니다.<ul><li><code>displot()</code>은 옆으로 밀려있고,</li><li><code>kdeplot()</code>은 <code>axes</code> 안에 담겨 있습니다.</li></ul></li></ul><ul><li><p>그런데 <b>문제</b>가 있습니다.</p><ul><li>legend를 옮기려면 <code>axes.legend()</code>로 제어해야 합니다.</li><li>그리고 <code>legend(handles, labels)</code>형태로 데이터를 넣어야 하는데, </li><li>handles와 labels를 추출하는 <code>axes.get_legend_handles_labels()</code>가 작동하지 않습니다.</li></ul></li><li><p>handles, labels를 출력시켜도 모두 []로만 나옵니다.</p></li><li><p><b>legend는 텅 비어 있습니다.</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># object oriented interface</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">sns.kdeplot(</span><br><span class="line">    data=diamonds,</span><br><span class="line">    x=<span class="string">&quot;carat&quot;</span>, hue=<span class="string">&quot;cut&quot;</span>,</span><br><span class="line">    multiple=<span class="string">&quot;fill&quot;</span>, clip=(<span class="number">0</span>, <span class="literal">None</span>),</span><br><span class="line">    palette=<span class="string">&quot;ch:rot=-.25,hue=1,light=.75&quot;</span>,</span><br><span class="line"><span class="comment">#     height=5, aspect=2</span></span><br><span class="line">    ax=ax</span><br><span class="line">)</span><br><span class="line">h, l = ax.get_legend_handles_labels()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;handles=<span class="subst">&#123;h&#125;</span>\nlables=<span class="subst">&#123;l&#125;</span>\n&quot;</span>)</span><br><span class="line">ax.legend(h, l, bbox_to_anchor=(<span class="number">1.05</span>,<span class="number">0.9</span>))</span><br></pre></td></tr></table></figure><p><img src="32_displots_5.png"></p></li></ul><ul><li>강제로 labels를 인가하면 legend를 제어할 수 있습니다.</li><li>그러나 <b>순서가 반대</b>이고, 반대로 넣으면 <b>언제나 색상과 맞는지</b> 확신이 없습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">sns.kdeplot(</span><br><span class="line">    data=diamonds,</span><br><span class="line">    x=<span class="string">&quot;carat&quot;</span>, hue=<span class="string">&quot;cut&quot;</span>,</span><br><span class="line">    multiple=<span class="string">&quot;fill&quot;</span>, clip=(<span class="number">0</span>, <span class="literal">None</span>),</span><br><span class="line">    palette=<span class="string">&quot;ch:rot=-.25,hue=1,light=.75&quot;</span>,</span><br><span class="line"><span class="comment">#     height=5, aspect=2</span></span><br><span class="line">    ax=ax</span><br><span class="line">)</span><br><span class="line">ax.legend(diamonds[<span class="string">&quot;cut&quot;</span>].unique()[::-<span class="number">1</span>], bbox_to_anchor=(<span class="number">1.2</span>,<span class="number">0.9</span>))</span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><img src="32_displots_8.png"></li></ul><ul><li>아쉽게도 seaborn <b>공식문서</b>에도 설명이 제대로 나오지 않았네요.<ul><li>본 방법은 <b>임시변통</b>으로만 알고 정석을 찾아야 할 것 같습니다.</li><li>혹시 이 글을 보시는 분께서 방법을 알고 계시면, 제보 부탁드리겠습니다.</li><li><a href="mailto:jehyun.lee@gmail.com">jehyun.lee@gmail.com</a></li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/displot/">displot</category>
      
      
    </item>
    
    <item>
      <title>Create Shapefile from Polygon Dots</title>
      <link>https://jehyunlee.github.io/2020/09/14/GIS-Python-2-PolygonShapefile/</link>
      <guid>https://jehyunlee.github.io/2020/09/14/GIS-Python-2-PolygonShapefile/</guid>
      <pubDate>Mon, 14 Sep 2020 04:11:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;csv 파일에서 읽은 기본 정보를 바탕으로 polygon shapefile을 생성하는 과정입니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shapely&lt;/code&gt;와 &lt;code&gt;fiona&lt;/code&gt;를 사용했으며, &lt;code&gt;geopandas 0.</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>csv 파일에서 읽은 기본 정보를 바탕으로 polygon shapefile을 생성하는 과정입니다.</li><li><code>shapely</code>와 <code>fiona</code>를 사용했으며, <code>geopandas 0.8</code>을 설치할 때 함께 설치되는 버전을 사용했습니다.</li><li><code>shapely</code> 버전은 1.7, <code>fiona</code> 버전은 1.8.13.post1 입니다.</li></ul><p><b>References</b></p><blockquote><p><a href="https://shapely.readthedocs.io/en/latest/">shapely</a><br><a href="https://github.com/Toblerity/Fiona">fiona</a><br><a href="https://geopandas.org/">geopandas</a></p></blockquote><h3 id="1-csv-읽기"><a href="#1-csv-읽기" class="headerlink" title="1. csv 읽기"></a>1. csv 읽기</h3><ul><li><code>.csv</code> 파일에서 건물 정보를 읽어옵니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_ombb0914 = pd.read_csv(<span class="string">&#x27;./data/ombb_200914.csv&#x27;</span>)</span><br><span class="line">df_ombb0914.head()</span><br></pre></td></tr></table></figure><img src="2_polygonshp_2.png"><br></li></ul><ul><li>데이터 컬럼은 다음과 같습니다.<ul><li><b><code>BD_MGT_SN</code> : </b>건물관리번호 (건물 고유 번호)</li><li><b><code>width</code> $$w$$ : </b>최소경계도형 폭 ($$m$$)</li><li><b><code>height</code> $$h$$ : </b>최소경계도형 높이 ($$m$$)</li><li><b><code>angle</code> $$\theta$$ : </b>최소경계도형 회전각. 정북 기준 시계방향 ($$\text{deg.}$$)</li><li><b><code>area</code> : </b>최소경계도형 넓이 ($$m^2$$)</li><li><b><code>perimeter</code> : </b>최소경계도형 둘레 ($$m$$)</li><li><b><code>xcoord</code> : </b>최소경계도형 중심점 x좌표 (ESPG:5186)</li><li><b><code>ycoord</code> : </b>최소경계도형 중심점 y좌표 (ESPG:5186)</li></ul></li></ul><p><img src="2_polygonshp_3.png"><br></p><h3 id="2-polygon-변환"><a href="#2-polygon-변환" class="headerlink" title="2. polygon 변환"></a>2. polygon 변환</h3><ul><li>행 하나가 건물 하나에 해당합니다.</li><li>행 하나마다 정보를 좌표로 변환해서 <code>shapefile</code>로 저장합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> mapping, Polygon</span><br><span class="line"><span class="keyword">import</span> fiona</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_polygons</span>(<span class="params">x, y, width, height, angle, filename</span>):</span></span><br><span class="line">    h_half = height/<span class="number">2</span> </span><br><span class="line">    w_half = width/<span class="number">2</span></span><br><span class="line">    a_rad = np.deg2rad(angle)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 꼭지점 좌표 생성</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_coord</span>(<span class="params">x, y, h_half, w_half, a_rad</span>):</span></span><br><span class="line">        X = x + h_half * np.sin(a_rad) - w_half * np.cos(a_rad)</span><br><span class="line">        Y = y + h_half * np.cos(a_rad) + w_half * np.sin(a_rad)</span><br><span class="line">        <span class="keyword">return</span> (X, Y)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># shapefile schema 지정</span></span><br><span class="line">    schema = &#123;<span class="string">&quot;geometry&quot;</span>: <span class="string">&quot;Polygon&quot;</span>, <span class="string">&quot;properties&quot;</span>: &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;int&quot;</span>&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 행 수만큼 반복</span></span><br><span class="line">    n_polygon = <span class="built_in">len</span>(x)</span><br><span class="line">    <span class="keyword">with</span> fiona.<span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;filename&#125;</span>&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="string">&quot;ESRI Shapefile&quot;</span>, schema) <span class="keyword">as</span> c:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_polygon):</span><br><span class="line">            p_x, p_y = x.iloc[i], y.iloc[i]</span><br><span class="line">            p_h, p_w, p_r = h_half.iloc[i], w_half.iloc[i], a_rad.iloc[i]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># closed loop을 이루도록 point 지정.</span></span><br><span class="line">            points = [get_coord(p_x, p_y, p_h, p_w, p_r), </span><br><span class="line">                      get_coord(p_x, p_y, -p_h, p_w, p_r), </span><br><span class="line">                      get_coord(p_x, p_y, -p_h, -p_w, p_r), </span><br><span class="line">                      get_coord(p_x, p_y, p_h, -p_w, p_r), </span><br><span class="line">                      get_coord(p_x, p_y, p_h, p_w, p_r), </span><br><span class="line">                      ]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># shapefile 작성</span></span><br><span class="line">            c.write(&#123;</span><br><span class="line">                <span class="string">&quot;geometry&quot;</span>: mapping(Polygon(points)),</span><br><span class="line">                <span class="string">&quot;properties&quot;</span>: &#123;<span class="string">&quot;id&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-QGIS에서-확인"><a href="#3-QGIS에서-확인" class="headerlink" title="3. QGIS에서 확인"></a>3. QGIS에서 확인</h3><ul><li>QGIS에서 읽어서 잘 보이는지 확인합니다.<ul><li>.csv를 출력한 원본(노랑)과 생성된 shapefile(파랑) 비교 결과 완벽히 일치합니다.</li><li>최소경계도형(보라)과 비교해봐도 잘 복원되었습니다.</li></ul></li></ul><p><img src="2_polygonshp_4.png"><br></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/GIS/">GIS</category>
      
      <category domain="https://jehyunlee.github.io/categories/GIS/Python/">Python</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/gis/">gis</category>
      
      <category domain="https://jehyunlee.github.io/tags/polygon/">polygon</category>
      
      <category domain="https://jehyunlee.github.io/tags/shapefile/">shapefile</category>
      
      
    </item>
    
  </channel>
</rss>
