<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Pega Devlog</title>
    <link>https://jehyunlee.github.io/</link>
    
    <atom:link href="https://jehyunlee.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Pega&#39;s Development log for myself and others</description>
    <pubDate>Sun, 26 Mar 2023 00:00:03 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>서울특별시 교육청 - ChatGPT와 인공지능시대</title>
      <link>https://jehyunlee.github.io/2023/03/26/Python-General-20-seouledu/</link>
      <guid>https://jehyunlee.github.io/2023/03/26/Python-General-20-seouledu/</guid>
      <pubDate>Sat, 25 Mar 2023 22:49:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sen.go.kr/&quot;&gt;서울특별시 교육청&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.youtube.com/@GoodSenNews&quot;&gt;YouTube: 서울특별시 교육청 TV&lt;/a&gt;&lt;b</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><a href="https://www.sen.go.kr/">서울특별시 교육청</a><br><a href="https://www.youtube.com/@GoodSenNews">YouTube: 서울특별시 교육청 TV</a><br><a href="https://news.mt.co.kr/mtview.php?no=2023031609193638586">머니투데이: 챗GPT 활용방안 찾는 ‘서울시교육청’..직원 특강 -우수 사례 공유</a><br>[EBS뉴스: 서울교육청 “챗GPT 적극 활용한다” 사례집·연수 제공]</p></blockquote><ul><li>서울특별시 교육청에서 초청해주셔서 발표를 드렸습니다.</li><li>오프라인 200분을 포함해 460분 정도가 신청해주셨고 당일 500분 이상 접속하셨다고 들었습니다.</li><li>현장에서 반갑게 맞아주시고 경청해주셔서 감사드리고, 온라인으로 들어주신 분들께도 감사드립니다.</li></ul><ul><li><b>영상 링크:</b> (<a href="https://www.youtube.com/live/-5S8yHHsaHQ?feature=share">Youtube Link</a>)<br><ul><li>유튜브에서만 재생되도록 설정되어 있습니다. 링크를 클릭해서 시청해주시기 바랍니다.<br><img src="20_seouledu_01.png"><p><p></li></ul></li></ul><ul><li>며칠 전 <b><a href="https://jehyunlee.github.io/2023/03/24/Python-General-19-sciencepeople/">과학하고 앉아있네</a></b>에서도 그랬지만 이런 이야기를 하면 수렴하는 주제가 있습니다.</li><li><b>“앞으로 우리 아이들을 어떻게 가르쳐야 할 것인가”</b>가 그 것입니다.</li><li>작년 말 대전광역시 교육청에서 불러주셨던 덕에 인공지능시대에 대한 생각을 미리 정리할 수 있었습니다.</li><li>교육 전문가들 앞에서 교육 방식을 제가 언급하는 것은 어불성설이지만 <b>다가올 미래</b>에 대한 제 생각은 말씀드릴 수 있을 것 같아 전체의 3분의 1 정도를 할애했습니다.<p></li></ul><ul><li>영상 중 해당 부분 : (<a href="https://youtu.be/-5S8yHHsaHQ?t=3722">YoutTube Link</a>)<br></li></ul><ul><li><b>발표자료를 공유합니다. (<a href="230324_%EC%9D%B4%EC%A0%9C%ED%98%84_ChatGPT.pdf">다운로드</a>)</b></li><li>새로운 시대를 맞는 분들께 조금이나마 도움이 되시기를 바랍니다.</li><li><b>이 자료와 발표에서 언급한 ChatGPT는 2023년 3월 23일 현황입니다.</b> </li><li>매우 빠른 속도로 변화와 진화가 벌어지고 있기 때문에 이후에는 새로운 내용을 반영해야 함을 유의해주시기 바랍니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/openai/">openai</category>
      
      <category domain="https://jehyunlee.github.io/tags/chatgpt/">chatgpt</category>
      
      <category domain="https://jehyunlee.github.io/tags/seoul/">seoul</category>
      
      <category domain="https://jehyunlee.github.io/tags/education/">education</category>
      
      
    </item>
    
    <item>
      <title>과학하고 앉아있네 - 최팀장의 과학탐구</title>
      <link>https://jehyunlee.github.io/2023/03/24/Python-General-19-sciencepeople/</link>
      <guid>https://jehyunlee.github.io/2023/03/24/Python-General-19-sciencepeople/</guid>
      <pubDate>Fri, 24 Mar 2023 14:08:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sciencepeople.co.kr/&quot;&gt;과학과사람들&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;과학과 사람들에서 운영하는 유튜브, &lt;b&gt;과학하고 앉아있네&lt;/b&gt;에 출연</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><a href="https://www.sciencepeople.co.kr/">과학과사람들</a></p></blockquote><ul><li><p>과학과 사람들에서 운영하는 유튜브, <b>과학하고 앉아있네</b>에 출연했습니다.</p></li><li><p><b>최진영 팀장</b>, <b>곽재식 작가</b>, 게임평론가 <b>이경혁 작가</b>님과 함께 했습니다.</p></li><li><p>선망하는 채널이라 섭외 요청에 너무 기뻤는데 시간이 맞지 않아 함께 할 수 없었습니다.</p></li><li><p>다행히 운영진께서 배려해주셔서 온라인으로 함께 참여할 수 있었습니다.</p></li><li><p>영상 : (<a href="https://youtu.be/VMJ492EzKv4">Youtube Link</a>)<br></p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/VMJ492EzKv4" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><ul><li>스튜디오에서 함께 했다면, </li><li>이 분들과 사전에 친분이 좀 있어서 끼어들 수 있었다면 더 재밌었을 것 같은 아쉬움도 남습니다.</li><li>마이크가 넘어오기를 기다리며 가만히 있는 모습을 보고 사진인 줄 알았다는 댓글도 있네요 ^^;</li><li>2시간 반 녹화분이 2시간으로 편집되어서 정리되었습니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/openai/">openai</category>
      
      <category domain="https://jehyunlee.github.io/tags/chatgpt/">chatgpt</category>
      
      <category domain="https://jehyunlee.github.io/tags/science-and-people/">science and people</category>
      
      
    </item>
    
    <item>
      <title>대전MBC 시시각각- 대덕 과학자가 본 챗GPT 열풍</title>
      <link>https://jehyunlee.github.io/2023/03/19/Python-General-18-ssgg/</link>
      <guid>https://jehyunlee.github.io/2023/03/19/Python-General-18-ssgg/</guid>
      <pubDate>Sun, 19 Mar 2023 08:08:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://chat.openai.com/chat&quot;&gt;ChatGPT&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;대전 MBC&lt;/b&gt; 초청으로 ChatGPT 관련 방송에 참여했습니다.&lt;/li&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><a href="https://chat.openai.com/chat">ChatGPT</a></p></blockquote><ul><li><b>대전 MBC</b> 초청으로 ChatGPT 관련 방송에 참여했습니다.</li><li>시사토론 프로그램인 <b>시시각각</b>에 참여해 다른 전문가 분들과 함께 말씀을 나눴습니다.</li></ul><ul><li><p>2016년, 우리는 준비되지 않은 채 알파고라는 이름에 얽매였던 경험이 있습니다.</p></li><li><p>오늘의 우리는 <b>ChatGPT라는 이름에 얽매이지 않기를 바랍니다.</b></p></li><li><p>지금의 관심이 새로운 파도를 탈 수 있는 기초체력으로 이어지기를 희망합니다.</p></li><li><p>영상 : (<a href="https://youtu.be/snd_LISfByA">Youtube Link</a>)<br></p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/snd_LISfByA" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/openai/">openai</category>
      
      <category domain="https://jehyunlee.github.io/tags/chatgpt/">chatgpt</category>
      
      <category domain="https://jehyunlee.github.io/tags/mbc/">mbc</category>
      
      
    </item>
    
    <item>
      <title>Company Personification</title>
      <link>https://jehyunlee.github.io/2023/03/09/Python-General-17-company/</link>
      <guid>https://jehyunlee.github.io/2023/03/09/Python-General-17-company/</guid>
      <pubDate>Thu, 09 Mar 2023 14:02:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://chat.openai.com/chat&quot;&gt;ChatGPT&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://platform.openai.com/docs/introduction&quot;&gt;OpenAI API doc</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><a href="https://chat.openai.com/chat">ChatGPT</a><br><a href="https://platform.openai.com/docs/introduction">OpenAI API documentation</a></p></blockquote><ul><li>ChatGPT API가 공개되었습니다.</li><li>사전 신청자를 받고 있긴 했지만 기습적으로 느껴질만큼 갑자기 공개했습니다.</li><li>API를 공개했기 때문에 다른 여러 기능과 연계기를 발휘하기 좋습니다.</li><li>기존의 GPT API를 사용해 회사의 이미지를 의인화합니다.</li></ul><h1 id="1-인물로-본-회사-이미지"><a href="#1-인물로-본-회사-이미지" class="headerlink" title="1. 인물로 본 회사 이미지"></a>1. 인물로 본 회사 이미지</h1><blockquote><p><a href="https://www.yna.co.kr/view/GYH20141105001500044">연합뉴스: 인물로 본 6개 그룹 이미지</a></p></blockquote><p><img src="yna.jpg"></p><ul><li>가끔 언론에 이런 보도가 납니다.</li><li>특정 집단을 대상으로 특정 회사에 대한 이미지를 조사한 후 인물로 표현합니다.</li><li>직관적이기도 하지만 재미가 있어서 좋아하는 기사입니다.</li><li><b>ChatGPT</b>한테 이걸 시키면 잘 할 것 같다는 생각이 들었습니다.</li><li>그림으로 표현하는 능력이 없으니 그림은 <b>DALL.E</b>에게 그리도록 합니다.</li></ul><h1 id="2-ChatGPT를-통해-회사를-의인화해서-묘사하기"><a href="#2-ChatGPT를-통해-회사를-의인화해서-묘사하기" class="headerlink" title="2. ChatGPT를 통해 회사를 의인화해서 묘사하기"></a>2. ChatGPT를 통해 회사를 의인화해서 묘사하기</h1><ul><li><p>ChatGPT에게 회사 이름을 주고, 의인화해서 설명을 해보라면 잘 합니다.</p></li><li><p><b>삼성전자</b>가 사람으로 치면 어떤 사람인지 물어봤습니다.</p></li><li><p>한국인이고, 중성이고, 확신감에 차있고 전문성이 있다고 합니다.<br><br><img src="17_company_01.png"><br></p></li><li><p>ChatGPT 사이트에 가서 물어볼 수도 있지만 API를 이용해보겠습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"><span class="keyword">from</span> MyAPIKEY <span class="keyword">import</span> OpenAI  <span class="comment"># openai API key를 미리 발급받아 저장했습니다.</span></span><br><span class="line">openai.api_key = OpenAI  <span class="comment"># API Key 입력</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ChatGPT API 활용 : 회사를 의인화해서 정보 말하기.</span></span><br><span class="line">company = <span class="string">&quot;Samsung Electronics&quot;</span></span><br><span class="line">completion = openai.ChatCompletion.create(</span><br><span class="line">  model=<span class="string">&quot;gpt-3.5-turbo&quot;</span>,</span><br><span class="line">  messages=[</span><br><span class="line">    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, </span><br><span class="line">     <span class="string">&quot;content&quot;</span>: <span class="string">f&quot;Answer me about the company, whose name is <span class="subst">&#123;company&#125;</span>, without using any other words. \</span></span><br><span class="line"><span class="string">                  What is its nationality? \</span></span><br><span class="line"><span class="string">                  Imagine the company as a person. \</span></span><br><span class="line"><span class="string">                  Is it male or female? What is its impression? How does it dress?&quot;</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ChatGPT 응답 출력</span></span><br><span class="line">answer = completion.choices[<span class="number">0</span>].message</span><br><span class="line">answer</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;OpenAIObject at 0x1fd3ca48a40&gt; JSON: &#123;</span><br><span class="line">  <span class="string">&quot;content&quot;</span>: <span class="string">&quot;\n\nNationality: South Korean\n\nImagined person: Gender-neutral \n\nImpression: Technologically advanced and innovative \n\nDressing style: Modern and trendy with a focus on functionality.&quot;</span>,</span><br><span class="line">  <span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>웹과 완전 동일하지는 않지만 비슷한 형식의 답변이 나왔습니다.</p></li><li><p>다음과 같이 답변에서 원하는 문장만 깔끔하게 뽑아낼 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prompt = <span class="built_in">dict</span>(answer)[<span class="string">&quot;content&quot;</span>].lstrip(<span class="string">&quot;\n&quot;</span>).replace(<span class="string">&quot;\n\n&quot;</span>, <span class="string">&quot;, &quot;</span>)</span><br><span class="line">prompt</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;Nationality: South Korean, Imagined person: Gender-neutral , Impression: Technologically advanced and innovative , Dressing style: Modern and trendy with a focus on functionality.&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="3-DALL-E를-통해-그림으로-표현하기"><a href="#3-DALL-E를-통해-그림으로-표현하기" class="headerlink" title="3. DALL.E를 통해 그림으로 표현하기"></a>3. DALL.E를 통해 그림으로 표현하기</h1><ul><li><p>회사에 대한 이미지를 얻었으니 그림으로 그립니다.</p></li><li><p>마찬가지로 OpenAI API를 사용합니다.</p></li><li><p>ChatGPT가 만든 <code>prompt</code>를 입력으로 넣고, 그 앞에 <b>길에 서있는 사람의 몸통 사진</b>이라는 뜻의 문구를 추가합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">response = openai.Image.create(</span><br><span class="line">  prompt= <span class="string">&quot;a photography of torso of a person, standing on the street: &quot;</span> + prompt,</span><br><span class="line">  n=<span class="number">4</span>,</span><br><span class="line">  size=<span class="string">&quot;512x512&quot;</span></span><br><span class="line">)</span><br><span class="line">images = response[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">images_url = [i[<span class="string">&quot;url&quot;</span>] <span class="keyword">for</span> i <span class="keyword">in</span> images]</span><br><span class="line">images_url</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;https://oaidalleapiprodscus.blob.core.windows.net/private/org-AhUkzJK2WZGMFoMyGMghYXRV/user-GJilwEnUIKmd9QOgEkYhUF46/img-wmfnBPTbuqfFVPWhBCgWAehQ.png?st=2023-03-09T13%3A45%3A16Z&amp;se=2023-03-09T15%3A45%3A16Z&amp;sp=r&amp;sv=2021-08-06&amp;sr=b&amp;rscd=inline&amp;rsct=image/png&amp;skoid=6aaadede-4fb3-4698-a8f6-684d7786b067&amp;sktid=a48cca56-e6da-484e-a814-9c849652bcb3&amp;skt=2023-03-08T23%3A46%3A41Z&amp;ske=2023-03-09T23%3A46%3A41Z&amp;sks=b&amp;skv=2021-08-06&amp;sig=A9gkIRkfbORN06hfMsCAfIB6ZxDCyYg3PBGVhY9pjX4%3D&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;https://oaidalleapiprodscus.blob.core.windows.net/private/org-AhUkzJK2WZGMFoMyGMghYXRV/user-GJilwEnUIKmd9QOgEkYhUF46/img-ILfQqDLOe9qezlAS4HNDYIb0.png?st=2023-03-09T13%3A45%3A16Z&amp;se=2023-03-09T15%3A45%3A16Z&amp;sp=r&amp;sv=2021-08-06&amp;sr=b&amp;rscd=inline&amp;rsct=image/png&amp;skoid=6aaadede-4fb3-4698-a8f6-684d7786b067&amp;sktid=a48cca56-e6da-484e-a814-9c849652bcb3&amp;skt=2023-03-08T23%3A46%3A41Z&amp;ske=2023-03-09T23%3A46%3A41Z&amp;sks=b&amp;skv=2021-08-06&amp;sig=RSDcoiw3vqtHQTgXqEeQKBf2EOY9Zbx%2BCNrgcJetcFU%3D&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;https://oaidalleapiprodscus.blob.core.windows.net/private/org-AhUkzJK2WZGMFoMyGMghYXRV/user-GJilwEnUIKmd9QOgEkYhUF46/img-wxblEkkn0ZZjmp3vxwA3Kso2.png?st=2023-03-09T13%3A45%3A16Z&amp;se=2023-03-09T15%3A45%3A16Z&amp;sp=r&amp;sv=2021-08-06&amp;sr=b&amp;rscd=inline&amp;rsct=image/png&amp;skoid=6aaadede-4fb3-4698-a8f6-684d7786b067&amp;sktid=a48cca56-e6da-484e-a814-9c849652bcb3&amp;skt=2023-03-08T23%3A46%3A41Z&amp;ske=2023-03-09T23%3A46%3A41Z&amp;sks=b&amp;skv=2021-08-06&amp;sig=2pDH7f8ONdppBdPcEsQJcZ/qNt/jpmUrpZ9LVuLDzQw%3D&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;https://oaidalleapiprodscus.blob.core.windows.net/private/org-AhUkzJK2WZGMFoMyGMghYXRV/user-GJilwEnUIKmd9QOgEkYhUF46/img-lfyMHLR93DZ8a0iOM9H268Jr.png?st=2023-03-09T13%3A45%3A16Z&amp;se=2023-03-09T15%3A45%3A16Z&amp;sp=r&amp;sv=2021-08-06&amp;sr=b&amp;rscd=inline&amp;rsct=image/png&amp;skoid=6aaadede-4fb3-4698-a8f6-684d7786b067&amp;sktid=a48cca56-e6da-484e-a814-9c849652bcb3&amp;skt=2023-03-08T23%3A46%3A41Z&amp;ske=2023-03-09T23%3A46%3A41Z&amp;sks=b&amp;skv=2021-08-06&amp;sig=UJIty7F3F7wDiFhOLpMewwXjzw4K9M3zocJlGuHiwso%3D&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li><p>아주 긴 URL이 나왔습니다. 긁어다 인터넷 주소창에 붙이면 그림이 보입니다.</p></li><li><p>이 그림을 받아다 모아서 파일로 저장합니다.</p></li><li><p><code>urllib</code>과 <code>numpy</code>, <code>PIL</code>을 사용해 주소를 가져와 <code>Matplotlib</code>으로 표현합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> PIL</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>]=<span class="string">&#x27;NanumGothic&#x27;</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">imgs = [np.array(PIL.Image.<span class="built_in">open</span>(urllib.request.urlopen(url))) <span class="keyword">for</span> url <span class="keyword">in</span> images_url]</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(ncols=<span class="number">2</span>, nrows=<span class="number">2</span>, figsize=(<span class="number">6</span>, <span class="number">6</span>), gridspec_kw=&#123;<span class="string">&quot;hspace&quot;</span>:<span class="number">0</span>, <span class="string">&quot;wspace&quot;</span>:<span class="number">0</span>&#125;)</span><br><span class="line">axs = axes.ravel()</span><br><span class="line"><span class="keyword">for</span> ax, img <span class="keyword">in</span> <span class="built_in">zip</span>(axs, imgs):</span><br><span class="line">    ax.imshow(img)</span><br><span class="line">    ax.axis(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">fig.suptitle(<span class="string">f&quot;<span class="subst">&#123;company&#125;</span>&quot;</span>, fontsize=<span class="string">&quot;x-large&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">fig.savefig(<span class="string">f&quot;imgs_<span class="subst">&#123;company&#125;</span>.png&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="imgs_Samsung_Electronics.png"><br></p></li></ul><h1 id="4-회사-이름을-입력받아-그림으로-출력"><a href="#4-회사-이름을-입력받아-그림으로-출력" class="headerlink" title="4. 회사 이름을 입력받아 그림으로 출력"></a>4. 회사 이름을 입력받아 그림으로 출력</h1><ul><li><p>ChatGPT는 회사 이름에서 회사의 인상을 도출했고</p></li><li><p>DALL.E는 회사의 인상을 그림으로 표현했습니다.</p></li><li><p>이제 둘을 합칩니다.</p></li><li><p>먼저 ChatGPT 활용 부분을 함수로 만들어 잘 동작하는지 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tell_me_about</span>(<span class="params">company</span>):</span></span><br><span class="line">    completion = openai.ChatCompletion.create(</span><br><span class="line">      model=<span class="string">&quot;gpt-3.5-turbo&quot;</span>,</span><br><span class="line">      messages=[</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, </span><br><span class="line">         <span class="string">&quot;content&quot;</span>: <span class="string">f&quot;Answer me about the company, whose name is <span class="subst">&#123;company&#125;</span>, without using any other words. \</span></span><br><span class="line"><span class="string">                      What is its nationality? \</span></span><br><span class="line"><span class="string">                      Imagine the company as a person. \</span></span><br><span class="line"><span class="string">                      Is it male or female? What is its impression? How does it dress?&quot;</span>&#125;</span><br><span class="line">      ]</span><br><span class="line">    )</span><br><span class="line">    answer = completion.choices[<span class="number">0</span>].message</span><br><span class="line">    prompt = <span class="built_in">dict</span>(answer)[<span class="string">&quot;content&quot;</span>].lstrip(<span class="string">&quot;\n&quot;</span>).replace(<span class="string">&quot;\n\n&quot;</span>, <span class="string">&quot;, &quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> prompt</span><br><span class="line"></span><br><span class="line">prompt = tell_me_about(<span class="string">&quot;LG Chemistry&quot;</span>)</span><br><span class="line">prompt</span><br></pre></td></tr></table></figure></li><li><p>실행 결과</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;This company is from South Korea. As a person, LG Chemistry would be considered gender-neutral. Its impression would be innovative and tech-savvy. In terms of dressing, it would likely wear modern, professional attire.&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>잘 됩니다.</p></li><li><p>이번엔 DALL.E를 사용해 설명을 그림으로 변환합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_about</span>(<span class="params">prompt, company</span>):</span></span><br><span class="line">    response = openai.Image.create(</span><br><span class="line">    prompt= <span class="string">&quot;a photography of torso of a person, standing on the street: &quot;</span> + prompt,</span><br><span class="line">    n=<span class="number">4</span>,</span><br><span class="line">    size=<span class="string">&quot;512x512&quot;</span></span><br><span class="line">    )</span><br><span class="line">    images = response[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">    images_url = [i[<span class="string">&quot;url&quot;</span>] <span class="keyword">for</span> i <span class="keyword">in</span> images]</span><br><span class="line"></span><br><span class="line">    imgs = [np.array(PIL.Image.<span class="built_in">open</span>(urllib.request.urlopen(url))) <span class="keyword">for</span> url <span class="keyword">in</span> images_url]</span><br><span class="line"></span><br><span class="line">    fig, axes = plt.subplots(ncols=<span class="number">2</span>, nrows=<span class="number">2</span>, figsize=(<span class="number">6</span>, <span class="number">6</span>), gridspec_kw=&#123;<span class="string">&quot;hspace&quot;</span>:<span class="number">0</span>, <span class="string">&quot;wspace&quot;</span>:<span class="number">0</span>&#125;)</span><br><span class="line">    axs = axes.ravel()</span><br><span class="line">    <span class="keyword">for</span> ax, img <span class="keyword">in</span> <span class="built_in">zip</span>(axs, imgs):</span><br><span class="line">        ax.imshow(img)</span><br><span class="line">        ax.axis(<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    fig.suptitle(<span class="string">f&quot;<span class="subst">&#123;company&#125;</span>&quot;</span>, fontsize=<span class="string">&quot;x-large&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>)</span><br><span class="line">    fig.savefig(<span class="string">f&quot;imgs_<span class="subst">&#123;company.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;_&#x27;</span>)&#125;</span>.png&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> fig</span><br><span class="line"></span><br><span class="line">fig = draw_about(<span class="string">&quot;LG Chemistry&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="imgs_LG_Chemistry.png"><br></p></li></ul><ul><li>그리고 두 함수를 합칩니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tell_and_draw</span>(<span class="params">company</span>):</span></span><br><span class="line">    prompt = tell_me_about(company)</span><br><span class="line">    fig = draw_about(company)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;# Name: <span class="subst">&#123;company&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;# <span class="subst">&#123;prompt&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> prompt, fig</span><br><span class="line"></span><br><span class="line">prompt, fig = tell_and_draw(<span class="string">&quot;TSMC&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># Name: TSMC</span></span><br><span class="line"><span class="comment"># Taiwanese. , The company is an entity and therefore does not have a gender or dress style.</span></span><br></pre></td></tr></table></figure><img src="imgs_TSMC.png"><br></li></ul><h1 id="5-DeepL로-묘사-부분-번역"><a href="#5-DeepL로-묘사-부분-번역" class="headerlink" title="5. DeepL로 묘사 부분 번역"></a>5. DeepL로 묘사 부분 번역</h1><ul><li>나름 재밌게 돌아가는데 설명을 읽기 귀찮습니다. </li><li>외국어는 모국어보다 불편하거든요.</li><li>번역기를 붙입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> MyAPIKEY <span class="keyword">import</span> RapidAPI</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># DeepL 사용 번역</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deepl</span>(<span class="params">text, RapidAPI=RapidAPI, src=<span class="string">&quot;auto&quot;</span>, dest=<span class="string">&quot;ko&quot;</span></span>):</span></span><br><span class="line">    url = <span class="string">&quot;https://deepl-translator.p.rapidapi.com/translate&quot;</span></span><br><span class="line">    </span><br><span class="line">    payload = &#123;</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: text,</span><br><span class="line">        <span class="string">&quot;source&quot;</span>: src,</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: dest</span><br><span class="line">    &#125;</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;X-RapidAPI-Key&quot;</span>: RapidAPI,</span><br><span class="line">        <span class="string">&quot;X-RapidAPI-Host&quot;</span>: <span class="string">&quot;deepl-translator.p.rapidapi.com&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.request(<span class="string">&quot;POST&quot;</span>, url, json=payload, headers=headers)</span><br><span class="line">    translated = response.json()[<span class="string">&quot;text&quot;</span>]</span><br><span class="line">    <span class="keyword">return</span> translated</span><br><span class="line"></span><br><span class="line"><span class="comment"># DeelL 포함 함수 재정의</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tell_and_draw</span>(<span class="params">company</span>):</span></span><br><span class="line">    prompt = tell_me_about(company)</span><br><span class="line">    fig = draw_about(company)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;# Name: <span class="subst">&#123;company&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;# <span class="subst">&#123;deepl(prompt)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> prompt, fig</span><br><span class="line"></span><br><span class="line">prompt, fig = tell_and_draw(<span class="string">&quot;IBM&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>실행 결과 : 영문을 모르겠지만 IBM 묘사가 유달리 짧습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Name: IBM</span></span><br><span class="line"><span class="comment"># IBM은 컴퓨터 하드웨어, 미들웨어 및 소프트웨어를 설계하고 판매하는 다국적 기업입니다.</span></span><br></pre></td></tr></table></figure><img src="imgs_IBM.png"><br></li></ul><ul><li>하나를 더 해봅니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt, fig = tell_and_draw(<span class="string">&quot;Toyota&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># Name: Toyota</span></span><br><span class="line"><span class="comment"># 국적: 일본어, 의인화: 도요타는 품질과 신뢰성을 중시하는 근면하고 혁신적인 개인입니다. , 성별: 중립 , 인상: 도요타는 자동차 산업의 리더로 간주되며 첨단 기술과 친환경으로 존경 받고 있습니다. , 복장: 기업 이미지에 걸맞게 깔끔하고 전문적인 외모에 스마트한 정장 차림을 주로 합니다.</span></span><br></pre></td></tr></table></figure><img src="imgs_Toyota.png"><br></li></ul><h1 id="6-결론"><a href="#6-결론" class="headerlink" title="6. 결론"></a>6. 결론</h1><ul><li>길지 않은 코드이지만 ChatGPT + DALL.E + DeepL을 묶었습니다.</li><li><b>단순해보이지만 세 개의 API를 묶은 컴비네이션</b>입니다.</li><li>API를 활용하면 여러 기능을 레고 조립하듯 마음껏 엮을 수 있습니다.</li><li>마음껏 사용하시기 바랍니다.</li></ul><h1 id="6-마음껏-사용하기"><a href="#6-마음껏-사용하기" class="headerlink" title="6. 마음껏 사용하기"></a>6. 마음껏 사용하기</h1><h3 id="Apple"><a href="#Apple" class="headerlink" title="Apple"></a><b>Apple</b><br></h3><p><img src="Apple.png"><br></p><h3 id="Tesla"><a href="#Tesla" class="headerlink" title="Tesla"></a><b>Tesla</b><br></h3><p><img src="Tesla.png"><br></p><h3 id="Facebook"><a href="#Facebook" class="headerlink" title="Facebook"></a><b>Facebook</b><br></h3><p><img src="Facebook.png"><br></p><h3 id="McDonalds"><a href="#McDonalds" class="headerlink" title="McDonalds"></a><b>McDonalds</b><br></h3><p><img src="McDonalds.png"><br></p><h3 id="YouTube"><a href="#YouTube" class="headerlink" title="YouTube"></a><b>YouTube</b><br></h3><p><img src="YouTube.png"><br></p><h3 id="OpenAI"><a href="#OpenAI" class="headerlink" title="OpenAI"></a><b>OpenAI</b><br></h3><p><img src="OpenAI.png"><br></p><ul><li><b># Name: Amazon</b><ul><li><b># 국적: 미국, 의인화:</b> 성별: 중립. 인상: 혁신적이고, 기술에 정통함. 복장: 모던하고 캐주얼하면서도 전문적인 복장</li></ul></li><li><b># Name: Microsoft</b><ul><li><b># 국적: 미국, 의인화:</b> 마이크로소프트는 고도로 분석적이고 혁신적인 기술에 정통한 개인으로 묘사됩니다., 성별: N/A(마이크로소프트는 회사이기 때문에 성별이 없음), 인상: 소프트웨어, 하드웨어 및 클라우드 서비스 분야의 리더로서 기술 업계에서 높은 존경과 인정을 받고 있습니다., 복장: N/A(Microsoft는 회사이기 때문에 복장은 없지만 제품과 로고는 세련되고 현대적인 스타일을 나타냅니다).</li></ul></li><li><b># Name: Google</b><ul><li>(설명이 전혀 없음)<br><br><img src="imgs_Amazon_Microsoft_Google.png"><br></li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/DALL-E/">DALL.E</category>
      
      <category domain="https://jehyunlee.github.io/tags/openai/">openai</category>
      
      <category domain="https://jehyunlee.github.io/tags/chatgpt/">chatgpt</category>
      
      <category domain="https://jehyunlee.github.io/tags/DeepL/">DeepL</category>
      
      
    </item>
    
    <item>
      <title>번역 모델 비교 - 성능, 시간, 요금</title>
      <link>https://jehyunlee.github.io/2023/02/20/Python-DS-128-transqual/</link>
      <guid>https://jehyunlee.github.io/2023/02/20/Python-DS-128-transqual/</guid>
      <pubDate>Sun, 19 Feb 2023 22:09:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;딥러닝의 빠른 발전으로 기계번역이 매우 쉬워졌습니다.&lt;/li&gt;
&lt;li&gt;다양한 모델을 선택할 수 있고, 구독 모델도 여럿 나와있습니다.&lt;/li&gt;
&lt;li&gt;현명한 소비자가 되기 위해 모델들의 번역 성능을 비교합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>딥러닝의 빠른 발전으로 기계번역이 매우 쉬워졌습니다.</li><li>다양한 모델을 선택할 수 있고, 구독 모델도 여럿 나와있습니다.</li><li>현명한 소비자가 되기 위해 모델들의 번역 성능을 비교합니다.</li></ul><h1 id="1-번역-성능-평가"><a href="#1-번역-성능-평가" class="headerlink" title="1. 번역 성능 평가"></a>1. 번역 성능 평가</h1><blockquote><p><a href="https://dl.acm.org/doi/10.3115/1073083.1073135">BLEU: a method for automatic evaluation of machine translation</a><br><a href="https://wikidocs.net/31695">유원준, 안상준, “딥 러닝을 이용한 자연어 처리 입문”</a></p></blockquote><ul><li>최근 논문 내용을 요약, 추출하고 번역하여 제공하는 프로그램을 개발중입니다.</li><li>일반적으로 학술적으로 사용하는 성능 평가는 <b>BLEU significance</b>를 사용합니다.</li><li><a href="https://wikidocs.net/31695">기계 번역 결과와 사람이 직접 번역한 결과가 얼마나 유사한지 비교하여 성능을 측정하는 방법입니다.</a></li><li><a href="https://wikidocs.net/31695">n-gram에 기반하여 언어에 구애받지 않고 사용할 수 있으며 계산 속도가 빠릅니다.</a></li></ul><p><img src="128_transqual_01.png" alt="Skimmer: 논문 요약, 추출 번역 프로그램 (개발중)"></p><ul><li>그러나 제 프로그램에 사용할 프로그램은 <b>꼭 최고의 성능이 아니어도 됩니다.</b></li><li>문장이 다소 어색해도 내용을 파악할 수 있는 각 분야의 준전문가 이상이 예상 사용자입니다.</li><li><b>문장 끊김과 같은 치명적인 어색함</b>과 함께 <b>번역 속도</b>, <b>비용</b>이 중요 포인트입니다.</li></ul><h1 id="2-번역-모델"><a href="#2-번역-모델" class="headerlink" title="2. 번역 모델"></a>2. 번역 모델</h1><blockquote><p><a href="https://huggingface.co/docs/transformers">Huggingface Transformer</a><br><a href="https://rapidapi.com/">Rapidapi</a><br><a href="https://platform.openai.com/docs/guides/completion/translation">OpenAI</a><br><a href="https://developers.naver.com/docs/papago/">Naver Papago</a></p></blockquote><ul><li>몇 년 전만 해도 구글 번역기가 거의 유일한 대안이었지만 판도가 바뀌었습니다.</li><li>Transformer 딥러닝 모델의 대두로 언어 처리 성능이 크게 향상되었을 뿐더러,</li><li><a href="https://huggingface.co/docs/transformers">Huggingface</a>와 <a href="https://rapidapi.com/">Rapidapi</a>같은 곳들 덕택에 모델 사용이 쉬워졌습니다.</li><li><a href="https://platform.openai.com/docs/guides/completion/translation">OpenAI</a>에서 내놓은 GPT와 ChatGPT도 우수한 성능을 보입니다.</li><li>국내에서는 네이버의 <a href="https://developers.naver.com/docs/papago/">파파고</a>가 대표적입니다.</li></ul><blockquote><p><a href="https://jehyunlee.github.io/2022/07/02/Python-DS-106-aaicon/">실용인공지능학회: Open API를 이용한 고속 논문 분석</a></p></blockquote><ul><li>논문 초록(abstract)을 요약한 것과 함께 독창성(originality)을 추출한 문장을 대상으로 테스트를 진행합니다.</li><li><a href="https://jehyunlee.github.io/2022/07/02/Python-DS-106-aaicon/">지난 학회</a>에서 발표한 내용을 바탕으로 일차 서비스를 만들었습니다.</li><li>여기서 도출된 데이터를 이용해 번역 모델을 테스트합니다.</li><li><b>abstract summary</b>는 초록이 요약된 것, <b>originality</b>는 초록 중에서 독창성을 드러내는 문장을 추출한 것입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df_ex = pd.read_excel(<span class="string">&quot;samples.xlsx&quot;</span>)</span><br><span class="line">df_ex</span><br></pre></td></tr></table></figure><img src="128_transqual_02.png"></li></ul><ul><li>예컨대 첫 번째 데이터는 다음 논문입니다.</li></ul><p><img src="128_transqual_03.png"><br></p><ul><li><p>이 논문의 초록을 요약하면 다음과 같습니다.</p></li><li><p><b>초록 요약본</b>은 <b>64단어, 413자</b>로 구성되어 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abs0 =</span><br><span class="line"><span class="string">&quot;PV panels produce unnecessary heat energy during power generation which increases the temperature and affects the efficiency of PV cells. This article investigates the performance of PV modules using aluminum heat sinks and forced air cooling techniques. The average electrical efficiency of the studied PV panels is 17% and is very close to the PV module efficiency of 19.38% under standard test conditions (STC)&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>그리고 첫 문장 같은 전반적인 동향을 뜻하는 말을 제외하고 <b>독창성</b>만 추출하면 다음과 같습니다.</p></li><li><p><b>독창성 추출본</b>은 <b>31단어, 184자</b>로 구성되어 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org0 =</span><br><span class="line"><span class="string">&quot;The results of the study show that solar energy generation can be optimized by considering the design, use of materials and proper cooling methods even when using the same solar panel.&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>읽을 수 있는 영문이고 원문에 비해 길이도 크게 줄었습니다.</p></li><li><p>하지만 더 쉽게 읽고 싶습니다. 여러 번역 엔진을 비교합니다.</p></li></ul><h2 id="2-1-Google-Translate"><a href="#2-1-Google-Translate" class="headerlink" title="2.1. Google Translate"></a>2.1. Google Translate</h2><blockquote><p><a href="https://pypi.org/project/googletrans/">pypi:googletrans</a></p></blockquote><ul><li><p>googletrans를 사용하는 방법이 있고 Google Cloud를 API로 이용하는 방법이 있습니다.</p></li><li><p>googletrans도 <b>Google Translate Ajax API</b>를 사용한다니 완전한 설치형은 아닙니다.</p></li><li><p>여기서는 googletrans만 사용합니다. 글이 그다지 길지 않기 때문입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!pip install googletrans   # Error 발생</span></span><br><span class="line">!pip install googletrans==<span class="number">3.1</span><span class="number">.0</span>a0</span><br></pre></td></tr></table></figure></li><li><p><code>!pip install googletrans</code>를 실행하면 현재 기준 <code>3.0.0</code> 버전이 설치됩니다.</p></li><li><p>하지만 번역 수행시 오류가 발생하므로 문제가 없는 <code>3.1.0a0</code> 버전을 설치하시기 바랍니다.</p></li><li><p>사용법은 간단합니다. <code>Translator()</code>로 번역기 인스턴스를 만든 후 <code>.translate(문구, 목표언어)</code>를 입력하면 됩니다.</p></li><li><p>번역에 걸리는 소요시간을 계산하기 위해 앞뒤로 시간 계산 코드를 붙였습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> googletrans <span class="keyword">import</span> Translator</span><br><span class="line"></span><br><span class="line">google = Translator()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 초록 요약</span></span><br><span class="line">time_start = time()</span><br><span class="line">abs_translator0 = google.translate(abs0, dest=<span class="string">&quot;ko&quot;</span>)  <span class="comment"># 초록 번역</span></span><br><span class="line">time_end = time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# 초록요약= <span class="subst">&#123;abs_translator0.text&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;- 소요시간: <span class="subst">&#123;time_end-time_start:<span class="number">.2</span>f&#125;</span>s\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 독창성 추출</span></span><br><span class="line">time_start = time()</span><br><span class="line">org_translator0 = google.translate(org0, dest=<span class="string">&quot;ko&quot;</span>)  <span class="comment"># 독창성 번역</span></span><br><span class="line">time_end = time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# 독창성추출= <span class="subst">&#123;org_translator0.text&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;- 소요시간: <span class="subst">&#123;time_end-time_start:<span class="number">.2</span>f&#125;</span>s&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 초록요약= PV 패널은 발전 중에 불필요한 열 에너지를 생성하여 온도를 높이고 PV 전지의 효율에 영향을 미칩니다. 이 기사에서는 알루미늄 방열판과 강제 공기 냉각 기술을 사용하는 PV 모듈의 성능을 조사합니다. 연구된 PV 패널의 평균 전기 효율은 17%이며 표준 테스트 조건(STC)에서 PV 모듈 효율 19.38%에 매우 가깝습니다.</span></span><br><span class="line">- 소요시간: 0.39s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 독창성추출= 연구 결과는 동일한 태양광 패널을 사용하더라도 설계, 재료 사용 및 적절한 냉각 방법을 고려하여 태양광 발전을 최적화할 수 있음을 보여줍니다.</span></span><br><span class="line">- 소요시간: 0.29s</span><br></pre></td></tr></table></figure></li></ul></li><li><p><b>안정적인 성능</b>과 <b>매우 빠른 속도</b>를 보여줍니다.</p></li></ul><h2 id="2-2-Papago"><a href="#2-2-Papago" class="headerlink" title="2.2. Papago"></a>2.2. Papago</h2><blockquote><p><a href="https://developers.naver.com/docs/papago/">파파고 API</a><br><a href="https://console.ncloud.com/papago-translation/apis">네이버 클라우드 콘솔:파파고 번역</a><br><a href="https://www.fin-ncloud.com/product/aiService/papagoTranslation">네이버 파파고 API 활용 예시</a></p></blockquote><ul><li><p>일 5백만글자와 월 3천만글자 한도가 있습니다.</p></li><li><p><a href="https://console.ncloud.com/papago-translation/apis">네이버 클라우드 콘솔</a>에 가입하고 <b>client id</b>와 <b>secret</b>을 발급받아야 합니다.</p></li><li><p>이들을 각기 <code>Naver_client_id</code>, <code>Naver_client_secret</code>에 넣으면 다음과 같은 함수를 만들 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">papago</span>(<span class="params">text, src=<span class="string">&quot;en&quot;</span>, dest=<span class="string">&quot;ko&quot;</span></span>):</span>  </span><br><span class="line">    data = &#123;<span class="string">&#x27;text&#x27;</span> : text,</span><br><span class="line">            <span class="string">&#x27;source&#x27;</span> : src,</span><br><span class="line">            <span class="string">&#x27;target&#x27;</span>: dest&#125;</span><br><span class="line"></span><br><span class="line">    url = <span class="string">&quot;https://naveropenapi.apigw.ntruss.com/nmt/v1/translation&quot;</span></span><br><span class="line"></span><br><span class="line">    header = &#123;<span class="string">&quot;X-NCP-APIGW-API-KEY-ID&quot;</span>:Naver_client_id,</span><br><span class="line">              <span class="string">&quot;X-NCP-APIGW-API-KEY&quot;</span>:Naver_client_secret&#125;</span><br><span class="line"></span><br><span class="line">    response = requests.post(url, headers=header, data=data)</span><br><span class="line">    rescode = response.status_code</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(rescode==<span class="number">200</span>):</span><br><span class="line">        send_data = response.json()</span><br><span class="line">        trans_data = (send_data[<span class="string">&#x27;message&#x27;</span>][<span class="string">&#x27;result&#x27;</span>][<span class="string">&#x27;translatedText&#x27;</span>])</span><br><span class="line">        <span class="keyword">return</span> trans_data</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error Code:&quot;</span> , rescode)</span><br></pre></td></tr></table></figure></li><li><p>위 함수를 사용해 번역을 수행합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 초록 요약</span></span><br><span class="line">time_start = time()</span><br><span class="line">abs_translator1 = papago(abs0, dest=<span class="string">&quot;ko&quot;</span>)</span><br><span class="line">time_end = time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# 초록요약= <span class="subst">&#123;abs_translator1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;- 소요시간: <span class="subst">&#123;time_end-time_start:<span class="number">.2</span>f&#125;</span>s\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 독창성 추출</span></span><br><span class="line">time_start = time()</span><br><span class="line">org_translator1 = papago(org0, dest=<span class="string">&quot;ko&quot;</span>)</span><br><span class="line">time_end = time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# 독창성추출= <span class="subst">&#123;org_translator1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;- 소요시간: <span class="subst">&#123;time_end-time_start:<span class="number">.2</span>f&#125;</span>s&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 초록요약= PV 패널은 발전 시 불필요한 열에너지를 발생시켜 온도를 상승시키고 PV 셀의 효율에 영향을 미친다. 본 논문에서는 알루미늄 히트 싱크와 강제 공기 냉각 기술을 사용한 PV 모듈의 성능을 조사한다. 연구된 PV 패널의 평균 전기 효율은 17%이며 표준 시험 조건(STC)에서 PV 모듈 효율 19.38%에 매우 가깝다</span></span><br><span class="line">- 소요시간: 0.15s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 독창성추출= 연구 결과는 동일한 태양광 패널을 사용하는 경우에도 설계와 재료 사용, 적절한 냉각 방식 등을 고려하면 태양광 발전을 최적화할 수 있음을 보여준다.</span></span><br><span class="line">- 소요시간: 0.35s</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Google Translate가 존대말을 하는 반면 Naver는 반말을 합니다. </p></li><li><p>속도도 Google Translate 비슷하지만 유료 과금이 다소 마음에 걸립니다.</p></li><li><p><b>5백만 글자/일</b>까지는 무료이지만 이후 <b>2만원/1백만 글자</b>로 월별 과금됩니다.</p></li><li><p>서비스가 인기라도 끌면 곤란해질 수 있습니다.</p></li></ul><h2 id="2-3-Huggingface"><a href="#2-3-Huggingface" class="headerlink" title="2.3. Huggingface"></a>2.3. Huggingface</h2><blockquote><p><a href="https://huggingface.co/docs/transformers/tasks/translation">Huggingface: Transformers-translation</a><br><a href="https://www.theclickreader.com/language-translation-using-hugging-face-and-python/">TheClickReader: Language Translation using Huggingface and Python in 3 lines of code</a><br><a href="https://ai.facebook.com/blog/introducing-many-to-many-multilingual-machine-translation/">Meta AI: The first AI model that translates 100 languages without relying on English data</a><br><a href="https://scontent.ficn2-2.fna.fbcdn.net/v/t39.8562-6/122141102_1284164108584699_8596121596808227915_n.pdf?_nc_cat=108&ccb=1-7&_nc_sid=ae5e01&_nc_ohc=hBPnkJzF-6AAX8qvUzN&_nc_ht=scontent.ficn2-2.fna&oh=00_AfAXVKNnFRZgRp37P9wjJFQAWslRGNXPFvCiOphK83fXXQ&oe=63F726B4">Beyond English-Centric Multilingual Machine Translation</a></p></blockquote><ul><li>Huggingface를 사용하면 transformer등 최신 모델을 활용하기 좋습니다.</li><li>별도 요금을 지불할 필요가 없기 때문에 과금에서도 자유롭습니다.</li><li><code>pip</code>로 간단하게 설치하고 시작합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install transformers sentencepiece -q</span><br></pre></td></tr></table></figure></li></ul><p><img src="128_transqual_04.png"><br></p><ul><li>여러 모델이 있지만 여기서는 최초의 다중언어 기계학습 모델인 M2M-100을 사용하겠습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> pipeline</span><br><span class="line"></span><br><span class="line">pipe = pipeline(task=<span class="string">&#x27;text2text-generation&#x27;</span>, model=<span class="string">&#x27;facebook/m2m100_418M&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 초록 요약</span></span><br><span class="line">time_start = time()</span><br><span class="line">abs_translator2 = pipe(abs0, forced_bos_token_id=pipe.tokenizer.get_lang_id(lang=<span class="string">&#x27;ko&#x27;</span>))</span><br><span class="line">time_end = time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# 초록요약= <span class="subst">&#123;abs_translator2[<span class="number">0</span>][<span class="string">&#x27;generated_text&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;- 소요시간: <span class="subst">&#123;time_end-time_start:<span class="number">.2</span>f&#125;</span>s\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 독창성 추출</span></span><br><span class="line">time_start = time()</span><br><span class="line">org_translator2 = pipe(org0, forced_bos_token_id=pipe.tokenizer.get_lang_id(lang=<span class="string">&#x27;ko&#x27;</span>))</span><br><span class="line">time_end = time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# 독창성추출= <span class="subst">&#123;org_translator2[<span class="number">0</span>][<span class="string">&#x27;generated_text&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;- 소요시간: <span class="subst">&#123;time_end-time_start:<span class="number">.2</span>f&#125;</span>s&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 초록요약= PV 패널은 전원 생산 중에 불필요한 열 에너지를 생산하여 온도를 증가시키고 PV 세포의 효율성에 영향을 미칩니다.이 기사는 알루미늄 열 싱크 및 강제 공기 냉각 기술을 사용하여 PV 모듈의 성능을 조사합니다. 연구 된 PV 패널의 평균 전기 효율성은 17 %이며 표준 테스트 조건 (STC)에서 19.38 %의 PV 모듈 효율성에 매우 가깝습니다.</span></span><br><span class="line">- 소요시간: 23.89s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 독창성추출= 연구 결과에 따르면 태양 에너지 생산은 디자인, 재료 사용 및 적절한 냉각 방법을 고려하여 동일한 태양 전지판을 사용할 때에도 최적화 될 수 있습니다.</span></span><br><span class="line">- 소요시간: 8.82s</span><br></pre></td></tr></table></figure></li></ul></li><li>앞의 두 모델과 달리 시간이 적지 않게 걸렸습니다.</li><li>GPU(NVIDIA GeForce RTX 2070)이 설치된 데스크탑에서도 실행해 보았습니다.</li><li>하지만 <b>abs0: 15.59s</b>, <b>org0: 5.88s</b>로 서비스에는 적합하지 않은 시간이 소요됐습니다.</li></ul><h2 id="2-4-OpenAI-GPT3"><a href="#2-4-OpenAI-GPT3" class="headerlink" title="2.4. OpenAI GPT3"></a>2.4. OpenAI GPT3</h2><blockquote><p><a href="https://platform.openai.com/docs/guides/completion/translation">OpenAI: Translation</a><br><a href="https://chat.openai.com/">ChatGPT</a><br><a href="https://community.openai.com/t/randomly-occurring-openai-api-timeouts/28573/12">OpenAI: Randomly Occuring OpenAI API Timeouts</a></p></blockquote><ul><li>최근 ChatGPT로 인해 언어 모델이 주목을 받고 있습니다.</li><li>많은 유튜버들이 ChatGPT를 엑셀 등에 적용한 영상을 올리고 있지만 실상은 OpenAI의 <b>GPT API</b>를 사용하는 것입니다.</li><li>OpenAI는 번역에 사용할 수 있는 GPT3계열의 여러 가지 모델을 지원합니다.</li></ul><ul><li>공식 설명을 <a href="https://www.deepl.com/">DeepL</a>로 번역한 결과는 다음과 같습니다.<ul><li><b>text-davinci-003</b> : GPT-3 시리즈 중 가장 성능이 뛰어난 모델입니다. 다른 GPT-3 모델보다 더 높은 품질, 더 긴 출력, 더 나은 명령 수행 능력으로 어떤 작업도 수행할 수 있습니다. 요청당 최대 4,000개의 토큰을 처리할 수 있습니다.</li><li><b>text-davinci-002</b> : GPT-3 시리즈의 2세대 모델입니다. GPT-3 모델의 엘리어가 할 수 있는 모든 작업을 수행할 수 있지만 컨텍스트가 적은 경우가 많습니다. 요청당 최대 4,000개의 토큰을 처리할 수 있습니다.</li><li><b>text-davinci-001</b> : GPT-3 시리즈 중 가장 성능이 뛰어난 모델의 이전 버전입니다. 다른 GPT-3 모델이 할 수 있는 모든 작업을 수행할 수 있지만 컨텍스트가 적은 경우가 많습니다.</li><li><b>text-curie-001</b> : 기능이 매우 뛰어나지만 텍스트 다빈치-003보다 빠르고 비용이 저렴합니다.</li></ul></li></ul><ul><li>GPT를 사용하려면 openai에서 API key를 받아야 합니다.</li><li>davinci 모델은 <b>0.12 USD/1k token</b>, curie 모델은 <b>0.012 USD/1k token</b>가 과금됩니다.</li><li>함수를 만드는 김에 시간 측정을 decorator로 합니다.</li><li>먼저 동일 모델을 여러번 반복하면서 일관성을 테스트합니다. 모델은 text-davinci-003 모델을 사용했습니다.</li><li><b>앞서 사용한 다른 모델들과 달리 수행시마다 다른 결과가 나옵니다.</b><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timed</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        time_start = time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        time_end = time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;- 소요시간: <span class="subst">&#123;time_end-time_start:<span class="number">.2</span>f&#125;</span>s&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timed</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translateGPT</span>(<span class="params">text, model=<span class="string">&quot;text-davinci-003&quot;</span>, max_tokens=<span class="number">1000</span>, top_p=<span class="number">1.0</span></span>):</span></span><br><span class="line">    response = openai.Completion.create(</span><br><span class="line">      model=model,</span><br><span class="line">      prompt=<span class="string">f&quot;Translate this in Korean:<span class="subst">&#123;text&#125;</span>&quot;</span>,</span><br><span class="line">      temperature=<span class="number">0.3</span>,</span><br><span class="line">      max_tokens=max_tokens,</span><br><span class="line">      top_p=top_p,</span><br><span class="line">      frequency_penalty=<span class="number">0.0</span>,</span><br><span class="line">      presence_penalty=<span class="number">0.0</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> response.to_dict()[<span class="string">&#x27;choices&#x27;</span>][<span class="number">0</span>][<span class="string">&quot;text&quot;</span>].lstrip(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 5회 번역</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;# <span class="subst">&#123;i&#125;</span>회: <span class="subst">&#123;translateGPT(abs0)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1회: - 소요시간: 23.38s</span></span><br><span class="line"><span class="string">&#x27;PV 패널은 전력 생산 시 불필요한 열 에너지를 발생시키며 온도를 증가시키고 PV 셀의 효율에 영향을 미칩니다. 이 기사는 알루미늄 히트 싱크와 강제 공기 쿨링 기술을 사용하여 PV 모듈의 성능을 조사합니다. 연구된 PV 패널의 평균 전기 효율은 17 %로 표준 시험 조건 (STC) 하에서의 PV 모듈 효율인 19.38 %에 매우 가깝습니다.&#x27;</span></span><br><span class="line"><span class="comment"># 2회: - 소요시간: 20.41s</span></span><br><span class="line"><span class="string">&#x27;PV 패널은 전력 생산 시 불필요한 열 에너지를 발생시켜 PV 셀의 수율에 영향을 미치는 온도를 증가시킵니다. 이 논문은 알루미늄 히트 싱크와 강제 공기 쿨링 기술을 사용한 PV 모듈의 성능을 조사합니다. 연구된 PV 패널의 평균 전기 효율은 17 %로 표준 시험 조건(STC)에서의 PV 모듈 효율인 19.38 %에 매우 가깝습니다.&#x27;</span></span><br><span class="line"><span class="comment"># 3회: - 소요시간: 23.22s</span></span><br><span class="line"><span class="string">&#x27;PV 패널은 전력 생산 중 불필요한 열 에너지를 생산하여 온도를 증가시키고 PV 셀의 효율에 영향을 미칩니다. 이 기사는 알루미늄 히트 싱크 및 강제 공기 쿨링 기술을 사용하여 PV 모듈의 성능을 조사합니다. 연구 된 PV 패널의 평균 전기 효율은 17 %이며 표준 시험 조건 (STC) 하에서의 PV 모듈 효율인 19.38 %에 가깝습니다.&#x27;</span></span><br><span class="line"><span class="comment"># 4회: - 소요시간: 22.51s</span></span><br><span class="line"><span class="string">&#x27;PV 패널은 전력 생산 중 불필요한 열 에너지를 생산하여 온도를 증가시키고 PV 셀의 효율에 영향을 미칩니다. 이 논문은 알루미늄 히트 싱크와 강제 공기 쿨링 기술을 사용하는 PV 모듈의 성능을 조사합니다. 연구 된 PV 패널의 평균 전기 효율은 17 %이며 표준 시험 조건 (STC) 의 PV 모듈 효율인 19.38 %에 가깝습니다.&#x27;</span></span><br><span class="line"><span class="comment"># 5회: - 소요시간: 22.86s</span></span><br><span class="line"><span class="string">&#x27;PV 패널은 전력 생산 중에 불필요한 열 에너지를 발생시켜 온도를 증가시키고 PV 셀의 효율에 영향을 미칩니다. 이 기사는 알루미늄 히트 싱크와 강제 공기 쿨링 기술을 사용한 PV 모듈의 성능을 조사합니다. 연구된 PV 패널의 평균 전기 효율은 17 %이며 표준 시험 조건 (STC) 에서의 PV 모듈 효율인 19.38 %에 매우 가깝습니다.&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li><li>모델별 소요 시간을 확인하기 위해 같은 문구를 모델만 바꾸어 적용했습니다. </li><li>초록 요약본에서 과거 모델일수록 시간이 짧게 걸리는 동향이 확인되지만 독창성은 그렇지 않습니다.<br><br><img src="128_transqual_06.png"><br></li></ul><ul><li><p>이상해서 확인을 해보니 <b>좀 심각한 문제가 있습니다.</b></p></li><li><p><b>originality 번역이 간혹 엉뚱한 결과를 내놓습니다.</b><br></p></li><li><p><b>text-davinci-001</b>은 번역을 하다가 말았고 <b>text-curie-001</b>은 영문을 같이 내뱉습니다.<br><br><img src="128_transqual_05.png"><br></p></li><li><p><b><a href="https://community.openai.com/t/randomly-occurring-openai-api-timeouts/28573/12">간혹 API 접속 오류도 발생합니다</a></b></p></li><li><p>최근 ChatGPT의 인기 때문인지 모르겠지만 접속이 불안정합니다.</p></li><li><p>이런 일을 겪는 것이 저 혼자만은 아닌 것 같습니다.</p></li></ul><h2 id="2-5-Deep-Translate-RapidAPI"><a href="#2-5-Deep-Translate-RapidAPI" class="headerlink" title="2.5. Deep Translate (RapidAPI)"></a>2.5. Deep Translate (RapidAPI)</h2><blockquote><p><a href="https://rapidapi.com/gatzuma/api/deep-translate1">RapidAPI: Deep Translate</a></p></blockquote><p><img src="128_transqual_07.png" alt="RapidAPI에서 제공하는 번역 API"><br></p><ul><li><a href="https://rapidapi.com/">Rapidapi</a>는 장점이 많습니다.</li><li>딥러닝 모델과 여러 데이터 등을 API로 제공할 뿐 아니라</li><li>다양한 언어로 예제 코드를 지원하기 때문에 고급 기능을 복붙 수준으로 구현할 수 있습니다.</li><li>그 중 Google Translate와 동일 품질에 100배 저렴하다고 광고하는 Deep Translate를 사용해봅니다.</li><li><b>무료로 월 10만글자</b>를 번역할 수 있고, <b>월 9달러를 지불하면 천만 글자</b>를 번역할 수 있습니다.</li></ul><ul><li><p>API를 받고, 예제를 따라 Deep Translate를 실행하는 함수를 만듭니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deeptranslate</span>(<span class="params">text, RapidAPI=RapidAPI, sl=<span class="string">&quot;en&quot;</span>, tl=<span class="string">&quot;ko&quot;</span></span>):</span></span><br><span class="line">    url = <span class="string">&quot;https://deep-translate1.p.rapidapi.com/language/translate/v2&quot;</span></span><br><span class="line">    </span><br><span class="line">    payload = &#123;</span><br><span class="line">        <span class="string">&quot;q&quot;</span>: text,</span><br><span class="line">        <span class="string">&quot;source&quot;</span>: sl,</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: tl</span><br><span class="line">    &#125;</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">        <span class="string">&quot;X-RapidAPI-Key&quot;</span>: RapidAPI,</span><br><span class="line">        <span class="string">&quot;X-RapidAPI-Host&quot;</span>: <span class="string">&quot;deep-translate1.p.rapidapi.com&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    response = requests.request(<span class="string">&quot;POST&quot;</span>, url, json=payload, headers=headers)</span><br><span class="line">    translated = response.json()[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;translations&quot;</span>][<span class="string">&quot;translatedText&quot;</span>]</span><br><span class="line">    <span class="keyword">return</span> translated</span><br></pre></td></tr></table></figure></li><li><p>위와 마찬가지로 소요 시간을 확인하며 실행합니다.</p></li><li><p>먼저 초록 요약본 번역입니다. 5회 반복합니다.</p></li><li><p>5회 모두 동일하며, 광고대로 구글 번역 결과와 완전 동일합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;# <span class="subst">&#123;i&#125;</span>회: <span class="subst">&#123;deeptranslate(abs0)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 소요시간: 1.84s</span><br><span class="line"><span class="comment"># 1회: PV 패널은 발전 중에 불필요한 열 에너지를 생성하여 온도를 높이고 PV 전지의 효율에 영향을 미칩니다. 이 기사에서는 알루미늄 방열판과 강제 공기 냉각 기술을 사용하는 PV 모듈의 성능을 조사합니다. 연구된 PV 패널의 평균 전기 효율은 17%이며 표준 테스트 조건(STC)에서 PV 모듈 효율 19.38%에 매우 가깝습니다.</span></span><br><span class="line">- 소요시간: 2.00s</span><br><span class="line"><span class="comment"># 2회: PV 패널은 발전 중에 불필요한 열 에너지를 생성하여 온도를 높이고 PV 전지의 효율에 영향을 미칩니다. 이 기사에서는 알루미늄 방열판과 강제 공기 냉각 기술을 사용하는 PV 모듈의 성능을 조사합니다. 연구된 PV 패널의 평균 전기 효율은 17%이며 표준 테스트 조건(STC)에서 PV 모듈 효율 19.38%에 매우 가깝습니다.</span></span><br><span class="line">- 소요시간: 3.20s</span><br><span class="line"><span class="comment"># 3회: PV 패널은 발전 중에 불필요한 열 에너지를 생성하여 온도를 높이고 PV 전지의 효율에 영향을 미칩니다. 이 기사에서는 알루미늄 방열판과 강제 공기 냉각 기술을 사용하는 PV 모듈의 성능을 조사합니다. 연구된 PV 패널의 평균 전기 효율은 17%이며 표준 테스트 조건(STC)에서 PV 모듈 효율 19.38%에 매우 가깝습니다.</span></span><br><span class="line">- 소요시간: 1.83s</span><br><span class="line"><span class="comment"># 4회: PV 패널은 발전 중에 불필요한 열 에너지를 생성하여 온도를 높이고 PV 전지의 효율에 영향을 미칩니다. 이 기사에서는 알루미늄 방열판과 강제 공기 냉각 기술을 사용하는 PV 모듈의 성능을 조사합니다. 연구된 PV 패널의 평균 전기 효율은 17%이며 표준 테스트 조건(STC)에서 PV 모듈 효율 19.38%에 매우 가깝습니다.</span></span><br><span class="line">- 소요시간: 2.35s</span><br><span class="line"><span class="comment"># 5회: PV 패널은 발전 중에 불필요한 열 에너지를 생성하여 온도를 높이고 PV 전지의 효율에 영향을 미칩니다. 이 기사에서는 알루미늄 방열판과 강제 공기 냉각 기술을 사용하는 PV 모듈의 성능을 조사합니다. 연구된 PV 패널의 평균 전기 효율은 17%이며 표준 테스트 조건(STC)에서 PV 모듈 효율 19.38%에 매우 가깝습니다.</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>독창성 부분 번역입니다. 5회 반복합니다.</p></li><li><p>초록 요약본과 마찬가지로 2초 가량 소요되며, 결과물도 마찬가지입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;# <span class="subst">&#123;i&#125;</span>회: <span class="subst">&#123;deeptranslate(abs0)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 소요시간: 3.10s</span><br><span class="line"><span class="comment"># 1회: 연구 결과는 동일한 태양광 패널을 사용하더라도 설계, 재료 사용 및 적절한 냉각 방법을 고려하여 태양광 발전을 최적화할 수 있음을 보여줍니다.</span></span><br><span class="line">- 소요시간: 2.05s</span><br><span class="line"><span class="comment"># 2회: 연구 결과는 동일한 태양광 패널을 사용하더라도 설계, 재료 사용 및 적절한 냉각 방법을 고려하여 태양광 발전을 최적화할 수 있음을 보여줍니다.</span></span><br><span class="line">- 소요시간: 2.07s</span><br><span class="line"><span class="comment"># 3회: 연구 결과는 동일한 태양광 패널을 사용하더라도 설계, 재료 사용 및 적절한 냉각 방법을 고려하여 태양광 발전을 최적화할 수 있음을 보여줍니다.</span></span><br><span class="line">- 소요시간: 1.99s</span><br><span class="line"><span class="comment"># 4회: 연구 결과는 동일한 태양광 패널을 사용하더라도 설계, 재료 사용 및 적절한 냉각 방법을 고려하여 태양광 발전을 최적화할 수 있음을 보여줍니다.</span></span><br><span class="line">- 소요시간: 1.76s</span><br><span class="line"><span class="comment"># 5회: 연구 결과는 동일한 태양광 패널을 사용하더라도 설계, 재료 사용 및 적절한 냉각 방법을 고려하여 태양광 발전을 최적화할 수 있음을 보여줍니다.</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>무료로 사용할 수 있는 Google Translate와 동일한 성능이라면,</p></li><li><p><b>시간도 10배쯤 더 걸리는데 굳이 돈을 내고 사용할 필요가 없습니다.</b></p></li></ul><h2 id="2-6-DeepL-Translator-RapidAPI"><a href="#2-6-DeepL-Translator-RapidAPI" class="headerlink" title="2.6. DeepL Translator (RapidAPI)"></a>2.6. DeepL Translator (RapidAPI)</h2><blockquote><p><a href="https://www.deepl.com/">DeepL Translator</a><br><a href="https://rapidapi.com/splintPRO/api/deepl-translator">RapidAPI: DeepL Translator</a></p></blockquote><p><img src="128_transqual_08.png" alt="RapidAPI DeepL"><br></p><ul><li><p><b><a href="https://www.deepl.com/">DeepL</a></b>은 최근 공개되어 <b>구글 번역기를 능가하는 성능</b>으로 유명한 번역기입니다.</p></li><li><p>DeepL API를 사용하려면 신용카드 등록이 필요한데, 현재 대한민국의 신용카드는 지원하지 않습니다.</p></li><li><p>그러나 뜻밖으로 <b>RapidAPI</b>에서 DeepL API를 찾을 수 있었습니다.</p></li><li><p><b>DeepL 개발사에서 업로드한 것인지는 알 수 없으나</b>(검색을 해도 나오지 않습니다) </p></li><li><p>테스트 결과 <b>검색 품질은 DeepL.com</b>에서 수행한 것과 동일합니다.</p></li><li><p>누군가 본인의 DeepL 계정을 사용해 사설 API를 개발하고 올린 것이 아닌가 추측합니다.</p></li><li><p>함수를 만들고 사용합니다. <b>RapidAPI는 동일 Key를 모든 API에 사용할 수 있습니다.</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timed</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deepl</span>(<span class="params">text, RapidAPI=RapidAPI, sl=<span class="string">&quot;en&quot;</span>, tl=<span class="string">&quot;ko&quot;</span></span>):</span></span><br><span class="line">    url = <span class="string">&quot;https://deepl-translator.p.rapidapi.com/translate&quot;</span></span><br><span class="line">    </span><br><span class="line">    payload = &#123;</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: text,</span><br><span class="line">        <span class="string">&quot;source&quot;</span>: sl,</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: tl</span><br><span class="line">    &#125;</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;X-RapidAPI-Key&quot;</span>: RapidAPI,</span><br><span class="line">        <span class="string">&quot;X-RapidAPI-Host&quot;</span>: <span class="string">&quot;deepl-translator.p.rapidapi.com&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    response = requests.request(<span class="string">&quot;POST&quot;</span>, url, json=payload, headers=headers)</span><br><span class="line">    <span class="keyword">return</span> response.json()[<span class="string">&quot;text&quot;</span>]</span><br></pre></td></tr></table></figure></li><li><p>초록과 독창성 부분을 번역시킵니다. 5회 반복해도 동일한 결과가 반복되며 시간은 2초 미만입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(deepl(abs0))</span><br><span class="line"><span class="built_in">print</span>(deepl(org0))</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 소요시간: 0.94s</span><br><span class="line"><span class="string">&#x27;태양광 패널은 발전 중에 불필요한 열 에너지를 생성하여 온도를 높이고 태양광 셀의 효율에 영향을 미칩니다. 이 글에서는 알루미늄 방열판과 강제 공기 냉각 기술을 사용한 태양광 모듈의 성능을 조사합니다. 연구 대상 태양광 패널의 평균 전기 효율은 17%이며 표준 테스트 조건(STC)에서의 태양광 모듈 효율인 19.38%에 매우 근접합니다.&#x27;</span></span><br><span class="line">- 소요시간: 0.85s</span><br><span class="line">연구 결과에 따르면 동일한 태양 전지판을 사용하더라도 설계, 재료 사용, 적절한 냉각 방법을 고려하면 태양 에너지 생산을 최적화할 수 있습니다.</span><br></pre></td></tr></table></figure></li></ul></li><li><p>DeepL은 <b>대체 문장을 제공한다</b>는 특징이 있습니다.</p></li><li><p>짧은 문장을 입력하면 <code>response.json()</code>에서 <code>&quot;text&quot;</code>를 우선 번역 결과로 제공하지만,</p></li><li><p><code>&quot;alternative_texts&quot;</code>에는 다른 버전의 번역본을 제공합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># input text</span></span><br><span class="line">text = <span class="string">&quot;what a wonderful world.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DeepL 실행: payload와 headers는 deepl() 내부와 동일. payload내 text만 변경.</span></span><br><span class="line">response = requests.request(<span class="string">&quot;POST&quot;</span>, url, json=payload, headers=headers)</span><br><span class="line">r_json = response.json()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# text : <span class="subst">&#123;r_json[<span class="string">&#x27;text&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# alternative_texts : <span class="subst">&#123;r_json[<span class="string">&#x27;alternative_texts&#x27;</span>]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># text : 정말 멋진 세상입니다.</span></span><br><span class="line"><span class="comment"># alternative_texts : [&#x27;이 얼마나 멋진 세상인가요.&#x27;, &#x27;이 얼마나 멋진 세상입니까.&#x27;, &#x27;이 얼마나 멋진 세상입니까.&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="3-번역-성능-비교"><a href="#3-번역-성능-비교" class="headerlink" title="3. 번역 성능 비교"></a>3. 번역 성능 비교</h1><ul><li>이제까지 동일 문장을 6가지 모델을 사용해 번역해 보았습니다.</li><li>GPT 모델을 반응시간이 가장 짧은 <code>text-curie-001</code>으로 고정하고 얻은 결과를 포함하여 <a href="transqual.xlsx">결과 파일</a>에 정리했습니다.</li><li><b>경어와 반어</b>, <b>매끄러운 문장 구사</b>, <b>가격</b>, <b>속도, 안정성</b> 관점에서 정리합니다.</li></ul><h2 id="3-1-경어와-반어-존대말과-반말"><a href="#3-1-경어와-반어-존대말과-반말" class="headerlink" title="3.1. 경어와 반어 (존대말과 반말)"></a>3.1. 경어와 반어 (존대말과 반말)</h2><ul><li>존대말이든 반말이든 <b>일관성</b>이 중요합니다.<ul><li><b>GOOD :</b> Google Translate(경어), huggingface(경어), GPT3(반어), DeepL(경어)</li><li><b>BAD :</b> Papago, Deep Translate</li></ul></li></ul><ul><li>Deep Translate는 본 테스트 파일에서는 모두 경어로 일관되었으나 다른 테스트에서 섞어 쓰는 것이 다수 발견되었습니다.</li></ul><h2 id="3-2-매끄러운-문장-구사"><a href="#3-2-매끄러운-문장-구사" class="headerlink" title="3.2. 매끄러운 문장 구사"></a>3.2. 매끄러운 문장 구사</h2><ul><li>문장의 자연스러움과 띄어쓰기를 확인합니다.<ul><li><b>BEST :</b> DeepL</li><li><b>GOOD :</b> Google Translate, Papago, Deep Translate</li><li><b>BAD :</b> Huggingface, GPT3</li></ul></li></ul><ul><li>Huggingface는 문장끼리 붙여쓰는 경우가 발견되었습니다.</li><li>GPT는 어색한 번역투 문장이 자주 보입니다 (ex. “에너지 공급을 가진다”)</li><li>DeepL의 유려함이 빛납니다. Abstract를 “초록”이라 번역하는 것은 DeepL뿐입니다.</li></ul><h2 id="3-3-가격"><a href="#3-3-가격" class="headerlink" title="3.3. 가격"></a>3.3. 가격</h2><ul><li>당연히 무료가 좋습니다. 적당한 선에서 가격을 지불할 용의도 있습니다. </li><li>운영 차원에서 종량제는 예측이 어려울 수 있습니다.<ul><li><b>BEST :</b> Google Translate, Huggingface</li><li><b>GOOD :</b> Deep Translate(hard limit), DeepL(hard limit), Papago(soft limit)</li><li><b>FAIR :</b> GPT3(종량제)</li></ul></li></ul><h2 id="3-4-속도-안정성"><a href="#3-4-속도-안정성" class="headerlink" title="3.4. 속도, 안정성"></a>3.4. 속도, 안정성</h2><ul><li>서비스 사용자 입장에서는 속도와 안정성이 매우 중요합니다. <ul><li><b>BEST :</b> Google Translate, Papago</li><li><b>GOOD :</b> Deep Translate(hard limit), DeepL(hard limit)</li><li><b>BAD :</b> Huggingface(속도)</li><li><b>WORST :</b> GPT3(속도, 안정성)</li></ul></li></ul><ul><li>Huggingface와 GPT3는 번역 결과를 받기까지 10초 이상 걸렸습니다. </li><li>GPT3는 사용자가 몰려서인지 모르겠으나 접속 안정성 이슈가 있었고 번역이 깨지는 경우가 확인됩니다.</li><li>향후 안정성을 업데이트하리라 믿습니다.</li></ul><h1 id="4-결론"><a href="#4-결론" class="headerlink" title="4. 결론"></a>4. 결론</h1><ul><li>RapidAPI의 <b>DeepL API</b>가 정상적인 것인지 의심이 되기는 하지만 성능과 안정성면에서는 가장 우수합니다.</li><li>hard limit라는 단점이 있는 만큼 이용자가 한도를 넘으면 <b>Google Translate</b>로 넘기는 방식을 구현할 수 있습니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/translation/">translation</category>
      
      <category domain="https://jehyunlee.github.io/tags/latural-language-processing/">latural language processing</category>
      
      
    </item>
    
    <item>
      <title>ChatGPT 업무효율화 가이드</title>
      <link>https://jehyunlee.github.io/2023/02/15/Python-General-16-chatgpt/</link>
      <guid>https://jehyunlee.github.io/2023/02/15/Python-General-16-chatgpt/</guid>
      <pubDate>Tue, 14 Feb 2023 16:08:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://chat.openai.com/chat&quot;&gt;ChatGPT&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;최근 대통령이 정부부처 업무보고에서 ChatGPT를 언급한 이후 관심이 뜨겁습니다.</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><a href="https://chat.openai.com/chat">ChatGPT</a></p></blockquote><ul><li>최근 대통령이 정부부처 업무보고에서 ChatGPT를 언급한 이후 관심이 뜨겁습니다.</li><li>여러 부처 및 기관 분들을 만나뵙고 받은 공통적인 질문들을 정리했습니다.</li><li><b>사무 업무효율화에 ChatGPT를 적용하기 위한</b> 가이드입니다.</li><li>AI가 낯선 분들께 ChatGPT가 다가선 만큼 엉뚱한 기대도 느껴진 것이 사실입니다.</li></ul><ul><li><b>ChatGPT가 향후 업데이트가 될 것이고, 다른 모델들이 경쟁하며 개발중입니다.</b></li><li><b>현재 시점에서의 가이드라는 점을 말씀드리며, 향후 ChatGPT 업그레이드 상황에 따라 변경될 수 있습니다.</b></li><li><a href="ChatGPT_AiFrenz_guide.pdf">pdf 파일은 여기에서 다운받으실 수 있습니다.</a></li><li>AI프렌즈 분들과 함께 여러 분들을 만났던 자리인 만큼 AI프렌즈 명의로 작성했습니다.</li></ul><p><img src="ChatGPT_AiFrenz_guide_01.png" alt="11줄 요약"></p><p><img src="ChatGPT_AiFrenz_guide_02.png" alt="예시 1"></p><p><img src="ChatGPT_AiFrenz_guide_03.png" alt="예시 2"></p><p><img src="ChatGPT_AiFrenz_guide_04.png" alt="예시 3"></p><p><img src="ChatGPT_AiFrenz_guide_05.png" alt="예시 3"></p><p><img src="ChatGPT_AiFrenz_guide_06.png" alt="예시 4"></p><p><img src="ChatGPT_AiFrenz_guide_07.png" alt="예시 4"></p><p><img src="ChatGPT_AiFrenz_guide_08.png" alt="예시 4"></p><p><img src="ChatGPT_AiFrenz_guide_09.png" alt="예시 6"></p><p><img src="ChatGPT_AiFrenz_guide_10.png" alt="예시 8"></p><p><img src="ChatGPT_AiFrenz_guide_11.png" alt="예시 9"></p><p><img src="ChatGPT_AiFrenz_guide_12.png" alt="예시 9"></p><p><img src="ChatGPT_AiFrenz_guide_13.png" alt="예시 10"></p><p><img src="ChatGPT_AiFrenz_guide_14.png" alt="예시 11"></p><p><img src="ChatGPT_AiFrenz_guide_15.png" alt="예시 11"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/openai/">openai</category>
      
      <category domain="https://jehyunlee.github.io/tags/chatgpt/">chatgpt</category>
      
      
    </item>
    
    <item>
      <title>KDE + threshold</title>
      <link>https://jehyunlee.github.io/2023/02/12/Python-DS-127_kdeth/</link>
      <guid>https://jehyunlee.github.io/2023/02/12/Python-DS-127_kdeth/</guid>
      <pubDate>Sun, 12 Feb 2023 08:20:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;밀도 함수는 데이터 분포를 볼 때 가장 많이 그리는 그림 중 하나입니다.&lt;/li&gt;
&lt;li&gt;특정 값을 기준으로 Pass와 Fail을 정한다고 할 때, 전체의 비율도 중요합니다.&lt;/li&gt;
&lt;li&gt;seaborn kdeplot을 살짝 다듬어서</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>밀도 함수는 데이터 분포를 볼 때 가장 많이 그리는 그림 중 하나입니다.</li><li>특정 값을 기준으로 Pass와 Fail을 정한다고 할 때, 전체의 비율도 중요합니다.</li><li>seaborn kdeplot을 살짝 다듬어서 쪼개고 비율을 계산합니다.</li></ul><h1 id="1-오늘의-목표"><a href="#1-오늘의-목표" class="headerlink" title="1. 오늘의 목표"></a>1. 오늘의 목표</h1><ul><li>오늘 우리는 데이터를 선별하는 데 쓰는, 이런 그림을 그릴 겁니다.</li><li>특정 값을 기준으로 왼쪽은 Fail, 오른쪽은 Pass입니다.</li><li>공장에서 발생하는 양품과 불량품으로 생각을 해도 좋고, 학생들 시험 결과의 분포로 봐도 좋습니다.</li><li>중요한 것은 <b>특정 지점을 기준으로 KDE plot을 자르고</b>, <b>좌우를 다른 색으로 칠하는 것</b>입니다.<br><br><img src="127_kdeth_8.png"><br></li></ul><h1 id="2-데이터-→-밀도-함수"><a href="#2-데이터-→-밀도-함수" class="headerlink" title="2. 데이터 → 밀도 함수"></a>2. 데이터 → 밀도 함수</h1><ul><li><p><code>numpy</code>를 사용해서 정규분포에 가까운 데이터를 만듭니다.</p></li><li><p><code>np.random.normal()</code>을 사용하면 뚝딱 만들어집니다.</p></li><li><p><code>loc</code>, <code>scale</code>을 사용해서 평균과 표준편차를 지정하고, <code>size</code>에는 10만을 넣습니다.</p></li><li><p>이렇게 얻은 결과를 <code>seaborn.kdeplot()</code>으로 밀도함수로 표현합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 예제 데이터 생성</span></span><br><span class="line">set0 = np.random.normal(loc=<span class="number">3</span>, scale=<span class="number">1</span>, size=<span class="number">100_000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 데이터 분포 밀도함수 시각화</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">sns.kdeplot(set0, fill=<span class="literal">True</span>, ax=ax)</span><br></pre></td></tr></table></figure><p><img src="127_kdeth_0.png"><br></p></li><li><p>매끈한 밀도함수가 얻어졌습니다.</p></li><li><p>이토록 데이터 분포가 매끈해보이는 것은 <code>seaborn.kdeplot()</code>에 숨겨진 <code>gridsize=200</code>이라는 매개변수 덕분입니다.</p></li><li><p>데이터가 쪼개지는 지점을 눈에 잘 띄게 하겠습니다. <code>gridsize=20</code>을 입력해서 같은 데이터를 거칠게 표현합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">sns.kdeplot(set0, fill=<span class="literal">True</span>, gridsize=<span class="number">20</span>, ax=ax)</span><br></pre></td></tr></table></figure><p><img src="127_kdeth_1.png"><br></p></li></ul><h1 id="3-밀도-함수-절단"><a href="#3-밀도-함수-절단" class="headerlink" title="3. 밀도 함수 절단"></a>3. 밀도 함수 절단</h1><blockquote><p><a href="https://matplotlib.org/stable/api/path_api.html">matplotlib.org matplotlib.path</a></p></blockquote><ul><li>똑같은 데이터인데 전혀 매끈하지 않습니다.</li><li>한 눈에 봐도 꼭지점과 선분으로 이루어진 다각형이라는 것을 알 수 있습니다.</li><li><b>$x = 2$</b></li><li>꼭지점 중 <b>$x &gt; 2$만 남겨서 이것들로 다각형을 새로 만들면 되지 않을까요?</b></li></ul><ul><li><p>KDE plot을 구성하는 다각형은 <code>ax.collections</code>로 추출할 수 있습니다.</p></li><li><p>이 중에서도 윤곽선은 <code>.get_path()[0]</code>명령으로 뽑아낼 수 있고,</p></li><li><p>꼭지점은 여기에 <code>.vertices</code>, 꼭지점의 특성은 <code>.codes</code> 속성을 보면 됩니다.</p></li><li><p>한번 추출해 봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vertices</span></span><br><span class="line">path = ax.collections[<span class="number">0</span>].get_paths()[<span class="number">0</span>]</span><br><span class="line">vertices = path.vertices</span><br><span class="line">codes = path.codes</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# vertices = <span class="subst">&#123;vertices&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;#    codes = <span class="subst">&#123;codes&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vertices = [[-1.68144422e+00  4.44446302e-07]</span></span><br><span class="line">[-1.68144422e+00  0.00000000e+00]</span><br><span class="line">[-1.20843724e+00  0.00000000e+00]</span><br><span class="line">[-7.35430261e-01  0.00000000e+00]</span><br><span class="line">[-2.62423283e-01  0.00000000e+00]</span><br><span class="line"> </span><br><span class="line">              (중략)</span><br><span class="line">        </span><br><span class="line">[-1.68144422e+00  4.44446302e-07]</span><br><span class="line">[-1.68144422e+00  4.44446302e-07]]</span><br><span class="line"><span class="comment">#    codes = [ 1  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2</span></span><br><span class="line"> 2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2 79]</span><br></pre></td></tr></table></figure></li></ul></li><li><p><b>vertices</b>에는 수많은 점의 $(x, y)$ 좌표가 나열되어 있습니다. </p></li><li><p>이 데이터를 기준으로 threshold를 적용하면 될 것 같습니다.</p></li><li><p>해당 데이터의 index를 추출합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x &gt; 2 인 꼭지점 추출</span></span><br><span class="line">idx_th = np.where(vertices[:, <span class="number">0</span>] &gt; <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">idx_th</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([ 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,</span><br><span class="line">     26, 27, 28, 29, 30, 31, 32, 33])</span><br></pre></td></tr></table></figure></li></ul></li><li><p><b>codes</b>가 <a href="https://matplotlib.org/stable/api/path_api.html">중요한 정보</a>를 담고 있습니다.</p></li><li><p><b>1은 시작점</b>, <b>2는 연결점</b>, <b>79는 polygon close</b>입니다.</p></li><li><p><b>$ x &gt; 2 $</b>인 점들의 index를 추출하다 보면 code가 규칙에서 어긋날 수 있습니다.</p></li><li><p>그렇기 때문에, 첫 점과 마지막 점의 code에 강제로 1과 79를 할당합니다.</p></li><li><p>이렇게 추출된 vertices와 codes를 다시 윤곽선을 의미하는 path에 할당하고 그림을 그리면 변화가 관찰됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vertices_th = vertices[idx_th]</span><br><span class="line">codes_th = codes[idx_th]</span><br><span class="line"></span><br><span class="line">path.vertices = vertices_th</span><br><span class="line">path.codes = codes_th</span><br><span class="line">path.codes[<span class="number">0</span>] = <span class="number">1</span>    <span class="comment"># 시작점 (MOVETE)</span></span><br><span class="line">path.codes[-<span class="number">1</span>] = <span class="number">79</span>  <span class="comment"># 닫는 점 (CLOSEPOLY)</span></span><br><span class="line"></span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure></li></ul><h1 id="4-부가-요소-활용"><a href="#4-부가-요소-활용" class="headerlink" title="4. 부가 요소 활용"></a>4. 부가 요소 활용</h1><ul><li><p>전체 코드를 한 번 정리합니다.</p></li><li><p><code>gridsize</code>를 기본값으로 복구시켜 매끈한 곡선을 얻고,</p></li><li><p>밀도 함수를 절단한 뒤 다시 전체 밀도 함수를 선으로만 그려 부분과 전체를 동시에 표시합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. threshold 적용 KDE plot</span></span><br><span class="line">sns.kdeplot(set0, fill=<span class="literal">True</span>, ax=ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># vertices</span></span><br><span class="line">path = ax.collections[<span class="number">0</span>].get_paths()[<span class="number">0</span>]</span><br><span class="line">vertices = path.vertices</span><br><span class="line">codes = path.codes</span><br><span class="line"></span><br><span class="line"><span class="comment"># threshold</span></span><br><span class="line">idx_th = np.where(vertices[:, <span class="number">0</span>] &gt; <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">vertices_th = vertices[idx_th]</span><br><span class="line">codes_th = codes[idx_th]</span><br><span class="line">path.vertices = vertices_th</span><br><span class="line">path.codes = codes_th</span><br><span class="line">path.codes[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">path.codes[-<span class="number">1</span>] = <span class="number">79</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. threshold 미적용 KDE plot</span></span><br><span class="line">sns.kdeplot(set0, fill=<span class="literal">False</span>, color=<span class="string">&quot;k&quot;</span>, ax=ax)</span><br></pre></td></tr></table></figure><p><img src="127_kdeth_3.png"></p></li><li><p>이제 저 영역이 Pass라는 것을 문자를 사용해 명시합니다.</p></li><li><p>색도 기본색보다 조금은 의지를 반영해 특정 색을 지정합니다. 파랑으로 갑시다.</p></li><li><p>기준점이 되는 <b>$x = 2$</b>에 기준 막대도 우뚝 세워줍니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. threshold 적용 KDE plot</span></span><br><span class="line">sns.kdeplot(set0, color=<span class="string">&quot;b&quot;</span>, gridsize=<span class="number">500</span>, fill=<span class="literal">True</span>, ax=ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># vertices</span></span><br><span class="line">path = ax.collections[<span class="number">0</span>].get_paths()[<span class="number">0</span>]</span><br><span class="line">vertices = path.vertices</span><br><span class="line">codes = path.codes</span><br><span class="line"></span><br><span class="line"><span class="comment"># threshold</span></span><br><span class="line">idx_th = np.where(vertices[:, <span class="number">0</span>] &gt; <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">vertices_th = vertices[idx_th]</span><br><span class="line">codes_th = codes[idx_th]</span><br><span class="line">path.vertices = vertices_th</span><br><span class="line">path.codes = codes_th</span><br><span class="line">path.codes[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">path.codes[-<span class="number">1</span>] = <span class="number">79</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. threshold 미적용 KDE plot</span></span><br><span class="line">sns.kdeplot(set0, fill=<span class="literal">False</span>, color=<span class="string">&quot;k&quot;</span>, ax=ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. additional information</span></span><br><span class="line">ax.collections[<span class="number">0</span>].set_lw(<span class="number">0</span>)     <span class="comment"># threshold 적용 KDE plot의 윤곽선 제거</span></span><br><span class="line">ax.axvline(<span class="number">2</span>, c=<span class="string">&quot;k&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>) <span class="comment"># threshold line</span></span><br><span class="line">ax.text(<span class="number">3.2</span>, <span class="number">0.15</span>, <span class="string">&quot;PASS&quot;</span>, color=<span class="string">&quot;b&quot;</span>, ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="127_kdeth_4.png"></p></li></ul><ul><li>같은 요령으로, 왼쪽에 FAIL이라고 명시할 수 있습니다.</li><li>동일한 작업을 threshold 방향만 바꾸어 반복하면 됩니다.<details>  <summary><b>코드 보기/접기</b></summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PASS and FAIL</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. threshold 적용 KDE plot</span></span><br><span class="line">sns.kdeplot(set0, color=<span class="string">&quot;b&quot;</span>, gridsize=<span class="number">500</span>, fill=<span class="literal">True</span>, ax=ax)  <span class="comment"># Pass</span></span><br><span class="line">sns.kdeplot(set0, color=<span class="string">&quot;r&quot;</span>, gridsize=<span class="number">500</span>, fill=<span class="literal">True</span>, ax=ax)  <span class="comment"># Fail</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## PASS</span></span><br><span class="line"><span class="comment"># vertices</span></span><br><span class="line">path_p = ax.collections[<span class="number">0</span>].get_paths()[<span class="number">0</span>]</span><br><span class="line">vertices_p = path_p.vertices</span><br><span class="line">codes_p = path_p.codes</span><br><span class="line"></span><br><span class="line"><span class="comment"># threshold</span></span><br><span class="line">idx_th_p = np.where(vertices_p[:, <span class="number">0</span>] &gt; <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">vertices_th_p = vertices_p[idx_th_p]</span><br><span class="line">codes_th_p = codes_p[idx_th_p]</span><br><span class="line">path_p.vertices = vertices_th_p</span><br><span class="line">path_p.codes = codes_th_p</span><br><span class="line">path_p.codes[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">path_p.codes[-<span class="number">1</span>] = codes[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## FAIL</span></span><br><span class="line"><span class="comment"># vertices</span></span><br><span class="line">path_f = ax.collections[<span class="number">1</span>].get_paths()[<span class="number">0</span>]</span><br><span class="line">vertices_f = path_f.vertices</span><br><span class="line">codes_f = path_f.codes</span><br><span class="line"></span><br><span class="line"><span class="comment"># threshold</span></span><br><span class="line">idx_th_f = np.where(vertices_p[:, <span class="number">0</span>] &lt;= <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">vertices_th_f = vertices_p[idx_th_f]</span><br><span class="line">codes_th_f = codes_p[idx_th_f]</span><br><span class="line">path_f.vertices = vertices_th_f</span><br><span class="line">path_f.codes = codes_th_f</span><br><span class="line">path_f.codes[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">path_f.codes[-<span class="number">1</span>] = <span class="number">79</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. threshold 미적용 KDE plot</span></span><br><span class="line">sns.kdeplot(set0, fill=<span class="literal">False</span>, color=<span class="string">&quot;k&quot;</span>, ax=ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. additional information</span></span><br><span class="line">ax.collections[<span class="number">0</span>].set_lw(<span class="number">0</span>)     <span class="comment"># PASS KDE plot의 윤곽선 제거</span></span><br><span class="line">ax.collections[<span class="number">1</span>].set_lw(<span class="number">0</span>)     <span class="comment"># FAIL KDE plot의 윤곽선 제거</span></span><br><span class="line">ax.axvline(<span class="number">2</span>, c=<span class="string">&quot;k&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>) <span class="comment"># threshold line</span></span><br><span class="line">ax.text(<span class="number">3.2</span>, <span class="number">0.15</span>, <span class="string">&quot;PASS&quot;</span>, color=<span class="string">&quot;b&quot;</span>, ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>)</span><br><span class="line">ax.text(<span class="number">0.5</span>, <span class="number">0.15</span>, <span class="string">&quot;FAIL&quot;</span>, color=<span class="string">&quot;r&quot;</span>, ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;center&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><p><img src="127_kdeth_5.png"></p><h1 id="5-넓이-계산"><a href="#5-넓이-계산" class="headerlink" title="5. 넓이 계산"></a>5. 넓이 계산</h1><blockquote><p><a href="https://shapely.readthedocs.io/en/stable/manual.html#polygons">shapely.geometry.Polygon</a></p></blockquote><ul><li>이런 시각화는 그림 뿐 아니라 숫자도 중요합니다.</li><li>기준선을 넘은 데이터가 전체의 몇 %인지, 넘지 못한 것은 얼마인지 알아야 합니다.</li><li>밀도 함수의 전체 넓이는 1이라는 사실은 널리 알려져 있지만 이렇게 자르면 계산이 어렵습니다.</li></ul><ul><li><p><b><code>shapely</code> 라이브러리가 이런 도형 계산에 편리합니다.</b></p></li><li><p><code>shapely.geometry.Polygon()</code>에 vertices를 넣은 뒤 <code>.area</code>속성을 출력하면 넓이가 나옵니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> Polygon</span><br><span class="line"></span><br><span class="line">poly_p = Polygon(vertices_th_p)</span><br><span class="line">poly_f = Polygon(vertices_th_f)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# PASS: <span class="subst">&#123;poly_p.area*<span class="number">100</span>:<span class="number">.2</span>f&#125;</span> %&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# FAIL: <span class="subst">&#123;poly_f.area*<span class="number">100</span>:<span class="number">.2</span>f&#125;</span> %&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# PASS + FAIL: <span class="subst">&#123;(poly_p.area + poly_f.area)*<span class="number">100</span>:<span class="number">.2</span>f&#125;</span> %&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PASS: 83.87 %</span></span><br><span class="line"><span class="comment"># FAIL: 15.70 %</span></span><br><span class="line"><span class="comment"># PASS + FAIL: 99.57 %</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>더해서 100%가 되어야 하는데, 0.5%가량 부족하지만 전체적으로 얼추 맞습니다.</p></li><li><p>대략 84%는 Pass, 16%는 Fail로 볼 수 있을 듯 합니다.</p></li><li><p>실제 앞에서 만든 우리 데이터셋으로 확인하면 84.25% vs 15.75%라고 합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# PASS (Ground Truth): <span class="subst">&#123;<span class="built_in">len</span>(set0[set0 &gt; <span class="number">2</span>])/<span class="number">1e5</span> * <span class="number">100</span>:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;# FAIL (Ground Truth): <span class="subst">&#123;<span class="built_in">len</span>(set0[set0 &lt;= <span class="number">2</span>])/<span class="number">1e5</span> * <span class="number">100</span>:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PASS (Ground Truth): 84.25</span></span><br><span class="line"><span class="comment"># FAIL (Ground Truth): 15.75</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="6-함수-제작"><a href="#6-함수-제작" class="headerlink" title="6. 함수 제작"></a>6. 함수 제작</h1><ul><li><p>자, 이제 함수를 만들어 사용합시다.</p></li><li><p>data와 threshold를 필수로 입력하게 하고, pass와 fail의 색, 그리고 gridsize를 보조 입력으로 받습니다.</p></li><li><p>제가 만드는 다른 함수들처럼 활용성을 위해 Axes를 입력받을 수 있는, Axes를 출력하는 함수로 만듭니다.</p></li><li><p>이러면 다른 큰 그림의 일부로 활용하기 좋습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_passfail</span>(<span class="params">data, threshold, color_pass=<span class="string">&quot;b&quot;</span>, color_fail=<span class="string">&quot;r&quot;</span>, gridsize=<span class="number">500</span>, ax=<span class="literal">None</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ax:    <span class="comment"># 입력 Axes가 없을 때, 생성</span></span><br><span class="line">        fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. threshold 적용 KDE plot</span></span><br><span class="line">    sns.kdeplot(x=data, color=color_pass, gridsize=gridsize, fill=<span class="literal">True</span>, ax=ax)  <span class="comment"># Pass</span></span><br><span class="line">    sns.kdeplot(x=data, color=color_fail, gridsize=gridsize, fill=<span class="literal">True</span>, ax=ax)  <span class="comment"># Fail</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. pass, fail thrsholding &amp; coloring</span></span><br><span class="line">    labels = []</span><br><span class="line">    <span class="keyword">for</span> i, (part, color_pf, label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(ax.collections, [color_pass, color_fail], [<span class="string">&quot;PASS&quot;</span>, <span class="string">&quot;FAIL&quot;</span>])):</span><br><span class="line">        part.set_lw(<span class="number">0</span>)</span><br><span class="line">        path = part.get_paths()[<span class="number">0</span>]</span><br><span class="line">        vertices = path.vertices</span><br><span class="line">        codes = path.codes</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>: <span class="comment"># pass</span></span><br><span class="line">            idx_th = np.where(vertices[:, <span class="number">0</span>] &gt; threshold)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            idx_th = np.where(vertices[:, <span class="number">0</span>] &lt;= threshold)[<span class="number">0</span>]</span><br><span class="line">            </span><br><span class="line">        vertices_th = vertices[idx_th]</span><br><span class="line">        codes_th = codes_p[idx_th]</span><br><span class="line">        path.vertices = vertices_th</span><br><span class="line">        path.codes = codes_th</span><br><span class="line">        path.codes[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        path.codes[-<span class="number">1</span>] = <span class="number">79</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># calculate area</span></span><br><span class="line">        poly = Polygon(vertices_th)</span><br><span class="line">        labels.append(<span class="string">f&quot;<span class="subst">&#123;label&#125;</span>: <span class="subst">&#123;poly.area*<span class="number">100</span>:<span class="number">.1</span>f&#125;</span> %&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. threshold 미적용 KDE plot</span></span><br><span class="line">    sns.kdeplot(data, fill=<span class="literal">False</span>, color=<span class="string">&quot;k&quot;</span>, ax=ax)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. additional information</span></span><br><span class="line">    ax.axvline(threshold, c=<span class="string">&quot;k&quot;</span>, lw=<span class="number">3</span>, alpha=<span class="number">0.5</span>) <span class="comment"># threshold line</span></span><br><span class="line">    ax.legend(handles=ax.collections, labels=labels, loc=<span class="string">&quot;upper right&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 5. auxiliaries</span></span><br><span class="line">    ax.spines[[<span class="string">&quot;left&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;right&quot;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.set_yticks([])</span><br><span class="line">    ax.set_ylabel(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ax</span><br><span class="line"></span><br><span class="line"><span class="comment"># 함수 실행</span></span><br><span class="line">ax = plot_passfail(set0, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><img src="127_kdeth_6.png"><br></p></li><li><p>Pass와 Fail 비율은 범례로 출력하게 만들었습니다.</p></li><li><p>실제 활용시 다른 그래프와 중첩될 수 있고, 그래프 모양이 데이터에 따라 달라지기 때문에</p></li><li><p>아까처럼 그래프 위에 글자를 놓으려면 고칠 일이 더 많아질 수 있기 때문입니다.</p></li><li><p>이제 한 줄로 threshold가 반영된 밀도 함수를 그릴 수 있게 되었습니다.</p></li></ul><h1 id="7-함수-수정"><a href="#7-함수-수정" class="headerlink" title="7. 함수 수정"></a>7. 함수 수정</h1><ul><li>이렇게 만들어진 그래프는 객체 제어를 통해 색을 비롯한 여러 요소를 마음껏 제어할 수 있습니다.</li><li>Pass를 green, Fail을 orange로 바꾸고 legend까지 반영합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">labels = []</span><br><span class="line"><span class="keyword">for</span> part, fc, label <span class="keyword">in</span> <span class="built_in">zip</span>(ax.collections, [<span class="string">&quot;green&quot;</span>, <span class="string">&quot;orange&quot;</span>], [<span class="string">&quot;PASS&quot;</span>, <span class="string">&quot;FAIL&quot;</span>]):</span><br><span class="line">    part.set_fc(fc)</span><br><span class="line">    part.set_alpha(<span class="number">0.5</span>)</span><br><span class="line">    vertices = part.get_paths()[<span class="number">0</span>].vertices</span><br><span class="line">    labels.append(<span class="string">f&quot;<span class="subst">&#123;label&#125;</span>: <span class="subst">&#123;Polygon(vertices).area*<span class="number">100</span>:<span class="number">.1</span>f&#125;</span> %&quot;</span>)</span><br><span class="line">    </span><br><span class="line">ax.legend(ax.collections, labels, loc=<span class="string">&quot;upper right&quot;</span>)</span><br><span class="line">ax.set_xlim(-<span class="number">1</span>, <span class="number">8</span>)</span><br><span class="line">display(ax.figure)</span><br></pre></td></tr></table></figure><img src="127_kdeth_7.png"><br></li></ul><h1 id="8-활용-펭귄-데이터셋"><a href="#8-활용-펭귄-데이터셋" class="headerlink" title="8. 활용 - 펭귄 데이터셋"></a>8. 활용 - 펭귄 데이터셋</h1><ul><li>펭귄 데이터셋의 세 수치형 데이터, bill_length, bill_depth, flipper_length에 이 함수를 적용합니다.</li><li><code>plt.subplots(ncols=3)</code>으로 틀을 잡아 놓고 Axes마다 데이터를 threshold와 함께 넣었습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 데이터셋 읽어오기</span></span><br><span class="line">df_peng = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 전체 Figure 설정</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Axes마다 함수 적용</span></span><br><span class="line">plot_passfail(df_peng[<span class="string">&quot;bill_length_mm&quot;</span>], <span class="number">40</span>, ax=axs[<span class="number">0</span>], color_pass=<span class="string">&quot;b&quot;</span>, color_fail=<span class="string">&quot;r&quot;</span>)</span><br><span class="line">plot_passfail(df_peng[<span class="string">&quot;bill_depth_mm&quot;</span>], <span class="number">15</span>, ax=axs[<span class="number">1</span>], color_pass=<span class="string">&quot;g&quot;</span>, color_fail=<span class="string">&quot;orange&quot;</span>)</span><br><span class="line">plot_passfail(df_peng[<span class="string">&quot;flipper_length_mm&quot;</span>], <span class="number">180</span>, ax=axs[<span class="number">2</span>], color_pass=<span class="string">&quot;c&quot;</span>, color_fail=<span class="string">&quot;m&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Axes마다 y 범위 설정</span></span><br><span class="line">axs[<span class="number">0</span>].set_ylim(<span class="number">0</span>, <span class="number">0.1</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_ylim(<span class="number">0</span>, <span class="number">0.4</span>)</span><br><span class="line">axs[<span class="number">2</span>].set_ylim(<span class="number">0</span>, <span class="number">0.06</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 전체 title 설정</span></span><br><span class="line">fig.suptitle(<span class="string">&quot;penguins dataset feature distribution with threshold\n&quot;</span>, color=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig.savefig(<span class="string">&quot;127_kdeth_8.png&quot;</span>)</span><br></pre></td></tr></table></figure><img src="127_kdeth_8.png"><br></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      
    </item>
    
    <item>
      <title>신천식의 이슈토론 - 과학자 그들은 누구인가? 과학자가 행복한 도시는?</title>
      <link>https://jehyunlee.github.io/2023/02/02/Python-General-15-scs_issue/</link>
      <guid>https://jehyunlee.github.io/2023/02/02/Python-General-15-scs_issue/</guid>
      <pubDate>Wed, 01 Feb 2023 20:11:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;중도TV &lt;b&gt;신천식의 이슈토론&lt;/b&gt;에 패널로 출연했습니다.&lt;ul&gt;
&lt;li&gt;&lt;b&gt;과학자 그들은 누구인가? 과학자가 행복한 도시는?&lt;/b&gt;이라는 주제로 대화를 나눴고,&lt;/li&gt;
&lt;li&gt;채연석 박사님 (前항공우주연구원장, 現국토교통부 항</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>중도TV <b>신천식의 이슈토론</b>에 패널로 출연했습니다.<ul><li><b>과학자 그들은 누구인가? 과학자가 행복한 도시는?</b>이라는 주제로 대화를 나눴고,</li><li>채연석 박사님 (前항공우주연구원장, 現국토교통부 항공,철도사고조사위원회 위원장),<br>유용균 박사 (한국원자력연구원 인공지능응용연구실 실장, AI프렌즈 즈장)<br>두 분과 함께 말씀을 나눴습니다.</li></ul></li></ul><ul><li>영상 : (<a href="https://youtu.be/gDC7agLJFeY">Youtube Link</a>)<br></li><li>기사 : <a href="http://www.joongdo.co.kr/web/view.php?key=20230201010000231">중도일보, “[신천식의 이슈토론]과학자 그들은 누구인가, 과학자들이 행복한 대전”</a></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/gDC7agLJFeY" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><img src="15_scs_issue_01.png" alt="신천식의 이슈토론이 1일 오전 10 중도일보 스튜디오에서 &#39;과학자 그들운 누구인가, 과학자들이 행복한 대전&#39;을 주제로 진행됐다. (왼쪽부터)최연석 전 항공우주연구원장, 신천식 박사, 유용균 원자력 연구원 박사, 이제헌 한국에너지기술 연구원 박사"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/youtube/">youtube</category>
      
      
    </item>
    
    <item>
      <title>연구소의 문헌분석 기술 활용</title>
      <link>https://jehyunlee.github.io/2023/01/09/Python-DS-126-labnlp/</link>
      <guid>https://jehyunlee.github.io/2023/01/09/Python-DS-126-labnlp/</guid>
      <pubDate>Mon, 09 Jan 2023 02:21:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;2022년 12월 13일 &lt;b&gt;모두의 연구소&lt;/b&gt; 초청으로  &lt;b&gt;MODUPOP&lt;/b&gt; 강연을 했습니다.&lt;ul&gt;
&lt;li&gt;몸담고 있는 연구원에서 적용하고 있는 문헌분석 기술을 공유드렸습니다.&lt;/li&gt;
&lt;li&gt;짧은 시간에 압축해서 전달드</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>2022년 12월 13일 <b>모두의 연구소</b> 초청으로  <b>MODUPOP</b> 강연을 했습니다.<ul><li>몸담고 있는 연구원에서 적용하고 있는 문헌분석 기술을 공유드렸습니다.</li><li>짧은 시간에 압축해서 전달드린터라 세부 기술보다는 적용처 중심으로 봐주시면 감사하겠습니다.</li><li>저녁 7시부터 시작된 강의였고, 비와 눈으로 날씨가 많이 나쁜 날이었습니다.</li><li>귀중한 시간을 내서 온라인, 오프라인으로 참석해주신 분들께 다시 한번 감사드립니다.</li><li>초반 2분 가량 소리가 조금 울립니다. 양해 부탁드립니다.</li></ul></li></ul><ul><li>발표 영상 : (<a href="https://youtu.be/fuyOoDBZc1k">Youtube Link</a>)<br></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/fuyOoDBZc1k" frameborder="0" loading="lazy" allowfullscreen></iframe></div> ]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/KIER/">KIER</category>
      
      <category domain="https://jehyunlee.github.io/tags/API/">API</category>
      
      <category domain="https://jehyunlee.github.io/tags/NLP/">NLP</category>
      
      
    </item>
    
    <item>
      <title>Impact of RPA</title>
      <link>https://jehyunlee.github.io/2023/01/01/Python-DS-125-rpa/</link>
      <guid>https://jehyunlee.github.io/2023/01/01/Python-DS-125-rpa/</guid>
      <pubDate>Sun, 01 Jan 2023 07:02:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;RPA(Robotic Process Automation: 업무 자동화) 과제를 하려고 합니다.&lt;/li&gt;
&lt;li&gt;RPA를 적용하면 효용이 얼마나 좋은지를 설득하기 위한 그림을 그립니다.&lt;/li&gt;
&lt;li&gt;RPA 도입 전과 후를 비교하는 그</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>RPA(Robotic Process Automation: 업무 자동화) 과제를 하려고 합니다.</li><li>RPA를 적용하면 효용이 얼마나 좋은지를 설득하기 위한 그림을 그립니다.</li><li>RPA 도입 전과 후를 비교하는 그림을 그려서 보여줍시다.</li></ul><h1 id="1-행정-업무"><a href="#1-행정-업무" class="headerlink" title="1. 행정 업무"></a>1. 행정 업무</h1><p><img src="125_rpa_01.png"></p><ul><li><p>어떤 가상의 데이터 관련 행정 업무가 있다고 합시다.</p></li><li><p>현재는 <b>총 2천만원의 용역비</b>를 포함해 <b>12주</b>가 걸립니다. <b>수작업</b>이기 때문입니다.</p></li><li><p>여기에 RPA를 적용하면, <b>용역비가 없어지고</b> 이어지는 작업도 훨씬 짧게 걸립니다.</p></li><li><p>서류 작업과 취합 작업도 단순 반복 작업에서 <b>검증으로 업무 성격이 바뀝니다.</b><br></p></li><li><p><b>보고서</b>나 <b>기획서</b>등에서 이 훌륭한 업무를 어필하고 싶습니다.</p></li><li><p>일단 <a href="RPA_comparison.xlsx">엑셀로 정리</a>해보니 이렇습니다. 전달은 되는데 아쉽습니다.<br><br><img src="125_rpa_02.png"><br></p></li></ul><h1 id="2-시각화"><a href="#2-시각화" class="headerlink" title="2. 시각화"></a>2. 시각화</h1><h2 id="2-1-용역-비용-amp-인력"><a href="#2-1-용역-비용-amp-인력" class="headerlink" title="2.1. 용역 비용 &amp; 인력"></a>2.1. 용역 비용 &amp; 인력</h2><ul><li>RPA 효과는 크게 두 가지입니다. 하나는 <b>용역 비용</b>, 하나는 <b>인력</b></li><li>인력도 man-week (MW)으로 정리했기 때문에 담당자의 연봉을 적용하면 비용 산정이 됩니다.</li><li>하지만 여기선 용역은 용역, 인력은 인력으로 나누어 그리기로 합니다.</li><li>항목 수에 따라 용역 비용과 인력이 그려질 공간을 1:3의 비율로 분할합니다.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), gridspec_kw=&#123;<span class="string">&quot;width_ratios&quot;</span>:[<span class="number">1</span>, <span class="number">3</span>]&#125;)</span><br></pre></td></tr></table></figure><img src="125_rpa_03.png"><br></li></ul><h2 id="2-2-용역-비용"><a href="#2-2-용역-비용" class="headerlink" title="2.2. 용역 비용"></a>2.2. 용역 비용</h2><ul><li>왼쪽 공간에 RPA 적용 전 2천만원이 들어간 용역 비용과 적용 후 0원이 된 것을 비교하여 그립니다.</li><li>이럴 때는 grouped bar plot이 제격입니다.</li><li>용역 비용 뿐 아니라 다른 모든 항목을 비교할 것이기 때문에 <b>RPA 전</b>과 <b>RPA 후</b> 비교에 일관성이 필요합니다.</li><li>적용 전과 후를 <b>“brown”</b>과 <b>“royalblue”</b>로 표기합니다.</li></ul><ul><li>또한, <b>grouped bar plot</b>은 <b>pandas가 더 편합니다.</b></li><li>pandas DataFrame에서 그림을 그릴 부분만 <code>.loc[]</code>를 사용해 데이터를 한정하고,</li><li><code>.plot.bar()</code>를 사용해 groupled bar plot을 그립니다.</li><li><code>cs = [&quot;brown&quot;, &quot;royalblue&quot;]</code>과 <code>color=cs</code>를 입력하면 적용 전과 후 색이 차례로 입혀집니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data 읽기</span></span><br><span class="line">rpa = pd.read_excel(<span class="string">&quot;RPA_comparison.xlsx&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), gridspec_kw=&#123;<span class="string">&quot;width_ratios&quot;</span>:[<span class="number">1</span>, <span class="number">3</span>]&#125;, constrained_layout=<span class="literal">True</span>)</span><br><span class="line">cs = [<span class="string">&quot;brown&quot;</span>, <span class="string">&quot;royalblue&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 용역 비용</span></span><br><span class="line">rpa.loc[[<span class="number">0</span>]].plot.bar(ax=axs[<span class="number">0</span>], lw=<span class="number">1</span>, ec=<span class="string">&quot;w&quot;</span>, legend=<span class="literal">False</span>, color=cs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 인력</span></span><br><span class="line">rpa.loc[<span class="number">1</span>:].plot.bar(ax=axs[<span class="number">1</span>], lw=<span class="number">1</span>, ec=<span class="string">&quot;w&quot;</span>, legend=<span class="literal">False</span>, color=cs)</span><br></pre></td></tr></table></figure><img src="125_rpa_04.png"><br></li></ul><h2 id="2-3-Annotation"><a href="#2-3-Annotation" class="headerlink" title="2.3. Annotation"></a>2.3. Annotation</h2><ul><li><p>가장 중요한 틀이 갖춰졌습니다.</p></li><li><p>이제 ticks, ticklabels 등을 다듬으면 쓸만한 그래프가 될겁니다.</p></li><li><p>하지만 그 전에, <b>데이터를 직설적으로 알려주는 장치를 하려고 합니다.</b></p></li><li><p>위 코드 아래에 코드를 덧붙여 bar 위에 데이터를 출력합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 용역 비용</span></span><br><span class="line">xs, ws, hs = [], [], []</span><br><span class="line"><span class="keyword">for</span> p, c <span class="keyword">in</span> <span class="built_in">zip</span>(axs[<span class="number">0</span>].patches, cs):</span><br><span class="line">    x, w, h = p.get_x(), p.get_width(), p.get_height()</span><br><span class="line">    xs.append(x)</span><br><span class="line">    ws.append(w)</span><br><span class="line">    hs.append(h)</span><br><span class="line">    cost = <span class="built_in">format</span>(<span class="built_in">int</span>(h), <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> h &gt; <span class="number">0</span>:</span><br><span class="line">        cost = <span class="string">f&quot;<span class="subst">&#123;cost&#125;</span> 천원&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cost = <span class="string">f&quot;<span class="subst">&#123;cost&#125;</span> 원&quot;</span></span><br><span class="line">    axs[<span class="number">0</span>].text(x+w/<span class="number">2</span>, h+<span class="number">1000</span>, cost, ha=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;small&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>, color=c, zorder=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><img src="125_rpa_05.png"><br></p></li><li><p>왼쪽 Axes를 구성하는 두 막대의 위치, 너비, 높이를 뽑아내 글자를 입혔습니다.</p></li><li><p>일반적으로 금액을 <b>천원</b>단위로 표현하기 때문에 일부러 엑셀 파일부터 천원으로 끊었습니다.</p></li></ul><h2 id="2-4-Spines-and-Ticks"><a href="#2-4-Spines-and-Ticks" class="headerlink" title="2.4. Spines and Ticks"></a>2.4. Spines and Ticks</h2><ul><li>이제 y축이 없어도 데이터가 잘 전달됩니다.</li><li>y축과 함께 네모난 테두리(spines)를 없애버립시다.</li><li>x축 눈금은 <code>tick_params()</code>를 사용해 폭을 0으로(<code>width=0</code>) 만듭니다.</li><li>그런데 xticklabel은 여기 말고도 오른쪽 Axes에도 세 개나 더 적용해야 됩니다.</li><li><code>font_label</code>이라는 이름의 dictionary type 매개변수를 만들어 적용합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Spines and Ticks</span></span><br><span class="line">axs[<span class="number">0</span>].spines[[<span class="string">&quot;left&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;right&quot;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_yticks([])</span><br><span class="line">font_label = &#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;</span><br><span class="line">axs[<span class="number">0</span>].tick_params(axis=<span class="string">&quot;x&quot;</span>, width=<span class="number">0</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_xticklabels([<span class="string">&quot;용역 비용&quot;</span>], **font_label, rotation=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><img src="125_rpa_06.png"><br></li></ul><h2 id="2-5-Arrow"><a href="#2-5-Arrow" class="headerlink" title="2.5. Arrow"></a>2.5. Arrow</h2><blockquote><p><a href="https://matplotlib.org/stable/gallery/userdemo/connectionstyle_demo.html">matplotlib: Connection styles for annotations</a><br><a href="https://matplotlib.org/stable/gallery/text_labels_and_annotations/fancyarrow_demo.html">matplotlib: Annotation arrow style reference</a></p></blockquote><ul><li>RPA 적용 전후는 나왔는데 그림에서 알아보기 어렵습니다.</li><li><b>RPA를 적용했더니 확 비용이 확 떨어진다</b>는 느낌의 화살표가 있으면 좋을 것 같습니다.</li><li>Matplotlib에서 멋진 화살표를 만들기에는 <code>Axes.annotate()</code>가 가장 좋습니다.</li><li><b>“arrowstyle”:”fancy”</b>와 <b>“connectionstyle”</b>을 이용해 다이나믹한 화살표를 그립니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Arrow</span></span><br><span class="line">axs[<span class="number">0</span>].annotate(<span class="string">&quot;&quot;</span>, xy=(xs[<span class="number">1</span>]+w/<span class="number">2</span>, hs[<span class="number">1</span>]+w/<span class="number">2</span>), xytext=(xs[<span class="number">0</span>]+w/<span class="number">2</span>, hs[<span class="number">0</span>]+w/<span class="number">2</span>),</span><br><span class="line">            arrowprops=&#123;<span class="string">&quot;arrowstyle&quot;</span>:<span class="string">&quot;fancy&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;fc&quot;</span>:<span class="string">&quot;cornflowerblue&quot;</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>,</span><br><span class="line">                        <span class="string">&quot;connectionstyle&quot;</span>:<span class="string">&quot;arc3,rad=-0.3&quot;</span>, <span class="string">&quot;mutation_scale&quot;</span>:<span class="number">100</span>&#125;)</span><br></pre></td></tr></table></figure><img src="125_rpa_07.png"><br></li></ul><h2 id="2-6-인력에도-동일하게"><a href="#2-6-인력에도-동일하게" class="headerlink" title="2.6. 인력에도 동일하게"></a>2.6. 인력에도 동일하게</h2><ul><li>용역 비용에 적용한 사항들을 인력에도 동일하게 적용합니다.</li><li>아까 왼쪽 Axes의 xticklabel에 넣었던 <b>용역 비용</b>은 title이 더 잘 어울리는 것 같습니다.</li><li>내용을 올리고, xticklabel은 새롭게 <b>분석 용역</b>이라고 넣습니다.</li><li>오른쪽에도 여기에 대응되도록 <b>용역 검증</b>, <b>서류 작업</b>, <b>취합 작업</b>을 넣습니다.<br><br><img src="125_rpa_08.png"><br></li></ul><h2 id="2-7-비용과-기간-사이-칸막이"><a href="#2-7-비용과-기간-사이-칸막이" class="headerlink" title="2.7. 비용과 기간 사이 칸막이"></a>2.7. 비용과 기간 사이 칸막이</h2><ul><li>마지막 작업입니다.</li><li>왼쪽과 오른쪽 구간을 나누는 막대를 하나 넣습니다.</li><li><code>matplotlib.lines.Line2D</code>객체를 사용해 선을 그립니다. </li><li>양 끝점의 좌표를 입력해야 하는데 Figure 전체의 상대 좌표를 사용해 <code>[0.255, 0.255], [0.15, 0.85]</code>를 입력합니다.</li><li>양 끝을 둥글게 만들고자 <code>solid_capstyle = &quot;round&quot;</code>를 입력했습니다.</li><li>두 Axes 사이 공간에 그려야 하는 그림이기 때문에 <code>fig.add_artist()</code>로 추가합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.lines <span class="keyword">import</span> Line2D</span><br><span class="line"></span><br><span class="line">line = Line2D([<span class="number">0.255</span>, <span class="number">0.255</span>], [<span class="number">0.15</span>, <span class="number">0.85</span>], linewidth=<span class="number">5</span>, solid_capstyle=<span class="string">&quot;round&quot;</span>, color=<span class="string">&quot;0.6&quot;</span>)</span><br><span class="line">fig.add_artist(line)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">1</span>].legend()</span><br></pre></td></tr></table></figure><img src="125_rpa_09.png"><br></li></ul><h1 id="3-활용"><a href="#3-활용" class="headerlink" title="3. 활용"></a>3. 활용</h1><blockquote><p><a href="https://m.etnews.com/20221228000275">관련기사: 전자신문- NST, 출연연 연구행정혁신 성과확산 공모전 시상식 개최</a></p></blockquote><ul><li>이렇게 정리된 그림은 <b>적절한 표</b>, <b>근거 자료</b>와 함께 <b>보고서</b>와 <b>ppt</b>에 삽입하면 좋습니다.</li><li><b>그냥 파워포인트에서 그리면 더 쉽지 않냐</b>고 하실 수 있습니다.</li><li>경험상 이런 일은 현업 부서에서 수치가 수차례 변경되는 것이 일반적이고, 실제로 열번쯤 바뀐 것 같습니다.</li><li>일일이 새로 그렸다면 너무 힘들었을테지만 코드로 그린 덕택에 그때마다 데이터만 바꿔 끼웠습니다.</li></ul><ul><li><p>위 그림은 실제로 최근 있었던 한 공모전에서 서류 작성과 발표 자료에 사용했습니다.</p></li><li><p>데이터는 제가 접한 실제 사례와 다르게 바꾸었습니다만, 전반적인 틀은 살렸습니다.<br><br><img src="125_rpa_10.png" alt="혹시나 싶은 마음에 내용은 흐리게 가렸습니다."><br></p></li><li><p>전체 코드는 아래와 여기에서 확인할 수 있습니다: <a href="https://colab.research.google.com/drive/1RLo4aTtP_sM9EoxWyfkvR5hetGNmvVZH?usp=share_link">Colab 링크</a></p></li><li><p>여러분께도 좋은 결과가 있기를 바랍니다.</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> matplotlib.lines <span class="keyword">import</span> Line2D</span><br><span class="line"></span><br><span class="line">sns.set_context(<span class="string">&quot;talk&quot;</span>)</span><br><span class="line">plt.rcParams[<span class="string">&quot;font.family&quot;</span>] = <span class="string">&quot;NanumGothic&quot;</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># data 읽기</span></span><br><span class="line">rpa = pd.read_excel(<span class="string">&quot;RPA_comparison.xlsx&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), gridspec_kw=&#123;<span class="string">&quot;width_ratios&quot;</span>:[<span class="number">1</span>, <span class="number">3</span>]&#125;, constrained_layout=<span class="literal">True</span>)</span><br><span class="line">cs = [<span class="string">&quot;brown&quot;</span>, <span class="string">&quot;royalblue&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 용역 비용</span></span><br><span class="line">rpa.loc[[<span class="number">0</span>]].plot.bar(ax=axs[<span class="number">0</span>], lw=<span class="number">1</span>, ec=<span class="string">&quot;w&quot;</span>, legend=<span class="literal">False</span>, color=cs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 인력</span></span><br><span class="line">rpa.loc[<span class="number">1</span>:].plot.bar(ax=axs[<span class="number">1</span>], lw=<span class="number">1</span>, ec=<span class="string">&quot;w&quot;</span>, legend=<span class="literal">False</span>, color=cs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 용역 비용</span></span><br><span class="line">xs, ws, hs = [], [], []</span><br><span class="line"><span class="keyword">for</span> p, c <span class="keyword">in</span> <span class="built_in">zip</span>(axs[<span class="number">0</span>].patches, cs):</span><br><span class="line">    x, w, h = p.get_x(), p.get_width(), p.get_height()</span><br><span class="line">    xs.append(x)</span><br><span class="line">    ws.append(w)</span><br><span class="line">    hs.append(h)</span><br><span class="line">    cost = <span class="built_in">format</span>(<span class="built_in">int</span>(h), <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> h &gt; <span class="number">0</span>:</span><br><span class="line">        cost = <span class="string">f&quot;<span class="subst">&#123;cost&#125;</span> 천원&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cost = <span class="string">f&quot;<span class="subst">&#123;cost&#125;</span> 원&quot;</span></span><br><span class="line">    axs[<span class="number">0</span>].text(x+w/<span class="number">2</span>, h+<span class="number">1000</span>, cost, ha=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;small&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>, color=c, zorder=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Spines and Ticks</span></span><br><span class="line">font_label = &#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;gray&quot;</span>, <span class="string">&quot;fontweight&quot;</span>:<span class="string">&quot;bold&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> ax, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [<span class="string">&quot;용역 비용\n&quot;</span>, <span class="string">&quot;업무 기간\n&quot;</span>]):</span><br><span class="line">    ax.spines[[<span class="string">&quot;left&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;right&quot;</span>]].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.set_yticks([])</span><br><span class="line">    ax.tick_params(axis=<span class="string">&quot;x&quot;</span>, width=<span class="number">0</span>)</span><br><span class="line">    ax.set_title(title, **font_label)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">0</span>].set_xticklabels([<span class="string">&quot;분석 용역&quot;</span>], rotation=<span class="number">0</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_xticklabels([<span class="string">&quot;용역 검증&quot;</span>, <span class="string">&quot;서류 작업&quot;</span>, <span class="string">&quot;취합 작업&quot;</span>], </span><br><span class="line">                       rotation=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Arrow</span></span><br><span class="line">axs[<span class="number">0</span>].annotate(<span class="string">&quot;&quot;</span>, xy=(xs[<span class="number">1</span>]+w/<span class="number">2</span>, hs[<span class="number">1</span>]+w/<span class="number">2</span>), xytext=(xs[<span class="number">0</span>]+w/<span class="number">2</span>, hs[<span class="number">0</span>]+w/<span class="number">2</span>),</span><br><span class="line">            arrowprops=&#123;<span class="string">&quot;arrowstyle&quot;</span>:<span class="string">&quot;fancy&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;fc&quot;</span>:<span class="string">&quot;cornflowerblue&quot;</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.5</span>,</span><br><span class="line">                        <span class="string">&quot;connectionstyle&quot;</span>:<span class="string">&quot;arc3,rad=-0.3&quot;</span>, <span class="string">&quot;mutation_scale&quot;</span>:<span class="number">100</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 인력 감축</span></span><br><span class="line">xs, ws, hs = [], [], []</span><br><span class="line"><span class="keyword">for</span> i, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(axs[<span class="number">1</span>].patches):</span><br><span class="line">    x, w, h = p.get_x(), p.get_width(), p.get_height()</span><br><span class="line">    xs.append(x)</span><br><span class="line">    ws.append(w)</span><br><span class="line">    hs.append(h)</span><br><span class="line">    person = <span class="built_in">format</span>(<span class="built_in">int</span>(h), <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> h &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> h%<span class="number">1</span>:</span><br><span class="line">            h = <span class="built_in">int</span>(h)</span><br><span class="line">        day = <span class="string">f&quot;<span class="subst">&#123;h&#125;</span> 주&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">3</span>:</span><br><span class="line">        c = cs[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        c = cs[<span class="number">1</span>]</span><br><span class="line">    p.set_fc(c)</span><br><span class="line">    axs[<span class="number">1</span>].text(x+w/<span class="number">2</span>, h+<span class="number">0.3</span>, day, ha=<span class="string">&quot;center&quot;</span>, fontsize=<span class="string">&quot;small&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>, color=c, zorder=<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    axs[<span class="number">1</span>].annotate(<span class="string">&quot;&quot;</span>, xy=(xs[i+<span class="number">3</span>]+w/<span class="number">2</span>, hs[i+<span class="number">3</span>]+w/<span class="number">2</span>), xytext=(xs[i]+w/<span class="number">2</span>, hs[i]+w/<span class="number">2</span>),</span><br><span class="line">            arrowprops=&#123;<span class="string">&quot;arrowstyle&quot;</span>:<span class="string">&quot;fancy&quot;</span>, <span class="string">&quot;ec&quot;</span>:<span class="string">&quot;skyblue&quot;</span>, <span class="string">&quot;fc&quot;</span>:<span class="string">&quot;skyblue&quot;</span>, <span class="string">&quot;alpha&quot;</span>:<span class="number">0.8</span>,</span><br><span class="line">                        <span class="string">&quot;connectionstyle&quot;</span>:<span class="string">&quot;arc3,rad=-0.3&quot;</span>, <span class="string">&quot;mutation_scale&quot;</span>:<span class="number">40</span>&#125;)</span><br><span class="line"></span><br><span class="line">line = Line2D([<span class="number">0.255</span>, <span class="number">0.255</span>], [<span class="number">0.15</span>, <span class="number">0.85</span>], linewidth=<span class="number">5</span>, solid_capstyle=<span class="string">&quot;round&quot;</span>, color=<span class="string">&quot;0.6&quot;</span>)</span><br><span class="line">fig.add_artist(line)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">1</span>].legend()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      
    </item>
    
    <item>
      <title>산타 방문 증빙 feat. DALL.E</title>
      <link>https://jehyunlee.github.io/2022/12/26/Python-General-14_santa/</link>
      <guid>https://jehyunlee.github.io/2022/12/26/Python-General-14_santa/</guid>
      <pubDate>Mon, 26 Dec 2022 07:30:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;2022년 한 해는 그림 생성 모델로 뜨거웠습니다.&lt;/li&gt;
&lt;li&gt;DALL.E를 사용해서 산타가 다녀갔다는 증빙을 만듭니다.&lt;/li&gt;
&lt;li&gt;사진 한 장이 필요합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-산타가-다녀가셨다&quot;&gt;&lt;a h</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>2022년 한 해는 그림 생성 모델로 뜨거웠습니다.</li><li>DALL.E를 사용해서 산타가 다녀갔다는 증빙을 만듭니다.</li><li>사진 한 장이 필요합니다.</li></ul><h1 id="1-산타가-다녀가셨다"><a href="#1-산타가-다녀가셨다" class="headerlink" title="1. 산타가 다녀가셨다!"></a>1. 산타가 다녀가셨다!</h1><ul><li>크리스마스에 다녀가시는 산타는 아이들에게 큰 기쁨입니다.</li><li>선물 자체도 기쁘고, 한 해 잘 살았다는 칭찬을 받는 듯한 느낌도 나지요.</li><li>반면 부모에게는 어떻게 올해를 넘길지가 고민입니다.</li></ul><blockquote><p><b>산타가 다녀가셨나봐! 선물도 있고 아빠 핸드폰에 사진도 찍혔어!</b></p></blockquote><p><img src="14_santa_02.png"></p><ul><li>다행히 아이들은 눈을 동그랗게 뜨고 믿어주었습니다.</li><li><b>산타를 제외한 배경이 우리 집이었기 때문에 의심도 안 했을 것입니다.</b></li></ul><h1 id="2-준비"><a href="#2-준비" class="headerlink" title="2. 준비"></a>2. 준비</h1><blockquote><p><a href="https://labs.openai.com/">DALL.E</a></p></blockquote><ul><li><p>먼저, 그림을 그려주는 AI, <b><a href="https://labs.openai.com/">DALL.E</a> 계정</b>이 필요합니다.</p></li><li><p>아직 계정이 없으시다면 위 링크로 들어가 회원 가입을 합니다.</p></li><li><p>로그인을 마치면 아래와 같은 화면이 나타납니다.<br><br><img src="14_santa_04.png"><br></p></li><li><p>그리고 <b>집 사진 한 장</b>이 필요합니다.</p></li><li><p>크리스마스를 맞아 꾸민 트리 밑에 아이들에게 줄 선물을 놓고 사진을 찍습니다.</p></li><li><p>산타가 등장할 곳은 다소 어두워야 부모에게 유리합니다.<br><br><img src="14_santa_01.jpg"><br></p></li></ul><h1 id="3-DALL-E-활약"><a href="#3-DALL-E-활약" class="headerlink" title="3. DALL.E 활약"></a>3. DALL.E 활약</h1><ul><li><b>Upload an image</b>를 클릭해서 집 사진을 올립니다.</li><li>그러면 정사각형으로 자르라고 하는데, 적절히 위치를 지정하고 <b>Crop</b>을 누릅니다.<br><br><img src="14_santa_05.png"><br></li></ul><ul><li><p>확인이 되었으면 <b>Edit image</b>를 눌러 수정을 들어갑니다.</p></li><li><p>기본으로 설정된 <b>지우개</b> 아이콘으로 산타가 놓일 자리를 지웁니다.<br><br><img src="14_santa_06.png"><br></p></li><li><p>이제 산타를 그릴 차례입니다.</p></li><li><p>구글 검색창을 닮은 하얀 막대 안에 산타가 어떤 모습으로 들어올지를 씁니다.</p></li><li><p>저는 이렇게 적었습니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Realistic photography of Santa Clause from backside, bending his knee towards the tree, standing to distribute Christmas presents.</span><br></pre></td></tr></table></figure></li><li><p>마지막으로 <b>Generate</b> 버튼을 누르면 4장의 이미지가 한번에 생성됩니다.<br><br><img src="14_santa_03.png"><br></p></li><li><p>마음에 드는 이미지가 없다면 <b>Generate</b>를 다시 눌러 다른 그림을 만들어봅니다.</p></li><li><p>마음에 드는 이미지가 나오면 그림을 다운받아 휴대폰에 저장합니다.<br><br><img src="14_santa_02.png"><br></p></li><li><p>언젠가 산타의 정체가 부모라는 것을 알게 되겠지만, 그 날이 오기 전까지는 동심을 간직하기를 바랍니다.</p></li><li><p>훗날 아이들이 이 포스팅을 읽게 된다면, 2022년의 산타와 선물을 떠올려주면 좋겠습니다. :)</p></li></ul><blockquote><p><b>아빠, 산타가 우리가 키우는 나무 만져줬나봐! 하루 사이에 더 자랐어!</b></p></blockquote>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/General/">General</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/dall-e/">dall.e</category>
      
      <category domain="https://jehyunlee.github.io/tags/inpaining/">inpaining</category>
      
      
    </item>
    
    <item>
      <title>Deep Learning by Open API</title>
      <link>https://jehyunlee.github.io/2022/11/29/Python-DS-124-kierlecture8/</link>
      <guid>https://jehyunlee.github.io/2022/11/29/Python-DS-124-kierlecture8/</guid>
      <pubDate>Mon, 28 Nov 2022 17:02:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;한국에너지기술연구원 AI 학습조직&lt;/b&gt;에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.&lt;ul&gt;
&lt;li&gt;이번에는 직접 하는 코딩을 벗어나 공개된 딥러닝 모델을 사용하는 방법을 알아봅니다.&lt;/li&gt;
&lt;li&gt;영상과 자연어 처</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b>한국에너지기술연구원 AI 학습조직</b>에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.<ul><li>이번에는 직접 하는 코딩을 벗어나 공개된 딥러닝 모델을 사용하는 방법을 알아봅니다.</li><li>영상과 자연어 처리를 중심으로 OpenAI에서 제공하는 여러 모델이 있습니다.</li><li>강의실 예약 시간 문제로 마무리가 매끄럽지 못했습니다.</li><li>요약본이 번역되다 만 문제는 <code>max_tokens=300</code>을 추가하면 해결됩니다.</li><li><a href="221128_9%EC%B0%A8%EB%AA%A8%EC%9E%84.pdf">강의 자료는 여기에서 다운받으실 수 있습니다</a></li></ul></li></ul><ul><li><p>발표 영상 : (<a href="https://youtu.be/dsnrl0tLkdU">Youtube Link</a>)<br></p></li><li><p>실습 코드 : (<a href="https://bit.ly/3gEMeUS">https://bit.ly/3gEMeUS</a>)<br></p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/dsnrl0tLkdU" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><img src="cats.png" alt="DALL.E Open API로 그린 그림"><br></p><p><ul><li>1년간 총 8개의 강좌로 정리되었습니다.</li></ul><p><img src="schedule.png" alt="학습조직 일정"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/machine-learning/">machine learning</category>
      
      <category domain="https://jehyunlee.github.io/tags/KIER/">KIER</category>
      
      <category domain="https://jehyunlee.github.io/tags/API/">API</category>
      
      <category domain="https://jehyunlee.github.io/tags/Open-AI/">Open AI</category>
      
      <category domain="https://jehyunlee.github.io/tags/DALL-E/">DALL.E</category>
      
      <category domain="https://jehyunlee.github.io/tags/summary/">summary</category>
      
      
    </item>
    
    <item>
      <title>Gaussian Process Practice (3) Beware Boundaries</title>
      <link>https://jehyunlee.github.io/2022/11/19/Python-DS-123-gpr3/</link>
      <guid>https://jehyunlee.github.io/2022/11/19/Python-DS-123-gpr3/</guid>
      <pubDate>Sat, 19 Nov 2022 08:35:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;Gaussian Process 연습입니다.&lt;/li&gt;
&lt;li&gt;scikit-learn을 비롯한 예제를 재구성하여 연습합니다.&lt;/li&gt;
&lt;li&gt;주의사항을 알려드립니다. Gaussian Process는 경계조건에 매우 취약합니다.&lt;/li&gt;
&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>Gaussian Process 연습입니다.</li><li>scikit-learn을 비롯한 예제를 재구성하여 연습합니다.</li><li>주의사항을 알려드립니다. Gaussian Process는 경계조건에 매우 취약합니다.</li></ul><h1 id="1-Gaussian-Process의-한계"><a href="#1-Gaussian-Process의-한계" class="headerlink" title="1. Gaussian Process의 한계"></a>1. Gaussian Process의 한계</h1><blockquote><p><a href="https://scikit-learn.org/stable/auto_examples/gaussian_process/plot_gpr_noisy_targets.html#sphx-glr-auto-examples-gaussian-process-plot-gpr-noisy-targets-py">scikit-learn: Gaussian Process Regression: basic introductory example</a></p></blockquote><ul><li><p>Gaussian Process는 적은 데이터로도 꽤 믿을만한 결과를 출력합니다.</p></li><li><p>심지어 신뢰 구간까지 알 수 있어서 매우 정직해 보입니다.</p></li><li><p>하지만 치명적인 단점이 있습니다.</p></li><li><p><a href="https://jehyunlee.github.io/2022/11/16/Python-DS-121-gpr1/">지난 글</a>과 같은 예제를 사용합니다.<br><img src="123_gpr3_3.png"><br></p></li><li><p>모든 것이 정상으로 보입니다.</p></li><li><p>합리적인 범위의 평균값(<code>GP prediction (mean)</code>)과 신뢰 구간(<code>95% CI</code>)을 보이고 있습니다.</p></li><li><p>하지만 오른쪽 끄트머리를 보면, 조금 미심쩍습니다.</p></li><li><p><b>참값이 신뢰 구간의 바닥에 겨우 걸려있습니다.</b><br><br><img src="123_gpr3_8.png" alt="개그콘서트, &quot;불편한 진실&quot; "><br></p></li><li><p>극단적인 경우를 살펴봅니다.</p></li><li><p><b>X 값의 범위</b>로 참값의 좌우에 50씩을 보태 <b>-50 ~ 60을 입력</b>합니다.</p></li><li><p>평균이 0, 95% 신뢰구간이 무려 10에 가까운 커다란 밴드가 생겼습니다.</p></li><li><p>다항회귀를 해도 이렇지는 않을 것 같습니다.<br><br><img src="123_gpr3_7.png"><br></p></li><li><p><b>Gaussian Process의 원리</b>에 답이 있습니다.</p></li><li><p>Gaussian 분포를 prior로 놓기 때문에 평균이 0입니다.</p></li><li><p>학습 데이터(evidence)가 반영된 구간 안쪽은 그나마 괜찮지만 바깥쪽이 문제입니다.</p></li><li><p><b>안쪽에서 학습을 시켜봐야 바깥쪽의 중심값이 0이라고 가정되어 있기 때문에 저런 일이 벌어집니다.</b></p></li></ul><h1 id="2-비교"><a href="#2-비교" class="headerlink" title="2. 비교"></a>2. 비교</h1><ul><li><p>조금 더 확실하게 확인합니다.</p></li><li><p>위의 예제에 <b>offset = $\pm 5$</b>를 해서 <b>새로운 참값</b>을 만듭니다.</p></li><li><p>그리고, 여기서 같은 X 좌표의 데이터들을 학습용으로 추출합니다.<br><br><img src="123_gpr3_4.png"><br></p></li><li><p>여기에 똑같은 RBF 커널을 적용한 Gaussian Process를 적용하면 아래와 같은 결과가 나옵니다.</p></li><li><p>좌우 그림에서 <b>파란 선</b>으로 표시한 평균값의 양 끝이 향하는 방향이 반대입니다.<br></p></li><li><p><b>offset=+5</b>인 왼쪽 그림은 양 끝이 아래를 향하고 있고,</p></li><li><p><b>offset=-5</b>인 오른쪽 그림은 양 끝이 기를 쓰고 고개를 들려고 하고 있습니다.</p></li><li><p>모두 <b>0을 향하고 있습니다.</b><br><br><img src="123_gpr3_5.png"><br></p></li><li><p>양 끝만 영향을 받는 것이 아닙니다.</p></li><li><p>X = 6~8 사이 구간도 offset에 따라 달라집니다.</p></li><li><p>0에서 먼 왼쪽 그림은 신뢰 구간이 비교적 얇은 반면 오른쪽은 두텁고 mean 값도 참값과 더 벌어져 있습니다.</p></li></ul><h1 id="3-Solution"><a href="#3-Solution" class="headerlink" title="3. Solution"></a>3. Solution</h1><ul><li><p>해결 방법은 생각보다 간단합니다.</p></li><li><p>외삽(extrapolation)이 문제라면 외삽을 하지 않으면 됩니다.</p></li><li><p>학습 데이터에 데이터 범위의 양 끝을 추가하면 모든 범위가 내삽이 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sample including ends</span></span><br><span class="line">training_indices += [<span class="number">0</span>, <span class="number">999</span>]</span><br><span class="line">Xp_train1, Xm_train1 = Xp[training_indices], Xm[training_indices]</span><br><span class="line">yp_train1, ym_train1 = yp[training_indices], ym[training_indices]</span><br></pre></td></tr></table></figure></li><li><p>그리고 같은 학습을 시키면 offset에 관계 없이 동일한 결과를 얻을 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">6</span>, <span class="number">3</span>), constrained_layout=<span class="literal">True</span>, sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, X, y, X_train, y_train, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [Xp, Xm], [yp, ym], </span><br><span class="line">                                             [Xp_train1, Xm_train1], [yp_train1, ym_train1], </span><br><span class="line">                                             [<span class="string">&quot;offset = +5&quot;</span>, <span class="string">&quot;offset = -5&quot;</span>]):</span><br><span class="line">    <span class="comment"># Gaussian Process</span></span><br><span class="line">    gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, random_state=<span class="number">0</span>)</span><br><span class="line">    gpr.fit(X_train, y_train)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># prediction</span></span><br><span class="line">    y_pred_mean, y_pred_std = gpr.predict(X, return_std=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    ax.plot(X, y, c=<span class="string">&quot;0.5&quot;</span>, label=<span class="string">&quot;true&quot;</span>)</span><br><span class="line">    ax.scatter(X_train, y_train, label=<span class="string">&quot;sample&quot;</span>)</span><br><span class="line">    ax.plot(X.ravel(), y_pred_mean, c=<span class="string">&quot;b&quot;</span>, label=<span class="string">&quot;GP prediction (mean)&quot;</span>)</span><br><span class="line">    ax.fill_between(X.ravel(), y_pred_mean-<span class="number">1.96</span>*y_pred_std, y_pred_mean+<span class="number">1.96</span>*y_pred_std, alpha=<span class="number">0.5</span>, fc=<span class="string">&quot;cornflowerblue&quot;</span>, label=<span class="string">&quot;95% CI&quot;</span>)</span><br><span class="line">    ax.axhline(<span class="number">0</span>, c=<span class="string">&quot;g&quot;</span>, lw=<span class="number">1</span>)</span><br><span class="line">    ax.set_title(title, pad=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">axs[<span class="number">0</span>].legend(loc=<span class="string">&quot;lower right&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="123_gpr3_6.png"><br></p></li></ul><h1 id="4-결론"><a href="#4-결론" class="headerlink" title="4. 결론"></a>4. 결론</h1><ul><li>머신 러닝 기법들이 모두 그렇지만 외삽은 주의해야 합니다.</li><li>Gaussian Process는 prior의 존재로 인해 외삽에 더 취약할 수 있으니 각별히 주의해야 합니다.</li><li>본 글에 사용된 코드는 <b><a href="gpr3.ipynb">여기에서 다운받으실 수 있습니다.</a></b></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/gaussian-process/">gaussian process</category>
      
      <category domain="https://jehyunlee.github.io/tags/bayesian/">bayesian</category>
      
      <category domain="https://jehyunlee.github.io/tags/scikit-learn/">scikit-learn</category>
      
      
    </item>
    
    <item>
      <title>Gaussian Process Practice (2) Kernels</title>
      <link>https://jehyunlee.github.io/2022/11/17/Python-DS-122-gpr2/</link>
      <guid>https://jehyunlee.github.io/2022/11/17/Python-DS-122-gpr2/</guid>
      <pubDate>Thu, 17 Nov 2022 10:22:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;Gaussian Process 연습입니다.&lt;/li&gt;
&lt;li&gt;scikit-learn을 비롯한 예제를 재구성하여 연습합니다.&lt;/li&gt;
&lt;li&gt;여러 커널의 특징을 알아보고 사용처를 알아봅니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-Data-</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>Gaussian Process 연습입니다.</li><li>scikit-learn을 비롯한 예제를 재구성하여 연습합니다.</li><li>여러 커널의 특징을 알아보고 사용처를 알아봅니다.</li></ul><h1 id="1-Data-Preparation"><a href="#1-Data-Preparation" class="headerlink" title="1. Data Preparation"></a>1. Data Preparation</h1><blockquote><p><a href="https://scikit-learn.org/stable/auto_examples/gaussian_process/plot_gpr_noisy_targets.html#sphx-glr-auto-examples-gaussian-process-plot-gpr-noisy-targets-py">scikit-learn: Gaussian Process Regression: basic introductory example</a></p></blockquote><h2 id="1-1-example-data"><a href="#1-1-example-data" class="headerlink" title="1.1. example data"></a>1.1. example data</h2><ul><li><a href="https://jehyunlee.github.io/2022/11/16/Python-DS-121-gpr1/">지난 글</a>과 같은 예제를 사용합니다.</li><li>오늘은 어제보다는 색을 많이 사용할 겁니다. 참값과 Gaussian Process 결과를 무채색으로 표현합니다.</li><li>관측값은 참값이라고 합시다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.gaussian_process <span class="keyword">import</span> GaussianProcessRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> RBF</span><br><span class="line"></span><br><span class="line"><span class="comment"># Random Number Generation</span></span><br><span class="line">rng = np.random.RandomState(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Gaussian Process Regression</span></span><br><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, random_state=<span class="number">0</span>)</span><br><span class="line">gpr.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prediction</span></span><br><span class="line">y_pred_mean, y_pred_std = gpr.predict(X, return_std=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br><span class="line">ax.plot(X, y, c=<span class="string">&quot;k&quot;</span>, label=<span class="string">&quot;true&quot;</span>)</span><br><span class="line">ax.scatter(X_train, y_train, fc=<span class="string">&quot;k&quot;</span>, label=<span class="string">&quot;sample without noise&quot;</span>)</span><br><span class="line"></span><br><span class="line">ax.plot(X.ravel(), y_pred_mean, c=<span class="string">&quot;0.5&quot;</span>, label=<span class="string">&quot;GP prediction (mean)&quot;</span>)</span><br><span class="line">ax.fill_between(X.ravel(), y_pred_mean-<span class="number">1.96</span>*y_pred_std, y_pred_mean+<span class="number">1.96</span>*y_pred_std, alpha=<span class="number">0.5</span>, fc=<span class="string">&quot;lightgray&quot;</span>, label=<span class="string">&quot;95% CI&quot;</span>)</span><br><span class="line">ax.legend(loc=<span class="string">&quot;upper left&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_3.png"><br></li></ul><h2 id="1-2-sample-추출"><a href="#1-2-sample-추출" class="headerlink" title="1.2. sample 추출"></a>1.2. sample 추출</h2><blockquote><p><a href="https://scikit-learn.org/stable/auto_examples/gaussian_process/plot_gpr_prior_posterior.html#sphx-glr-auto-examples-gaussian-process-plot-gpr-prior-posterior-py">scikit-learn: Illustration of prior and posterior Gaussian process for different kernels</a></p></blockquote><p><img src="ds.gif" alt="14,000,605개의 미래를 보는 닥터 스트레인지, 대혼돈의 멀티버스 中"></p><ul><li><p>신뢰구간에는 다양한 가능성이 내포되어 있습니다.</p></li><li><p>이들 중 일부를 골라 추출할 수 있습니다.</p></li><li><p>5개를 골라 Gaussian Process Regression 위에 얹어봅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sampling</span></span><br><span class="line">n_samples=<span class="number">5</span></span><br><span class="line">y_samples = gpr.sample_y(X, n_samples)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prediction</span></span><br><span class="line">y_pred_mean, y_pred_std = gpr.predict(X, return_std=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br><span class="line">ax.plot(X, y, c=<span class="string">&quot;k&quot;</span>, label=<span class="string">&quot;true&quot;</span>)</span><br><span class="line">ax.scatter(X_train, y_train, fc=<span class="string">&quot;k&quot;</span>, label=<span class="string">&quot;sample without noise&quot;</span>)</span><br><span class="line"></span><br><span class="line">ax.plot(X.ravel(), y_pred_mean, c=<span class="string">&quot;0.5&quot;</span>, label=<span class="string">&quot;GP prediction (mean)&quot;</span>)</span><br><span class="line">ax.fill_between(X.ravel(), y_pred_mean-<span class="number">1.96</span>*y_pred_std, y_pred_mean+<span class="number">1.96</span>*y_pred_std, alpha=<span class="number">0.5</span>, fc=<span class="string">&quot;lightgray&quot;</span>, label=<span class="string">&quot;95% CI&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> y_sample <span class="keyword">in</span> y_samples.T:</span><br><span class="line">    ax.plot(X.ravel(), y_sample, lw=<span class="number">1</span>, ls=<span class="string">&quot;:&quot;</span>, label=<span class="string">&quot;GP prediction (mean)&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="122_gpr2_4.png"><br></p></li><li><p>대부분 신뢰구간 안에 들어와 있지만 일부는 신뢰구간 밖으로도 나가 있습니다.</p></li><li><p>정상입니다.</p></li></ul><h2 id="1-3-posterior-vs-prior"><a href="#1-3-posterior-vs-prior" class="headerlink" title="1.3. posterior vs prior"></a>1.3. posterior vs prior</h2><ul><li><p>지금 그린 그림은 evidence가 반영된 결과, 즉 <b>posterior(사후확률)</b>입니다.</p></li><li><p>학습을 시키지 않은 채 예측을 하고 sample curve를 뽑을 수도 있습니다.</p></li><li><p>evidence가 반영되기 전의 <b>prior(사전확률)</b>입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prior</span></span><br><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sampling</span></span><br><span class="line">y_samples = gpr.sample_y(X, n_samples)</span><br></pre></td></tr></table></figure><p><img src="122_gpr2_5.png"><br></p></li><li><p>관측값이 반영되어 있지 않기 때문에 데이터와는 무관한 모습입니다.</p></li><li><p>그러나 곡선의 모양에는 우리가 선택한 RBF 커널이 드러나 있습니다.</p></li><li><p>학습에 커널이 반영되는만큼 <b>데이터의 모습을 반영</b>해 <b>커널을 선정</b>해야 합니다.</p></li><li><p>scikit-learn이 지원하는 커널들의 prior와 posterior를 살펴보겠습니다.</p></li></ul><h1 id="2-Kernels"><a href="#2-Kernels" class="headerlink" title="2. Kernels"></a>2. Kernels</h1><blockquote><p><a href="https://pasus.tistory.com/209">Deep Campus: 가우시안 프로세스의 개념</a><br><a href="https://towardsdatascience.com/understanding-gaussian-process-the-socratic-way-ba02369d804">towardsdatascience: Understanding Gaussian Process, the Socratic Way</a><br><a href="https://thegradient.pub/gaussian-process-not-quite-for-dummies/">The Gradient, Gaussian process not quite for dummies</a></p></blockquote><h2 id="2-1-커널의-정체"><a href="#2-1-커널의-정체" class="headerlink" title="2.1. 커널의 정체"></a>2.1. 커널의 정체</h2><ul><li><p>Gaussian Process의 커널은 covariance function입니다. </p></li><li><p>서로 다른 두 점 $x_i$와 $x_j$와의 상호 연관성을 나타냅니다.</p></li><li><p>이 함수를 커널 함수라고 하며, <b>Radial basis function</b>은 다음과 같이 정의됩니다.<br>$$k(x_i, x_j) = \exp\left(- \frac{d(x_i, x_j)^2}{2l^2} \right)$$</p></li><li><p>$x_i$와 $x_j$의 거리가 같아도 $l$이 크면 $k$가 큽니다: 먼 거리의 데이터까지 연관성을 가진다는 뜻입니다.</p></li><li><p>$x_i = x_j$ 일때 공분산은 최대값으로 1을 가집니다.</p></li><li><p>그렇다면 $x_i$과 $x_j$ 사이의 한 점은 두 점 모두와의 공분산을 최대한 높이는 방향으로 결정될텐데</p></li><li><p>Gaussian Process는 결정변수가 아니라 확률변수이므로 <b>확률</b>이 높을 뿐 조금씩 변합니다.</p></li><li><p>이로 인해 아무런 관찰값이 입력되지 않아도(prior) <b>RBF</b>의 sample 함수는 <b>랜덤하게 매끈한 곡선</b>을 이룹니다.</p></li></ul><ul><li>같은 이유로 참값으로 관측값이 지정되면(posterior) <b>관측값과 관측값 사이를 최대한 매끈하게 잇는 곡선의 존재 범위</b>가 도출됩니다.</li><li>그렇다면, <b>커널 함수가 바뀌면 예측값이 바뀔 것</b>이라는 것을 상상할 수 있으며</li><li><b>데이터의 성격에 맞는 커널 함수가 있음</b>을 예상할 수도 있습니다.</li><li>최적값을 얻는 방법으로 <b>MLE(Maximum Likelihood Estimation)</b>이 사용됩니다.</li><li><code>log_marginal_likelihood()</code> 메소드를 사용해 결과값을 추출할 수 있습니다.</li></ul><ul><li>커널 종류를 바꾸며 prior와 posterior를 관찰합니다.</li><li><b>커널을 입력받는 시각화 함수</b>를 아래와 같이 준비합니다.</li><li>코드가 길어 접어두었습니다.<details>  <summary><b>코드 보기/접기</b></summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">plt.rcParams[<span class="string">&#x27;mathtext.fontset&#x27;</span>] = <span class="string">&quot;cm&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_pp</span>(<span class="params">kernel, kernel_name=<span class="string">&quot;&quot;</span>, X_train=X_train, y_train=y_train, X_true=X, y_true=y, n_samples=<span class="number">5</span></span>):</span></span><br><span class="line">    gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, random_state=<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># prior</span></span><br><span class="line">    y_prior_mean, y_prior_std = gpr.predict(X_true, return_std=<span class="literal">True</span>)</span><br><span class="line">    y_prior_samples = gpr.sample_y(X_true, n_samples)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># posterior</span></span><br><span class="line">    gpr.fit(X_train, y_train)</span><br><span class="line">    y_posterior_mean, y_posterior_std = gpr.predict(X_true, return_std=<span class="literal">True</span>)</span><br><span class="line">    y_posterior_samples = gpr.sample_y(X_true, n_samples)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># kernel after fitting</span></span><br><span class="line">    kernel_ = gpr.kernel_</span><br><span class="line">    theta = gpr.kernel_.theta</span><br><span class="line">    ll = gpr.log_marginal_likelihood(theta)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># visualize</span></span><br><span class="line">    fig, axs = plt.subplots(nrows=<span class="number">2</span>, figsize=(<span class="number">6</span>, <span class="number">4</span>), sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>, constrained_layout=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> ax, y_mean, y_std, y_samples, title, k <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [y_prior_mean, y_posterior_mean], </span><br><span class="line">                                                           [y_prior_std, y_posterior_std], [y_prior_samples, y_posterior_samples],</span><br><span class="line">                                                           [<span class="string">&quot;prior&quot;</span>, <span class="string">&quot;posterior&quot;</span>], [kernel, kernel_]):</span><br><span class="line">        <span class="comment"># true</span></span><br><span class="line">        ax.plot(X_true, y_true, c=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">        ax.scatter(X_train, y_train, fc=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># pred</span></span><br><span class="line">        ax.plot(X_true.ravel(), y_mean, c=<span class="string">&quot;0.5&quot;</span>)</span><br><span class="line">        ax.fill_between(X_true.ravel(), y_mean-<span class="number">1.96</span>*y_std, y_mean+<span class="number">1.96</span>*y_std, alpha=<span class="number">0.5</span>, fc=<span class="string">&quot;lightgray&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># samples</span></span><br><span class="line">        <span class="keyword">for</span> y_sample <span class="keyword">in</span> y_samples.T:</span><br><span class="line">            ax.plot(X_true.ravel(), y_sample, lw=<span class="number">1</span>, ls=<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># title</span></span><br><span class="line">        ax.text(<span class="number">0.18</span>, <span class="number">0.97</span>, title, fontsize=<span class="string">&quot;large&quot;</span>, fontweight=<span class="string">&quot;bold&quot;</span>, color=<span class="string">&quot;b&quot;</span>, ha=<span class="string">&quot;right&quot;</span>, va=<span class="string">&quot;top&quot;</span>, transform=ax.transAxes)</span><br><span class="line">        str_k = <span class="built_in">str</span>(k).replace(<span class="string">&#x27; ** &#x27;</span>,<span class="string">&#x27;^&#x27;</span>).replace(<span class="string">&#x27;**&#x27;</span>,<span class="string">&#x27;^&#x27;</span>).replace(<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;\cdot&#x27;</span>).replace(<span class="string">&#x27;length_scale&#x27;</span>,<span class="string">&#x27;l&#x27;</span>).replace(<span class="string">&#x27;alpha&#x27;</span>,<span class="string">&#x27;\\alpha&#x27;</span>).replace(<span class="string">&#x27;periodicity&#x27;</span>, <span class="string">&#x27;p&#x27;</span>).replace(<span class="string">&#x27;sigma&#x27;</span>,<span class="string">&#x27;\\sigma&#x27;</span>).replace(<span class="string">&#x27;nu&#x27;</span>,<span class="string">&#x27;\\nu&#x27;</span>)</span><br><span class="line">        ax.text(<span class="number">0.2</span>, <span class="number">0.97</span>, <span class="string">&quot;kernel: &quot;</span> + <span class="string">f&quot;$<span class="subst">&#123;str_k&#125;</span>$&quot;</span>, ha=<span class="string">&quot;left&quot;</span>, va=<span class="string">&quot;top&quot;</span>, color=<span class="string">&quot;darkblue&quot;</span>, transform=ax.transAxes)</span><br><span class="line">        </span><br><span class="line">    axs[<span class="number">1</span>].text(<span class="number">0.105</span>, <span class="number">0.84</span>, <span class="string">&quot;Log-likelihood: &quot;</span> + <span class="string">f&quot;$&#123;&#123;<span class="subst">&#123;ll:<span class="number">.3</span>f&#125;</span>&#125;&#125;$&quot;</span>, ha=<span class="string">&quot;left&quot;</span>, va=<span class="string">&quot;top&quot;</span>, color=<span class="string">&quot;darkblue&quot;</span>, transform=axs[<span class="number">1</span>].transAxes)</span><br><span class="line">    str_theta = <span class="string">&quot;, &quot;</span>.join([<span class="string">f&quot;<span class="subst">&#123;t:<span class="number">.3</span>f&#125;</span>&quot;</span> <span class="keyword">for</span> t <span class="keyword">in</span> theta])</span><br><span class="line">    axs[<span class="number">1</span>].text(<span class="number">0.265</span>, <span class="number">0.71</span>, <span class="string">f&quot;$\\theta: (&#123;&#123;<span class="subst">&#123;str_theta&#125;</span>&#125;&#125;)$&quot;</span>, ha=<span class="string">&quot;left&quot;</span>, va=<span class="string">&quot;top&quot;</span>, color=<span class="string">&quot;darkblue&quot;</span>, transform=axs[<span class="number">1</span>].transAxes)</span><br><span class="line">    fig.suptitle(kernel_name, fontsize=<span class="string">&quot;x-large&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fig</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2-Radial-Basis-Function"><a href="#2-2-Radial-Basis-Function" class="headerlink" title="2.2. Radial Basis Function"></a>2.2. Radial Basis Function</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.RBF.html">scikit-learn: RBF Kernel</a></p></blockquote><ul><li>Gaussian Process의 가장 기본이 되는 커널입니다.</li><li>매끈한 곡선이 우리가 알고 있는 가장 기본적인 모양입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;Radial Basis Function&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_6.png"><br></li></ul><h2 id="2-2-White-Kernel"><a href="#2-2-White-Kernel" class="headerlink" title="2.2. White Kernel"></a>2.2. White Kernel</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.WhiteKernel.html">scikit-learn: White Kernel</a></p></blockquote><p>$$k(x_i, x_j) = noise \_ level \text{ if } x_i == x_j \text{ else } 0$$</p><ul><li>단독으로 사용되기보다 다른 커널에 더해져 노이즈 레벨을 측정하는데 활용됩니다.</li><li>아래 예제에서는 RBF와의 합으로 사용되었으며, posterior에서 noise level = $1.13 \times 10^{-8}$에 불과합니다.</li><li>prior의 noise level이 데이터를 만나 0에 가깝게 수렴한 것입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> WhiteKernel</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>)) + WhiteKernel(noise_level=<span class="number">1</span>, noise_level_bounds=(<span class="number">1e-8</span>, <span class="number">1e1</span>))</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;Radial Basis Function + White Noise&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_11.png"><br></li></ul><h2 id="2-3-Radial-Quadratic-Kernel"><a href="#2-3-Radial-Quadratic-Kernel" class="headerlink" title="2.3. Radial Quadratic Kernel"></a>2.3. Radial Quadratic Kernel</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.RationalQuadratic.html">scikit-learn: Rational Quadratic Kernel</a></p></blockquote><p>$$k(x_i, x_j) = \left(1 + \frac{d(x_i, x_j)^2 }{ 2\alpha  l^2}\right)^{-\alpha}$$</p><ul><li>RBF Kernel과 다른 거리 스케일링의 혼합 척도(scale mixture)로 볼 수 있습니다.</li><li>prior에서는 RBF 커널에 비해 곧게 펴진 듯한 모습이지만 posterior는 RBF와 잘 구분되지 않습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> RationalQuadratic</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1.0</span> * RationalQuadratic(length_scale=<span class="number">1.0</span>, alpha=<span class="number">0.1</span>, alpha_bounds=(<span class="number">1e-5</span>, <span class="number">1e15</span>))</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;Radial Quadratic Function&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_7.png"><br></li></ul><h2 id="2-4-Constant-Kernel"><a href="#2-4-Constant-Kernel" class="headerlink" title="2.4. Constant Kernel"></a>2.4. Constant Kernel</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.ConstantKernel.html">scikit-learn: Constant Kernel</a></p></blockquote><p>$$k(x_1, x_2) = constant\_value ;\forall; x_1, x_2$$</p><ul><li>글자 그대로 상수 커널입니다.</li><li>White Kernel과 유사하게 다른 커널과 함께 사용됩니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> ConstantKernel</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1.0</span> * ConstantKernel(constant_value=<span class="number">1.0</span>, constant_value_bounds=(<span class="number">1e-5</span>, <span class="number">1e15</span>))</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;Constant Kernel&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_15.png"><br></li></ul><h2 id="2-5-Exp-Sine-Squared-Kernel-periodic-kernel"><a href="#2-5-Exp-Sine-Squared-Kernel-periodic-kernel" class="headerlink" title="2.5. Exp-Sine-Squared Kernel (periodic kernel)"></a>2.5. Exp-Sine-Squared Kernel (periodic kernel)</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.ExpSineSquared.html">scikit-learn: ExpSineSquared</a></p></blockquote><p>$$k(x_i, x_j) = \text{exp}\left(-\frac{ 2\sin^2(\pi d(x_i, x_j)/p) }{ l^ 2} \right)$$</p><ul><li>지수함수에 sine함수의 제곱이 포함된 형태입니다.</li><li>주기성을 갖는 데이터를 묘사하기 좋으며 length scale $l &gt; 0$과 함께 periodicity $p &gt; 0$를 매개변수로 가집니다.</li><li>$p$는 Euclidean distance입니다.</li><li>prior와 posterior 모두 자세히 보면 주기성을 띄고 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> ExpSineSquared</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1.0</span> * ExpSineSquared(</span><br><span class="line">    length_scale=<span class="number">1.0</span>,</span><br><span class="line">    periodicity=<span class="number">3.0</span>,</span><br><span class="line">    length_scale_bounds=(<span class="number">0.1</span>, <span class="number">10.0</span>),</span><br><span class="line">    periodicity_bounds=(<span class="number">1.0</span>, <span class="number">10.0</span>),</span><br><span class="line">)</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;ExpSineSquared&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_8.png"><br></li></ul><h2 id="2-6-Dot-Product"><a href="#2-6-Dot-Product" class="headerlink" title="2.6. Dot Product"></a>2.6. Dot Product</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.DotProduct.html?highlight=dotproduct#sklearn.gaussian_process.kernels.DotProduct">scikit-learn: Dot Product</a></p></blockquote><p>$$k(x_i, x_j) = \sigma_0 ^ 2 + x_i \cdot x_j$$</p><ul><li><p>앞에서 본 커널들은 형태는 달라도 두 점 사이의 거리 $d(x_i, x_j)$를 주요 인자로 가집니다.</p></li><li><p>이런 커널을 <b>stationary kernel</b>이라고 합니다.</p></li><li><p>반면 $x_i$, $x_j$ 값 자체에 의해 좌우되는 커널을 <b>non-stationary kernel</b>이라고 합니다.</p></li><li><p>dot product로 정의되기 때문에 원점으로부터의 회전에는 무관하지만 transition에는 민감하게 반응합니다.</p></li><li><p>$\sigma_0 = 0$이라면 homogeneous linear kernel, $\sigma_0 \neq 0$이라면 inhomogeneous가 됩니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1st degree</span></span><br><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> DotProduct</span><br><span class="line"></span><br><span class="line">kernel = DotProduct(sigma_0=<span class="number">1.0</span>, sigma_0_bounds=(<span class="number">0.1</span>, <span class="number">100.0</span>))</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;DotProduct&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="122_gpr2_9.png"><br></p></li><li><p>제곱식을 통해 다항식을 만들 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3rd degree</span></span><br><span class="line">kernel = DotProduct(sigma_0=<span class="number">1.0</span>, sigma_0_bounds=(<span class="number">0.1</span>, <span class="number">100.0</span>))**<span class="number">3</span></span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;DotProduct&quot;</span>)</span><br><span class="line">fig.axes[<span class="number">1</span>].set_ylim(-<span class="number">25</span>, <span class="number">25</span>)</span><br></pre></td></tr></table></figure><p><img src="122_gpr2_16.png"><br></p></li></ul><h2 id="2-7-Matern-Kernel"><a href="#2-7-Matern-Kernel" class="headerlink" title="2.7. Matérn Kernel"></a>2.7. Matérn Kernel</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.Matern.html#sklearn.gaussian_process.kernels.Matern">scikit-learn: Matern</a></p></blockquote><p>$$k(x_i, x_j) =  \frac{1}{\Gamma(\nu)2^{\nu-1}}\Bigg(\frac{\sqrt{2\nu}}{l} d(x_i , x_j )\Bigg)^\nu K_\nu\Bigg(\frac{\sqrt{2\nu}}{l} d(x_i , x_j )\Bigg)$$</p><ul><li>RBF의 일반화된 버전입니다.</li><li>$\nu$로 결과 함수의 smoothness를 조절하는데 $\nu$가 $\infty$에 접근할수록 RBF에 가까워집니다.</li><li>위 식의 $K_{\nu}(\cdot)$는 modified Bessel function, $\Gamma(\cdot)$는 gamma function입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> Matern</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1.0</span> * Matern(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-1</span>, <span class="number">10.0</span>), nu=<span class="number">1.5</span>)</span><br><span class="line">fig = plot_pp(kernel, <span class="string">&quot;Matérn&quot;</span>)</span><br></pre></td></tr></table></figure><img src="122_gpr2_10.png"><br></li></ul><h2 id="3-결론"><a href="#3-결론" class="headerlink" title="3. 결론"></a>3. 결론</h2><ul><li>Gaussian Process는 임의의 적은 데이터로 멋진 결과물을 만들어내지만 Kernel function에 크게 좌우됩니다.</li><li>문제의 성격과 데이터의 특성에 맞는 적절한 Kernel 선택이 매우 중요합니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/gaussian-process/">gaussian process</category>
      
      <category domain="https://jehyunlee.github.io/tags/bayesian/">bayesian</category>
      
      <category domain="https://jehyunlee.github.io/tags/scikit-learn/">scikit-learn</category>
      
      
    </item>
    
    <item>
      <title>Gaussian Process Practice (1) 1D</title>
      <link>https://jehyunlee.github.io/2022/11/16/Python-DS-121-gpr1/</link>
      <guid>https://jehyunlee.github.io/2022/11/16/Python-DS-121-gpr1/</guid>
      <pubDate>Wed, 16 Nov 2022 12:38:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;Gaussian Process 연습입니다.&lt;/li&gt;
&lt;li&gt;scikit-learn을 비롯한 예제를 재구성하여 연습합니다.&lt;/li&gt;
&lt;li&gt;오차가 없을 때와 있을 때를 비교합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-Data-Prepa</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>Gaussian Process 연습입니다.</li><li>scikit-learn을 비롯한 예제를 재구성하여 연습합니다.</li><li>오차가 없을 때와 있을 때를 비교합니다.</li></ul><h1 id="1-Data-Preparation"><a href="#1-Data-Preparation" class="headerlink" title="1. Data Preparation"></a>1. Data Preparation</h1><blockquote><p><a href="https://scikit-learn.org/stable/auto_examples/gaussian_process/plot_gpr_noisy_targets.html#sphx-glr-auto-examples-gaussian-process-plot-gpr-noisy-targets-py">scikit-learn: Gaussian Process Regression: basic introductory example</a></p></blockquote><h2 id="1-1-example-data"><a href="#1-1-example-data" class="headerlink" title="1.1. example data"></a>1.1. example data</h2><ul><li><p>Gaussian Process 연습을 위한 데이터를 준비합니다.</p></li><li><p><a href="https://scikit-learn.org/stable/auto_examples/gaussian_process/plot_gpr_noisy_targets.html#sphx-glr-auto-examples-gaussian-process-plot-gpr-noisy-targets-py">scikit-learn의 예제</a>를 일부 변형합니다.</p></li><li><p>1000개로 이루어진 매끈한 곡선을 만듭니다. </p></li><li><p>이번 글에서는 랜덤 함수를 많이 사용합니다. <b>random number generator</b>를 정의해 재현성을 확보합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 라이브러리 및 random number generator</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">rng = np.random.RandomState(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># example data visualization</span></span><br><span class="line">X = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">1000</span>).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">y = np.squeeze(X*np.sin(X))</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">ax.plot(X, y)</span><br></pre></td></tr></table></figure><p><img src="121_gpr1_1.png"><br></p></li><li><p>지금 그린 그래프는 우리가 Gaussian Process로 찾아야 할 참값입니다.</p></li></ul><h2 id="1-2-6-training-points"><a href="#1-2-6-training-points" class="headerlink" title="1.2. 6 training points"></a>1.2. 6 training points</h2><ul><li>임의의 x 좌표 6개를 골라 예제 데이터를 뽑습니다. <b>측정값(evidence)</b>이라 볼 수 있습니다.</li><li>두 가지 상황을 가정해 이 지점들로 참값 곡선을 찾아갈 것입니다.</li><li><b>① 측정을 하면 정확한 값을 찾아내는 경우:</b> 딱 6개만 뽑으면 됩니다.</li><li><b>② 측정이 불확실성을 안고 있는 경우: </b> x 하나당 10번씩 측정했다고 하겠습니다. 표준 편차 = 1입니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">training_indices = rng.choice(np.arange(y.size), size=<span class="number">6</span>, replace=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ① exact observation</span></span><br><span class="line">X_train = X[training_indices]</span><br><span class="line">y_train = y[training_indices]</span><br><span class="line"></span><br><span class="line"><span class="comment"># ② noisy situation</span></span><br><span class="line">noise_std = <span class="number">1</span></span><br><span class="line">X_train_noisy = np.array(X[training_indices].tolist()*<span class="number">10</span>)</span><br><span class="line">y_train_noisy = np.array(<span class="built_in">list</span>(y[training_indices])*<span class="number">10</span>) + rng.normal(<span class="number">0</span>, noise_std, size=y_train.shape[<span class="number">0</span>]*<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">ax.plot(X, y, c=<span class="string">&quot;lightgray&quot;</span>, label=<span class="string">&quot;true&quot;</span>)</span><br><span class="line">ax.scatter(X_train, y_train, label=<span class="string">&quot;sample without noise&quot;</span>)</span><br><span class="line">ax.scatter(X_train_noisy, y_train_noisy, label=<span class="string">&quot;sample with noise&quot;</span>, s=<span class="number">5</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">ax.legend()</span><br></pre></td></tr></table></figure><img src="121_gpr1_2.png"><br></li></ul><h1 id="2-Gaussian-Process"><a href="#2-Gaussian-Process" class="headerlink" title="2. Gaussian Process"></a>2. Gaussian Process</h1><h2 id="2-1-Without-Noise"><a href="#2-1-Without-Noise" class="headerlink" title="2.1. Without Noise"></a>2.1. Without Noise</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.RBF.html">scikit-learn: Radial basis function kernel</a><br><a href="https://thegradient.pub/gaussian-process-not-quite-for-dummies/">The Gradient: Gaussian Process, not quite for dummies</a></p></blockquote><ul><li><p>evidence가 참값인 경우의 Gaussian Process를 실행합니다.</p></li><li><p>커널에는 Radial Bassis Function 커널을 사용합니다.</p></li><li><p>length_scale 초기값은 1, 범위는 0.01부터 100 안에서 fitting합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.gaussian_process <span class="keyword">import</span> GaussianProcessRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.gaussian_process.kernels <span class="keyword">import</span> RBF</span><br><span class="line"></span><br><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>)</span><br><span class="line">gpr.fit(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(gpr.kernel_)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5.02**2 * RBF(length_scale=1.43)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>fitting 결과 1로 지정했던 계수와 <code>length_scale</code>이 변경되었습니다.</p></li><li><p>계수는 신뢰구간의 폭, <code>length_scale</code>은 곡선의 매끈함(smoothness)에 해당합니다.<br><br><img src="121_gpr1_10.png" alt="The Gradient"><br><br><img src="121_gpr1_11.png" alt="The Gradient"><br></p></li><li><p>다음 명령으로 추가 정보를 얻을 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpr.kernel_.theta</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([3.22768806, 0.36021977])</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>gpr.kernel_theta</code>는 <code>(flattened, log-transformed) non-fixed hyperparameters</code>입니다.</p></li><li><p>전체 X를 넣고 Gaussian Process 결과를 그림으로 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prediction</span></span><br><span class="line">y_pred_mean, y_pred_std = gpr.predict(X, return_std=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="121_gpr1_3.png"><br></p></li><li><p>확대를 해도 측정값은 신뢰구간의 폭이 0임을 확인할 수 있습니다.</p></li><li><p>측정된 데이터를 참값으로 가정했으므로 측정값의 분산은 0입니다.</p></li></ul><h2 id="2-2-With-Noise"><a href="#2-2-With-Noise" class="headerlink" title="2.2. With Noise"></a>2.2. With Noise</h2><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.GaussianProcessRegressor.html#sklearn.gaussian_process.GaussianProcessRegressor">scikit-learn: GaussianProcessRegressor</a></p></blockquote><ul><li>이번에는 측정 데이터에 오차가 포함된 경우를 살펴봅니다.</li><li>오차가 있는 데이터는 <code>GaussianProcessRegressor()</code>에 측정 오차를 의미하는 매개변수 <code>alpha</code>를 추가해야 합니다.</li><li>수식에서는 커널 행렬의 대각 요소에 추가되는 값으로 fitting시 발생하는 numerical issue를 예방합니다. </li></ul><h3 id="2-2-1-오차-데이터-직접-입력"><a href="#2-2-1-오차-데이터-직접-입력" class="headerlink" title="2.2.1. 오차 데이터 직접 입력"></a>2.2.1. 오차 데이터 직접 입력</h3><ul><li><p>아까와 동일하게 Gaussian Process fitting을 수행합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">gpr.fit(X_train_noisy, y_train_noisy)</span><br><span class="line"><span class="built_in">print</span>(gpr.kernel_)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.92**2 * RBF(length_scale=1.37)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>아까와는 다른 값으로 수렴했습니다.</p></li><li><p>다시 전체 X를 넣고 예측 결과를 확인합니다.</p></li><li><p>참값은 입력하지 않았지만 대조를 위해 함께 도시합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prediction</span></span><br><span class="line">y_pred_mean, y_pred_std = gpr.predict(X, return_std=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="121_gpr1_4.png"><br></p></li><li><p>데이터를 확보한 곳에서도 불확실성에 의해 신뢰구간이 한 점으로 수렴하지 않습니다.</p></li><li><p>아울러 전체의 평균값도 참값에서 조금씩 어긋나 있음을 확인할 수 있습니다.</p></li></ul><h3 id="2-2-2-오차-분산-입력"><a href="#2-2-2-오차-분산-입력" class="headerlink" title="2.2.2. 오차 분산 입력"></a>2.2.2. 오차 분산 입력</h3><ul><li>이번에는 모든 데이터를 입력하는 대신 <b>참값</b>데이터와 함께 <b>분산</b>을 입력합니다.</li><li>앞서 noise를 만들 때 표준 편차 = 1을 입력했는데 정말 그런지 확인합니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df_noisy = pd.DataFrame(&#123;<span class="string">&quot;X_noisy&quot;</span>:X_train_noisy.ravel(), <span class="string">&quot;y_noisy&quot;</span>:y_train_noisy&#125;)</span><br><span class="line">dfg_noisy = df_noisy.groupby(<span class="string">&quot;X_noisy&quot;</span>).std()</span><br><span class="line">std = dfg_noisy.mean().values[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(std)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.0616168585081918</span><br></pre></td></tr></table></figure></li></ul></li><li>의도한 바와 같이 데이터의 평균 분산은 1과 유사한 값으로 나왔습니다.</li><li>애초에 의도한 값 1을 제곱하여 <code>alpha</code>에 입력하고 Gaussian Process를 진행합니다.</li><li>계수가 아까보다 작게 나왔습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, alpha=<span class="number">1</span>**<span class="number">2</span>)</span><br><span class="line">gpr.fit(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(gpr.kernel_)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.39**2 * RBF(length_scale=1.16)</span><br></pre></td></tr></table></figure></li></ul></li><li>같은 코드로 그림을 그려 확인합니다.</li><li>줄어든 계수가 무색하게 전체적으로 신뢰구간이 더 넓은 듯한 느낌입니다.<br><img src="121_gpr1_5.png"><br></li></ul><h3 id="2-2-3-alpha가-같을-때-데이터-수에-따른-비교"><a href="#2-2-3-alpha가-같을-때-데이터-수에-따른-비교" class="headerlink" title="2.2.3. alpha가 같을 때 데이터 수에 따른 비교"></a>2.2.3. alpha가 같을 때 데이터 수에 따른 비교</h3><ul><li><p>noisy data를 직접 입력했을 때와 모양이 달라진 것이 데이터에 무관한, alpha에 따른 차이가 아닐까 의구심이 듭니다.</p></li><li><p><code>alpha=1</code>로 설정하고 noisy data로 학습시킨 후 양상을 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br><span class="line">gpr = GaussianProcessRegressor(kernel, n_restarts_optimizer=<span class="number">9</span>, alpha=<span class="number">1</span>)</span><br><span class="line">gpr.fit(X_train_noisy, y_train_noisy)</span><br><span class="line"><span class="built_in">print</span>(gpr.kernel_)</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.84**2 * RBF(length_scale=1.34)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>값이 조금 다르기는 하지만 noisy data를 입력했을 때에 가깝습니다.</p></li><li><p>그래프 모양을 보면 더 확연하게 드러납니다.<br><img src="121_gpr1_8.png"><br></p></li></ul><h3 id="2-2-4-커널-parameter-범위에-따른-결과"><a href="#2-2-4-커널-parameter-범위에-따른-결과" class="headerlink" title="2.2.4. 커널 parameter 범위에 따른 결과"></a>2.2.4. 커널 parameter 범위에 따른 결과</h3><ul><li><p>앞서 kernel을 다음과 같이 정의했습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">1.0</span>, length_scale_bounds=(<span class="number">1e-2</span>, <span class="number">1e2</span>))</span><br></pre></td></tr></table></figure></li><li><p>RBF kernel의 length scale이 가질 수 있는 범위를 0.01 ~ 100으로 지정한 것입니다.</p></li><li><p>그리고 결과적으로 입력된 데이터에 의해 <code>length scale = 1.16</code>로 결정되었습니다.</p></li><li><p>그런데 초기값의 범위가 이 밖에 있으면 전혀 다른 결과가 얻어집니다.</p></li><li><p>먼저, length scale이 너무 클 때입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">100</span>, length_scale_bounds=(<span class="number">10</span>, <span class="number">1e3</span>))</span><br></pre></td></tr></table></figure></li><li><p>초기값을 100, 범위를 10~1000으로 잡으면 결과적으로 <code>316**2 * RBF(length_scale=10)</code>에 수렴합니다.</p></li><li><p>이 때 결과는 다음과 같습니다.</p></li><li><p>지나친 과소적합(underfitting)으로 인해 x=0 부근에서 참값을 따라가지 못하고 평균값이 40 가까이 발산해 버렸습니다.<br><img src="121_gpr1_6.png"><br></p></li></ul><ul><li><p>이번에는 거꾸로 kernel의 length_scale이 너무 작은 경우입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="number">1</span>*RBF(length_scale=<span class="number">0.01</span>, length_scale_bounds=(<span class="number">1e-4</span>, <span class="number">1e-1</span>))</span><br></pre></td></tr></table></figure></li><li><p>학습 결과 kernel이 <code>4.16**2 * RBF(length_scale=0.01)</code>로, length scale이 입력된 범위의 최대값에 닿았습니다.</p></li><li><p>결과적으로 과대적합(overfitting)이라고 불러야 할지 애매하지만 측정값 외에는 미동도 하지 않았습니다.<br><img src="121_gpr1_7.png"><br></p></li></ul><h1 id="3-결론"><a href="#3-결론" class="headerlink" title="3. 결론"></a>3. 결론</h1><ul><li>Gaussian Process는 적은 데이터로 오차를 포함한 결과를 효과적으로 추론합니다.</li><li>그러나 커널의 제약에 민감하기 때문에 주의깊게 살펴볼 필요가 있습니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/gaussian-process/">gaussian process</category>
      
      <category domain="https://jehyunlee.github.io/tags/bayesian/">bayesian</category>
      
      <category domain="https://jehyunlee.github.io/tags/scikit-learn/">scikit-learn</category>
      
      
    </item>
    
    <item>
      <title>딥러닝 공개 모델 활용 정보 수집 효율화</title>
      <link>https://jehyunlee.github.io/2022/11/11/Python-DS-120-eost2022/</link>
      <guid>https://jehyunlee.github.io/2022/11/11/Python-DS-120-eost2022/</guid>
      <pubDate>Fri, 11 Nov 2022 13:13:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;&lt;a href=&quot;https://www.etri.re.kr/&quot;&gt;한국전자통신연구원&lt;/a&gt;&lt;/b&gt; 오픈소스센터가 주축이 되어 &lt;b&gt;ETRI Open Source Tech Day&lt;/b&gt;가 열렸습니다.&lt;ul&gt;
&lt;li&gt;과학기술정보통신부가 주</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b><a href="https://www.etri.re.kr/">한국전자통신연구원</a></b> 오픈소스센터가 주축이 되어 <b>ETRI Open Source Tech Day</b>가 열렸습니다.<ul><li>과학기술정보통신부가 주최하고</li><li>한국전자통신연구원, 한국과학기술정보연구원, 한국식품연구원, 한국에너지기술연구원, 한국원자력연구원, 한국화학연구원, 한국항공우주연구원이 공동 주관했습니다.<br></li></ul></li></ul><ul><li>2021년 <b><a href="https://www.youtube.com/watch?v=X3FjEzfHsyc">내가 해온 연구에 데이터 분석 끼얹기</a></b>라는 제목으로 온라인 발표를 했고,</li><li>올해는 오프라인으로 <b>딥러닝 공개 모델 활용 정보 수집 효율화</b> 발표를 진행했습니다.<ul><li>저희 연구원 글로벌전략실과 협업을 진행하는 내용을 공개했습니다.</li><li>해외 연구원과 효과적인 협업을 위해 현황과 양측의 상대적 장단점을 파악했습니다.<br></li></ul></li></ul><ul><li>발표 영상 : <a href="https://youtu.be/epOab26Zsas">Youtube Link</a><br><p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/epOab26Zsas" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><img src="kier.PNG"><br><br></p><ul><li>행사 홈페이지: <a href="https://eostday.kr/">https://eostday.kr/</a><br><br><img src="EOST2022-EDM-v1.3.jpg" alt="EOST2022 일정표"></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/EOST/">EOST</category>
      
      <category domain="https://jehyunlee.github.io/tags/natural-language-processing/">natural language processing</category>
      
      <category domain="https://jehyunlee.github.io/tags/ETRI/">ETRI</category>
      
      
    </item>
    
    <item>
      <title>gaussian process</title>
      <link>https://jehyunlee.github.io/2022/11/04/Python-DS-119-kierlecture7/</link>
      <guid>https://jehyunlee.github.io/2022/11/04/Python-DS-119-kierlecture7/</guid>
      <pubDate>Fri, 04 Nov 2022 07:18:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;b&gt;한국에너지기술연구원 AI 학습조직&lt;/b&gt;에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.&lt;ul&gt;
&lt;li&gt;실험을 계획하고 최적 실험 조건을 탐색하는 방법들을 살펴봅니다.&lt;/li&gt;
&lt;li&gt;전통적인 실험계획법(design of</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><b>한국에너지기술연구원 AI 학습조직</b>에서는 2022년 한 해동안 머신러닝을 공부하고 있습니다.<ul><li>실험을 계획하고 최적 실험 조건을 탐색하는 방법들을 살펴봅니다.</li><li>전통적인 실험계획법(design of experiment), 반응표면법(response surface method)을 살펴보고,</li><li>효과적인 실험 설계를 도와주는 Gaussian Process와 이 바탕에 깔린 베이즈 법칙(Bayes’ Rule)을 살펴봅니다.</li><li><a href="221104_%EC%9D%B4%EC%A0%9C%ED%98%84_8%EC%B0%A8%EB%AA%A8%EC%9E%84_GaussianProcess.pdf">강의 자료는 여기에서 다운받으실 수 있습니다</a></li></ul></li></ul><ul><li><p>발표 영상 : (<a href="https://youtu.be/9vIPzpzfw-o">Youtube Link</a>)<br></p></li><li><p>실습 코드 : (<a href="https://bit.ly/3NvEwIO">https://bit.ly/3NvEwIO</a>)<br></p></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/9vIPzpzfw-o" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><img src="gp.gif"><br></p><p><ul><li>바쁜 연구원 일정 속에 변동이 있겠지만, 최대한 일정을 지켜보고자 합니다.</li></ul><p><img src="schedule.png" alt="학습조직 일정"></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/presentation/">presentation</category>
      
      <category domain="https://jehyunlee.github.io/tags/machine-learning/">machine learning</category>
      
      <category domain="https://jehyunlee.github.io/tags/KIER/">KIER</category>
      
      <category domain="https://jehyunlee.github.io/tags/gaussian-process/">gaussian process</category>
      
      <category domain="https://jehyunlee.github.io/tags/bayesian/">bayesian</category>
      
      <category domain="https://jehyunlee.github.io/tags/design-of-experiment/">design of experiment</category>
      
      <category domain="https://jehyunlee.github.io/tags/response-surface-method/">response surface method</category>
      
      
    </item>
    
    <item>
      <title>Auto Contrast on SEM image</title>
      <link>https://jehyunlee.github.io/2022/10/29/Python-DS-118-autocontrast/</link>
      <guid>https://jehyunlee.github.io/2022/10/29/Python-DS-118-autocontrast/</guid>
      <pubDate>Fri, 28 Oct 2022 19:58:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;영상 촬영을 하다 보면 결과물이 마음에 들지 않는 여러 이유가 있습니다.&lt;/li&gt;
&lt;li&gt;애초에 잘 찍으면 되겠지만 장비나 숙련도 등의 문제로 한계가 있습니다.&lt;/li&gt;
&lt;li&gt;전자현미경 사진은 여기에 시료의 상태까지 한 몫 합니다.&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>영상 촬영을 하다 보면 결과물이 마음에 들지 않는 여러 이유가 있습니다.</li><li>애초에 잘 찍으면 되겠지만 장비나 숙련도 등의 문제로 한계가 있습니다.</li><li>전자현미경 사진은 여기에 시료의 상태까지 한 몫 합니다.</li><li>방해 요소를 제외하고 자동 명도 및 대비 보정을 하는 방법을 알아봅니다.</li></ul><h1 id="1-예제-이미지"><a href="#1-예제-이미지" class="headerlink" title="1. 예제 이미지"></a>1. 예제 이미지</h1><p><img src="118_autocontrast_0.png"><br></p><ul><li>위와 같은 전자현미경 사진을 얻었다고 합시다.</li><li>전자현미경은 빛 대신 전자빔을 쏘아 매우 작은 시료를 찍는 도구입니다.</li><li>전자빔을 충분히 강하게 쬐면 밝고 좋은 영상을 얻을 수 있지만 시료에 따라 망가지기도 합니다.</li></ul><h1 id="2-ImageJ-사용-보정"><a href="#2-ImageJ-사용-보정" class="headerlink" title="2. ImageJ 사용 보정"></a>2. ImageJ 사용 보정</h1><blockquote><p><a href="https://imagej.net/">ImageJ</a></p></blockquote><ul><li><p>이미지 보정 프로그램에서 대비를 높일 수 있습니다.</p></li><li><p><a href="https://imagej.net/software/fiji/">ImageJ Fiji</a>를 사용해 개선을 시도합니다.</p></li><li><p><b>File &gt; Open</b>으로 파일을 불러온 후 <b>Image &gt; Adjust &gt; Bright &amp; Contrast</b>를 실행합니다.<br><br><img src="118_autocontrast_1.png"><br></p></li><li><p><b>B&amp;C</b>라는 이름의 작은 창에 이미지를 구성하는 픽셀들의 히스토그램이 보입니다.</p></li><li><p><b>Auto</b>를 두 번 누르면 아래와 같이 밝아지지만 대비가 개선되지 않습니다.<br><br><img src="118_autocontrast_2.png"><br></p></li><li><p>이미지 하단에 촬영 조건과 스케일바가 검정과 흰색 부분으로 붙어 있어 이 부분이 걸림돌이 됩니다.</p></li><li><p>이미지를 구성하는 음영 중 최대값(white)와 최소값(black)이 정해져 있는 바람에 가운데 몰린 분포가 개선되지 않는 것입니다.</p></li><li><p>하단을 잘라내고 재시도합니다. 메뉴 바 왼쪽의 사각형을 골라 이미지 부분만 선택합니다.<br><br><img src="118_autocontrast_3.png"><br></p></li><li><p><b>Image &gt; Crop</b>을 실행하면 아래처럼 하단이 사라집니다.<br><br><img src="118_autocontrast_4.png"><br></p></li><li><p>다시 <b>Image &gt; Adjust &gt; Bright &amp; Contrast</b>에서 Auto를 실행하면 비로소 선명해집니다.<br><br><img src="118_autocontrast_5.png"><br></p></li><li><p>하지만 스케일 바를 비롯한 중요 정보를 잃어버린 상태입니다.</p></li><li><p>논문에 싣거나 내부 발표라도 하려면 스케일 바를 다시 붙여야 합니다.</p></li><li><p>몹시 귀찮아지고, 잘 하더라도 실수가 생길 수 있습니다.</p></li><li><p>무엇보다 대개 이런 이미지는 한 두 장으로 끝나지 않습니다. 자동화가 필요합니다.</p></li></ul><h1 id="3-scikit-image-사용-보정"><a href="#3-scikit-image-사용-보정" class="headerlink" title="3. scikit-image 사용 보정"></a>3. <code>scikit-image</code> 사용 보정</h1><blockquote><p><a href="https://scikit-image.org/">scikit-image</a></p></blockquote><h2 id="3-1-scikit-image-설치"><a href="#3-1-scikit-image-설치" class="headerlink" title="3.1. scikit-image 설치"></a>3.1. <code>scikit-image</code> 설치</h2><ul><li>파이썬에는 이미지 처리 라이브러리가 여럿 있습니다.</li><li>오늘은 <a href="https://scikit-image.org/">scikit-image</a>를 사용해 작업합니다.</li><li><code>pip</code>를 사용해 설치할 수 있습니다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!pip install scikit-image -U</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-2-이미지-불러오기"><a href="#3-2-이미지-불러오기" class="headerlink" title="3.2. 이미지 불러오기"></a>3.2. 이미지 불러오기</h2><ul><li><p><code>skimage.io</code>의 <code>imread</code> 모듈을 사용해 이미지를 읽고 <code>imshow</code>로 출력합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage.io <span class="keyword">import</span> imread, imshow</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">infilename = <span class="string">&quot;sample.jpg&quot;</span></span><br><span class="line"></span><br><span class="line">img_ = imread(infilename)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(img_))</span><br><span class="line">imshow(img_)</span><br></pre></td></tr></table></figure><p><img src="118_autocontrast_6.png"><br></p></li><li><p><code>imread</code>로 읽은 이미지의 정체는 <code>numpy.ndarray</code>입니다.</p></li><li><p>출력된 이미지의 정체는 사실 <code>matplotlib.image.AxesImage</code>입니다.</p></li><li><p><code>scikit-image</code> 내부에서 <code>matplotlib</code>을 호출하는 것입니다.</p></li><li><p><code>imshow(img_)</code> 대신 <code>plt.imshow(img_, cmap=&quot;Greys_r&quot;)</code>를 실행해도 같은 결과를 얻을 수 있습니다.</p></li></ul><h2 id="3-3-이미지-및-하단-영역-크기-분리"><a href="#3-3-이미지-및-하단-영역-크기-분리" class="headerlink" title="3.3. 이미지 및 하단 영역 크기 분리"></a>3.3. 이미지 및 하단 영역 크기 분리</h2><ul><li><p>이미지 크기는 <code>.shape</code>을 출력해 확인할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_.shape</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(480, 640)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>이제 하단 영역의 높이를 알아볼 차례입니다.</p></li><li><p>x = 300 지점에서 세로로 나열된 픽셀들의 line profile을 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">0</span>].imshow(img_, cmap=<span class="string">&quot;Greys_r&quot;</span>)   <span class="comment"># 왼쪽 Axes에 Image 출력</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># x = 300을 추출해서 오른쪽 Axes에 line profile 출력, 왼쪽에 선 표시</span></span><br><span class="line">x = <span class="number">300</span></span><br><span class="line">axs[<span class="number">1</span>].plot(img_[:, x], c=<span class="string">&quot;orange&quot;</span>)   <span class="comment"># 오른쪽 Axes에 line profile 출력</span></span><br><span class="line">axs[<span class="number">0</span>].axvline(x, c=<span class="string">&quot;orange&quot;</span>)         <span class="comment"># 왼쪽 image 위에 해당 line 출력   </span></span><br></pre></td></tr></table></figure><p><img src="118_autocontrast_7.png"><br></p></li><li><p>450 부근부터의 데이터 값이 모두 0입니다. </p></li><li><p>여기가 하단 메타데이터 영역입니다.</p></li><li><p>말단 50개 데이터를 출력해 0을 세어 보면 0이 31개 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_[-<span class="number">50</span>:, x]</span><br></pre></td></tr></table></figure><ul><li>실행 결과<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array([118, 112, 115, 113, 111, 122, 122, 118, 111, 114, 111, 116, 122,</span><br><span class="line">      120, 120, 123, 124, 101,  25,   0,   0,   0,   0,   0,   0,   0,</span><br><span class="line">      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,</span><br><span class="line">      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0], dtype=uint8)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>480행 중 31행이면 16분의 1을 조금 넘습니다.</p></li><li><p>여유 있게 하단 15분의 1을 잘라내고 위쪽을 <code>img</code>, 아래쪽을 <code>desc</code>(description)라고 부릅니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">h, w = img_.shape</span><br><span class="line"></span><br><span class="line">imgfrac = <span class="number">14</span>/<span class="number">15</span></span><br><span class="line">img = img_[:<span class="built_in">int</span>(h*imgfrac), :]</span><br><span class="line">desc = img_[<span class="built_in">int</span>(h*imgfrac):, :]</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line">axs[<span class="number">0</span>].imshow(img, cmap=<span class="string">&quot;Greys_r&quot;</span>)</span><br><span class="line">axs[<span class="number">1</span>].imshow(desc, cmap=<span class="string">&quot;Greys_r&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig.savefig(<span class="string">&quot;118_autocontrast_8.png&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="118_autocontrast_8.png"><br></p></li><li><p>잘라낸 것만으로 왼쪽 그림이 선명해졌습니다.</p></li><li><p>Matplotlib이 그림을 보여주면서 데이터의 최소값과 최대값을 자동으로 적용했기 때문입니다.</p></li><li><p>원본 <code>img_</code>와 하단을 잘라낸 <code>img</code>의 데이터 분포를 확인합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>,</span><br><span class="line">                       sharex=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, im, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [img_, img], [<span class="string">&quot;original&quot;</span>, <span class="string">&quot;image only&quot;</span>]):</span><br><span class="line">    ax.hist(im.flatten(), bins=np.linspace(<span class="number">0</span>, <span class="number">255</span>, <span class="number">30</span>))</span><br><span class="line">    ax.text(<span class="number">0.7</span>, <span class="number">0.95</span>, <span class="string">f&quot;min = <span class="subst">&#123;im.<span class="built_in">min</span>()&#125;</span>\nmax = <span class="subst">&#123;im.<span class="built_in">max</span>()&#125;</span>&quot;</span>, va=<span class="string">&quot;top&quot;</span>,</span><br><span class="line">           fontsize=<span class="string">&quot;x-large&quot;</span>, transform=ax.transAxes)</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;x-large&quot;</span>, pad=<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p><img src="118_autocontrast_9.png"><br></p></li><li><p>원본이 0<del>252까지 범위를 가지는 데 비해 이미지 영역만 따지면 75</del>187에 분포하고 있습니다.</p></li></ul><h2 id="3-4-이미지-영역에-auto-contrast-적용"><a href="#3-4-이미지-영역에-auto-contrast-적용" class="headerlink" title="3.4. 이미지 영역에 auto contrast 적용"></a>3.4. 이미지 영역에 auto contrast 적용</h2><blockquote><p><a href="https://en.wikipedia.org/wiki/Salt-and-pepper_noise">wikipedia: salt and pepper noise</a></p></blockquote><ul><li><p>이미지의 최대값과 최소값을 0~255로 폅니다.</p></li><li><p>그 전에, 전자현미경 같은 디지털 영상에 흔한 <b>salt and pepper noise</b> 대응책을 마련합니다.</p></li><li><p><a href="https://en.wikipedia.org/wiki/Salt-and-pepper_noise">salt and pepper noise</a>는 영상 위에 희고 검은 점이 흩뿌려지는 현상입니다.</p></li><li><p>전기 신호가 불안정하거나 원본의 대비가 잡음보다 약할 때 주로 생깁니다.<br><br><img src="118_autocontrast_10.png" alt="wikipedia: salt and pepper noise"><br></p></li><li><p><code>numpy.percentile()</code>로 전체 데이터의 상하위 0.2%씩을 제거한 뒤,</p></li><li><p><code>skimage.exposure.rescale_intensity()</code>를 사용해 0부터 255까지 데이터의 범위를 늘려줍니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> exposure</span><br><span class="line"></span><br><span class="line"><span class="comment"># salt and pepper noise 제거</span></span><br><span class="line">v_min, v_max = np.percentile(img, (<span class="number">0.2</span>, <span class="number">99.8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># auto contrast 적용</span></span><br><span class="line">img_ac = exposure.rescale_intensity(img, in_range=(v_min, v_max), out_range=(<span class="number">0</span>, <span class="number">255</span>)).astype(np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 전후 비교</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, im, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [img, img_ac], [<span class="string">&quot;original&quot;</span>, <span class="string">&quot;auto contrast&quot;</span>]):</span><br><span class="line">    ax.imshow(im, cmap=<span class="string">&quot;Greys_r&quot;</span>, vmin=<span class="number">0</span>, vmax=<span class="number">255</span>)</span><br><span class="line">    x_pos = <span class="number">0.045</span></span><br><span class="line">    <span class="keyword">if</span> ax == axs[<span class="number">1</span>]:</span><br><span class="line">        x_pos += <span class="number">0.5</span></span><br><span class="line">    ax_inset = fig.add_axes([x_pos, <span class="number">0.69</span>, <span class="number">0.15</span>, <span class="number">0.2</span>])</span><br><span class="line">    ax_inset.hist(im.flatten(), fc=<span class="string">&quot;orange&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, bins=np.linspace(<span class="number">0</span>, <span class="number">255</span>, <span class="number">30</span>))</span><br><span class="line">    ax_inset.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">255</span>), yticks=[], xticks=[])</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;x-large&quot;</span>, pad=<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p><img src="118_autocontrast_11.png"><br></p></li></ul><h2 id="3-4-하단-영역-결합"><a href="#3-4-하단-영역-결합" class="headerlink" title="3.4. 하단 영역 결합"></a>3.4. 하단 영역 결합</h2><ul><li>이제 처음에 분리해 둔 하단 영역을 결합할 차례입니다.</li><li><code>numpy.vstack()</code>을 사용합니다.</li><li>파일 저장은 <code>skimage.io</code>의 <code>imsave</code>로 실행합니다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage.io <span class="keyword">import</span> imsave</span><br><span class="line"></span><br><span class="line">img_merge = np.vstack((img_ac, desc))</span><br><span class="line">imsave(<span class="string">&quot;img_autocontrast.png&quot;</span>, img_merge)</span><br></pre></td></tr></table></figure><p><img src="img_autocontrast.png"><br></p><ul><li>스케일바를 비롯한 정보가 돌아왔습니다.</li></ul><h1 id="4-주의-사항"><a href="#4-주의-사항" class="headerlink" title="4. 주의 사항"></a>4. 주의 사항</h1><ul><li><p>분석을 열심히 하다 보면 크기를 재거나 중요 지점을 표시할 때가 있습니다.<br><br><img src="sample_annot.png"><br></p></li><li><p>여기에 위 코드를 동일하게 적용합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">infilename = <span class="string">&quot;sample_annot.png&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># read image</span></span><br><span class="line">img_ = imread(infilename)</span><br><span class="line"></span><br><span class="line"><span class="comment"># image split: img + desc</span></span><br><span class="line">imgfrac = <span class="number">14</span>/<span class="number">15</span></span><br><span class="line">img = img_[:<span class="built_in">int</span>(h*imgfrac), :]</span><br><span class="line">desc = img_[<span class="built_in">int</span>(h*imgfrac):, :]</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove salt and pepper noise</span></span><br><span class="line">v_min, v_max = np.percentile(img, (<span class="number">0.2</span>, <span class="number">99.8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># apply auto contrast</span></span><br><span class="line">img_ac = exposure.rescale_intensity(img, in_range=(v_min, v_max), out_range=(<span class="number">0</span>, <span class="number">255</span>)).astype(np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># merge images</span></span><br><span class="line">img_merge = np.vstack((img_ac, desc))</span><br><span class="line"></span><br><span class="line"><span class="comment"># save file</span></span><br><span class="line">imsave(<span class="string">&quot;annot_autocontrast.png&quot;</span>, img_merge)</span><br></pre></td></tr></table></figure></li><li><p>그리고 결과를 확인해 보면 대비 보정이 적용되지 않았습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fig, axs = plt.subplots(ncols=<span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">4</span>), constrained_layout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, im, title <span class="keyword">in</span> <span class="built_in">zip</span>(axs, [img_, img_merge], [<span class="string">&quot;original&quot;</span>, <span class="string">&quot;auto contrast&quot;</span>]):</span><br><span class="line">    ax.imshow(im, cmap=<span class="string">&quot;Greys_r&quot;</span>, vmin=<span class="number">0</span>, vmax=<span class="number">255</span>)</span><br><span class="line">    x_pos = <span class="number">0.045</span></span><br><span class="line">    <span class="keyword">if</span> ax == axs[<span class="number">1</span>]:</span><br><span class="line">        x_pos += <span class="number">0.5</span></span><br><span class="line">    ax_inset = fig.add_axes([x_pos, <span class="number">0.69</span>, <span class="number">0.15</span>, <span class="number">0.2</span>])</span><br><span class="line">    ax_inset.hist(im.flatten(), fc=<span class="string">&quot;orange&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, bins=np.linspace(<span class="number">0</span>, <span class="number">255</span>, <span class="number">30</span>))</span><br><span class="line">    ax_inset.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">255</span>), yticks=[], xticks=[])</span><br><span class="line">    ax.set_title(title, fontsize=<span class="string">&quot;x-large&quot;</span>, pad=<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p><img src="118_autocontrast_12.png"><br></p></li><li><p><b>이미지 영역에 추가한 표지가 문제</b>가 되는 경우입니다.</p></li><li><p>salt and pepper noise를 제거하기 위해 상하위 0.2%만 제거했는데, 이 그림에는 <b>하양과 검정으로 표현된 화살표와 글자들이 0.2%를 넘어섰기 때문에 제거되지 않고 명도의 최대값고 최소값으로 인지된 것</b>입니다. </p></li><li><p>이러한 보정은 추가 정보를 기입하지 않은 상태에서 적용해야 올바르게 적용되니 주의해야 합니다.</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/python/">python</category>
      
      <category domain="https://jehyunlee.github.io/tags/imagej/">imagej</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/image/">image</category>
      
      <category domain="https://jehyunlee.github.io/tags/scikit-image/">scikit-image</category>
      
      
    </item>
    
    <item>
      <title>혼란한 Matplotlib에서 질서 찾기</title>
      <link>https://jehyunlee.github.io/2022/10/16/Python-DS-117-pycon2022/</link>
      <guid>https://jehyunlee.github.io/2022/10/16/Python-DS-117-pycon2022/</guid>
      <pubDate>Sun, 16 Oct 2022 12:49:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://2022.pycon.kr/&quot;&gt;&lt;b&gt;PyCon Korea 2022&lt;/b&gt;&lt;/a&gt;에서 한 발표 영상입니다.&lt;ul&gt;
&lt;li&gt;Matplotlib을 데이터를 그리는 도구로 많이 알고 계십니다.&lt;/li&gt;
&lt;li&gt;하지</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><a href="https://2022.pycon.kr/"><b>PyCon Korea 2022</b></a>에서 한 발표 영상입니다.<ul><li>Matplotlib을 데이터를 그리는 도구로 많이 알고 계십니다.</li><li>하지만 Matplotlib은 시각화 라이브러리 이상의 생태계입니다. </li><li>seaborn을 사용해 데이터 시각화 결과물의 퀄리티를 높일 수 있고,</li><li>생태계의 다른 라이브러리를 사용해 그린 그림을 Matplotlib으로 편집할 수 있습니다.</li></ul></li></ul><ul><li>발표 영상 : (<a href="https://youtu.be/ZTRKojTLE8M">Youtube Link</a>)<br></li></ul><div class="video-container"><iframe src="https://www.youtube.com/embed/ZTRKojTLE8M" frameborder="0" loading="lazy" allowfullscreen></iframe></div> <p><img src="117_pycon2022_1.png"><br></p>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/visualization/">visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/seaborn/">seaborn</category>
      
      <category domain="https://jehyunlee.github.io/tags/matplotlib/">matplotlib</category>
      
      <category domain="https://jehyunlee.github.io/tags/pycon/">pycon</category>
      
      
    </item>
    
    <item>
      <title>Python Script in Power BI Desktop</title>
      <link>https://jehyunlee.github.io/2022/10/14/Python-DS-116-powerbi/</link>
      <guid>https://jehyunlee.github.io/2022/10/14/Python-DS-116-powerbi/</guid>
      <pubDate>Fri, 14 Oct 2022 00:47:00 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;Microsoft가 출시한 Power BI는 강력합니다.&lt;ul&gt;
&lt;li&gt;윈도 환경에서 데이터를 쉽게 시각화할 수 있을 뿐 아니라&lt;/li&gt;
&lt;li&gt;온라인 배포를 통해 동료와 공유하기도 쉽습니다.&lt;/li&gt;
&lt;li&gt;한편으로 데이터 불러오기,</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li>Microsoft가 출시한 Power BI는 강력합니다.<ul><li>윈도 환경에서 데이터를 쉽게 시각화할 수 있을 뿐 아니라</li><li>온라인 배포를 통해 동료와 공유하기도 쉽습니다.</li><li>한편으로 데이터 불러오기, 전처리, 시각화를 python script로 할 수도 있습니다.</li><li>공식 문서도 풍부하여 익히기 좋습니다.</li></ul></li></ul><h1 id="1-Power-BI-설치"><a href="#1-Power-BI-설치" class="headerlink" title="1. Power BI 설치"></a>1. Power BI 설치</h1><blockquote><p><a href="https://learn.microsoft.com/ko-kr/power-bi/fundamentals/desktop-get-the-desktop">Microsoft Learn: Power BI Desktop 다운로드</a></p></blockquote><ul><li><p>Power BI Desktop은 <b>무료</b>로 <b>Microsoft Store</b>에서 설치합니다.<br><br><img src="116_powerbi_04.png" alt="Microsoft Store Power BI 설치 화면"></p></li><li><p>파일을 다운받아 설치할 수도 있지만 직접 다운받으면 다음과 같은 이점이 있다고 합니다.</p></li></ul><ol><li><b>자동 업데이트:</b> 최신 버전이 제공되는 즉시, Windows가 백그라운드에서 자동으로 다운로드하므로 항상 최신 버전이 유지됩니다.</li><li><b>필요한 파일만 다운로드:</b> Microsoft Store는 각 업데이트에서 변경된 구성 요소만 사용자 머신에 다운로드하므로 각 업데이트에 필요한 파일만 다운로드됩니다.</li><li><b>관리자 권한이 필요하지 않음:</b> 패키지를 직접 다운로드하고 설치하는 경우 설치가 성공적으로 완료되려면 관리자여야 합니다. Microsoft Store에서 Power BI Desktop을 가져오는 경우에는 관리자 권한이 필요하지 ‘않습니다’.</li><li><b>IT 롤아웃 사용:</b> 비즈니스용 Microsoft Store를 통해 조직의 모든 사용자에게 Power BI Desktop을 보다 쉽게 배포하거나 ‘롤아웃’할 수 있습니다.</li><li><b>언어 감지:</b> Microsoft Store 버전은 지원되는 언어를 모두 포함하며, 시작할 때마다 컴퓨터에서 사용되는 언어를 확인합니다. 이 언어 지원은 Power BI Desktop에서 만든 모델의 지역화에도 영향을 줍니다. 예를 들어 기본 제공 날짜 계층 구조는 .pbix 파일을 만들 때 Power BI Desktop에서 사용 중인 언어와 일치합니다.</li></ol><h1 id="2-데이터-불러오기"><a href="#2-데이터-불러오기" class="headerlink" title="2. 데이터 불러오기"></a>2. 데이터 불러오기</h1><ul><li><p>그림으로 표현할 데이터를 불러옵니다. </p></li><li><p><b>엑셀 파일</b>, <b>SQL 서버</b>, <b>붙여넣기</b>를 제공하고 <b>샘플 데이터</b>를 사용할 수 있습니다.<br><br><img src="116_powerbi_05.png"><br></p></li><li><p>또한 <b>파이썬 스크립트</b>를 사용해 데이터를 불러올 수 있습니다.</p></li><li><p>엑셀 파일과 파이썬 스크립트를 사용해 데이터를 불러 scatter plot을 그리겠습니다.</p></li></ul><h2 id="2-1-엑셀-파일-불러오기"><a href="#2-1-엑셀-파일-불러오기" class="headerlink" title="2.1. 엑셀 파일 불러오기"></a>2.1. 엑셀 파일 불러오기</h2><ul><li><p><b>Excel 파일에서 데이터 가져오기</b>를 클릭하고 파일을 선택합니다.</p></li><li><p>seaborn의 <a href="penguins.xlsx"><b>펭귄 데이터셋</b>을 추출한 파일</a>을 선택합니다.<br><br><img src="116_powerbi_06.png"><br></p></li><li><p>Sheet를 선택하면 데이터 일부가 화면에 출력됩니다.</p></li><li><p>결측치는 <em>null</em> 이라고 표현됩니다.</p></li><li><p><b>[로드]</b>를 누르면 <b>PowerQuery</b>로 넘어갑니다.<br></p></li></ul><p><img src="116_powerbi_07.png"><br></p><ul><li>Power Query에서 전처리를 적용할 수 있습니다.</li><li>여기서는 매뉴의 맨 왼쪽, <b>[닫기 및 적용]</b>을 눌러 그대로 가져옵니다.</li><li>창을 닫아도 마찬가지로 동작하며, 이제 그림을 그릴 준비가 되었습니다.<br></li></ul><p><img src="116_powerbi_08.png"><br></p><ul><li>그림이 그려질 공간과 함께 <b>[시각화]</b> 메뉴에 다양한 선택지가 보입니다.</li><li>왼쪽 위부터 3행 3열에 있는 버튼을 클릭해 산점도를 그립시다.</li><li>산점도를 클릭하면 왼쪽에 네모난 공간이 생깁니다. 마우스로 크기와 위치를 정합니다.<br></li></ul><p><img src="116_powerbi_10.png"><br></p><ul><li>데이터를 지정할 차례입니다.</li><li><b>[시각화]</b> 메뉴 아래 있는<b>[X축]</b>, <b>[Y축]</b>에 인자를 끌어다 놓습니다.</li><li>여기서는 <b><code>bill_length_mm</code></b>와 <b><code>bill_depth_mm</code></b>를 선택했습니다.</li><li>기본값으로 <b>합계</b>가 선택되어 점이 하나밖에 나오지 않습니다. </li><li>우클릭을 하거나 <b>v</b> 버튼을 눌러 <b>[요약 안함]</b>을 누릅니다.<br></li></ul><p><img src="116_powerbi_11.png"><br></p><ul><li><b>범례</b>에 <b><code>species</code></b>를 추가하면 종에 따라 다른 색이 입혀집니다.</li></ul><p><img src="116_powerbi_12.png"><br></p><ul><li>일단 여기에서 정리하고 파이썬으로 불러보겠습니다.</li><li>화면 왼쪽 하단 <b>1 페이지</b> 옆에 있는 <b>+</b>를 눌러 새 페이지를 엽니다.</li></ul><h2 id="2-2-파이썬으로-불러오기"><a href="#2-2-파이썬으로-불러오기" class="headerlink" title="2.2. 파이썬으로 불러오기"></a>2.2. 파이썬으로 불러오기</h2><blockquote><p><a href="https://learn.microsoft.com/ko-kr/power-bi/connect-data/desktop-python-scripts">Microsoft Learn: Power BI, Power BI Desktop에서 Python 스크립트 실행</a></p></blockquote><ul><li>먼저 파이썬이 설치되어 있어야 합니다.</li><li><b>[파일] &gt; [옵션 및 설정] &gt; [옵션] &gt; [Python 스크립팅]</b>을 선택합니다.<br></li></ul><p><img src="116_powerbi_14.png"><br></p><ul><li>설정이 되어 있다면 자동으로 검색된 경로를 가져옵니다. 필요하다면 다른 경로를 지정할 수 있습니다.</li><li>상단 메뉴의 <b>[데이터 가져오기] &gt; [기타] &gt; [Python 스크립트]</b>를 선택합니다.<br></li></ul><p><img src="116_powerbi_15.png"><br></p><ul><li>데이터를 로딩하는 파이썬 스크립트를 작성합니다.</li><li><code>seaborn</code>을 읽어들여 내장된 펭귄 데이터셋을 부릅니다.<br></li></ul><p><img src="116_powerbi_16.png"><br></p><ul><li>엑셀로 불렀을 때와 동일한 화면이 나옵니다.<br></li></ul><p><img src="116_powerbi_17.png"><br></p><ul><li>앞에서 진행한 것과 같은 단계를 거치면 동일한 결과를 얻을 수 있습니다.<br></li></ul><p><img src="116_powerbi_19.png"><br></p><h1 id="3-파이썬-데이터-처리"><a href="#3-파이썬-데이터-처리" class="headerlink" title="3. 파이썬 데이터 처리"></a>3. 파이썬 데이터 처리</h1><blockquote><p><a href="https://learn.microsoft.com/ko-kr/power-bi/connect-data/desktop-python-in-query-editor?source=recommendations">Microsoft Learn: Power BI, 쿼리 편집기에서 Python 사용</a></p></blockquote><ul><li>내장 파이썬 스크립트를 사용해 데이터를 처리하겠습니다.</li><li><code>bill_length_mm</code>와 <code>bill_depth_mm</code>의 비율을 구해 <b><code>bill_ratio</code></b>라는 새 인자를 만듭니다.<br></li><li>데이터 이름인 <code>df_peng</code>에서 오른쪽 클릭을 한 후 <b>쿼리 편집</b>을 선택합니다.<br></li></ul><p><img src="116_powerbi_20.png"><br></p><ul><li>데이터를 처음 불렀을 때와 마찬가지로 Power Query가 실행됩니다.<br></li></ul><p><img src="116_powerbi_21.png"><br></p><ul><li>상단 메뉴에서 <b>[변환] &gt; [스크립트] 중 [Python 스크립트 실행]</b>을 선택합니다.</li><li>파이썬 스크립트를 입력합니다.</li><li>Power BI 내부의 데이터 이름은 <b>dataset</b>입니다.</li><li><code>bill_ratio</code>를 구하는 코드를 다음과 같이 입력합니다.<br></li></ul><p><img src="116_powerbi_28.png"><br></p><ul><li><b>[확인]</b>을 누르면 스크립트가 실행됩니다.<br></li></ul><p><img src="116_powerbi_29.png"><br></p><ul><li><b>[Table]</b>을 클릭하면 하단에 데이터가 펼쳐집니다.</li><li><b>[Table]</b>을 우클릭 후 <b>[새 쿼리로 추가]</b>를 선택합니다.</li></ul><p><img src="116_powerbi_30.png"><br></p><ul><li>새로 추가된 쿼리에서 <b>데이터 형식을 지정</b>할 차례입니다.</li><li>수치 데이터를 선택한 후 <b>[형식 변경]</b>에서 적절한 형식을 선택합니다. </li><li>여기서는 <b>10진수</b>를 선택해 수치형으로 변경했습니다.</li><li>상단의 수식에서 <code>type number</code>를 추가해도 좋습니다. 변수가 많을 경우 이게 더 편합니다.</li></ul><p><img src="116_powerbi_31.png"><br></p><ul><li>처리한 데이터를 그림으로 표현할 차례입니다.</li><li>Power Query를 닫고 돌아온 창에서 x축에 <code>bill_ratio</code>, y축에 <code>body_mass_g</code>, 그리고 범례에 <code>species</code>를 입력하면 아래와 같은 그림이 그려집니다.</li></ul><p><img src="116_powerbi_32.png"><br></p><h1 id="4-결론"><a href="#4-결론" class="headerlink" title="4. 결론"></a>4. 결론</h1><ul><li>Power BI는 상당히 많은 기능을 가지고 있습니다.</li><li>저도 이제 막 시작했지만 차분히 알아가려고 합니다.</li><li>파이썬도 함께 활용할 수 있으니 많은 분들이 잘 사용하시면 좋겠습니다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jehyunlee.github.io/categories/Python/">Python</category>
      
      <category domain="https://jehyunlee.github.io/categories/Python/Data-Science/">Data Science</category>
      
      
      <category domain="https://jehyunlee.github.io/tags/data-visualization/">data visualization</category>
      
      <category domain="https://jehyunlee.github.io/tags/power-platform/">power platform</category>
      
      <category domain="https://jehyunlee.github.io/tags/power-bi/">power bi</category>
      
      
    </item>
    
  </channel>
</rss>
